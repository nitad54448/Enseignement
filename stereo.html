<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stereographic Projection & 3D Sphere</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        /* --- Base Styles --- */
        :root {
            --panel-bg: #111827;
            --main-bg: #ffffff;
            --border-light: #e5e7eb;
            --border-dark: #374151;
            --text-light: #d1d5db;
            --text-dark: #111827;
            --accent-blue: #3b82f6;
            --accent-red: #dc2626;
            --panel-width: 350px;
            --handle-width: 6px;
            --drawer-button-size: 40px;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: #f0f0f0;
            display: flex;
            height: 100vh;
            overflow: hidden; 
        }
        #app-container {
            display: flex;
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        /* --- Controls Panel (Left Side) --- */
        #controls-panel {
            width: var(--panel-width);
            min-width: var(--panel-width);
            flex-shrink: 0;
            padding: 24px;
            background-color: var(--panel-bg);
            overflow-y: auto;
            color: var(--text-light);
            position: relative;
            transition: min-width 0.3s ease-in-out, width 0.3s ease-in-out, padding 0.3s ease-in-out;
        }

        /* --- Drag Handle & Drawer Button --- */
        #drag-handle-vertical {
            width: var(--handle-width);
            min-width: var(--handle-width);
            cursor: col-resize;
            background-color: var(--border-dark);
            flex-shrink: 0;
            transition: min-width 0.3s ease-in-out, width 0.3s ease-in-out;
        }
        #drag-handle-vertical:hover { background-color: var(--accent-blue); }

        #drawer-toggle-btn {
            position: absolute;
            top: 2.5rem;
            left: var(--panel-width);
            transform: translateX(calc(var(--handle-width) / 2 - 50%));
            width: var(--drawer-button-size);
            height: var(--drawer-button-size);
            background-color: var(--accent-blue);
            color: white;
            border: 1px solid var(--border-light);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 1;
            z-index: 110;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: left 0.3s ease-in-out, background-color 0.2s;
        }
        #drawer-toggle-btn:hover { background-color: #2563eb; }
        
        /* --- Visualization Container (Right Side) --- */
        #visualization-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            background-color: var(--main-bg);
            position: relative;
        }

        /* Header & Top Buttons */
        #main-header { text-align: center; padding: 1rem 1rem 0.5rem 1rem; color: var(--text-dark); flex-shrink: 0; }
        #main-header h1 { font-size: 1.8em; margin-bottom: 4px; font-weight: 700; }
        #main-header p { font-size: 0.9em; color: #4b5563; margin: 0; }
        #top-buttons-container { display: flex; justify-content: center; align-items: center; gap: 1rem; padding: 0.75rem; flex-shrink: 0; flex-wrap: wrap; }
        #top-buttons-container button, #top-buttons-container .checkbox-container { border: none; color: #ffffff; border-radius: 0.375rem; padding: 0.5rem 1rem; font-weight: 500; cursor: pointer; transition: background-color 0.2s, box-shadow 0.2s; box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06); }
        #top-buttons-container button { min-width: 150px; background-color: var(--accent-blue); }
        #top-buttons-container button:hover { background-color: #2563eb; }
        #top-buttons-container #clear-btn { background-color: var(--accent-red); }
        #top-buttons-container #clear-btn:hover { background-color: #b91c1c; }
        #top-buttons-container .checkbox-container { display: flex; align-items: center; color: var(--text-dark); background-color: var(--border-light); user-select: none; }
        #top-buttons-container .checkbox-container:hover { background-color: #d1d5db; }
        #top-buttons-container .checkbox-container input { margin-right: 8px; width: 1.1em; height: 1.1em; }

        /* --- Canvas Areas --- */
        #canvas-row { display: flex; flex-direction: row; flex-grow: 1; min-height: 0; }
        
        /* Square canvas containers */
        #projection-area, #sphere-area { 
            flex: 1; 
            position: relative; 
            min-height: 0; 
            min-width: 0; 
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem; 
            color: #1f2937; 
            overflow: hidden;
        }
        #sphere-area { border-left: 1px solid var(--border-light); }
        
        .canvas-wrapper { 
            position: relative;
            width: min(100%, 100vh);
            height: min(100%, 100vw);
            aspect-ratio: 1 / 1;
            max-width: 100%;
            max-height: 100%;
        }
        
        #projection-canvas, #sphere-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f7fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; }
        #projection-canvas { cursor: crosshair; }
        #sphere-canvas { cursor: grab; }
        #sphere-canvas:grabbing { cursor: grabbing; }

        /* --- Control Panel Components --- */
        .info-table { font-family: monospace; font-size: 0.9rem; width: 100%; text-align: left; background-color: #374151; border-radius: 0.25rem; border: 1px solid #4b5563; border-collapse: collapse; color: var(--text-light); }
        .info-table th, .info-table td { padding: 0.5rem 1rem; border-bottom: 1px solid #4b5563; }
        .info-table th { background-color: rgba(255, 255, 255, 0.1); color: #ffffff; }
        #controls-panel h2 { font-size: 1.25em; font-weight: 600; margin-bottom: 16px; border-bottom: 1px solid #374151; padding-bottom: 8px; color: #ffffff; }
        #symmetry-generators-list label { background-color: #374151; border: 1px solid #4b5563; color: #e5e7eb; border-radius: 0.375rem; padding: 0.5rem; width: 100%; display: flex; align-items: center; cursor: pointer; transition: background-color 0.2s; }
        #symmetry-generators-list label:hover { background-color: #4b5563; }
        #symmetry-generators-list input[type="checkbox"] { height: 1.1em; width: 1.1em; margin-right: 0.75rem; }

        #footer-note { position: fixed; bottom: 8px; right: 12px; font-size: 0.75rem; color: #9ca3af; z-index: 1000; }

        /* --- Collapsed Panel State (Desktop) --- */
        #app-container.panel-collapsed #controls-panel {
            width: 0;
            min-width: 0;
            padding: 24px 0;
            overflow: hidden;
        }
        #app-container.panel-collapsed #drag-handle-vertical {
            width: 0;
            min-width: 0;
        }
        #app-container.panel-collapsed #drawer-toggle-btn {
            left: 0;
            transform: translate(50%, -50%);
        }
       
        /* --- Responsive Styles for Mobile (< 768px) --- */
        @media (max-width: 768px) {
            #controls-panel {
                position: fixed;
                height: 100%;
                z-index: 1100;
                box-shadow: 4px 0 15px rgba(0,0,0,0.2);
                border-right: 2px solid var(--border-dark);
                transform: translateX(0);
                transition: transform 0.3s ease-in-out;
                width: 85% !important; 
                min-width: unset !important;
                max-width: 350px !important;
            }

            #app-container.panel-collapsed #controls-panel {
                transform: translateX(-105%);
            }

            #drag-handle-vertical {
                display: none;
            }

            #drawer-toggle-btn {
                position: fixed;
                top: 0.75rem;
                left: 0.75rem;
                transform: none;
                z-index: 1200;
            }

            #app-container.panel-collapsed #drawer-toggle-btn {
                 left: 0.75rem;
            }
            #app-container:not(.panel-collapsed) #drawer-toggle-btn {
                left: calc(min(85%, 350px) + 0.75rem); 
            }
            
            #visualization-container {
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
                height: 100vh;
            }
            
            #main-header { 
                padding-top: 3.5rem;
                padding-bottom: 0.5rem;
            }
            #main-header h1 { font-size: 1.5em; }
            #main-header p { font-size: 0.85em; }
            
            #top-buttons-container { 
                flex-direction: column; 
                align-items: stretch;
                padding: 0.5rem 1rem;
                gap: 0.5rem;
            }
            #top-buttons-container button { min-width: auto; }
            
            #canvas-row { 
                flex-direction: column; 
                gap: 1.5rem; 
                padding: 1rem;
                flex-grow: 0;
                flex-shrink: 0;
            }
            
            #projection-area, #sphere-area { 
                padding: 0;
                min-height: 0;
                flex-shrink: 0;
                width: 100%;
                height: auto;
            }
            
            #sphere-area { 
                border-left: none; 
                border-top: 1px solid var(--border-light);
                padding-top: 1.5rem;
            }
            
            /* Make canvas wrappers full width in mobile */
            .canvas-wrapper {
                width: 100% !important;
                height: auto !important;
                aspect-ratio: 1 / 1;
            }
            
            #footer-note { display: none; }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <button id="drawer-toggle-btn">
            <span id="drawer-icon"></span>
        </button>

        <div id="controls-panel">
            <h2>Symmetry Generators</h2>
            <div id="symmetry-generators-list" class="space-y-2 max-h-98 overflow-y-auto pr-2">
                <label><input type="checkbox" value="inversion"> Inversion (Ä«)</label>
                <label><input type="checkbox" value="mirror_xy"> Mirror plane (001) (m)</label>
                <label><input type="checkbox" value="mirror_yz"> Mirror plane (100) (m)</label>
                <label><input type="checkbox" value="mirror_xz"> Mirror plane (010) (m)</label>
                <label><input type="checkbox" value="rot2_z"> 2-fold axis || [001] (2)</label>
                <label><input type="checkbox" value="rot3_z"> 3-fold axis || [001] (3)</label>
                <label><input type="checkbox" value="rot4_z"> 4-fold axis || [001] (4)</label>
                <label><input type="checkbox" value="rot6_z"> 6-fold axis || [001] (6)</label>
                <label><input type="checkbox" value="rotoinv3_z"> 3-fold rotoinversion || [001] (-3)</label>
                <label><input type="checkbox" value="rotoinv4_z"> 4-fold rotoinversion || [001] (-4)</label>
                <label><input type="checkbox" value="rotoinv6_z"> 6-fold rotoinversion || [001] (-6)</label>
            </div>
            
            <div id="info-panel" style="margin-top: 1.5rem;">
                <div id="pole-info-table-wrapper">
                    <p class="text-sm" style="color: #9ca3af;">Click on the projection to add a pole.</p>
                </div>
            </div>
        </div>
        
        <div id="drag-handle-vertical"></div>

        <div id="visualization-container">
            <div id="main-header">
                <h1>Stereographic Projection</h1>
                <p>Click on the projection to add a pole. Select a symmetry element to generate all the poles.  If you select a symmetry element and then a pole, you can generate the other poles one by one. Drag the sphere to rotate or select the parent pole to move its family.</p>
            </div>

            <div id="top-buttons-container">
                 <label class="checkbox-container">
                    <input type="checkbox" id="show-intersections-checkbox">
                    <span>Show intersections</span>
                </label>
                 <label class="checkbox-container">
                    <input type="checkbox" id="show-elements-checkbox">
                    <span>Show elements</span>
                </label>
                <button id="generate-poles-btn">Next Pole</button>
                <button id="clear-btn">Clear All</button>
            </div>
            
            <div id="canvas-row">
                <div id="projection-area">
                    <div class="canvas-wrapper">
                        <canvas id="projection-canvas"></canvas>
                    </div>
                </div>
                <div id="sphere-area">
                     <div class="canvas-wrapper">
                        <canvas id="sphere-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    document.addEventListener('DOMContentLoaded', () => {
        // --- UI ELEMENT REFERENCES ---
        const appContainer = document.getElementById('app-container');
        const drawerToggleBtn = document.getElementById('drawer-toggle-btn');
        const drawerIcon = document.getElementById('drawer-icon');
        const controlsPanel = document.getElementById('controls-panel');

        const projectionCanvas = document.getElementById('projection-canvas');
        const sphereCanvas = document.getElementById('sphere-canvas');
        const projectionCanvasWrapper = document.querySelector('#projection-area .canvas-wrapper');
        const sphereCanvasWrapper = document.querySelector('#sphere-area .canvas-wrapper');
        
        const generatePolesBtn = document.getElementById('generate-poles-btn');
        const clearBtn = document.getElementById('clear-btn');
        const poleInfoWrapper = document.getElementById('pole-info-table-wrapper');
        const generatorListDiv = document.getElementById('symmetry-generators-list');
        const showIntersectionsCheckbox = document.getElementById('show-intersections-checkbox');
        const showElementsCheckbox = document.getElementById('show-elements-checkbox');


        // --- Drawer Panel Logic ---
        const updateDrawerIcon = () => {
            if (appContainer.classList.contains('panel-collapsed')) {
                drawerIcon.innerHTML = '&#9654;'; // Right arrow (to open)
            } else {
                drawerIcon.innerHTML = '&#9664;'; // Left arrow (to close)
            }
        };

        const triggerCanvasResize = () => {
            // Wait for CSS transition to finish before resizing
            setTimeout(() => {
                if (typeof resizeProjectionCanvas === 'function') resizeProjectionCanvas();
                if (typeof resizeSphereCanvas === 'function') resizeSphereCanvas();
            }, 350); 
        };

        drawerToggleBtn.addEventListener('click', () => {
            appContainer.classList.toggle('panel-collapsed');
            updateDrawerIcon();
            triggerCanvasResize();
        });

        // Set initial panel state
        if (window.innerWidth <= 768) {
            appContainer.classList.add('panel-collapsed');
        } else {
            appContainer.classList.remove('panel-collapsed');
        }
        updateDrawerIcon();

        // --- STATE AND 3D SETUP ---
        const ctx = projectionCanvas.getContext('2d');
        let poles = [];
        let selectedPoleIndex = -1;
        let projRadius, projCenterX, projCenterY;
        let poleIdCounter = 0;
        let isDragging = false;
        let draggedPoleId = null;
        let showIntersectionLines = false;
        let showSymmetryElements = false;
        const colorPalette = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
        const lowerHemisphereColor = '#dc2626';
        let scene, camera, renderer, controls, sphere, poleMarkersGroup, intersectionLinesGroup, intersectionMarkersGroup, symmetryElementsGroup;
        const SPHERE_RADIUS = 12.6;

        function createSphereGrid() {
            const gridGroup = new THREE.Group();
            const gridMaterial = new THREE.LineBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.8 });
            const segments = 64;
            for (let i = 1; i <= 3; i++) {
                const rho = i * (Math.PI / 6);
                const radius = SPHERE_RADIUS * Math.sin(rho);
                const y = SPHERE_RADIUS * Math.cos(rho);
                const points = [];
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(radius * Math.cos(angle), y, radius * Math.sin(angle)));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                gridGroup.add(new THREE.Line(geometry, gridMaterial));
                if (y > 1e-6) {
                     gridGroup.add(new THREE.Line(geometry.clone().translate(0, -2*y, 0), gridMaterial));
                }
            }
            const meridianPoints = [];
            for (let j = 0; j <= segments; j++) {
                const angle = (j / segments) * Math.PI;
                meridianPoints.push(new THREE.Vector3(SPHERE_RADIUS * Math.sin(angle), SPHERE_RADIUS * Math.cos(angle), 0));
            }
            const meridianGeometry = new THREE.BufferGeometry().setFromPoints(meridianPoints);
            for (let i = 0; i < 12; i++) {
                const line = new THREE.Line(meridianGeometry, gridMaterial);
                line.rotation.y = (i / 12) * Math.PI * 2;
                gridGroup.add(line);
            }
            scene.add(gridGroup);
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf7fafc);
            const frustumSize = 30;
            camera = new THREE.OrthographicCamera(frustumSize / -2, frustumSize / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            camera.position.z = 32;
            camera.lookAt(0,0,0);
            renderer = new THREE.WebGLRenderer({ canvas: sphereCanvas, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(sphereCanvasWrapper.clientWidth, sphereCanvasWrapper.clientHeight);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            const sphereGeometry = new THREE.SphereGeometry(SPHERE_RADIUS, 64, 64);
            const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xadb5bd, transparent: true, opacity: 0.15, shininess: 50 });
            sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphere);
            const planeGeometry = new THREE.CircleGeometry(SPHERE_RADIUS, 64);
            const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xe6e6f6, transparent: false, opacity: 0.25, side: THREE.DoubleSide, depthWrite: false });
            const equatorialPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            equatorialPlane.rotation.x = -Math.PI / 2;
            scene.add(equatorialPlane);
            createSphereGrid();
            poleMarkersGroup = new THREE.Group();
            scene.add(poleMarkersGroup);
            intersectionLinesGroup = new THREE.Group();
            scene.add(intersectionLinesGroup);
            intersectionMarkersGroup = new THREE.Group();
            scene.add(intersectionMarkersGroup);
            symmetryElementsGroup = new THREE.Group();
            scene.add(symmetryElementsGroup);
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        }

        function updateSphereVisuals() {
            drawSpherePoleMarkers();
            drawIntersectionLines();
            drawIntersectionMarkers();
            drawSymmetryElementsOnSphere();
        }

        function drawSymmetryElementsOnSphere() {
            if (!symmetryElementsGroup) return;
            // Always clear existing elements first
            while (symmetryElementsGroup.children.length > 0) {
                symmetryElementsGroup.remove(symmetryElementsGroup.children[0]);
            }

            // Only draw new elements if the checkbox is checked
            if (!showSymmetryElements) return;

            const checkedOps = Array.from(generatorListDiv.querySelectorAll('input:checked')).map(cb => cb.value);
            if (checkedOps.length === 0) return;

            const elementMaterial = new THREE.MeshPhongMaterial({ color: 0xe11d48, shininess: 80 });
            const planeMaterial = new THREE.MeshPhongMaterial({ color: 0xe11d48, side: THREE.DoubleSide, transparent: true, opacity: 0.3, depthWrite: false, shininess: 30 });

            // --- Draw Axes and Symbols ---
            // Find the highest-order axis to determine which symbol to draw
            const axisOps = ['rotoinv6_z', 'rot6_z', 'rotoinv4_z', 'rot4_z', 'rotoinv3_z', 'rot3_z', 'rot2_z'];
            const selectedAxisOp = axisOps.find(op => checkedOps.includes(op));

            if (selectedAxisOp) {
                // 1. Draw the axis cylinder
                const axisGeom = new THREE.CylinderGeometry(0.1, 0.1, SPHERE_RADIUS * 2.4, 12);
                const axisMesh = new THREE.Mesh(axisGeom, elementMaterial);
                symmetryElementsGroup.add(axisMesh);

                // 2. Create and add the symbol on top
                const symbolSize = 1.2;
                let symbolGeom;
                const shape = new THREE.Shape();

                switch (selectedAxisOp) {
                    case 'rot2_z': {
                        symbolGeom = new THREE.CircleGeometry(symbolSize, 32);
                        symbolGeom.scale(1.0, 0.6, 1.0); // Make it elliptical
                        break;
                    }
                    case 'rotoinv3_z':
                    case 'rot3_z': {
                        shape.moveTo(0, symbolSize);
                        shape.lineTo(symbolSize * -0.866, symbolSize * -0.5);
                        shape.lineTo(symbolSize * 0.866, symbolSize * -0.5);
                        shape.closePath();
                        symbolGeom = new THREE.ShapeGeometry(shape);
                        break;
                    }
                    case 'rotoinv4_z':
                    case 'rot4_z': {
                        symbolGeom = new THREE.PlaneGeometry(symbolSize * 1.4, symbolSize * 1.4);
                        break;
                    }
                    case 'rotoinv6_z':
                    case 'rot6_z': {
                        for (let i = 0; i < 6; i++) {
                            const a = i * Math.PI / 3;
                            const x = symbolSize * Math.cos(a);
                            const y = symbolSize * Math.sin(a);
                            if (i === 0) shape.moveTo(x, y); else shape.lineTo(x, y);
                        }
                        shape.closePath();
                        symbolGeom = new THREE.ShapeGeometry(shape);
                        break;
                    }
                }

                if (symbolGeom) {
                    const symbolMesh = new THREE.Mesh(symbolGeom, elementMaterial);
                    symbolMesh.position.y = SPHERE_RADIUS * 1.25; // Place it just above the cylinder end
                    symbolMesh.rotation.x = -Math.PI / 2; // Rotate to be flat
                    symmetryElementsGroup.add(symbolMesh);
                }
            }

            // --- Draw Inversion and Mirror Planes ---
            checkedOps.forEach(op => {
                let mesh;
                switch (op) {
                    case 'inversion':
                        const invGeom = new THREE.SphereGeometry(0.4, 16, 16);
                        mesh = new THREE.Mesh(invGeom, elementMaterial);
                        symmetryElementsGroup.add(mesh);
                        break;
                    case 'mirror_xy':
                        const planeXYGeom = new THREE.PlaneGeometry(SPHERE_RADIUS * 2.1, SPHERE_RADIUS * 2.1);
                        mesh = new THREE.Mesh(planeXYGeom, planeMaterial);
                        mesh.rotation.x = -Math.PI / 2;
                        symmetryElementsGroup.add(mesh);
                        break;
                    case 'mirror_yz':
                        const planeYZGeom = new THREE.PlaneGeometry(SPHERE_RADIUS * 2.1, SPHERE_RADIUS * 2.1);
                        mesh = new THREE.Mesh(planeYZGeom, planeMaterial);
                        mesh.rotation.y = Math.PI / 2;
                        symmetryElementsGroup.add(mesh);
                        break;
                    case 'mirror_xz':
                        const planeXZGeom = new THREE.PlaneGeometry(SPHERE_RADIUS * 2.1, SPHERE_RADIUS * 2.1);
                        mesh = new THREE.Mesh(planeXZGeom, planeMaterial);
                        symmetryElementsGroup.add(mesh);
                        break;
                }
            });
        }
        
        function drawIntersectionLines() {
            if (!intersectionLinesGroup) return;
            while(intersectionLinesGroup.children.length > 0){
                intersectionLinesGroup.remove(intersectionLinesGroup.children[0]);
            }
            if (!showIntersectionLines) return;
            const northPole = new THREE.Vector3(0, SPHERE_RADIUS, 0);
            const southPole = new THREE.Vector3(0, -SPHERE_RADIUS, 0);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x4b5563, transparent: true, opacity: 0.6, depthTest: false });
            poles.forEach(pole => {
                const polePosition = new THREE.Vector3(SPHERE_RADIUS * pole.h, SPHERE_RADIUS * pole.l, -SPHERE_RADIUS * pole.k);
                const targetPole = pole.l < 0 ? northPole : southPole;
                const points = [polePosition, targetPole];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                intersectionLinesGroup.add(line);
            });
        }
        
        function drawIntersectionMarkers() {
            if (!intersectionMarkersGroup) return;
            while(intersectionMarkersGroup.children.length > 0){
                intersectionMarkersGroup.remove(intersectionMarkersGroup.children[0]);
            }
            if (!showIntersectionLines) return;
            poles.forEach(pole => {
                const polePosition = new THREE.Vector3(SPHERE_RADIUS * pole.h, SPHERE_RADIUS * pole.l, -SPHERE_RADIUS * pole.k);
                let intersectionPoint;
                if (pole.l < 0) {
                    const t = -pole.l / (1 - pole.l);
                    intersectionPoint = new THREE.Vector3(polePosition.x * (1 - t), 0, polePosition.z * (1 - t));
                } else {
                    const t = pole.l / (1 + pole.l);
                    intersectionPoint = new THREE.Vector3(polePosition.x * (1 - t), 0, polePosition.z * (1 - t));
                }
                const materialColor = pole.isLowerHemisphere ? lowerHemisphereColor : pole.color;
                const markerSize = 0.4;
                if (pole.isLowerHemisphere) {
                    const material = new THREE.LineBasicMaterial({ color: materialColor, depthTest: false });
                    const points1 = [new THREE.Vector3(-markerSize, 0, -markerSize), new THREE.Vector3(markerSize, 0, markerSize)];
                    const geometry1 = new THREE.BufferGeometry().setFromPoints(points1);
                    const line1 = new THREE.Line(geometry1, material);
                    const points2 = [new THREE.Vector3(markerSize, 0, -markerSize), new THREE.Vector3(-markerSize, 0, markerSize)];
                    const geometry2 = new THREE.BufferGeometry().setFromPoints(points2);
                    const line2 = new THREE.Line(geometry2, material);
                    const crossGroup = new THREE.Group();
                    crossGroup.add(line1, line2);
                    crossGroup.position.copy(intersectionPoint);
                    intersectionMarkersGroup.add(crossGroup);
                } else {
                    const geometry = new THREE.RingGeometry(markerSize - 0.08, markerSize, 32);
                    const material = new THREE.MeshBasicMaterial({ color: materialColor, side: THREE.DoubleSide, depthTest: false });
                    const ring = new THREE.Mesh(geometry, material);
                    ring.position.copy(intersectionPoint);
                    ring.rotation.x = -Math.PI / 2;
                    intersectionMarkersGroup.add(ring);
                }
            });
        }

        function drawSpherePoleMarkers() {
            if (!poleMarkersGroup) return;
            while(poleMarkersGroup.children.length > 0){ poleMarkersGroup.remove(poleMarkersGroup.children[0]); }
            poles.forEach((pole, index) => {
                const poleRadius = (index === selectedPoleIndex) ? 0.45 : 0.3;
                const materialColor = pole.isLowerHemisphere ? lowerHemisphereColor : pole.color;
                let geometry;
                if (pole.isLowerHemisphere) {
                    geometry = new THREE.TorusGeometry(poleRadius, 0.08, 8, 32);
                } else {
                    geometry = new THREE.SphereGeometry(poleRadius, 16, 16);
                }
                const material = new THREE.MeshLambertMaterial({ color: materialColor });
                const marker = new THREE.Mesh(geometry, material);
                marker.position.set(SPHERE_RADIUS * pole.h, SPHERE_RADIUS * pole.l, -SPHERE_RADIUS * pole.k);
                if (pole.isLowerHemisphere) { marker.lookAt(new THREE.Vector3(0,0,0)); }
                poleMarkersGroup.add(marker);
            });
        }

        function sphericalToCartesian(phi, rho) { const r_proj = projRadius * Math.tan(rho / 2); const x = projCenterX + r_proj * Math.cos(phi); const y = projCenterY - r_proj * Math.sin(phi); return { x, y }; }
        function cartesianToSpherical(x, y) { const dx = x - projCenterX; const dy = projCenterY - y; const r_proj = Math.sqrt(dx*dx + dy*dy); const phi = Math.atan2(dy, dx); let rho = 2 * Math.atan(r_proj / projRadius); rho = Math.min(rho, Math.PI); return { phi, rho }; }
        function sphericalToMiller(phi, rho) { return { h: Math.sin(rho) * Math.cos(phi), k: Math.sin(rho) * Math.sin(phi), l: Math.cos(rho) }; }
        function millerToSpherical(h, k, l) { if (h === 0 && k === 0 && l === 0) return null; const mag = Math.sqrt(h*h + k*k + l*l); const h_norm = h / mag; const k_norm = k / mag; let l_norm = l / mag; const plot_l_norm = Math.abs(l_norm); const phi = Math.atan2(k_norm, h_norm); const rho = Math.acos(Math.max(-1, Math.min(1, plot_l_norm))); return { phi, rho }; }

        function addPoleByValue(h, k, l, isLower = false) {
            const mag = Math.sqrt(h*h + k*k + l*l);
            if (mag === 0) return;
            const h_norm = h / mag;
            const k_norm = k / mag;
            const l_norm = l / mag;
            const spherical = millerToSpherical(h_norm, k_norm, l_norm);
            if (!spherical) return;
            const parentPoleCount = poles.filter(p => p.parentId === null).length;
            const color = colorPalette[parentPoleCount % colorPalette.length];
            const pole = { id: poleIdCounter++, h: h_norm, k: k_norm, l: l_norm, phi: spherical.phi, rho: spherical.rho, color: color, parentId: null, generatingOp: null, isLowerHemisphere: isLower ? true : (l_norm < -1e-6) };
            poles.push(pole);
            selectedPoleIndex = poles.length - 1;
            updateAllVisuals();
        }

        function addPoleByClick(x, y) { const spherical = cartesianToSpherical(x, y); if (spherical.rho > Math.PI / 2 + 1e-5) return; const miller = sphericalToMiller(spherical.phi, spherical.rho); addPoleByValue(miller.h, miller.k, miller.l); }
        
        function applySingleOperation(op, pole) {
            const { h, k, l } = pole; let newPoles = [];
            switch(op) {
                case 'inversion': newPoles.push({ h: -h, k: -k, l: -l }); break;
                case 'mirror_xy': newPoles.push({ h: h, k: k, l: -l }); break;
                case 'mirror_yz': newPoles.push({ h: -h, k: k, l: l }); break;
                case 'mirror_xz': newPoles.push({ h: h, k: -k, l: l }); break;
                case 'rot2_z': newPoles.push({ h: -h, k: -k, l: l }); break;
                case 'rot3_z': newPoles.push({h: h*Math.cos(2*Math.PI/3)-k*Math.sin(2*Math.PI/3), k: h*Math.sin(2*Math.PI/3)+k*Math.cos(2*Math.PI/3), l:l}); newPoles.push({h: h*Math.cos(4*Math.PI/3)-k*Math.sin(4*Math.PI/3), k: h*Math.sin(4*Math.PI/3)+k*Math.cos(4*Math.PI/3), l:l}); break;
                case 'rot4_z': newPoles.push({ h: -k, k: h, l: l }); newPoles.push({ h: -h, k: -k, l: l }); newPoles.push({ h: k, k: -h, l: l }); break;
                case 'rot6_z': for (let i = 1; i < 6; i++) { const angle = i * Math.PI / 3; newPoles.push({ h: h*Math.cos(angle)-k*Math.sin(angle), k: h*Math.sin(angle)+k*Math.cos(angle), l: l }); } break;
                case 'rotoinv3_z': let a120 = 2*Math.PI/3; let rh120 = h*Math.cos(a120) - k*Math.sin(a120); let rk120 = h*Math.sin(a120) + k*Math.cos(a120); newPoles.push({h:-rh120, k:-rk120, l:-l}); let a240 = 4*Math.PI/3; let rh240 = h*Math.cos(a240) - k*Math.sin(a240); let rk240 = h*Math.sin(a240) + k*Math.cos(a240); newPoles.push({h:-rh240, k:-rk240, l:-l}); break;
                case 'rotoinv4_z': newPoles.push({ h: k, k: -h, l: -l }); newPoles.push({ h: -k, k: h, l: -l }); break;
                case 'rotoinv6_z': const a60=Math.PI/3; const rh60=h*Math.cos(a60)-k*Math.sin(a60); const rk60=h*Math.sin(a60)+k*Math.cos(a60); newPoles.push({h:-rh60,k:-rk60,l:-l}); const a300=5*Math.PI/3; const rh300=h*Math.cos(a300)-k*Math.sin(a300); const rk300=h*Math.sin(a300)+k*Math.cos(a300); newPoles.push({h:-rh300,k:-rk300,l:-l}); break;
            }
            return newPoles;
        }

        function arePolesEqual(p1, p2, epsilon = 1e-4) { return Math.abs(p1.h - p2.h) < epsilon && Math.abs(p1.k - p2.k) < epsilon && Math.abs(p1.l - p2.l) < epsilon; }
        function findPoleInList(poleList, poleToFind) { return poleList.some(p => arePolesEqual(p, poleToFind)); }
        function calculateTargetGroup(parentPole, ops) { let knownPoles = [{h: parentPole.h, k: parentPole.k, l: parentPole.l}]; let i = 0; while (i < knownPoles.length) { const currentPole = knownPoles[i]; for (const op of ops) { const newPoles = applySingleOperation(op, currentPole); for (const newPole of newPoles) { if (!findPoleInList(knownPoles, newPole)) { knownPoles.push(newPole); } } } i++; } return knownPoles; }
        
        function handleGenerateClick() {
            if (selectedPoleIndex === -1) { alert("Please select a pole first."); return; }
            const checkedOps = Array.from(generatorListDiv.querySelectorAll('input:checked')).map(cb => cb.value);
            if (checkedOps.length === 0) { alert("Please select at least one symmetry operation."); return; }
            let selected = poles[selectedPoleIndex];
            let parentPole = selected.parentId !== null ? poles.find(p => p.id === selected.parentId) : selected;
            if (!parentPole) { console.error("Parent pole not found!"); return; }
            let targetPoleSet;
            if (checkedOps.length > 1) {
                const targetPoleHkl = calculateTargetGroup(parentPole, checkedOps);
                targetPoleSet = targetPoleHkl.map(p_hkl => { const mag = Math.sqrt(p_hkl.h*p_hkl.h + p_hkl.k*p_hkl.k + p_hkl.l*p_hkl.l); return { h: p_hkl.h / mag, k: p_hkl.k / mag, l: p_hkl.l / mag }; });
            } else {
                const op = checkedOps[0]; const startPole = poles[selectedPoleIndex]; const potentialNewPoles = applySingleOperation(op, startPole); if (!potentialNewPoles || potentialNewPoles.length === 0) return; const newPoleHkl = potentialNewPoles[0]; const mag = Math.sqrt(newPoleHkl.h**2 + newPoleHkl.k**2 + newPoleHkl.l**2); if (mag > 1e-6) { newPoleHkl.h /= mag; newPoleHkl.k /= mag; newPoleHkl.l /= mag; } const existingPoleIndex = poles.findIndex(p => arePolesEqual(p, newPoleHkl));
                if (existingPoleIndex !== -1) { selectedPoleIndex = existingPoleIndex; } else { const spherical = millerToSpherical(newPoleHkl.h, newPoleHkl.k, newPoleHkl.l); const newPoleObject = { id: poleIdCounter++, h: newPoleHkl.h, k: newPoleHkl.k, l: newPoleHkl.l, phi: spherical.phi, rho: spherical.rho, color: parentPole.color, parentId: parentPole.id, generatingOp: op, isLowerHemisphere: newPoleHkl.l < -1e-6 }; poles.push(newPoleObject); selectedPoleIndex = poles.length - 1; }
                updateAllVisuals(); return;
            }
            const familyPoles = poles.filter(p => p.id === parentPole.id || p.parentId === parentPole.id);
            let nextPoleToAdd = null;
            for (const targetPole of targetPoleSet) { if (!findPoleInList(familyPoles, targetPole)) { nextPoleToAdd = targetPole; break; } }
            if (nextPoleToAdd) {
                const spherical = millerToSpherical(nextPoleToAdd.h, nextPoleToAdd.k, nextPoleToAdd.l);
                const newPoleObject = { id: poleIdCounter++, ...nextPoleToAdd, ...spherical, color: parentPole.color, parentId: parentPole.id, generatingOp: 'group', isLowerHemisphere: nextPoleToAdd.l < -1e-6 };
                poles.push(newPoleObject); selectedPoleIndex = poles.length - 1;
            } else {
                const orderedVisiblePoles = targetPoleSet.map(target => familyPoles.find(visible => arePolesEqual(target, visible))).filter(Boolean);
                const currentSelectedInFamily = poles[selectedPoleIndex]; const currentIndex = orderedVisiblePoles.findIndex(p => arePolesEqual(p, currentSelectedInFamily));
                const nextIndex = (currentIndex + 1) % orderedVisiblePoles.length; selectedPoleIndex = poles.indexOf(orderedVisiblePoles[nextIndex]);
            }
            updateAllVisuals();
        }

        function updateAllVisuals() { drawProjection(); updateSphereVisuals(); updatePoleInfoTable(); }
        
        function updatePoleInfoTable() {
            if (poles.length === 0) { poleInfoWrapper.innerHTML = `<p style="font-size: 0.875rem; color: #9ca3af;">Click on the projection to add a pole.</p>`; return; }
            let tableHTML = `<table class="info-table"><tr><th></th><th>Pole (x,y,z)</th><th>Type</th></tr>`;
            poles.forEach((p, index) => {
                const xyz = `(${p.h.toFixed(2)}, ${p.k.toFixed(2)}, ${p.l.toFixed(2)})`;
                const rowStyle = (index === selectedPoleIndex) ? `border-left: 4px solid #f59e0b; background-color: rgba(245, 158, 11, 0.2);` : '';
                const symbolColor = p.isLowerHemisphere ? lowerHemisphereColor : p.color;
                let symbolHTML = p.isLowerHemisphere ? `<div style="width: 18px; height: 18px; color: ${symbolColor}; font-weight: bold; font-size: 22px; line-height: 18px; text-align: center; display: inline-block; vertical-align: middle;">&times;</div>` : `<div style="width: 16px; height: 16px; background-color: transparent; border: 2px solid ${symbolColor}; border-radius: 50%; box-sizing: border-box; display: inline-block; vertical-align: middle;"></div>`;
                const type = p.parentId === null ? 'Parent' : 'Generated';
                tableHTML += `<tr style="cursor: pointer; ${rowStyle}" onclick="document.dispatchEvent(new CustomEvent('selectPole', {detail: ${index}}))"> <td style="text-align: center;">${symbolHTML}</td><td>${xyz}</td><td style="font-size: 0.8em;">${type}</td> </tr>`;
            });
            tableHTML += '</table>'; poleInfoWrapper.innerHTML = tableHTML;
        }

        function drawSymmetryElements() {
            const checkedOps = Array.from(generatorListDiv.querySelectorAll('input:checked')).map(cb => cb.value);
            if (checkedOps.length === 0) return;
            const symbolSize = 14; const symbolColor = '#e11d48';
            ctx.fillStyle = symbolColor; ctx.strokeStyle = symbolColor; ctx.lineWidth = 2.5;
            checkedOps.forEach(op => {
                ctx.beginPath();
                switch(op) {
                    case 'inversion': ctx.arc(projCenterX, projCenterY, symbolSize / 2.5, 0, 2 * Math.PI); ctx.stroke(); break;
                    case 'mirror_xy': ctx.arc(projCenterX, projCenterY, projRadius, 0, 2 * Math.PI); ctx.stroke(); break;
                    case 'mirror_yz': ctx.moveTo(projCenterX, projCenterY - projRadius); ctx.lineTo(projCenterX, projCenterY + projRadius); ctx.stroke(); break;
                    case 'mirror_xz': ctx.moveTo(projCenterX - projRadius, projCenterY); ctx.lineTo(projCenterX + projRadius, projCenterY); ctx.stroke(); break;
                    case 'rot2_z': ctx.ellipse(projCenterX, projCenterY, symbolSize, symbolSize * 0.6, 0, 0, 2 * Math.PI); ctx.fill(); break;
                    case 'rot3_z': ctx.moveTo(projCenterX, projCenterY - symbolSize); ctx.lineTo(projCenterX - symbolSize * 0.866, projCenterY + symbolSize * 0.5); ctx.lineTo(projCenterX + symbolSize * 0.866, projCenterY + symbolSize * 0.5); ctx.closePath(); ctx.fill(); break;
                    case 'rot4_z': ctx.rect(projCenterX - symbolSize / 1.4, projCenterY - symbolSize / 1.4, symbolSize * 1.4, symbolSize * 1.4); ctx.fill(); break;
                    case 'rot6_z': for(let i=0;i<6;i++){ const a=i*Math.PI/3;const x=projCenterX+symbolSize*Math.cos(a);const y=projCenterY-symbolSize*Math.sin(a);(i===0)?ctx.moveTo(x,y):ctx.lineTo(x,y);} ctx.closePath(); ctx.fill(); break;
                    case 'rotoinv3_z': ctx.moveTo(projCenterX, projCenterY - symbolSize); ctx.lineTo(projCenterX - symbolSize * 0.866, projCenterY + symbolSize * 0.5); ctx.lineTo(projCenterX + symbolSize * 0.866, projCenterY + symbolSize * 0.5); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.arc(projCenterX, projCenterY, symbolSize / 3, 0, 2 * Math.PI); ctx.stroke(); break;
                    case 'rotoinv4_z': { const s = symbolSize * 1.5; ctx.rect(projCenterX - s / 2, projCenterY - s / 2, s, s); ctx.stroke(); ctx.beginPath(); ctx.arc(projCenterX, projCenterY, symbolSize * 0.4, 0, 2 * Math.PI); ctx.stroke(); break; }
                    case 'rotoinv6_z': { const hexPoints = []; for (let i = 0; i < 6; i++) { const a = i * Math.PI / 3; hexPoints.push({x: projCenterX + symbolSize * Math.cos(a), y: projCenterY - symbolSize * Math.sin(a)}); } ctx.beginPath(); ctx.moveTo(hexPoints[0].x, hexPoints[0].y); for (let i = 1; i < 6; i++) ctx.lineTo(hexPoints[i].x, hexPoints[i].y); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(hexPoints[0].x, hexPoints[0].y); ctx.lineTo(hexPoints[2].x, hexPoints[2].y); ctx.lineTo(hexPoints[4].x, hexPoints[4].y); ctx.closePath(); ctx.stroke(); break; }
                }
            });
        }

        function drawProjection() {
            ctx.clearRect(0, 0, projectionCanvas.width, projectionCanvas.height);
            drawGrid();
            drawSymmetryElements();
            ctx.beginPath(); ctx.arc(projCenterX, projCenterY, projRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#334155'; ctx.lineWidth = 2; ctx.stroke();
            poles.forEach((pole, index) => {
                const { x, y } = sphericalToCartesian(pole.phi, pole.rho);
                ctx.strokeStyle = pole.isLowerHemisphere ? lowerHemisphereColor : pole.color;
                ctx.lineWidth = 2; ctx.beginPath();
                if (pole.isLowerHemisphere) {
                    const crossSize = 6;
                    ctx.moveTo(x - crossSize, y - crossSize); ctx.lineTo(x + crossSize, y + crossSize);
                    ctx.moveTo(x + crossSize, y - crossSize); ctx.lineTo(x - crossSize, y + crossSize);
                    ctx.stroke();
                } else {
                    ctx.arc(x, y, 6, 0, 2 * Math.PI); ctx.stroke();
                }
                if (index === selectedPoleIndex) {
                    ctx.beginPath(); ctx.arc(x, y, 10, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 3; ctx.stroke();
                }
            });
        }

        function drawGrid() {
            ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 1;
            for (let i = 0; i < 12; i++) { const angle = i * Math.PI / 6; ctx.beginPath(); ctx.moveTo(projCenterX, projCenterY); ctx.lineTo(projCenterX + projRadius * Math.cos(angle), projCenterY - projRadius * Math.sin(angle)); ctx.stroke(); }
            for (let i = 1; i <= 3; i++) { const rho = i * (Math.PI / 6); const r_proj = projRadius * Math.tan(rho / 2); ctx.beginPath(); ctx.arc(projCenterX, projCenterY, r_proj, 0, 2 * Math.PI); ctx.stroke(); }
        }

        function getEventCoords(e) { if (e.touches && e.touches.length > 0) { return { x: e.touches[0].clientX, y: e.touches[0].clientY }; } return { x: e.clientX, y: e.clientY }; }

        function handleDragStart(e) {
            const coords = getEventCoords(e);
            const rect = projectionCanvas.getBoundingClientRect();
            const canvasX = coords.x - rect.left; 
            const canvasY = coords.y - rect.top;
            let clickedIndex = -1; let minDistance = 15;
            poles.forEach((pole, index) => {
                const { x, y } = sphericalToCartesian(pole.phi, pole.rho);
                const distance = Math.sqrt((canvasX - x)**2 + (canvasY - y)**2);
                if (distance < minDistance) { minDistance = distance; clickedIndex = index; }
            });
            selectedPoleIndex = clickedIndex;
            if (clickedIndex !== -1 && poles[clickedIndex].parentId === null) {
                isDragging = true;
                draggedPoleId = poles[clickedIndex].id;
                projectionCanvas.style.cursor = 'grabbing';
                window.addEventListener('mousemove', handleDragMove);
                window.addEventListener('mouseup', handleDragEnd);
                window.addEventListener('touchmove', handleDragMove, { passive: false });
                window.addEventListener('touchend', handleDragEnd);
            } else if (clickedIndex === -1) {
                const distFromCenter = Math.sqrt((canvasX - projCenterX)**2 + (canvasY - projCenterY)**2);
                if (distFromCenter <= projRadius) { 
                    addPoleByClick(canvasX, canvasY); 
                }
            }
            updateAllVisuals();
        }

        function handleDragMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            const coords = getEventCoords(e);
            const rect = projectionCanvas.getBoundingClientRect();
            const canvasX = coords.x - rect.left;
            const canvasY = coords.y - rect.top;
            const dx = canvasX - projCenterX; 
            const dy = canvasY - projCenterY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            let constrainedX = canvasX; 
            let constrainedY = canvasY;
            if (dist > projRadius) { constrainedX = projCenterX + (dx / dist) * projRadius; constrainedY = projCenterY + (dy / dist) * projRadius; }
            const spherical = cartesianToSpherical(constrainedX, constrainedY);
            if (spherical.rho > Math.PI / 2) { spherical.rho = Math.PI / 2; }
            const miller = sphericalToMiller(spherical.phi, spherical.rho);
            const parentPole = poles.find(p => p.id === draggedPoleId);
            if (parentPole) { Object.assign(parentPole, { ...spherical, ...miller, isLowerHemisphere: miller.l < 0 }); }
            regenerateFamily(draggedPoleId);
            updateAllVisuals();
        }

        function handleDragEnd() {
            if (!isDragging) return;
            isDragging = false; 
            draggedPoleId = null;
            projectionCanvas.style.cursor = 'crosshair';
            window.removeEventListener('mousemove', handleDragMove);
            window.removeEventListener('mouseup', handleDragEnd);
            window.removeEventListener('touchmove', handleDragMove);
            window.removeEventListener('touchend', handleDragEnd);
        }

        function regenerateFamily(parentPoleId) {
            const parentPole = poles.find(p => p.id === parentPoleId); if (!parentPole) return;
            const checkedOps = Array.from(generatorListDiv.querySelectorAll('input:checked')).map(cb => cb.value);
            poles = poles.filter(p => p.parentId !== parentPoleId);
            selectedPoleIndex = poles.findIndex(p => p.id === parentPoleId);
            if (checkedOps.length === 0) return;
            const targetPoleHkl = calculateTargetGroup(parentPole, checkedOps);
            targetPoleHkl.forEach(p_hkl => {
                const mag = Math.sqrt(p_hkl.h**2 + p_hkl.k**2 + p_hkl.l**2);
                if (mag < 1e-6) return;
                const newPoleHkl = { h: p_hkl.h / mag, k: p_hkl.k / mag, l: p_hkl.l / mag };
                if (arePolesEqual(newPoleHkl, parentPole) || findPoleInList(poles, newPoleHkl)) return;
                const spherical = millerToSpherical(newPoleHkl.h, newPoleHkl.k, newPoleHkl.l);
                if (!spherical) return;
                const newPoleObject = { id: poleIdCounter++, ...newPoleHkl, ...spherical, color: parentPole.color, parentId: parentPole.id, generatingOp: 'group', isLowerHemisphere: newPoleHkl.l < -1e-6 };
                poles.push(newPoleObject);
            });
        }

        function setupEventListeners() {
            generatePolesBtn.addEventListener('click', handleGenerateClick);
            generatorListDiv.addEventListener('change', () => { if (selectedPoleIndex > -1) { const selectedPole = poles[selectedPoleIndex]; const parentId = selectedPole.parentId === null ? selectedPole.id : selectedPole.parentId; if (parentId !== null) { regenerateFamily(parentId); } } updateAllVisuals(); });
            clearBtn.addEventListener('click', () => { poles = []; selectedPoleIndex = -1; generatorListDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = false; }); updateAllVisuals(); });
            document.addEventListener('selectPole', (e) => {
                selectedPoleIndex = e.detail; 
                updateAllVisuals();
                if (window.innerWidth <= 768 && !appContainer.classList.contains('panel-collapsed')) {
                    appContainer.classList.add('panel-collapsed');
                    updateDrawerIcon();
                }
            });
            projectionCanvas.addEventListener('mousedown', handleDragStart);
            projectionCanvas.addEventListener('touchstart', handleDragStart, { passive: true });
            showIntersectionsCheckbox.addEventListener('change', (e) => { showIntersectionLines = e.target.checked; updateSphereVisuals(); });
            showElementsCheckbox.addEventListener('change', (e) => { showSymmetryElements = e.target.checked; updateAllVisuals(); });
        }
        
        function setupResizers() {
            const vResizer = document.getElementById('drag-handle-vertical');
            const leftPanel = document.getElementById('controls-panel');
            if (!vResizer || !leftPanel) return;
            vResizer.addEventListener('mousedown', (e) => {
                if (appContainer.classList.contains('panel-collapsed')) return;
                e.preventDefault();
                document.body.style.cursor = 'col-resize';
                const moveHandler = (moveEvent) => {
                    const newLeftWidth = moveEvent.clientX;
                    if (newLeftWidth > 250 && newLeftWidth < window.innerWidth - 350) {
                        document.documentElement.style.setProperty('--panel-width', `${newLeftWidth}px`);
                    }
                };
                const stopHandler = () => {
                    document.body.style.cursor = 'default';
                    window.removeEventListener('mousemove', moveHandler);
                    window.removeEventListener('mouseup', stopHandler);
                    triggerCanvasResize();
                };
                window.addEventListener('mousemove', moveHandler);
                window.addEventListener('mouseup', stopHandler);
            });
        }

        function resizeProjectionCanvas() {
            // Check if mobile view
            const isMobile = window.innerWidth <= 768;
            
            let size;
            if (isMobile) {
                // In mobile, use full available width
                const areaWidth = projectionCanvasWrapper.parentElement.clientWidth;
                size = areaWidth;
            } else {
                // In desktop, constrain to square within available space
                const areaWidth = projectionCanvasWrapper.parentElement.clientWidth - 32;
                const areaHeight = projectionCanvasWrapper.parentElement.clientHeight - 32;
                size = Math.min(areaWidth, areaHeight);
            }
            
            if (size <= 0) return;
            
            projectionCanvasWrapper.style.width = size + 'px';
            projectionCanvasWrapper.style.height = size + 'px';
            
            projectionCanvas.width = size; 
            projectionCanvas.height = size; 
            projRadius = size * 0.42; 
            projCenterX = size / 2; 
            projCenterY = size / 2;
            drawProjection();
        }

        function resizeSphereCanvas() {
            // Check if mobile view
            const isMobile = window.innerWidth <= 768;
            
            let size;
            if (isMobile) {
                // In mobile, use full available width
                const areaWidth = sphereCanvasWrapper.parentElement.clientWidth;
                size = areaWidth;
            } else {
                // In desktop, constrain to square within available space
                const areaWidth = sphereCanvasWrapper.parentElement.clientWidth - 32;
                const areaHeight = sphereCanvasWrapper.parentElement.clientHeight - 32;
                size = Math.min(areaWidth, areaHeight);
            }
            
            if (size <= 0) return;
            
            sphereCanvasWrapper.style.width = size + 'px';
            sphereCanvasWrapper.style.height = size + 'px';
            
            if (renderer && camera) {
                renderer.setSize(size, size);
                const frustumSize = 30;
                camera.left   = frustumSize / -2; 
                camera.right  = frustumSize / 2; 
                camera.top    = frustumSize / 2; 
                camera.bottom = frustumSize / -2;
                camera.updateProjectionMatrix();
            }
        }

        // --- INITIALIZATION ---
        initThreeJS();
        
        // Add window resize listener for proper responsive behavior
        window.addEventListener('resize', () => {
            resizeProjectionCanvas();
            resizeSphereCanvas();
        });
        
        new ResizeObserver(resizeProjectionCanvas).observe(projectionCanvasWrapper.parentElement);
        new ResizeObserver(resizeSphereCanvas).observe(sphereCanvasWrapper.parentElement);
        setupEventListeners();
        setupResizers();
    });
    </script>
    
    <div id="footer-note">
        NitaD, Univ Paris-Saclay, august 2025. Last update 8 october 2025
    </div>

</body>
</html>

