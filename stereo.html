<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stereographic Projection & 3D Sphere</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        /* --- Base Styles --- */
        :root {
            --panel-bg: #111827;
            --main-bg: #ffffff;
            --border-light: #e5e7eb;
            --border-dark: #374151;
            --text-light: #d1d5db;
            --text-dark: #111827;
            --accent-blue: #3b82f6;
            --accent-red: #dc2626;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: #f0f0f0;
            color: var(--text-light);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        #app-container {
            display: flex;
            width: 100%;
            height: 100%;
            position: relative; /* For mobile panel positioning */
        }
        
        /* --- Controls Panel (Left Side) --- */
        #controls-panel {
            width: 350px;
            min-width: 250px;
            max-width: 500px;
            flex-shrink: 0;
            padding: 24px;
            background-color: var(--panel-bg);
            border-right: 1px solid var(--border-dark);
            overflow-y: auto;
            color: var(--text-light);
            transition: transform 0.3s ease-in-out;
        }
        #drag-handle-vertical {
            width: 6px;
            cursor: col-resize;
            background-color: var(--border-dark);
            flex-shrink: 0;
            transition: background-color 0.2s;
        }
        #drag-handle-vertical:hover { background-color: var(--accent-blue); }
        
        /* --- Visualization Container (Right Side) --- */
        #visualization-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            background-color: var(--main-bg);
        }

        /* Header & Top Buttons */
        #main-header {
            text-align: center;
            padding: 1rem 1rem 0.5rem 1rem;
            color: var(--text-dark);
            flex-shrink: 0;
            position: relative;
        }
        #main-header h1 { font-size: 1.8em; margin-bottom: 4px; font-weight: 700; }
        #main-header p { font-size: 0.9em; color: #4b5563; margin: 0; }

        #menu-toggle-btn {
            display: none; /* Hidden by default, shown on mobile */
            position: absolute;
            top: 1rem;
            left: 1rem;
            font-size: 1.5rem;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            color: var(--text-dark);
            width: 40px;
            height: 40px;
            border-radius: 0.375rem;
            cursor: pointer;
            z-index: 101; /* Above control panel */
        }

        #top-buttons-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem;
            flex-shrink: 0;
        }
        #top-buttons-container button, #top-buttons-container .checkbox-container {
            border: none;
            color: #ffffff;
            border-radius: 0.375rem;
            padding: 0.5rem 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06);
        }
        #top-buttons-container button { min-width: 150px; background-color: var(--accent-blue); }
        #top-buttons-container button:hover { background-color: #2563eb; }
        #top-buttons-container #clear-btn { background-color: var(--accent-red); }
        #top-buttons-container #clear-btn:hover { background-color: #b91c1c; }
        #top-buttons-container .checkbox-container {
            display: flex;
            align-items: center;
            color: var(--text-dark);
            background-color: var(--border-light);
            user-select: none;
        }
        #top-buttons-container .checkbox-container:hover { background-color: #d1d5db; }
        #top-buttons-container .checkbox-container input { margin-right: 8px; width: 1.1em; height: 1.1em; }

        /* --- Canvas Areas --- */
        #canvas-row {
            display: flex;
            flex-direction: row;
            flex-grow: 1;
            min-height: 0;
        }
        #projection-area, #sphere-area {
            flex: 1;
            position: relative;
            min-height: 300px; /* Minimum height for mobile */
            min-width: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            color: #1f2937;
        }
        #sphere-area { border-left: 1px solid var(--border-light); }
        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 1 / 1;
            margin: auto;
        }
        #projection-canvas, #sphere-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
        }
        #projection-canvas { cursor: crosshair; }
        #sphere-canvas { cursor: grab; }
        #sphere-canvas:grabbing { cursor: grabbing; }

        /* --- Control Panel Components --- */
        .info-table {
            font-family: monospace; font-size: 0.9rem; width: 100%; text-align: left;
            background-color: #374151; border-radius: 0.25rem; border: 1px solid #4b5563;
            border-collapse: collapse; color: var(--text-light);
        }
        .info-table th, .info-table td { padding: 0.5rem 1rem; border-bottom: 1px solid #4b5563; }
        .info-table th { background-color: rgba(255, 255, 255, 0.1); color: #ffffff; }
        
        #controls-panel h2 { font-size: 1.25em; font-weight: 600; margin-bottom: 16px; border-bottom: 1px solid #374151; padding-bottom: 8px; color: #ffffff; }
        #symmetry-generators-list label {
            background-color: #374151; border: 1px solid #4b5563; color: #e5e7eb;
            border-radius: 0.375rem; padding: 0.5rem; width: 100%; display: flex;
            align-items: center; cursor: pointer; transition: background-color 0.2s;
        }
        #symmetry-generators-list label:hover { background-color: #4b5563; }
        #symmetry-generators-list input[type="checkbox"] { height: 1.1em; width: 1.1em; margin-right: 0.75rem; }

        #footer-note {
            position: fixed;
            bottom: 8px;
            right: 12px;
            font-size: 0.75rem;
            color: #9ca3af;
            z-index: 1000;
        }

        /* --- Responsive Styles for Mobile (< 768px) --- */
        @media (max-width: 768px) {
            #app-container {
                flex-direction: column;
            }

            #visualization-container {
                overflow-y: auto; /* Allow this container to scroll vertically */
                -webkit-overflow-scrolling: touch; /* Smoother scrolling on iOS */
            }

            /* Collapsible Controls Panel */
            #menu-toggle-btn {
                display: block;
                position: fixed; /* Changed to fixed to stick to the viewport */
                top: 1rem;
                left: 1rem;
                font-size: 1.5rem;
                background: #f3f4f6;
                border: 1px solid #d1d5db;
                color: var(--text-dark);
                width: 40px;
                height: 40px;
                border-radius: 0.375rem;
                cursor: pointer;
                z-index: 1002; /* Ensure it's on top of the header */
            }
            #controls-panel {
                position: absolute;
                top: 0;
                left: 0;
                width: 85%;
                max-width: 350px;
                min-width: unset;
                height: 100%;
                z-index: 100;
                border-right: 2px solid var(--border-dark);
                box-shadow: 4px 0 15px rgba(0,0,0,0.2);
            }
            #controls-panel.collapsed {
                transform: translateX(-101%);
            }

            /* Hide Desktop Resizer */
            #drag-handle-vertical {
                display: none;
            }

            /* Stack Top Buttons and make them sticky */
            #sticky-controls-wrapper {
                position: sticky;
                top: 0;
                z-index: 1001;
                background-color: var(--main-bg);
                padding: 0.75rem 1rem;
                border-bottom: 1px solid var(--border-light);
                display: flex;
                gap: 1rem;
                align-items: center;
            }

            #menu-toggle-btn {
                display: block;
                position: static; /* No longer fixed */
                flex-shrink: 0; /* Prevent it from shrinking */
                font-size: 1.5rem;
                background: #f3f4f6;
                border: 1px solid #d1d5db;
                color: var(--text-dark);
                width: 40px;
                height: 40px;
                border-radius: 0.375rem;
                cursor: pointer;
                z-index: auto; /* No longer needed */
            }

            #top-buttons-container {
                position: static; /* No longer sticky */
                flex-grow: 1; /* Take remaining space */
                flex-direction: column;
                align-items: stretch; /* Make items full width */
                padding: 0; /* Parent provides padding */
                border-bottom: none; /* Parent provides border */
                background-color: transparent; /* Parent provides background */
            }
            
            #top-buttons-container button {
                min-width: auto;
                width: 100%;
            }

            /* Stack Canvases */
            #canvas-row {
                flex-direction: column;
                gap: 1rem; /* Adds space between the stacked canvases */
                padding: 1rem; /* Add padding so canvases don't touch the edges */
            }
            #projection-area, #sphere-area {
                padding: 0; /* Remove padding from canvas areas, parent has it now */
                min-height: unset; /* Remove fixed height for better fluidity */
                flex-shrink: 0; /* Prevents the canvas containers from shrinking and overlapping */
            }
            #sphere-area {
                border-left: none;
                border-top: 1px solid var(--border-light);
            }
            
            #main-header {
                /* Let the header scroll naturally */
                position: static;
                padding: 1rem;
            }
            
            #footer-note {
                display: none; /* Hide footer on small screens to save space */
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- The control panel is now collapsible on mobile -->
        <div id="controls-panel" class="collapsed">
            <h2>Symmetry Generators</h2>
            <div id="symmetry-generators-list" class="space-y-2 max-h-98 overflow-y-auto pr-2">
                <label><input type="checkbox" value="inversion"> Inversion (ī)</label>
                <label><input type="checkbox" value="mirror_xy"> Mirror plane (001) (m)</label>
                <label><input type="checkbox" value="mirror_yz"> Mirror plane (100) (m)</label>
                <label><input type="checkbox" value="mirror_xz"> Mirror plane (010) (m)</label>
                <label><input type="checkbox" value="rot2_z"> 2-fold axis || [001] (2)</label>
                <label><input type="checkbox" value="rot3_z"> 3-fold axis || [001] (3)</label>
                <label><input type="checkbox" value="rot4_z"> 4-fold axis || [001] (4)</label>
                <label><input type="checkbox" value="rot6_z"> 6-fold axis || [001] (6)</label>
                <label><input type="checkbox" value="rotoinv3_z"> 3-fold rotoinversion || [001] (-3)</label>
                <label><input type="checkbox" value="rotoinv4_z"> 4-fold rotoinversion || [001] (-4)</label>
                <label><input type="checkbox" value="rotoinv6_z"> 6-fold rotoinversion || [001] (-6)</label>
            </div>
            
            <div id="info-panel" style="margin-top: 1.5rem;">
                <div id="pole-info-table-wrapper">
                    <p class="text-sm" style="color: #9ca3af;">Click on the projection to add a pole.</p>

                </div>
            </div>
        </div>
        
        <!-- This resizer is hidden on mobile via CSS -->
        <div id="drag-handle-vertical"></div>

        <div id="visualization-container">
            <div id="main-header">
                <h1>Stereographic Projection</h1>
                <p>Click on the projection to add a pole. Select a symmetry element to generate all the poles.  If you select a symmetry element and then a pole, you can generate the other poles one by one. Drag the sphere to rotate or select the parent pole to move its family.</p>
            </div>

            <!-- This new wrapper will be sticky on mobile -->
            <div id="sticky-controls-wrapper">
                <button id="menu-toggle-btn">☰</button>
                <div id="top-buttons-container">
                     <label class="checkbox-container">
                        <input type="checkbox" id="show-intersections-checkbox">
                        <span>Show intersections</span>
                    </label>
                    <button id="generate-poles-btn">Next Pole</button>
                    <button id="clear-btn">Clear All</button>
                </div>
            </div>
            
            <div id="canvas-row">
                <div id="projection-area">
                    <div class="canvas-wrapper">
                        <canvas id="projection-canvas"></canvas>
                    </div>
                </div>
                <div id="sphere-area">
                     <div class="canvas-wrapper">
                        <canvas id="sphere-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    document.addEventListener('DOMContentLoaded', () => {
        // --- CANVAS & CONTEXT SETUP ---
        const projectionCanvas = document.getElementById('projection-canvas');
        const ctx = projectionCanvas.getContext('2d');
        const projectionCanvasWrapper = document.querySelector('#projection-area .canvas-wrapper');

        const sphereCanvas = document.getElementById('sphere-canvas');
        const sphereCanvasWrapper = document.querySelector('#sphere-area .canvas-wrapper');
        
        // --- UI ELEMENT REFERENCES ---
        const generatePolesBtn = document.getElementById('generate-poles-btn');
        const clearBtn = document.getElementById('clear-btn');
        const poleInfoWrapper = document.getElementById('pole-info-table-wrapper');
        const generatorListDiv = document.getElementById('symmetry-generators-list');
        const showIntersectionsCheckbox = document.getElementById('show-intersections-checkbox');
        const menuToggleBtn = document.getElementById('menu-toggle-btn');
        const controlsPanel = document.getElementById('controls-panel');
        
        // --- STATE VARIABLES ---
        let poles = [];
        let selectedPoleIndex = -1;
        let projRadius, projCenterX, projCenterY;
        let poleIdCounter = 0;
        let isDragging = false;
        let draggedPoleId = null;
        let showIntersectionLines = false;
        
        const colorPalette = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
        const lowerHemisphereColor = '#dc2626'; // Red color for lower hemisphere poles

        // --- 3D SPHERE SETUP (three.js) ---
        let scene, camera, renderer, controls, sphere, poleMarkersGroup, intersectionLinesGroup, intersectionMarkersGroup;
        const SPHERE_RADIUS = 12.6;

        function createSphereGrid() {
            const gridGroup = new THREE.Group();
            const gridMaterial = new THREE.LineBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.8 });
            const segments = 64;

            // Latitude lines (parallels)
            for (let i = 1; i <= 3; i++) {
                const rho = i * (Math.PI / 6);
                const radius = SPHERE_RADIUS * Math.sin(rho);
                const y = SPHERE_RADIUS * Math.cos(rho);
                const points = [];
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(radius * Math.cos(angle), y, radius * Math.sin(angle)));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                gridGroup.add(new THREE.Line(geometry, gridMaterial));
                if (y > 1e-6) {
                     gridGroup.add(new THREE.Line(geometry.clone().translate(0, -2*y, 0), gridMaterial));
                }
            }

            // Longitude lines (meridians)
            const meridianPoints = [];
            for (let j = 0; j <= segments; j++) {
                const angle = (j / segments) * Math.PI;
                meridianPoints.push(new THREE.Vector3(SPHERE_RADIUS * Math.sin(angle), SPHERE_RADIUS * Math.cos(angle), 0));
            }
            const meridianGeometry = new THREE.BufferGeometry().setFromPoints(meridianPoints);
            for (let i = 0; i < 12; i++) {
                const line = new THREE.Line(meridianGeometry, gridMaterial);
                line.rotation.y = (i / 12) * Math.PI * 2;
                gridGroup.add(line);
            }
            
            scene.add(gridGroup);
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf7fafc);
            
            const frustumSize = 30;
            // Initialize camera with placeholder 1:1 aspect values. 
            // resizeSphereCanvas will set the correct ones immediately.
            camera = new THREE.OrthographicCamera(frustumSize / -2, frustumSize / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            camera.position.z = 32;
            camera.lookAt(0,0,0);
            
            renderer = new THREE.WebGLRenderer({ canvas: sphereCanvas, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            // Initial size will be corrected by ResizeObserver
            renderer.setSize(sphereCanvasWrapper.clientWidth, sphereCanvasWrapper.clientHeight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            const sphereGeometry = new THREE.SphereGeometry(SPHERE_RADIUS, 64, 64);
            const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xadb5bd, transparent: true, opacity: 0.15, shininess: 50 });
            sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphere);

            const planeGeometry = new THREE.CircleGeometry(SPHERE_RADIUS, 64);
            const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xe6e6f6, transparent: false, opacity: 0.25, side: THREE.DoubleSide, depthWrite: false });
            const equatorialPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            equatorialPlane.rotation.x = -Math.PI / 2;
            scene.add(equatorialPlane);

            createSphereGrid();

            poleMarkersGroup = new THREE.Group();
            scene.add(poleMarkersGroup);
            
            intersectionLinesGroup = new THREE.Group();
            scene.add(intersectionLinesGroup);

            intersectionMarkersGroup = new THREE.Group();
            scene.add(intersectionMarkersGroup);

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        }

        function updateSphereVisuals() {
            drawSpherePoleMarkers();
            drawIntersectionLines();
            drawIntersectionMarkers();
        }
        
        function drawIntersectionLines() {
            if (!intersectionLinesGroup) return;
            while(intersectionLinesGroup.children.length > 0){
                intersectionLinesGroup.remove(intersectionLinesGroup.children[0]);
            }

            if (!showIntersectionLines) return;

            const northPole = new THREE.Vector3(0, SPHERE_RADIUS, 0);
            const southPole = new THREE.Vector3(0, -SPHERE_RADIUS, 0);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0x4b5563,
                transparent: true,
                opacity: 0.6,
                depthTest: false // This ensures lines are drawn on top
            });

            poles.forEach(pole => {
                const polePosition = new THREE.Vector3(SPHERE_RADIUS * pole.h, SPHERE_RADIUS * pole.l, -SPHERE_RADIUS * pole.k);
                // For points in the lower hemisphere (l<0), projection is from North pole.
                // For points in the upper hemisphere (l>=0), projection is from South pole.
                const targetPole = pole.l < 0 ? northPole : southPole;
                
                const points = [polePosition, targetPole];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                intersectionLinesGroup.add(line);
            });
        }
        
        function drawIntersectionMarkers() {
            if (!intersectionMarkersGroup) return;
            while(intersectionMarkersGroup.children.length > 0){
                intersectionMarkersGroup.remove(intersectionMarkersGroup.children[0]);
            }

            if (!showIntersectionLines) return;

            poles.forEach(pole => {
                const polePosition = new THREE.Vector3(SPHERE_RADIUS * pole.h, SPHERE_RADIUS * pole.l, -SPHERE_RADIUS * pole.k);
                
                let intersectionPoint;

                if (pole.l < 0) { // Lower hemisphere, project from North Pole S=(0, R, 0)
                    const t = -pole.l / (1 - pole.l);
                    intersectionPoint = new THREE.Vector3(polePosition.x * (1 - t), 0, polePosition.z * (1 - t));
                } else { // Upper hemisphere, project from South Pole S=(0, -R, 0)
                    const t = pole.l / (1 + pole.l);
                    intersectionPoint = new THREE.Vector3(polePosition.x * (1 - t), 0, polePosition.z * (1 - t));
                }
                
                const materialColor = pole.isLowerHemisphere ? lowerHemisphereColor : pole.color;
                const markerSize = 0.4;
                
                if (pole.isLowerHemisphere) {
                    // Draw a cross to match the 2D projection
                    const material = new THREE.LineBasicMaterial({ color: materialColor, depthTest: false });
                    const points1 = [new THREE.Vector3(-markerSize, 0, -markerSize), new THREE.Vector3(markerSize, 0, markerSize)];
                    const geometry1 = new THREE.BufferGeometry().setFromPoints(points1);
                    const line1 = new THREE.Line(geometry1, material);
                    
                    const points2 = [new THREE.Vector3(markerSize, 0, -markerSize), new THREE.Vector3(-markerSize, 0, markerSize)];
                    const geometry2 = new THREE.BufferGeometry().setFromPoints(points2);
                    const line2 = new THREE.Line(geometry2, material);

                    const crossGroup = new THREE.Group();
                    crossGroup.add(line1, line2);
                    crossGroup.position.copy(intersectionPoint);
                    intersectionMarkersGroup.add(crossGroup);
                } else {
                    // Draw a stroked circle (ring) to match the 2D projection
                    const geometry = new THREE.RingGeometry(markerSize - 0.08, markerSize, 32);
                    const material = new THREE.MeshBasicMaterial({ color: materialColor, side: THREE.DoubleSide, depthTest: false });
                    const ring = new THREE.Mesh(geometry, material);
                    ring.position.copy(intersectionPoint);
                    ring.rotation.x = -Math.PI / 2; // Rotate to lie on the equatorial plane
                    intersectionMarkersGroup.add(ring);
                }
            });
        }

        function drawSpherePoleMarkers() {
            if (!poleMarkersGroup) return;
            while(poleMarkersGroup.children.length > 0){ poleMarkersGroup.remove(poleMarkersGroup.children[0]); }
            poles.forEach((pole, index) => {
                const poleRadius = (index === selectedPoleIndex) ? 0.45 : 0.3;
                const materialColor = pole.isLowerHemisphere ? lowerHemisphereColor : pole.color;
                let geometry;
                if (pole.isLowerHemisphere) {
                    geometry = new THREE.TorusGeometry(poleRadius, 0.08, 8, 32);
                } else {
                    geometry = new THREE.SphereGeometry(poleRadius, 16, 16);
                }
                const material = new THREE.MeshLambertMaterial({ color: materialColor });
                const marker = new THREE.Mesh(geometry, material);
                marker.position.set(SPHERE_RADIUS * pole.h, SPHERE_RADIUS * pole.l, -SPHERE_RADIUS * pole.k);
                if (pole.isLowerHemisphere) { marker.lookAt(new THREE.Vector3(0,0,0)); }
                poleMarkersGroup.add(marker);
            });
        }

        // --- COORDINATE TRANSFORMATION FUNCTIONS ---
        function sphericalToCartesian(phi, rho) {
            const r_proj = projRadius * Math.tan(rho / 2);
            const x = projCenterX + r_proj * Math.cos(phi);
            const y = projCenterY - r_proj * Math.sin(phi);
            return { x, y };
        }

        function cartesianToSpherical(x, y) {
            const dx = x - projCenterX;
            const dy = projCenterY - y;
            const r_proj = Math.sqrt(dx*dx + dy*dy);
            const phi = Math.atan2(dy, dx);
            let rho = 2 * Math.atan(r_proj / projRadius);
            rho = Math.min(rho, Math.PI);
            return { phi, rho };
        }

        function sphericalToMiller(phi, rho) {
            return {
                h: Math.sin(rho) * Math.cos(phi),
                k: Math.sin(rho) * Math.sin(phi),
                l: Math.cos(rho)
            };
        }

        function millerToSpherical(h, k, l) {
            if (h === 0 && k === 0 && l === 0) return null;
            const mag = Math.sqrt(h*h + k*k + l*l);
            const h_norm = h / mag;
            const k_norm = k / mag;
            let l_norm = l / mag;
            const plot_l_norm = Math.abs(l_norm);
            const phi = Math.atan2(k_norm, h_norm);
            const rho = Math.acos(Math.max(-1, Math.min(1, plot_l_norm)));
            return { phi, rho };
        }

        // --- POLE MANAGEMENT FUNCTIONS ---
        function addPoleByValue(h, k, l, isLower = false) {
            const mag = Math.sqrt(h*h + k*k + l*l);
            if (mag === 0) return;
            const h_norm = h / mag;
            const k_norm = k / mag;
            const l_norm = l / mag;
            const spherical = millerToSpherical(h_norm, k_norm, l_norm);
            if (!spherical) return;
            const parentPoleCount = poles.filter(p => p.parentId === null).length;
            const color = colorPalette[parentPoleCount % colorPalette.length];
            const pole = {
                id: poleIdCounter++,
                h: h_norm, k: k_norm, l: l_norm,
                phi: spherical.phi, rho: spherical.rho,
                color: color, parentId: null, generatingOp: null,
                isLowerHemisphere: isLower ? true : (l_norm < -1e-6)
            };
            poles.push(pole);
            selectedPoleIndex = poles.length - 1;
            updateAllVisuals();
        }

        function addPoleByClick(x, y) {
            const spherical = cartesianToSpherical(x, y);
            if (spherical.rho > Math.PI / 2 + 1e-5) return;
            const miller = sphericalToMiller(spherical.phi, spherical.rho);
            addPoleByValue(miller.h, miller.k, miller.l);
        }
        
        // --- SYMMETRY GENERATION LOGIC ---
        function applySingleOperation(op, pole) {
            const { h, k, l } = pole; let newPoles = [];
            switch(op) {
                case 'inversion': newPoles.push({ h: -h, k: -k, l: -l }); break;
                case 'mirror_xy': newPoles.push({ h: h, k: k, l: -l }); break;
                case 'mirror_yz': newPoles.push({ h: -h, k: k, l: l }); break;
                case 'mirror_xz': newPoles.push({ h: h, k: -k, l: l }); break;
                case 'rot2_z': newPoles.push({ h: -h, k: -k, l: l }); break;
                case 'rot3_z':
                     newPoles.push({h: h*Math.cos(2*Math.PI/3)-k*Math.sin(2*Math.PI/3), k: h*Math.sin(2*Math.PI/3)+k*Math.cos(2*Math.PI/3), l:l});
                     newPoles.push({h: h*Math.cos(4*Math.PI/3)-k*Math.sin(4*Math.PI/3), k: h*Math.sin(4*Math.PI/3)+k*Math.cos(4*Math.PI/3), l:l});
                    break;
                case 'rot4_z':
                     newPoles.push({ h: -k, k: h, l: l }); newPoles.push({ h: -h, k: -k, l: l }); newPoles.push({ h: k, k: -h, l: l });
                    break;
                case 'rot6_z':
                    for (let i = 1; i < 6; i++) {
                        const angle = i * Math.PI / 3; newPoles.push({ h: h*Math.cos(angle)-k*Math.sin(angle), k: h*Math.sin(angle)+k*Math.cos(angle), l: l });
                    }
                    break;
                case 'rotoinv3_z':
                    let angle120 = 2 * Math.PI / 3; let rh120 = h * Math.cos(angle120) - k * Math.sin(angle120); let rk120 = h * Math.sin(angle120) + k * Math.cos(angle120); newPoles.push({h: -rh120, k: -rk120, l: -l});
                    let angle240 = 4 * Math.PI / 3; let rh240 = h * Math.cos(angle240) - k * Math.sin(angle240); let rk240 = h * Math.sin(angle240) + k * Math.cos(angle240); newPoles.push({h: -rh240, k: -rk240, l: -l});
                    break;
                case 'rotoinv4_z':
                    newPoles.push({ h: k, k: -h, l: -l }); newPoles.push({ h: -k, k: h, l: -l }); break;
                case 'rotoinv6_z':
                     const angle60 = Math.PI / 3; const rh60 = h * Math.cos(angle60) - k * Math.sin(angle60); const rk60 = h * Math.sin(angle60) + k * Math.cos(angle60); newPoles.push({ h: -rh60, k: -rk60, l: -l });
                     const angle300 = 5 * Math.PI / 3; const rh300 = h * Math.cos(angle300) - k * Math.sin(angle300); const rk300 = h * Math.sin(angle300) + k * Math.cos(angle300); newPoles.push({ h: -rh300, k: -rk300, l: -l });
                    break;
            }
            return newPoles;
        }

        function arePolesEqual(p1, p2, epsilon = 1e-4) { return Math.abs(p1.h - p2.h) < epsilon && Math.abs(p1.k - p2.k) < epsilon && Math.abs(p1.l - p2.l) < epsilon; }
        function findPoleInList(poleList, poleToFind) { return poleList.some(p => arePolesEqual(p, poleToFind)); }
        function calculateTargetGroup(parentPole, ops) {
            let knownPoles = [{h: parentPole.h, k: parentPole.k, l: parentPole.l}];
            let i = 0;
            while (i < knownPoles.length) {
                const currentPole = knownPoles[i];
                for (const op of ops) {
                    const newPoles = applySingleOperation(op, currentPole);
                    for (const newPole of newPoles) { if (!findPoleInList(knownPoles, newPole)) { knownPoles.push(newPole); } }
                }
                i++;
            }
            return knownPoles;
        }
        function handleGenerateClick() {
            if (selectedPoleIndex === -1) { alert("Please select a pole first."); return; }
            const checkedOps = Array.from(generatorListDiv.querySelectorAll('input:checked')).map(cb => cb.value);
            if (checkedOps.length === 0) { alert("Please select at least one symmetry operation."); return; }
            let selected = poles[selectedPoleIndex];
            let parentPole = selected.parentId !== null ? poles.find(p => p.id === selected.parentId) : selected;
            if (!parentPole) { console.error("Parent pole not found!"); return; }
            let targetPoleSet;
            if (checkedOps.length > 1) {
                const targetPoleHkl = calculateTargetGroup(parentPole, checkedOps);
                targetPoleSet = targetPoleHkl.map(p_hkl => {
                    const mag = Math.sqrt(p_hkl.h*p_hkl.h + p_hkl.k*p_hkl.k + p_hkl.l*p_hkl.l);
                    return { h: p_hkl.h / mag, k: p_hkl.k / mag, l: p_hkl.l / mag };
                });
            } else {
                const op = checkedOps[0]; const startPole = poles[selectedPoleIndex]; const potentialNewPoles = applySingleOperation(op, startPole);
                if (!potentialNewPoles || potentialNewPoles.length === 0) return;
                const newPoleHkl = potentialNewPoles[0]; const mag = Math.sqrt(newPoleHkl.h**2 + newPoleHkl.k**2 + newPoleHkl.l**2);
                if (mag > 1e-6) { newPoleHkl.h /= mag; newPoleHkl.k /= mag; newPoleHkl.l /= mag; }
                const existingPoleIndex = poles.findIndex(p => arePolesEqual(p, newPoleHkl));
                if (existingPoleIndex !== -1) { selectedPoleIndex = existingPoleIndex; } 
                else {
                    const spherical = millerToSpherical(newPoleHkl.h, newPoleHkl.k, newPoleHkl.l);
                    const newPoleObject = { id: poleIdCounter++, h: newPoleHkl.h, k: newPoleHkl.k, l: newPoleHkl.l, phi: spherical.phi, rho: spherical.rho, color: parentPole.color, parentId: parentPole.id, generatingOp: op, isLowerHemisphere: newPoleHkl.l < -1e-6 };
                    poles.push(newPoleObject); selectedPoleIndex = poles.length - 1;
                }
                updateAllVisuals(); return;
            }
            const familyPoles = poles.filter(p => p.id === parentPole.id || p.parentId === parentPole.id);
            let nextPoleToAdd = null;
            for (const targetPole of targetPoleSet) { if (!findPoleInList(familyPoles, targetPole)) { nextPoleToAdd = targetPole; break; } }
            if (nextPoleToAdd) {
                const spherical = millerToSpherical(nextPoleToAdd.h, nextPoleToAdd.k, nextPoleToAdd.l);
                const newPoleObject = { id: poleIdCounter++, ...nextPoleToAdd, ...spherical, color: parentPole.color, parentId: parentPole.id, generatingOp: 'group', isLowerHemisphere: nextPoleToAdd.l < -1e-6 };
                poles.push(newPoleObject); selectedPoleIndex = poles.length - 1;
            } else {
                const orderedVisiblePoles = targetPoleSet.map(target => familyPoles.find(visible => arePolesEqual(target, visible))).filter(Boolean);
                const currentSelectedInFamily = poles[selectedPoleIndex]; const currentIndex = orderedVisiblePoles.findIndex(p => arePolesEqual(p, currentSelectedInFamily));
                const nextIndex = (currentIndex + 1) % orderedVisiblePoles.length; selectedPoleIndex = poles.indexOf(orderedVisiblePoles[nextIndex]);
            }
            updateAllVisuals();
        }

        // --- UI DRAWING AND UPDATING ---
        function updateAllVisuals() {
            drawProjection();
            updateSphereVisuals();
            updatePoleInfoTable();
        }
        
        function updatePoleInfoTable() {
            if (poles.length === 0) {
                poleInfoWrapper.innerHTML = `<p style="font-size: 0.875rem; color: #9ca3af;">Click on the projection to add a pole.</p>`; return;
            }
            let tableHTML = `<table class="info-table"><tr><th></th><th>Pole (x,y,z)</th><th>Type</th></tr>`;
            poles.forEach((p, index) => {
                const xyz = `(${p.h.toFixed(2)}, ${p.k.toFixed(2)}, ${p.l.toFixed(2)})`;
                const rowStyle = (index === selectedPoleIndex) ? `border-left: 4px solid #f59e0b; background-color: rgba(245, 158, 11, 0.2);` : '';
                const symbolColor = p.isLowerHemisphere ? lowerHemisphereColor : p.color;
                let symbolHTML = p.isLowerHemisphere 
                    ? `<div style="width: 18px; height: 18px; color: ${symbolColor}; font-weight: bold; font-size: 22px; line-height: 18px; text-align: center; display: inline-block; vertical-align: middle;">&times;</div>`
                    : `<div style="width: 16px; height: 16px; background-color: transparent; border: 2px solid ${symbolColor}; border-radius: 50%; box-sizing: border-box; display: inline-block; vertical-align: middle;"></div>`;
                const type = p.parentId === null ? 'Parent' : 'Generated';
                tableHTML += `<tr style="cursor: pointer; ${rowStyle}" onclick="document.dispatchEvent(new CustomEvent('selectPole', {detail: ${index}}))">
                    <td style="text-align: center;">${symbolHTML}</td><td>${xyz}</td><td style="font-size: 0.8em;">${type}</td>
                </tr>`;
            });
            tableHTML += '</table>'; poleInfoWrapper.innerHTML = tableHTML;
        }

        function drawSymmetryElements() {
            const checkedOps = Array.from(generatorListDiv.querySelectorAll('input:checked')).map(cb => cb.value);
            if (checkedOps.length === 0) return;
            const symbolSize = 14; const symbolColor = '#e11d48';
            ctx.fillStyle = symbolColor; ctx.strokeStyle = symbolColor; ctx.lineWidth = 2.5;
            checkedOps.forEach(op => {
                ctx.beginPath();
                switch(op) {
                    case 'inversion': ctx.arc(projCenterX, projCenterY, symbolSize / 2.5, 0, 2 * Math.PI); ctx.stroke(); break;
                    case 'mirror_xy': ctx.arc(projCenterX, projCenterY, projRadius, 0, 2 * Math.PI); ctx.stroke(); break;
                    case 'mirror_yz': ctx.moveTo(projCenterX, projCenterY - projRadius); ctx.lineTo(projCenterX, projCenterY + projRadius); ctx.stroke(); break;
                    case 'mirror_xz': ctx.moveTo(projCenterX - projRadius, projCenterY); ctx.lineTo(projCenterX + projRadius, projCenterY); ctx.stroke(); break;
                    case 'rot2_z': ctx.ellipse(projCenterX, projCenterY, symbolSize, symbolSize * 0.6, 0, 0, 2 * Math.PI); ctx.fill(); break;
                    case 'rot3_z': ctx.moveTo(projCenterX, projCenterY - symbolSize); ctx.lineTo(projCenterX - symbolSize * 0.866, projCenterY + symbolSize * 0.5); ctx.lineTo(projCenterX + symbolSize * 0.866, projCenterY + symbolSize * 0.5); ctx.closePath(); ctx.fill(); break;
                    case 'rot4_z': ctx.rect(projCenterX - symbolSize / 1.4, projCenterY - symbolSize / 1.4, symbolSize * 1.4, symbolSize * 1.4); ctx.fill(); break;
                    case 'rot6_z': for(let i=0;i<6;i++){ const a=i*Math.PI/3;const x=projCenterX+symbolSize*Math.cos(a);const y=projCenterY-symbolSize*Math.sin(a);(i===0)?ctx.moveTo(x,y):ctx.lineTo(x,y);} ctx.closePath(); ctx.fill(); break;
                    case 'rotoinv3_z': ctx.moveTo(projCenterX, projCenterY - symbolSize); ctx.lineTo(projCenterX - symbolSize * 0.866, projCenterY + symbolSize * 0.5); ctx.lineTo(projCenterX + symbolSize * 0.866, projCenterY + symbolSize * 0.5); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.arc(projCenterX, projCenterY, symbolSize / 3, 0, 2 * Math.PI); ctx.stroke(); break;
                    case 'rotoinv4_z': {
                        const s = symbolSize * 1.5;
                        ctx.rect(projCenterX - s / 2, projCenterY - s / 2, s, s); ctx.stroke();
                        ctx.beginPath(); ctx.arc(projCenterX, projCenterY, symbolSize * 0.4, 0, 2 * Math.PI); ctx.stroke(); break;
                    }
                    case 'rotoinv6_z': {
                        const hexPoints = [];
                        for (let i = 0; i < 6; i++) {
                            const a = i * Math.PI / 3;
                            hexPoints.push({x: projCenterX + symbolSize * Math.cos(a), y: projCenterY - symbolSize * Math.sin(a)});
                        }
                        ctx.beginPath(); ctx.moveTo(hexPoints[0].x, hexPoints[0].y);
                        for (let i = 1; i < 6; i++) ctx.lineTo(hexPoints[i].x, hexPoints[i].y);
                        ctx.closePath(); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(hexPoints[0].x, hexPoints[0].y);
                        ctx.lineTo(hexPoints[2].x, hexPoints[2].y);
                        ctx.lineTo(hexPoints[4].x, hexPoints[4].y);
                        ctx.closePath(); ctx.stroke(); break;
                    }
                }
            });
        }

        function drawProjection() {
            ctx.clearRect(0, 0, projectionCanvas.width, projectionCanvas.height);
            drawGrid();
            drawSymmetryElements();
            ctx.beginPath(); ctx.arc(projCenterX, projCenterY, projRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#334155'; ctx.lineWidth = 2; ctx.stroke();
            poles.forEach((pole, index) => {
                const { x, y } = sphericalToCartesian(pole.phi, pole.rho);
                ctx.strokeStyle = pole.isLowerHemisphere ? lowerHemisphereColor : pole.color;
                ctx.lineWidth = 2; ctx.beginPath();
                if (pole.isLowerHemisphere) {
                    const crossSize = 6;
                    ctx.moveTo(x - crossSize, y - crossSize); ctx.lineTo(x + crossSize, y + crossSize);
                    ctx.moveTo(x + crossSize, y - crossSize); ctx.lineTo(x - crossSize, y + crossSize);
                    ctx.stroke();
                } else {
                    ctx.arc(x, y, 6, 0, 2 * Math.PI); ctx.stroke();
                }
                if (index === selectedPoleIndex) {
                    ctx.beginPath(); ctx.arc(x, y, 10, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 3; ctx.stroke();
                }
            });
        }

        function drawGrid() {
            ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 1;
            for (let i = 0; i < 12; i++) {
                const angle = i * Math.PI / 6; ctx.beginPath(); ctx.moveTo(projCenterX, projCenterY);
                ctx.lineTo(projCenterX + projRadius * Math.cos(angle), projCenterY - projRadius * Math.sin(angle)); ctx.stroke();
            }
            for (let i = 1; i <= 3; i++) {
                const rho = i * (Math.PI / 6); const r_proj = projRadius * Math.tan(rho / 2);
                ctx.beginPath(); ctx.arc(projCenterX, projCenterY, r_proj, 0, 2 * Math.PI); ctx.stroke();
            }
        }

        // --- UNIFIED EVENT HANDLING (MOUSE & TOUCH) ---
        function getEventCoords(e) {
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        function handleDragStart(e) {
            const coords = getEventCoords(e);
            const rect = projectionCanvas.getBoundingClientRect();
            const canvasX = coords.x - rect.left; 
            const canvasY = coords.y - rect.top;
            
            let clickedIndex = -1; let minDistance = 15;
            poles.forEach((pole, index) => {
                const { x, y } = sphericalToCartesian(pole.phi, pole.rho);
                const distance = Math.sqrt((canvasX - x)**2 + (canvasY - y)**2);
                if (distance < minDistance) { minDistance = distance; clickedIndex = index; }
            });

            selectedPoleIndex = clickedIndex;

            if (clickedIndex !== -1 && poles[clickedIndex].parentId === null) {
                isDragging = true;
                draggedPoleId = poles[clickedIndex].id;
                projectionCanvas.style.cursor = 'grabbing';
                // Attach move/end listeners to the window to capture events outside the canvas
                window.addEventListener('mousemove', handleDragMove);
                window.addEventListener('mouseup', handleDragEnd);
                window.addEventListener('touchmove', handleDragMove, { passive: false });
                window.addEventListener('touchend', handleDragEnd);
            } else if (clickedIndex === -1) {
                const distFromCenter = Math.sqrt((canvasX - projCenterX)**2 + (canvasY - projCenterY)**2);
                if (distFromCenter <= projRadius) { 
                    addPoleByClick(canvasX, canvasY); 
                }
            }
            updateAllVisuals();
        }

        function handleDragMove(e) {
            if (!isDragging) return;
            e.preventDefault(); // Prevents page scrolling on touch devices
            
            const coords = getEventCoords(e);
            const rect = projectionCanvas.getBoundingClientRect();
            const canvasX = coords.x - rect.left;
            const canvasY = coords.y - rect.top;

            const dx = canvasX - projCenterX; 
            const dy = canvasY - projCenterY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            let constrainedX = canvasX; 
            let constrainedY = canvasY;
            
            if (dist > projRadius) {
                constrainedX = projCenterX + (dx / dist) * projRadius;
                constrainedY = projCenterY + (dy / dist) * projRadius;
            }

            const spherical = cartesianToSpherical(constrainedX, constrainedY);
            if (spherical.rho > Math.PI / 2) { spherical.rho = Math.PI / 2; }
            const miller = sphericalToMiller(spherical.phi, spherical.rho);
            
            const parentPole = poles.find(p => p.id === draggedPoleId);
            if (parentPole) { 
                Object.assign(parentPole, { ...spherical, ...miller, isLowerHemisphere: miller.l < 0 });
            }
            regenerateFamily(draggedPoleId);
            updateAllVisuals();
        }

        function handleDragEnd() {
            if (!isDragging) return;
            isDragging = false; 
            draggedPoleId = null;
            projectionCanvas.style.cursor = 'crosshair';
            // Clean up all listeners
            window.removeEventListener('mousemove', handleDragMove);
            window.removeEventListener('mouseup', handleDragEnd);
            window.removeEventListener('touchmove', handleDragMove);
            window.removeEventListener('touchend', handleDragEnd);
        }

        function regenerateFamily(parentPoleId) {
            const parentPole = poles.find(p => p.id === parentPoleId); if (!parentPole) return;
            const checkedOps = Array.from(generatorListDiv.querySelectorAll('input:checked')).map(cb => cb.value);
            poles = poles.filter(p => p.parentId !== parentPoleId);
            selectedPoleIndex = poles.findIndex(p => p.id === parentPoleId);
            if (checkedOps.length === 0) return;
            const targetPoleHkl = calculateTargetGroup(parentPole, checkedOps);
            targetPoleHkl.forEach(p_hkl => {
                const mag = Math.sqrt(p_hkl.h**2 + p_hkl.k**2 + p_hkl.l**2);
                if (mag < 1e-6) return;
                const newPoleHkl = { h: p_hkl.h / mag, k: p_hkl.k / mag, l: p_hkl.l / mag };
                if (arePolesEqual(newPoleHkl, parentPole) || findPoleInList(poles, newPoleHkl)) return;
                const spherical = millerToSpherical(newPoleHkl.h, newPoleHkl.k, newPoleHkl.l);
                if (!spherical) return;
                const newPoleObject = { id: poleIdCounter++, ...newPoleHkl, ...spherical, color: parentPole.color, parentId: parentPole.id, generatingOp: 'group', isLowerHemisphere: newPoleHkl.l < -1e-6 };
                poles.push(newPoleObject);
            });
        }

        function setupEventListeners() {
            generatePolesBtn.addEventListener('click', handleGenerateClick);
            generatorListDiv.addEventListener('change', () => {
                if (selectedPoleIndex > -1) {
                    const selectedPole = poles[selectedPoleIndex];
                    const parentId = selectedPole.parentId === null ? selectedPole.id : selectedPole.parentId;
                    if (parentId !== null) { regenerateFamily(parentId); }
                }
                updateAllVisuals();
            });
            clearBtn.addEventListener('click', () => {
                poles = []; selectedPoleIndex = -1;
                generatorListDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = false; });
                updateAllVisuals();
            });
            document.addEventListener('selectPole', (e) => {
                selectedPoleIndex = e.detail; 
                updateAllVisuals();
                if (window.innerWidth <= 768) {
                    controlsPanel.classList.add('collapsed');
                }
            });

            // Add both mouse and touch start events
            projectionCanvas.addEventListener('mousedown', handleDragStart);
            projectionCanvas.addEventListener('touchstart', handleDragStart, { passive: true });

            showIntersectionsCheckbox.addEventListener('change', (e) => {
                showIntersectionLines = e.target.checked;
                updateSphereVisuals();
            });
            
            // Event listener for the mobile menu toggle
            menuToggleBtn.addEventListener('click', () => {
                controlsPanel.classList.toggle('collapsed');
            });
        }
        
        function setupResizers() {
            const vResizer = document.getElementById('drag-handle-vertical');
            const leftPanel = document.getElementById('controls-panel');
            if (!vResizer || !leftPanel) return;

            vResizer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                document.body.style.cursor = 'col-resize';
                const moveHandler = (moveEvent) => {
                    const newLeftWidth = moveEvent.clientX;
                    if (newLeftWidth > 250 && newLeftWidth < window.innerWidth - 350) {
                        leftPanel.style.width = `${newLeftWidth}px`;
                    }
                };
                const stopHandler = () => {
                    document.body.style.cursor = 'default';
                    window.removeEventListener('mousemove', moveHandler);
                    window.removeEventListener('mouseup', stopHandler);
                };
                window.addEventListener('mousemove', moveHandler);
                window.addEventListener('mouseup', stopHandler);
            });
        }

        function resizeProjectionCanvas() {
            const size = Math.min(projectionCanvasWrapper.clientWidth, projectionCanvasWrapper.clientHeight);
            if (size <= 0) return;
            projectionCanvas.width = size;
            projectionCanvas.height = size;
            projRadius = size * 0.42;
            projCenterX = size / 2;
            projCenterY = size / 2;
            drawProjection();
        }

        function resizeSphereCanvas() {
            const rect = sphereCanvasWrapper.getBoundingClientRect();
            const size = Math.min(rect.width, rect.height);
            
            if (size <= 0) return; // Do not resize to zero or negative dimensions

            if (renderer && camera) {
                renderer.setSize(size, size);

                // For an OrthographicCamera, we must update the frustum properties (left, right, top, bottom)
                // instead of just the aspect ratio.
                const frustumSize = 30;
                const aspect = 1.0; // Our canvas is always a square

                camera.left   = frustumSize * aspect / -2;
                camera.right  = frustumSize * aspect / 2;
                camera.top    = frustumSize / 2;
                camera.bottom = frustumSize / -2;
                
                camera.updateProjectionMatrix();
            }
        }

        // --- INITIALIZATION ---
        initThreeJS();
        new ResizeObserver(resizeProjectionCanvas).observe(projectionCanvasWrapper);
        new ResizeObserver(resizeSphereCanvas).observe(sphereCanvasWrapper);
        
        setupEventListeners();
        setupResizers();
    });
    </script>
    
    <div id="footer-note">
        NitaD, Univ Paris-Saclay, august 2025. Last update 5 october 2025
    </div>

</body>
</html>






