<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stereographic Projection & 3D Sphere</title>
    <link href="./dist/output.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: #f0f0f0;
            color: #e5e7eb;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        #app-container {
            display: flex;
            width: 100%;
            height: 100vh;
        }
        #controls-panel {
            width: 400px;
            min-width: 350px;
            max-width: 600px;
            flex-shrink: 0;
            padding: 24px;
            background-color: #111827;
            border-right: 1px solid #374151;
            overflow-y: auto;
            color: #d1d5db;
        }
        #drag-handle-vertical {
            width: 6px;
            cursor: col-resize;
            background-color: #374151;
            flex-shrink: 0;
            transition: background-color 0.2s;
        }
        #drag-handle-vertical:hover { background-color: #3b82f6; }
        
        #visualization-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            background-color: #ffffff;
        }

        #main-header {
            text-align: center;
            padding: 1rem 1rem 0.5rem 1rem;
            color: #111827;
            flex-shrink: 0;
        }
        #main-header h1 {
            font-size: 1.8em;
            margin-bottom: 4px;
            font-weight: 700;
        }
        #main-header p {
            font-size: 0.9em;
            color: #4b5563;
            margin: 0;
        }

        #top-buttons-container {
            display: flex;
            justify-content: center;
            gap: 1rem;
            padding: 0.75rem;
            flex-shrink: 0;
        }
        #top-buttons-container button {
            background-color: #3b82f6; border: none; color: #ffffff;
            border-radius: 0.375rem; padding: 0.5rem 1rem;
            min-width: 200px;
            font-weight: 500; cursor: pointer; transition: background-color 0.2s;
        }
        #top-buttons-container button:hover { background-color: #2563eb; }
        #top-buttons-container #clear-btn { background-color: #dc2626; }
        #top-buttons-container #clear-btn:hover { background-color: #b91c1c; }

        #canvas-row {
            display: flex;
            flex-direction: row;
            flex-grow: 1;
            min-height: 0;
        }

        #projection-area, #sphere-area {
            flex: 1;
            position: relative;
            min-height: 0;
            min-width: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            color: #1f2937;
        }
        #sphere-area { 
            border-left: 1px solid #e5e7eb;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 1 / 1;
            margin: auto;
        }
        #projection-canvas, #sphere-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
        }
        #sphere-canvas { cursor: grab; }
        #sphere-canvas:grabbing { cursor: grabbing; }

        .info-table {
            font-family: monospace; font-size: 0.9rem; width: 100%; text-align: left;
            background-color: #374151; border-radius: 0.25rem; border: 1px solid #4b5563;
            border-collapse: collapse; color: #d1d5db;
        }
        .info-table th, .info-table td { padding: 0.5rem 1rem; border-bottom: 1px solid #4b5563; }
        .info-table th { background-color: rgba(255, 255, 255, 0.1); color: #ffffff; }
        .control-group {
            margin-bottom: 1.5rem; padding: 1rem; border: 1px solid #374151;
            border-radius: 0.5rem; background-color: rgba(255, 255, 255, 0.05);
        }

        #controls-panel h2 { font-size: 1.25em; font-weight: 600; margin-bottom: 16px; border-bottom: 1px solid #374151; padding-bottom: 8px; color: #ffffff; }
        .control-group p { color: #9ca3af; }
        #controls-panel label { display: block; margin-bottom: 8px; font-weight: 500; color: #9ca3af; }
        #symmetry-generators-list label {
            background-color: #374151; border: 1px solid #4b5563; color: #e5e7eb;
            border-radius: 0.375rem; padding: 0.5rem; width: 100%; display: flex;
            align-items: center; cursor: pointer; transition: background-color 0.2s;
        }
        #symmetry-generators-list label:hover { background-color: #4b5563; }
        #symmetry-generators-list input[type="checkbox"] { height: 1.1em; width: 1.1em; margin-right: 0.75rem; }

        #footer-note {
            position: fixed;
            bottom: 8px;
            right: 12px;
            font-size: 0.75rem;
            color: #9ca3af;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="controls-panel">
    
            <h2>Symmetry Generators</h2>
            <div id="symmetry-generators-list" class="space-y-2 max-h-98 overflow-y-auto pr-2">
                <label><input type="checkbox" value="inversion"> Inversion (Ä«)</label>
                <label><input type="checkbox" value="mirror_xy"> Mirror plane (001) (m)</label>
                <label><input type="checkbox" value="mirror_yz"> Mirror plane (100) (m)</label>
                <label><input type="checkbox" value="mirror_xz"> Mirror plane (010) (m)</label>
                <label><input type="checkbox" value="rot2_z"> 2-fold axis || [001] (2)</label>
                <label><input type="checkbox" value="rot3_z"> 3-fold axis || [001] (3)</label>
                <label><input type="checkbox" value="rot4_z"> 4-fold axis || [001] (4)</label>
                <label><input type="checkbox" value="rot6_z"> 6-fold axis || [001] (6)</label>
                <label><input type="checkbox" value="rotoinv3_z"> 3-fold rotoinversion || [001] (-3)</label>
                <label><input type="checkbox" value="rotoinv4_z"> 4-fold rotoinversion || [001] (-4)</label>
                <label><input type="checkbox" value="rotoinv6_z"> 6-fold rotoinversion || [001] (-6)</label>
            </div>
            
            <div id="info-panel" class="mt-8 space-y-4">
                <div id="pole-info-table-wrapper">
                    <p class="text-sm" style="color: #9ca3af;">Click on the projection to add a pole.</p>
                </div>
            </div>
            </div>
        <div id="drag-handle-vertical"></div>
        <div id="visualization-container">
            <div id="main-header">
                <h1>Stereographic Projection</h1>
                <p>Click on the projection to add a pole. Select a symmetry element to generate all the poles.  If you select a symmetry element and then a pole, you can generate the other poles one by one. Drag the sphere to rotate or select the parent pole to move its family.</p>
            </div>
            <div id="top-buttons-container">
                <button id="generate-poles-btn">Next Pole</button>
                <button id="clear-btn">Clear All</button>
            </div>
            <div id="canvas-row">
                <div id="projection-area">
                    <div class="canvas-wrapper">
                        <canvas id="projection-canvas"></canvas>
                    </div>
                </div>
                <div id="sphere-area">
                     <div class="canvas-wrapper">
                        <canvas id="sphere-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';



    document.addEventListener('DOMContentLoaded', () => {
        // --- CANVAS & CONTEXT SETUP ---
        const projectionCanvas = document.getElementById('projection-canvas');
        const ctx = projectionCanvas.getContext('2d');
        const projectionCanvasWrapper = document.querySelector('#projection-area .canvas-wrapper');

        const sphereCanvas = document.getElementById('sphere-canvas');
        const sphereCanvasWrapper = document.querySelector('#sphere-area .canvas-wrapper');
        
        // --- UI ELEMENT REFERENCES ---
        const generatePolesBtn = document.getElementById('generate-poles-btn');
        const clearBtn = document.getElementById('clear-btn');
        const poleInfoWrapper = document.getElementById('pole-info-table-wrapper');
        const generatorListDiv = document.getElementById('symmetry-generators-list');
        
        // --- STATE VARIABLES ---
        let poles = [];
        let selectedPoleIndex = -1;
        let projRadius, projCenterX, projCenterY;
        let poleIdCounter = 0;
        let isDragging = false;
        let draggedPoleId = null;
        
        const colorPalette = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
        const lowerHemisphereColor = '#dc2626'; // Red color for lower hemisphere poles

        // --- 3D SPHERE SETUP (three.js) ---
        let scene, camera, renderer, controls, sphere, poleMarkersGroup;
        const SPHERE_RADIUS = 12.6;


        function createSphereGrid() {
            const gridGroup = new THREE.Group();
            const gridMaterial = new THREE.LineBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.8 });
            const segments = 64;

            // Latitude lines (parallels)
            for (let i = 1; i <= 3; i++) {
                const rho = i * (Math.PI / 6);
                const radius = SPHERE_RADIUS * Math.sin(rho);
                const y = SPHERE_RADIUS * Math.cos(rho);
                const points = [];
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(radius * Math.cos(angle), y, radius * Math.sin(angle)));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                gridGroup.add(new THREE.Line(geometry, gridMaterial));
                if (y > 1e-6) {
                     gridGroup.add(new THREE.Line(geometry.clone().translate(0, -2*y, 0), gridMaterial));
                }
            }

            // Longitude lines (meridians)
            const meridianPoints = [];
            for (let j = 0; j <= segments; j++) {
                const angle = (j / segments) * Math.PI;
                meridianPoints.push(new THREE.Vector3(SPHERE_RADIUS * Math.sin(angle), SPHERE_RADIUS * Math.cos(angle), 0));
            }
            const meridianGeometry = new THREE.BufferGeometry().setFromPoints(meridianPoints);
            for (let i = 0; i < 12; i++) {
                const line = new THREE.Line(meridianGeometry, gridMaterial);
                line.rotation.y = (i / 12) * Math.PI * 2;
                gridGroup.add(line);
            }
            
            scene.add(gridGroup);
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf7fafc); // Unified background color
            const aspect = sphereCanvasWrapper.clientWidth / sphereCanvasWrapper.clientHeight;

            const frustumSize = 30;
    //const aspect = sphereCanvasWrapper.clientWidth / sphereCanvasWrapper.clientHeight;
    camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);

            camera.position.z = 32; // Camera moved closer
            renderer = new THREE.WebGLRenderer({ canvas: sphereCanvas, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(sphereCanvasWrapper.clientWidth, sphereCanvasWrapper.clientHeight);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Main Sphere
            const sphereGeometry = new THREE.SphereGeometry(SPHERE_RADIUS, 64, 64);
            const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xadb5bd, transparent: true, opacity: 0.15, shininess: 50 });
            sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphere);

            // Equatorial Plane
            const planeGeometry = new THREE.CircleGeometry(SPHERE_RADIUS, 64);
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0xe6e6f6,       //  gris ?
                transparent: false,
                opacity: 0.25,         // Makes it see-through
                side: THREE.DoubleSide, // Ensures it's visible from all angles
                depthWrite: false,
            });
            const equatorialPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            equatorialPlane.rotation.x = -Math.PI / 2; // Rotates the circle to be flat
            scene.add(equatorialPlane);

            // Add Latitude/Longitude Grid
            createSphereGrid();

            // Axes (N-S)
            const axisMaterial = new THREE.LineBasicMaterial({ color: 0x495057, linewidth: 2 });
            const points = [new THREE.Vector3(0, SPHERE_RADIUS * 1.2, 0), new THREE.Vector3(0, -SPHERE_RADIUS * 1.2, 0)];
            const axisGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const axisLine = new THREE.Line(axisGeometry, axisMaterial);
            scene.add(axisLine);

            
            poleMarkersGroup = new THREE.Group();
            scene.add(poleMarkersGroup);
            
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        }

        function drawSpherePoles() {
            if (!poleMarkersGroup) return;
            while(poleMarkersGroup.children.length > 0){ poleMarkersGroup.remove(poleMarkersGroup.children[0]); }
            poles.forEach((pole, index) => {
                const poleRadius = (index === selectedPoleIndex) ? 0.45 : 0.3;
                const materialColor = pole.isLowerHemisphere ? lowerHemisphereColor : pole.color;
                let geometry;
                if (pole.isLowerHemisphere) {
                    geometry = new THREE.TorusGeometry(poleRadius, 0.08, 8, 32);
                } else {
                    geometry = new THREE.SphereGeometry(poleRadius, 16, 16);
                }
                const material = new THREE.MeshLambertMaterial({ color: materialColor });
                const marker = new THREE.Mesh(geometry, material);
                marker.position.set(SPHERE_RADIUS * pole.h, SPHERE_RADIUS * pole.l, SPHERE_RADIUS * pole.k);
                if (pole.isLowerHemisphere) { marker.lookAt(new THREE.Vector3(0,0,0)); }
                poleMarkersGroup.add(marker);
            });
        }

        // --- COORDINATE TRANSFORMATION FUNCTIONS ---
        function sphericalToCartesian(phi, rho) {
            const r_proj = projRadius * Math.tan(rho / 2);
            const x = projCenterX + r_proj * Math.cos(phi);
            const y = projCenterY - r_proj * Math.sin(phi);
            return { x, y };
        }

        function cartesianToSpherical(x, y) {
            const dx = x - projCenterX;
            const dy = projCenterY - y;
            const r_proj = Math.sqrt(dx*dx + dy*dy);
            const phi = Math.atan2(dy, dx);
            let rho = 2 * Math.atan(r_proj / projRadius);
            rho = Math.min(rho, Math.PI);
            return { phi, rho };
        }

        function sphericalToMiller(phi, rho) {
            return {
                h: Math.sin(rho) * Math.cos(phi),
                k: Math.sin(rho) * Math.sin(phi),
                l: Math.cos(rho)
            };
        }

        function millerToSpherical(h, k, l) {
            if (h === 0 && k === 0 && l === 0) return null;
            const mag = Math.sqrt(h*h + k*k + l*l);
            const h_norm = h / mag;
            const k_norm = k / mag;
            let l_norm = l / mag;
            const plot_l_norm = Math.abs(l_norm);
            const phi = Math.atan2(k_norm, h_norm);
            const rho = Math.acos(Math.max(-1, Math.min(1, plot_l_norm)));
            return { phi, rho };
        }

        // --- POLE MANAGEMENT FUNCTIONS ---
        function addPoleByValue(h, k, l, isLower = false) {
            const mag = Math.sqrt(h*h + k*k + l*l);
            if (mag === 0) return;
            const h_norm = h / mag;
            const k_norm = k / mag;
            const l_norm = l / mag;
            const spherical = millerToSpherical(h_norm, k_norm, l_norm);
            if (!spherical) return;
            const parentPoleCount = poles.filter(p => p.parentId === null).length;
            const color = colorPalette[parentPoleCount % colorPalette.length];
            const pole = {
                id: poleIdCounter++,
                h: h_norm, k: k_norm, l: l_norm,
                phi: spherical.phi, rho: spherical.rho,
                color: color, parentId: null, generatingOp: null,
                isLowerHemisphere: isLower ? true : (l_norm < -1e-6)
            };
            poles.push(pole);
            selectedPoleIndex = poles.length - 1;
            updateAllVisuals();
        }

        function addPoleByClick(x, y) {
            const spherical = cartesianToSpherical(x, y);
            if (spherical.rho > Math.PI / 2 + 1e-5) return;
            const miller = sphericalToMiller(spherical.phi, spherical.rho);
            addPoleByValue(miller.h, miller.k, miller.l);
        }
        
        // --- SYMMETRY GENERATION LOGIC ---
        function applySingleOperation(op, pole) {
            const { h, k, l } = pole; let newPoles = [];
            switch(op) {
                case 'inversion': newPoles.push({ h: -h, k: -k, l: -l }); break;
                case 'mirror_xy': newPoles.push({ h: h, k: k, l: -l }); break;
                case 'mirror_yz': newPoles.push({ h: -h, k: k, l: l }); break;
                case 'mirror_xz': newPoles.push({ h: h, k: -k, l: l }); break;
                case 'rot2_z': newPoles.push({ h: -h, k: -k, l: l }); break;
                case 'rot3_z':
                     newPoles.push({h: h*Math.cos(2*Math.PI/3)-k*Math.sin(2*Math.PI/3), k: h*Math.sin(2*Math.PI/3)+k*Math.cos(2*Math.PI/3), l:l});
                     newPoles.push({h: h*Math.cos(4*Math.PI/3)-k*Math.sin(4*Math.PI/3), k: h*Math.sin(4*Math.PI/3)+k*Math.cos(4*Math.PI/3), l:l});
                    break;
                case 'rot4_z':
                     newPoles.push({ h: -k, k: h, l: l }); newPoles.push({ h: -h, k: -k, l: l }); newPoles.push({ h: k, k: -h, l: l });
                    break;
                case 'rot6_z':
                    for (let i = 1; i < 6; i++) {
                        const angle = i * Math.PI / 3; newPoles.push({ h: h*Math.cos(angle)-k*Math.sin(angle), k: h*Math.sin(angle)+k*Math.cos(angle), l: l });
                    }
                    break;
                case 'rotoinv3_z':
                    let angle120 = 2 * Math.PI / 3; let rh120 = h * Math.cos(angle120) - k * Math.sin(angle120); let rk120 = h * Math.sin(angle120) + k * Math.cos(angle120); newPoles.push({h: -rh120, k: -rk120, l: -l});
                    let angle240 = 4 * Math.PI / 3; let rh240 = h * Math.cos(angle240) - k * Math.sin(angle240); let rk240 = h * Math.sin(angle240) + k * Math.cos(angle240); newPoles.push({h: -rh240, k: -rk240, l: -l});
                    break;
                case 'rotoinv4_z':
                    newPoles.push({ h: k, k: -h, l: -l }); newPoles.push({ h: -k, k: h, l: -l }); break;
                case 'rotoinv6_z':
                     const angle60 = Math.PI / 3; const rh60 = h * Math.cos(angle60) - k * Math.sin(angle60); const rk60 = h * Math.sin(angle60) + k * Math.cos(angle60); newPoles.push({ h: -rh60, k: -rk60, l: -l });
                     const angle300 = 5 * Math.PI / 3; const rh300 = h * Math.cos(angle300) - k * Math.sin(angle300); const rk300 = h * Math.sin(angle300) + k * Math.cos(angle300); newPoles.push({ h: -rh300, k: -rk300, l: -l });
                    break;
            }
            return newPoles;
        }

        function arePolesEqual(p1, p2, epsilon = 1e-4) { return Math.abs(p1.h - p2.h) < epsilon && Math.abs(p1.k - p2.k) < epsilon && Math.abs(p1.l - p2.l) < epsilon; }
        function findPoleInList(poleList, poleToFind) { return poleList.some(p => arePolesEqual(p, poleToFind)); }
        function calculateTargetGroup(parentPole, ops) {
            let knownPoles = [{h: parentPole.h, k: parentPole.k, l: parentPole.l}];
            let i = 0;
            while (i < knownPoles.length) {
                const currentPole = knownPoles[i];
                for (const op of ops) {
                    const newPoles = applySingleOperation(op, currentPole);
                    for (const newPole of newPoles) { if (!findPoleInList(knownPoles, newPole)) { knownPoles.push(newPole); } }
                }
                i++;
            }
            return knownPoles;
        }
        function handleGenerateClick() {
            if (selectedPoleIndex === -1) { alert("Please select a pole first."); return; }
            const checkedOps = Array.from(generatorListDiv.querySelectorAll('input:checked')).map(cb => cb.value);
            if (checkedOps.length === 0) { alert("Please select at least one symmetry operation."); return; }
            let selected = poles[selectedPoleIndex];
            let parentPole = selected.parentId !== null ? poles.find(p => p.id === selected.parentId) : selected;
            if (!parentPole) { console.error("Parent pole not found!"); return; }
            let targetPoleSet;
            if (checkedOps.length > 1) {
                const targetPoleHkl = calculateTargetGroup(parentPole, checkedOps);
                targetPoleSet = targetPoleHkl.map(p_hkl => {
                    const mag = Math.sqrt(p_hkl.h*p_hkl.h + p_hkl.k*p_hkl.k + p_hkl.l*p_hkl.l);
                    return { h: p_hkl.h / mag, k: p_hkl.k / mag, l: p_hkl.l / mag };
                });
            } else {
                const op = checkedOps[0]; const startPole = poles[selectedPoleIndex]; const potentialNewPoles = applySingleOperation(op, startPole);
                if (!potentialNewPoles || potentialNewPoles.length === 0) return;
                const newPoleHkl = potentialNewPoles[0]; const mag = Math.sqrt(newPoleHkl.h**2 + newPoleHkl.k**2 + newPoleHkl.l**2);
                if (mag > 1e-6) { newPoleHkl.h /= mag; newPoleHkl.k /= mag; newPoleHkl.l /= mag; }
                const existingPoleIndex = poles.findIndex(p => arePolesEqual(p, newPoleHkl));
                if (existingPoleIndex !== -1) { selectedPoleIndex = existingPoleIndex; } 
                else {
                    const spherical = millerToSpherical(newPoleHkl.h, newPoleHkl.k, newPoleHkl.l);
                    const newPoleObject = { id: poleIdCounter++, h: newPoleHkl.h, k: newPoleHkl.k, l: newPoleHkl.l, phi: spherical.phi, rho: spherical.rho, color: parentPole.color, parentId: parentPole.id, generatingOp: op, isLowerHemisphere: newPoleHkl.l < -1e-6 };
                    poles.push(newPoleObject); selectedPoleIndex = poles.length - 1;
                }
                updateAllVisuals(); return;
            }
            const familyPoles = poles.filter(p => p.id === parentPole.id || p.parentId === parentPole.id);
            let nextPoleToAdd = null;
            for (const targetPole of targetPoleSet) { if (!findPoleInList(familyPoles, targetPole)) { nextPoleToAdd = targetPole; break; } }
            if (nextPoleToAdd) {
                const spherical = millerToSpherical(nextPoleToAdd.h, nextPoleToAdd.k, nextPoleToAdd.l);
                const newPoleObject = { id: poleIdCounter++, ...nextPoleToAdd, ...spherical, color: parentPole.color, parentId: parentPole.id, generatingOp: 'group', isLowerHemisphere: nextPoleToAdd.l < -1e-6 };
                poles.push(newPoleObject); selectedPoleIndex = poles.length - 1;
            } else {
                const orderedVisiblePoles = targetPoleSet.map(target => familyPoles.find(visible => arePolesEqual(target, visible))).filter(Boolean);
                const currentSelectedInFamily = poles[selectedPoleIndex]; const currentIndex = orderedVisiblePoles.findIndex(p => arePolesEqual(p, currentSelectedInFamily));
                const nextIndex = (currentIndex + 1) % orderedVisiblePoles.length; selectedPoleIndex = poles.indexOf(orderedVisiblePoles[nextIndex]);
            }
            updateAllVisuals();
        }

        // --- UI DRAWING AND UPDATING ---
        function updateAllVisuals() {
            drawProjection();
            drawSpherePoles();
            updatePoleInfoTable();
        }
        
        function updatePoleInfoTable() {
            if (poles.length === 0) {
                poleInfoWrapper.innerHTML = `<p class="text-sm" style="color: #9ca3af;">Click on the projection to add a pole.</p>`; return;
            }
            let tableHTML = `<table class="info-table"><tr><th></th><th>Pole (x,y,z)</th><th>Type</th></tr>`;
            poles.forEach((p, index) => {
                const xyz = `(${p.h.toFixed(2)}, ${p.k.toFixed(2)}, ${p.l.toFixed(2)})`;
                const rowStyle = (index === selectedPoleIndex) ? `border-left: 4px solid #f59e0b; background-color: rgba(245, 158, 11, 0.2);` : '';
                const symbolColor = p.isLowerHemisphere ? lowerHemisphereColor : p.color;
                let symbolHTML = p.isLowerHemisphere 
                    ? `<div style="width: 18px; height: 18px; color: ${symbolColor}; font-weight: bold; font-size: 22px; line-height: 18px; text-align: center; display: inline-block; vertical-align: middle;">&times;</div>`
                    : `<div style="width: 16px; height: 16px; background-color: transparent; border: 2px solid ${symbolColor}; border-radius: 50%; box-sizing: border-box; display: inline-block; vertical-align: middle;"></div>`;
                const type = p.parentId === null ? 'Parent' : 'Generated';
                tableHTML += `<tr style="cursor: pointer; ${rowStyle}" onclick="document.dispatchEvent(new CustomEvent('selectPole', {detail: ${index}}))">
                    <td style="text-align: center;">${symbolHTML}</td><td>${xyz}</td><td style="font-size: 0.8em;">${type}</td>
                </tr>`;
            });
            tableHTML += '</table>'; poleInfoWrapper.innerHTML = tableHTML;
        }

        function drawSymmetryElements() {
            const checkedOps = Array.from(generatorListDiv.querySelectorAll('input:checked')).map(cb => cb.value);
            if (checkedOps.length === 0) return;
            const symbolSize = 14; const symbolColor = '#e11d48';
            ctx.fillStyle = symbolColor; ctx.strokeStyle = symbolColor; ctx.lineWidth = 2.5;
            checkedOps.forEach(op => {
                ctx.beginPath();
                switch(op) {
                    case 'inversion': ctx.arc(projCenterX, projCenterY, symbolSize / 2.5, 0, 2 * Math.PI); ctx.stroke(); break;
                    case 'mirror_xy': ctx.arc(projCenterX, projCenterY, projRadius, 0, 2 * Math.PI); ctx.stroke(); break;
                    case 'mirror_yz': ctx.moveTo(projCenterX, projCenterY - projRadius); ctx.lineTo(projCenterX, projCenterY + projRadius); ctx.stroke(); break;
                    case 'mirror_xz': ctx.moveTo(projCenterX - projRadius, projCenterY); ctx.lineTo(projCenterX + projRadius, projCenterY); ctx.stroke(); break;
                    case 'rot2_z': ctx.ellipse(projCenterX, projCenterY, symbolSize, symbolSize * 0.6, 0, 0, 2 * Math.PI); ctx.fill(); break;
                    case 'rot3_z': ctx.moveTo(projCenterX, projCenterY - symbolSize); ctx.lineTo(projCenterX - symbolSize * 0.866, projCenterY + symbolSize * 0.5); ctx.lineTo(projCenterX + symbolSize * 0.866, projCenterY + symbolSize * 0.5); ctx.closePath(); ctx.fill(); break;
                    case 'rot4_z': ctx.rect(projCenterX - symbolSize / 1.4, projCenterY - symbolSize / 1.4, symbolSize * 1.4, symbolSize * 1.4); ctx.fill(); break;
                    case 'rot6_z': for(let i=0;i<6;i++){ const a=i*Math.PI/3;const x=projCenterX+symbolSize*Math.cos(a);const y=projCenterY-symbolSize*Math.sin(a);(i===0)?ctx.moveTo(x,y):ctx.lineTo(x,y);} ctx.closePath(); ctx.fill(); break;
                    case 'rotoinv3_z': ctx.moveTo(projCenterX, projCenterY - symbolSize); ctx.lineTo(projCenterX - symbolSize * 0.866, projCenterY + symbolSize * 0.5); ctx.lineTo(projCenterX + symbolSize * 0.866, projCenterY + symbolSize * 0.5); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.arc(projCenterX, projCenterY, symbolSize / 3, 0, 2 * Math.PI); ctx.stroke(); break;
                    case 'rotoinv4_z': const s = symbolSize * 1.5; ctx.rect(projCenterX - s / 2, projCenterY - s / 2, s, s); ctx.stroke(); ctx.font = `bold ${Math.round(symbolSize*1.2)}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('2', projCenterX, projCenterY); break;
                    case 'rotoinv6_z': for(let i=0;i<6;i++){ const a=i*Math.PI/3;const x=projCenterX+symbolSize*Math.cos(a);const y=projCenterY-symbolSize*Math.sin(a);(i===0)?ctx.moveTo(x,y):ctx.lineTo(x,y);} ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.arc(projCenterX, projCenterY, symbolSize / 3, 0, 2 * Math.PI); ctx.stroke(); break;
                }
            });
        }

        function drawProjection() {
            ctx.clearRect(0, 0, projectionCanvas.width, projectionCanvas.height);
            drawGrid();
            drawSymmetryElements();
            ctx.beginPath(); ctx.arc(projCenterX, projCenterY, projRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#334155'; ctx.lineWidth = 2; ctx.stroke();
            poles.forEach((pole, index) => {
                const { x, y } = sphericalToCartesian(pole.phi, pole.rho);
                ctx.strokeStyle = pole.isLowerHemisphere ? lowerHemisphereColor : pole.color;
                ctx.lineWidth = 2; ctx.beginPath();
                if (pole.isLowerHemisphere) {
                    const crossSize = 6;
                    ctx.moveTo(x - crossSize, y - crossSize); ctx.lineTo(x + crossSize, y + crossSize);
                    ctx.moveTo(x + crossSize, y - crossSize); ctx.lineTo(x - crossSize, y + crossSize);
                    ctx.stroke();
                } else {
                    ctx.arc(x, y, 6, 0, 2 * Math.PI); ctx.stroke();
                }
                if (index === selectedPoleIndex) {
                    ctx.beginPath(); ctx.arc(x, y, 10, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 3; ctx.stroke();
                }
            });
        }

        function drawGrid() {
            ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 1;
            for (let i = 0; i < 12; i++) {
                const angle = i * Math.PI / 6; ctx.beginPath(); ctx.moveTo(projCenterX, projCenterY);
                ctx.lineTo(projCenterX + projRadius * Math.cos(angle), projCenterY - projRadius * Math.sin(angle)); ctx.stroke();
            }
            for (let i = 1; i <= 3; i++) {
                const rho = i * (Math.PI / 6); const r_proj = projRadius * Math.tan(rho / 2);
                ctx.beginPath(); ctx.arc(projCenterX, projCenterY, r_proj, 0, 2 * Math.PI); ctx.stroke();
            }
        }

        // --- EVENT HANDLING ---
        function handleMouseDown(e) {
            const rect = projectionCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
            let clickedIndex = -1; let minDistance = 15;
            poles.forEach((pole, index) => {
                const { x, y } = sphericalToCartesian(pole.phi, pole.rho);
                const distance = Math.sqrt((mouseX - x)**2 + (mouseY - y)**2);
                if (distance < minDistance) { minDistance = distance; clickedIndex = index; }
            });
            selectedPoleIndex = clickedIndex;
            if (clickedIndex !== -1 && poles[clickedIndex].parentId === null) {
                isDragging = true; draggedPoleId = poles[clickedIndex].id;
                projectionCanvas.style.cursor = 'grabbing';
                window.addEventListener('mousemove', handleMouseMove); window.addEventListener('mouseup', handleMouseUp);
            } else if (clickedIndex === -1) {
                const distFromCenter = Math.sqrt((mouseX - projCenterX)**2 + (mouseY - projCenterY)**2);
                if (distFromCenter <= projRadius) { addPoleByClick(mouseX, mouseY); }
            }
            updateAllVisuals();
        }

        function handleMouseMove(e) {
            if (!isDragging) return; e.preventDefault();
            const rect = projectionCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
            const dx = mouseX - projCenterX; const dy = mouseY - projCenterY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            let constrainedX = mouseX; let constrainedY = mouseY;
            if (dist > projRadius) {
                constrainedX = projCenterX + (dx / dist) * projRadius;
                constrainedY = projCenterY + (dy / dist) * projRadius;
            }
            const spherical = cartesianToSpherical(constrainedX, constrainedY);
            if (spherical.rho > Math.PI / 2) { spherical.rho = Math.PI / 2; }
            const miller = sphericalToMiller(spherical.phi, spherical.rho);
            const parentPole = poles.find(p => p.id === draggedPoleId);
            if (parentPole) { Object.assign(parentPole, { ...spherical, ...miller, isLowerHemisphere: miller.l < 0 });}
            regenerateFamily(draggedPoleId);
            updateAllVisuals();
        }

        function handleMouseUp() {
            isDragging = false; draggedPoleId = null;
            projectionCanvas.style.cursor = 'crosshair';
            window.removeEventListener('mousemove', handleMouseMove); window.removeEventListener('mouseup', handleMouseUp);
        }

        function regenerateFamily(parentPoleId) {
            const parentPole = poles.find(p => p.id === parentPoleId); if (!parentPole) return;
            const checkedOps = Array.from(generatorListDiv.querySelectorAll('input:checked')).map(cb => cb.value);
            poles = poles.filter(p => p.parentId !== parentPoleId);
            selectedPoleIndex = poles.findIndex(p => p.id === parentPoleId);
            if (checkedOps.length === 0) return;
            const targetPoleHkl = calculateTargetGroup(parentPole, checkedOps);
            targetPoleHkl.forEach(p_hkl => {
                const mag = Math.sqrt(p_hkl.h**2 + p_hkl.k**2 + p_hkl.l**2);
                if (mag < 1e-6) return;
                const newPoleHkl = { h: p_hkl.h / mag, k: p_hkl.k / mag, l: p_hkl.l / mag };
                if (arePolesEqual(newPoleHkl, parentPole) || findPoleInList(poles, newPoleHkl)) return;
                const spherical = millerToSpherical(newPoleHkl.h, newPoleHkl.k, newPoleHkl.l);
                if (!spherical) return;
                const newPoleObject = { id: poleIdCounter++, ...newPoleHkl, ...spherical, color: parentPole.color, parentId: parentPole.id, generatingOp: 'group', isLowerHemisphere: newPoleHkl.l < -1e-6 };
                poles.push(newPoleObject);
            });
        }

        function setupEventListeners() {
            generatePolesBtn.addEventListener('click', handleGenerateClick);
            generatorListDiv.addEventListener('change', () => {
                if (selectedPoleIndex > -1) {
                    const selectedPole = poles[selectedPoleIndex];
                    const parentId = selectedPole.parentId === null ? selectedPole.id : selectedPole.parentId;
                    if (parentId !== null) { regenerateFamily(parentId); }
                }
                updateAllVisuals();
            });
            clearBtn.addEventListener('click', () => {
                poles = []; selectedPoleIndex = -1;
                generatorListDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = false; });
                updateAllVisuals();
            });
            document.addEventListener('selectPole', (e) => {
                selectedPoleIndex = e.detail; updateAllVisuals();
            });
            projectionCanvas.addEventListener('mousedown', handleMouseDown);
        }
        
        function setupResizers() {
            const vResizer = document.getElementById('drag-handle-vertical');
            const leftPanel = document.getElementById('controls-panel');
            vResizer.addEventListener('mousedown', () => {
                document.body.style.cursor = 'col-resize';
                const moveHandler = e => {
                    const newLeftWidth = e.clientX;
                    if (newLeftWidth > 350 && newLeftWidth < window.innerWidth - 400) {
                        leftPanel.style.width = `${newLeftWidth}px`;
                    }
                };
                const stopHandler = () => {
                    document.body.style.cursor = 'default';
                    window.removeEventListener('mousemove', moveHandler);
                    window.removeEventListener('mouseup', stopHandler);
                };
                window.addEventListener('mousemove', moveHandler);
                window.addEventListener('mouseup', stopHandler);
            });
        }

        function resizeProjectionCanvas() {
            const size = Math.min(projectionCanvasWrapper.clientWidth, projectionCanvasWrapper.clientHeight);
            projectionCanvas.width = size;
            projectionCanvas.height = size;
            projRadius = size * 0.42;
            projCenterX = size / 2;
            projCenterY = size / 2;
            drawProjection();
        }

        function resizeSphereCanvas() {
            const size = Math.min(sphereCanvasWrapper.clientWidth, sphereCanvasWrapper.clientHeight);
            if (renderer && camera) {
                renderer.setSize(size, size);
                camera.aspect = 1;
                camera.updateProjectionMatrix();
            }
        }

        // --- INITIALIZATION ---
        initThreeJS();
        new ResizeObserver(resizeProjectionCanvas).observe(projectionCanvasWrapper);
        new ResizeObserver(resizeSphereCanvas).observe(sphereCanvasWrapper);
        
        setupEventListeners();
        setupResizers();
    });
    </script>
    
    <div id="footer-note">
        NitaD, Univ Paris-Saclay, august 2025. Last update 5 october 2025
    </div>

</body>
</html>
}
