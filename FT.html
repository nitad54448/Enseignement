<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Fourier Transform Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        .canvas-wrapper {
            background-color: #e5e7eb; /* gray-200 */
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: 512px; /* Control max size */
        }
        canvas, video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        .active-btn {
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
        }
    </style>
</head>
<body class="flex flex-col h-screen bg-gray-100 overflow-hidden">

    <header class="bg-white p-3 shadow-md w-full z-10">
        <div class="container mx-auto flex items-center justify-between flex-wrap gap-4">
            <h1 class="text-xl font-bold text-gray-800 hidden sm:block">2D FT Explorer</h1>
            <div class="flex items-center gap-3 flex-wrap">
                <button id="use-upload-btn" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 focus:outline-none ring-blue-500 ring-offset-2 transition-all duration-200">
                    Upload Image
                </button>
                <button id="use-webcam-btn" class="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600 focus:outline-none ring-green-500 ring-offset-2 transition-all duration-200">
                    Use Webcam
                </button>
                <button id="use-function-btn" class="bg-indigo-500 text-white px-4 py-2 rounded-lg hover:bg-indigo-600 focus:outline-none ring-indigo-500 ring-offset-2 transition-all duration-200">
                    Generate Function
                </button>
                 <input type="file" id="image-upload" class="hidden" accept="image/png, image/jpeg">
            </div>
            <div id="status" class="w-full sm:w-auto text-sm text-center text-gray-600 mt-2 sm:mt-0">Select a source to begin.</div>
        </div>
        <div id="function-section" class="hidden container mx-auto mt-4 flex items-center gap-2">
            <select id="function-presets" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2">
                <option value="">Choose a preset...</option>
                <option value="128 * Math.sin(x * 20) + 128">Sine Wave (Vertical)</option>
                <option value="128 * Math.sin(y * 20) + 128">Sine Wave (Horizontal)</option>
                <option value="(Math.sin(x * 20) + Math.sin(y * 20)) * 64 + 128">Crosshatch</option>
                <option value="Math.sqrt(x*x + y*y) < 0.5 ? 255 : 0">Circle Aperture</option>
                <option value="(Math.abs(x) < 0.3 && Math.abs(y) < 0.3) ? 255 : 0">Square Aperture</option>
            </select>
            <input type="text" id="function-input" placeholder="Enter a function of x and y..." class="flex-grow p-2 border rounded-lg">
            <button id="generate-btn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700">Generate</button>
        </div>
    </header>

    <main class="flex-grow p-4 md:p-6 grid grid-cols-1 md:grid-cols-2 gap-6 items-center justify-items-center overflow-auto">
        <div class="w-full flex flex-col items-center">
            <h3 class="text-lg font-semibold text-center mb-3 text-gray-700">Source</h3>
            <div class="canvas-wrapper">
                <video id="webcam-video" class="hidden" autoplay playsinline></video>
                <canvas id="sourceCanvas"></canvas>
            </div>
        </div>
        <div class="w-full flex flex-col items-center">
            <h3 class="text-lg font-semibold text-center mb-3 text-gray-700">Fourier Transform</h3>
            <div class="canvas-wrapper">
                <canvas id="fftCanvas"></canvas>
            </div>
        </div>
    </main>

    <footer class="w-full p-3 bg-white border-t border-gray-200">
        <div class="container mx-auto text-xs text-gray-600 flex justify-between items-center">
            <p>This explorer uses a Radix-2 Fast Fourier Transform (FFT) algorithm and a logarithmic scale for the magnitude.</p>
            <p class="text-right font-medium">NitaD, Univ. Paris-Saclay, 2025</p>
        </div>
    </footer>

    <script>
        // --- DOM Elements ---
        const useUploadBtn = document.getElementById('use-upload-btn');
        const useWebcamBtn = document.getElementById('use-webcam-btn');
        const useFunctionBtn = document.getElementById('use-function-btn');
        const imageUpload = document.getElementById('image-upload');
        const statusEl = document.getElementById('status');
        const webcamVideo = document.getElementById('webcam-video');
        const sourceCanvas = document.getElementById('sourceCanvas');
        const fftCanvas = document.getElementById('fftCanvas');
        const sourceCtx = sourceCanvas.getContext('2d');
        const fftCtx = fftCanvas.getContext('2d');
        const functionSection = document.getElementById('function-section');
        const functionInput = document.getElementById('function-input');
        const functionPresets = document.getElementById('function-presets');
        const generateBtn = document.getElementById('generate-btn');


        // --- Constants ---
        const FFT_SIZE = 256; // Must be a power of 2
        sourceCanvas.width = sourceCanvas.height = FFT_SIZE;
        fftCanvas.width = fftCanvas.height = FFT_SIZE;

        // --- State ---
        let currentMode = null; // 'upload', 'webcam', or 'function'
        let webcamStream = null;
        let sourceImage = new Image();
        let isTransforming = false;
        let animationFrameId = null;

        // --- UI Event Listeners ---
        useUploadBtn.addEventListener('click', () => {
             setupMode('upload');
             imageUpload.click(); // Directly open file dialog
        });
        useWebcamBtn.addEventListener('click', () => setupMode('webcam'));
        useFunctionBtn.addEventListener('click', () => setupMode('function'));
        imageUpload.addEventListener('change', handleImageUpload);
        generateBtn.addEventListener('click', generateFromFunction);
        functionPresets.addEventListener('change', () => {
            if(functionPresets.value) {
                functionInput.value = functionPresets.value;
                generateFromFunction();
            }
        });

        // Initialize default mode
        setupMode('upload');

        // --- Mode Setup ---
        function setupMode(mode) {
            currentMode = mode;
            stopTransformLoop();
            
            const allButtons = [useUploadBtn, useWebcamBtn, useFunctionBtn];
            allButtons.forEach(btn => btn.classList.remove('active-btn'));
            
            // Reset visibility states
            functionSection.classList.add('hidden');
            useFunctionBtn.classList.remove('hidden');

            if (mode === 'upload') {
                stopWebcam();
                webcamVideo.classList.add('hidden');
                sourceCanvas.classList.remove('hidden');
                useUploadBtn.classList.add('active-btn');
                statusEl.textContent = 'Select an image file to begin.';
            } else if (mode === 'webcam') {
                stopWebcam(); // In case it was already running
                useWebcamBtn.classList.add('active-btn');
                startWebcam();
            } else if (mode === 'function') {
                stopWebcam();
                webcamVideo.classList.add('hidden');
                sourceCanvas.classList.remove('hidden');
                functionSection.classList.remove('hidden');
                useFunctionBtn.classList.add('hidden'); // Hide the top-level button as requested
                statusEl.textContent = 'Enter a function or choose a preset.';
            }
        }
        
        // --- Webcam Handling ---
        async function startWebcam() {
            try {
                if (webcamStream) return;
                statusEl.textContent = 'Requesting webcam access...';
                webcamStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                webcamVideo.srcObject = webcamStream;
                webcamVideo.classList.remove('hidden');
                sourceCanvas.classList.add('hidden');
                statusEl.textContent = 'Webcam active. Live transform running...';

                // Automatically start the transform
                isTransforming = true;
                transformLoop();
            } catch (err) {
                console.error("Webcam error:", err);
                statusEl.textContent = 'Could not access webcam.';
                setupMode('upload');
            }
        }

        function stopWebcam() {
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
            }
        }
        
        // --- Image/Function Handling ---
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    sourceImage.src = e.target.result;
                    sourceImage.onload = () => {
                        sourceCanvas.classList.remove('hidden');
                        webcamVideo.classList.add('hidden');
                        statusEl.textContent = 'Processing...';
                        performTransform();
                        statusEl.textContent = 'Transform complete.';
                    };
                };
                reader.readAsDataURL(file);
            }
        }
        
        function generateFromFunction() {
            statusEl.textContent = 'Generating function...';
            const fnBody = functionInput.value;
            if (!fnBody) {
                statusEl.textContent = 'Please enter a function.';
                return;
            }

            try {
                 // Create a safe function using the Function constructor
                const safeFn = new Function('x', 'y', 'Math', `return ${fnBody}`);
                const imageData = sourceCtx.createImageData(FFT_SIZE, FFT_SIZE);
                for (let j = 0; j < FFT_SIZE; j++) {
                    for (let i = 0; i < FFT_SIZE; i++) {
                        const x = (i - FFT_SIZE / 2) / (FFT_SIZE / 2); // Map i to [-1, 1]
                        const y = (j - FFT_SIZE / 2) / (FFT_SIZE / 2); // Map j to [-1, 1]
                        const color = Math.max(0, Math.min(255, safeFn(x, y, Math)));
                        const idx = (j * FFT_SIZE + i) * 4;
                        imageData.data[idx] = color;
                        imageData.data[idx + 1] = color;
                        imageData.data[idx + 2] = color;
                        imageData.data[idx + 3] = 255;
                    }
                }
                sourceCtx.putImageData(imageData, 0, 0);
                
                // Now that the source canvas is ready, transform it
                performTransform();
                statusEl.textContent = 'Transform complete.';
            } catch (e) {
                statusEl.textContent = 'Invalid function. Check syntax.';
                console.error("Function parsing error:", e);
            }
        }

        function drawSourceToCanvas(source) {
            sourceCtx.fillStyle = '#e5e7eb';
            sourceCtx.fillRect(0, 0, FFT_SIZE, FFT_SIZE);
            const sourceW = source.videoWidth || source.width;
            const sourceH = source.videoHeight || source.height;
            const hRatio = FFT_SIZE / sourceW;
            const vRatio = FFT_SIZE / sourceH;
            const ratio = Math.min(hRatio, vRatio);
            const centerShift_x = (FFT_SIZE - sourceW * ratio) / 2;
            const centerShift_y = (FFT_SIZE - sourceH * ratio) / 2;
            sourceCtx.drawImage(source, 0, 0, sourceW, sourceH, centerShift_x, centerShift_y, sourceW * ratio, sourceH * ratio);
        }

        // --- Core Transform Logic ---
        function transformLoop() {
            if (!isTransforming) return;
            performTransform();
            animationFrameId = requestAnimationFrame(transformLoop);
        }
        
        function stopTransformLoop() {
            isTransforming = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function performTransform() {
             if (currentMode === 'webcam') {
                drawSourceToCanvas(webcamVideo);
            } else if (currentMode === 'upload' && sourceImage.src) {
                drawSourceToCanvas(sourceImage);
            } else if (currentMode !== 'function'){
                 return; // Don't run if no valid source
            }

            const imageData = sourceCtx.getImageData(0, 0, FFT_SIZE, FFT_SIZE);
            const grayscaleMatrix = new Array(FFT_SIZE).fill(0).map(() => new Array(FFT_SIZE).fill(0));
            
            for (let y = 0; y < FFT_SIZE; y++) {
                for (let x = 0; x < FFT_SIZE; x++) {
                    const i = (y * FFT_SIZE + x) * 4;
                    grayscaleMatrix[y][x] = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                }
            }

            const complexMatrix = fft2d(grayscaleMatrix);
            fftshift(complexMatrix);

            const magnitudeMatrix = new Array(FFT_SIZE).fill(0).map(() => new Array(FFT_SIZE).fill(0));
            let maxMag = 0;
            for (let y = 0; y < FFT_SIZE; y++) {
                for (let x = 0; x < FFT_SIZE; x++) {
                    const logMag = Math.log(1 + complexMatrix[y][x].magnitude());
                    magnitudeMatrix[y][x] = logMag;
                    if (logMag > maxMag) maxMag = logMag;
                }
            }

            const fftImageData = fftCtx.createImageData(FFT_SIZE, FFT_SIZE);
            for (let y = 0; y < FFT_SIZE; y++) {
                for (let x = 0; x < FFT_SIZE; x++) {
                    const i = (y * FFT_SIZE + x) * 4;
                    const colorVal = maxMag > 0 ? (magnitudeMatrix[y][x] / maxMag) * 255 : 0;
                    fftImageData.data[i] = colorVal;
                    fftImageData.data[i + 1] = colorVal;
                    fftImageData.data[i + 2] = colorVal;
                    fftImageData.data[i + 3] = 255;
                }
            }
            fftCtx.putImageData(fftImageData, 0, 0);
        }

        // --- FFT Implementation ---
        class Complex {
            constructor(re = 0, im = 0) { this.re = re; this.im = im; }
            add(other) { return new Complex(this.re + other.re, this.im + other.im); }
            sub(other) { return new Complex(this.re - other.re, this.im - other.im); }
            mul(other) {
                const re = this.re * other.re - this.im * other.im;
                const im = athis.re * other.im + this.im * other.re;
                return new Complex(re, im);
            }
            magnitude() { return Math.sqrt(this.re * this.re + this.im * this.im); }
        }
        
        function fft1d(x) {
            const N = x.length;
            if (N <= 1) return x;
            const even = fft1d(x.filter((_, i) => i % 2 === 0));
            const odd = fft1d(x.filter((_, i) => i % 2 !== 0));
            const result = new Array(N);
            for (let k = 0; k < N / 2; k++) {
                const angle = -2 * Math.PI * k / N;
                const twiddle = new Complex(Math.cos(angle), Math.sin(angle));
                const t = twiddle.mul(odd[k]);
                result[k] = even[k].add(t);
                result[k + N / 2] = even[k].sub(t);
            }
            return result;
        }

        function fft2d(matrix) {
            const size = matrix.length;
            const complexMatrix = matrix.map(row => row.map(val => new Complex(val, 0)));
            for (let i = 0; i < size; i++) complexMatrix[i] = fft1d(complexMatrix[i]);
            const transposed = transpose(complexMatrix);
            for (let i = 0; i < size; i++) transposed[i] = fft1d(transposed[i]);
            return transpose(transposed);
        }
        
        function transpose(matrix) {
            const size = matrix.length;
            const newMatrix = new Array(size).fill(0).map(() => new Array(size));
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) newMatrix[j][i] = matrix[i][j];
            }
            return newMatrix;
        }

        function fftshift(matrix) {
            const half = Math.floor(matrix.length / 2);
            for (let y = 0; y < half; y++) {
                for (let x = 0; x < half; x++) {
                    [matrix[y][x], matrix[y + half][x + half]] = [matrix[y + half][x + half], matrix[y][x]];
                    [matrix[y][x + half], matrix[y + half][x]] = [matrix[y + half][x], matrix[y][x + half]];
                }
            }
        }

    </script>
</body>
</html>