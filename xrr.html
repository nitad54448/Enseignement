<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XRR Simulator</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.min.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: #f0f0f0;
            color: #e5e7eb;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        #app-container {
            display: flex;
            width: 100%;
            flex-grow: 1;
            min-height: 0;
        }
        #controls-panel {
            width: 420px;
            min-width: 320px;
            max-width: 600px;
            flex-shrink: 0;
            padding: 24px;
            background-color: #111827;
            border-right: 1px solid #374151;
            overflow-y: auto;
            color: #d1d5db;
        }
        #drag-handle {
            width: 6px;
            cursor: col-resize;
            background-color: #374151;
            flex-shrink: 0;
            transition: background-color 0.2s;
        }
        #drag-handle:hover {
            background-color: #3b82f6;
        }
        #visualization-area {
            flex-grow: 1;
            position: relative;
            background-color: #ffffff;
            min-width: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            color: #1f2937;
        }
        #chart-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        #controls-panel h1 { font-size: 1.8em; margin-bottom: 8px; font-weight: 700; color: #ffffff; }
        #controls-panel > p { font-size: 0.9em; margin-bottom: 24px; color: #9ca3af; line-height: 1.5; }
        #controls-panel label { display: block; margin-bottom: 8px; font-weight: 500; color: #9ca3af; }
        #controls-panel input[type="number"], #controls-panel select {
            width: 90px;
            background-color: #374151;
            border: 1px solid #4b5563;
            color: #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.5rem;
        }
        #controls-panel select { width: 100%; }
        #controls-panel input[type="number"] { text-align: right; }

        #controls-panel button {
            background-color: #3b82f6;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            font-weight: 500;
            width: 100%;
        }
        #controls-panel button:hover {
            background-color: #2563EB;
        }
        .control-group { margin-bottom: 1.5rem; }
        .control-row { display: flex; align-items: center; gap: 1rem; }
        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 6px; background: #4b5563;
            border-radius: 3px; outline: none; opacity: 0.8; transition: opacity .2s;
            flex-grow: 1;
        }
        input[type="range"]:hover { opacity: 1; }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 18px; height: 18px; background: #3b82f6;
            cursor: pointer; border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px; height: 18px; background: #3b82f6;
            cursor: pointer; border-radius: 50%; border: 0;
        }
        footer {
            width: 100%;
            background-color: #ffffff;
            padding: 8px 24px;
            text-align: left;
            font-size: 0.8em;
            color: #4b5563;
            border-top: 1px solid #e5e7eb;
            flex-shrink: 0;
        }
        
        .layer-container {
            padding: 1rem;
            border: 1px solid #374151;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            background-color: rgba(255, 255, 255, 0.05);
        }
        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .layer-name-input {
            background: transparent;
            border: none;
            color: white;
            font-size: 1.1em;
            font-weight: 600;
            padding: 4px;
            border-radius: 4px;
            width: 80%;
        }
        .layer-name-input:focus {
            background: #374151;
            outline: 1px solid #3b82f6;
        }
        .remove-layer-btn {
            background-color: #ef4444 !important;
            color: white !important;
            border: none;
            padding: 4px 8px !important;
            border-radius: 50% !important;
            cursor: pointer;
            font-weight: bold;
            line-height: 1;
            width: auto !important;
        }
        .remove-layer-btn:hover {
            background-color: #dc2626 !important;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">
            <p>Wheel or Ctrl+select to zoom, double click to unzoom.</p>
            
            <div class="control-group">
                <h3 class="text-lg font-semibold text-white mb-3 border-b border-gray-700 pb-2">Plot & X-Ray Parameters</h3>
                
                <label for="wavelength" class="mt-4">Wavelength (λ), Å</label>
                <div class="control-row">
                    <input type="range" id="wavelength" min="0.1" max="3" value="1.54" step="0.01">
                    <input type="number" id="wavelength-value" min="0.1" max="3" value="1.54" step="0.01">
                </div>
                
                <label for="plot-type" class="mt-2">Plot Type</label>
                <select id="plot-type">
                    <option value="r2_vs_q" selected>|R|² vs Q</option>
                    <option value="r_vs_q">|R| vs Q</option>
                    <option value="r_vs_theta">|R| vs theta</option>
                    <option value="r_vs_2theta">|R| vs 2theta</option>
                    <option value="porod">Porod (|R|² vs Q⁻⁴)</option>
                </select>
            </div>

            <div id="layers-list"></div>

            <div class="control-group">
                <button id="add-layer-btn">Add Layer</button>
            </div>

            <div class="control-group">
                <h3 class="text-lg font-semibold text-white mb-3 border-b border-gray-700 pb-2">Substrate</h3>
                <label for="substrate-density">e⁻ density (δ related), e⁻/Å³</label>
                <div class="control-row">
                    <input type="range" id="substrate-density" min="0" max="5" value="0.707" step="0.001">
                    <input type="number" id="substrate-density-value" min="0" max="5" value="0.707" step="0.001">
                </div>
                <label for="substrate-beta" class="mt-4">Absorption (β), x 10⁻⁷</label>
                <div class="control-row">
                    <input type="range" id="substrate-beta" min="0" max="100" value="0.00" step="0.01">
                    <input type="number" id="substrate-beta-value" min="0" max="100" value="0.00" step="0.01">
                </div>
            </div>

            <div class="control-group">
                 <button id="save-data-button">Save as .dat</button>
            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="visualization-area">
            <div id="chart-container">
                <canvas id="xrrChart"></canvas>
            </div>
        </div>
    </div>

    <footer class="text-gray-600">
        Parratt formalism with Névot-Croce roughness. NitaD & PLC, Univ Paris-Saclay, updated 17 oct 2025.
    </footer>


    <script>
    document.addEventListener('DOMContentLoaded', () => {
        //  Constants & Complex Math Library ---
        const Complex={create:(re=0,im=0)=>({re,im}),add:(a,b)=>({re:a.re+b.re,im:a.im+b.im}),subtract:(a,b)=>({re:a.re-b.re,im:a.im-b.im}),multiply:(a,b)=>({re:a.re*b.re-a.im*b.im,im:a.re*b.im+a.im*b.re}),divide:(a,b)=>{const d=b.re*b.re+b.im*b.im;return d===0?{re:Infinity,im:Infinity}:{re:(a.re*b.re+a.im*b.im)/d,im:(a.im*b.re-a.re*b.im)/d}},exp:c=>{const e=Math.exp(c.re);return{re:e*Math.cos(c.im),im:e*Math.sin(c.im)}},sqrt:c=>{const r=Math.sqrt(c.re*c.re+c.im*c.im),p=Math.atan2(c.im,c.re),s=Math.sqrt(r);return{re:s*Math.cos(p/2),im:s*Math.sin(p/2)}},magnitudeSq:c=>c.re*c.re+c.im*c.im};
        const CLASSICAL_ELECTRON_RADIUS=2.81794e-5,PI=Math.PI;

        let xrrChart;
        let calculatedData = [];
        
      const customTooltipPlugin = {
    id: 'customTooltip',
    afterEvent: (chart, args) => {
        if (args.event.type === 'mouseout') {
            chart.customCursor = null;
            args.changed = true;
            return;
        }
        
        if (!args.event.type.includes('mouse')) return;
        
        const event = args.event;
        const data = chart.data.datasets[0].data;
        if (data.length === 0) return;
        
        const xValue = chart.scales.x.getValueForPixel(event.x);
        let low = 0, high = data.length - 1;
        while (high - low > 1) {
            let mid = Math.floor((low + high) / 2);
            if (data[mid].x < xValue) { low = mid; } else { high = mid; }
        }
        const closestIndex = (Math.abs(xValue - data[low].x) < Math.abs(data[high].x - xValue)) ? low : high;
        chart.customCursor = { index: closestIndex };
        args.changed = true;
    },
    afterDraw: (chart) => {
        if (!chart.customCursor) return;
        
        const { ctx } = chart;
        const { index } = chart.customCursor;
        const point = chart.data.datasets[0].data[index];
        if (!point) return;

        // point rouge, PLC
        const x = chart.scales.x.getPixelForValue(point.x);
        const y = chart.scales.y.getPixelForValue(point.y);
        const chartArea = chart.chartArea;
        if (x < chartArea.left || x > chartArea.right || y < chartArea.top || y > chartArea.bottom) return;
        
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, 2 * Math.PI);
        ctx.fillStyle = 'red';
        ctx.fill();
        ctx.restore();
        
        // Fixed position coordinates display (top right)
        const textX = `X: ${point.x.toExponential(4)}`;
        const textY = `Y: ${point.y.toExponential(4)}`;
        
        // Set font and measure text
        ctx.font = 'plain 12px Courier, monospace';
        const textXWidth = ctx.measureText(textX).width;
        const textYWidth = ctx.measureText(textY).width;
        const maxTextWidth = Math.max(textXWidth, textYWidth);
        
        // Auto-size box to text width with padding
        const boxPadding = 20;
        const boxWidth = maxTextWidth + boxPadding;
        const boxHeight = 50;
        const boxX = chartArea.right - boxWidth - 20; // 20px from right edge
        const boxY = chartArea.top + 20; // 20px from top edge
        
        // Background box
        ctx.fillStyle = 'rgba(240, 240, 240, 0.9)';
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        ctx.strokeStyle = '#cccccc';
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // Center text horizontally in the box
        const textStartX = boxX + (boxWidth / 2);
        
        // Text
        ctx.fillStyle = '#111827';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText(textX, textStartX, boxY + 12);
        ctx.fillText(textY, textStartX, boxY + 32);
        ctx.restore();
    }
};  
        // --- Core Calculation Engine ---
        function calculateReflectivity(layers, subParams, lambda) {
            const k0 = 2 * PI / lambda;
            const allMaterials = [ { density: 0, beta: 0 }, ...layers.map(l => ({ density: l.density, beta: l.beta })), { density: subParams.density, beta: subParams.beta } ];
            const materialProps = allMaterials.map(m => ({
                delta: (CLASSICAL_ELECTRON_RADIUS * lambda * lambda / (2 * PI)) * m.density,
                beta: m.beta
            }));
            const data = [];
            const qMax = 2.0;
            const qSteps = 2000;
            for (let i = 1; i <= qSteps; i++) {
                const Q = i / qSteps * qMax;
                const theta_sq = (Q / (2 * k0)) * (Q / (2 * k0));
                const kz = materialProps.map(p => {
                    const term_re = theta_sq - 2 * p.delta;
                    const term_im = 2 * p.beta;
                    return Complex.sqrt(Complex.multiply(Complex.create(term_re, term_im), Complex.create(k0 * k0, 0)));
                });
                const N = layers.length;
                let R = Complex.divide(Complex.subtract(kz[N], kz[N + 1]), Complex.add(kz[N], kz[N + 1]));
                if (N > 0) {
                    const sigma_sub = layers[N - 1].roughness;
                    const rough_factor_sub = Math.exp(-2 * kz[N].re * kz[N + 1].re * sigma_sub * sigma_sub);
                    R = Complex.multiply(R, Complex.create(rough_factor_sub, 0));
                }
                for (let j = N - 1; j >= 0; j--) {
                    const k_z_layer = kz[j+1], d_layer = layers[j].thickness;
                    const phaseFactor = Complex.exp(Complex.multiply(Complex.create(0, 2), Complex.multiply(k_z_layer, Complex.create(d_layer, 0))));
                    const k_z_above = kz[j];
                    const r_j_ideal = Complex.divide(Complex.subtract(k_z_above, k_z_layer), Complex.add(k_z_above, k_z_layer));
                    const sigma_j = layers[j].roughness;
                    const rough_factor = Math.exp(-2 * k_z_above.re * k_z_layer.re * sigma_j * sigma_j);
                    const r_j_rough = Complex.multiply(r_j_ideal, Complex.create(rough_factor, 0));
                    const numerator = Complex.add(r_j_rough, Complex.multiply(R, phaseFactor));
                    const denominator = Complex.add(Complex.create(1, 0), Complex.multiply(r_j_rough, Complex.multiply(R, phaseFactor)));
                    R = Complex.divide(numerator, denominator);
                }
                data.push({ q: Q, r_sq: Complex.magnitudeSq(R) });
            }
            return data;
        }
        
        function transformDataForPlotting(data) {
            const plotType = document.getElementById('plot-type').value;
            const lambda = +document.getElementById('wavelength').value;
            switch (plotType) {
                case 'r_vs_q': return data.map(d => ({ x: d.q, y: Math.sqrt(d.r_sq) }));
                case 'r_vs_theta': return data.map(d => { const arg = d.q * lambda / (4 * PI); const theta = arg <= 1 ? Math.asin(arg) * 180 / PI : null; return { x: theta, y: Math.sqrt(d.r_sq) }; }).filter(d => d.x !== null);
                case 'r_vs_2theta': return data.map(d => { const arg = d.q * lambda / (4 * PI); const theta = arg <= 1 ? Math.asin(arg) * 180 / PI : null; return { x: theta !== null ? 2 * theta : null, y: Math.sqrt(d.r_sq) }; }).filter(d => d.x !== null);
                case 'porod': return data.filter(d => d.q > 0.2).map(d => ({ x: Math.pow(d.q, -4), y: d.r_sq }));
                case 'r2_vs_q': default: return data.map(d => ({ x: d.q, y: d.r_sq }));
            }
        }
        
        function initializeChart() {
            const ctx = document.getElementById('xrrChart').getContext('2d');
            xrrChart = new Chart(ctx, {
                type: 'scatter',
                data: { 
                   
                    datasets: [{ 
    data: [], 
    borderColor: '#3b82f6', 
    borderWidth: 2, 
    showLine: true, 
    pointRadius: 0,
    pointHoverRadius: 0, // vide
    hoverRadius: 0, // pas de hover
    hitRadius: 0, 
    fill: false
}]
                },
                plugins: [customTooltipPlugin],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                        elements: {
        point: {
            hoverRadius: 0,
            radius: 0
        }
    },
                    scales: {
                        x: { 
                            type: 'linear', 
                            position: 'bottom', 
                            title: { display: true, text: 'Wavevector transfer Q [Å⁻¹]', font: { size: 16 } },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        y: {
                            type: 'logarithmic',
                            title: { display: true, text: 'Reflectivity |R|²', font: { size: 16 } },
                            min: 1e-10,
                            grid: { 
                                color: (ctx) => {
                                    if (ctx.tick && Math.abs(Math.log10(ctx.tick.value) % 1) < 1e-9) {
                                        return 'rgba(0, 0, 0, 0.1)';
                                    }
                                    return 'transparent';
                                }
                            },
                            ticks: { 
                                callback: (value) => {
                                    if (Math.abs(Math.log10(value) % 1) < 1e-9) {
                                        return value.toExponential(0);
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { 
                            enabled: false, // Disable default tooltip
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'xy',
                            },
                            zoom: {
                                wheel: { 
                                    enabled: true,
                                    speed: 0.1
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'xy',
                                drag: {
                                    enabled: true,
                                    modifierKey: 'ctrl'
                                }
                            },
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        intersect: false,
                               axis: 'x',
                        includeInvisible: false //pour le curseur natif
                    }
                }
            });

            // Double-click to reset zoom
            xrrChart.canvas.addEventListener('dblclick', (e) => {
                e.preventDefault();
                if (xrrChart) xrrChart.resetZoom();
            });
        }
        
        function updateChart() {
            const layers = [];
            document.querySelectorAll('.layer-container').forEach(layerEl => {
                layers.push({
                    thickness: +layerEl.querySelector('input[id^="thickness-"]').value,
                    density: +layerEl.querySelector('input[id^="film-density-"]').value,
                    roughness: +layerEl.querySelector('input[id^="roughness-"]').value,
                    beta: +layerEl.querySelector('input[id^="beta-"]').value / 1e7,
                });
            });
            const subParams = { density: +document.getElementById('substrate-density').value, beta: +document.getElementById('substrate-beta').value / 1e7 };
            const lambda = +document.getElementById('wavelength').value;
            calculatedData = calculateReflectivity(layers, subParams, lambda);
            const plotData = transformDataForPlotting(calculatedData);
            xrrChart.data.datasets[0].data = plotData;
            const plotType = document.getElementById('plot-type').value;
            const options = xrrChart.options;
            let yIsLog = true;
            switch (plotType) {
                case 'r_vs_q': 
                    options.scales.x.title.text = "Wavevector transfer Q [Å⁻¹]"; 
                    options.scales.y.title.text = "Reflectivity |R|"; 
                    break;
                case 'r_vs_theta': 
                    options.scales.x.title.text = "θ [degrees]"; 
                    options.scales.y.title.text = "Reflectivity |R|"; 
                    break;
                case 'r_vs_2theta': 
                    options.scales.x.title.text = "2θ [degrees]"; 
                    options.scales.y.title.text = "Reflectivity |R|"; 
                    break;
                case 'porod': 
                    options.scales.x.title.text = "Q⁻⁴ [Å⁻⁴]"; 
                    options.scales.y.title.text = "Reflectivity |R|²"; 
                    yIsLog = false; 
                    break;
                default: 
                    options.scales.x.title.text = "Wavevector transfer Q [Å⁻¹]"; 
                    options.scales.y.title.text = "Reflectivity |R|²"; 
                    break;
            }
            options.scales.y.type = yIsLog ? 'logarithmic' : 'linear';
            xrrChart.update('none');
            xrrChart.resetZoom('none');
        }

        const layersList = document.getElementById('layers-list');
        function updateLayerIndices() { 
            layersList.querySelectorAll('.layer-container').forEach((div, i) => { 
                const n = div.querySelector('.layer-name-input'); 
                if (n.value.startsWith('Layer ')||n.value==='') n.value = `Layer ${i+1}`; 
            }); 
        }
        
        function createLayer(p = {}) { 
            const { name = '', thickness = 100, density = 2.0, roughness = 5.0, beta = 2.5 } = p; 
            const id = Date.now(), div = document.createElement('div'); 
            div.className = 'layer-container'; 
            div.innerHTML = `
                <div class="layer-header">
                    <input type="text" class="layer-name-input" placeholder="Enter layer name" value="${name}">
                    <button class="remove-layer-btn" title="Remove Layer">&times;</button>
                </div>
                <div>
                    <label for="thickness-${id}">Thickness, Å</label>
                    <div class="control-row">
                        <input type="range" id="thickness-${id}" min="10" max="500" value="${thickness}" step="0.1">
                        <input type="number" id="thickness-value-${id}" min="10" max="500" value="${thickness}" step="0.1">
                    </div>
                </div>
                <div>
                    <label for="film-density-${id}">e⁻ density (δ related), e⁻/Å³</label>
                    <div class="control-row">
                        <input type="range" id="film-density-${id}" min="0.1" max="5" value="${density}" step="0.001">
                        <input type="number" id="film-density-value-${id}" min="0.1" max="5" value="${density}" step="0.001">
                    </div>
                </div>
                <div>
                    <label for="beta-${id}">Absorption (β), x 10⁻⁷</label>
                    <div class="control-row">
                        <input type="range" id="beta-${id}" min="0" max="100" value="${beta}" step="0.1">
                        <input type="number" id="beta-value-${id}" min="0" max="100" value="${beta}" step="0.1">
                    </div>
                </div>
                <div>
                    <label for="roughness-${id}">Interface Roughness (σ), Å</label>
                    <div class="control-row">
                        <input type="range" id="roughness-${id}" min="0" max="20" value="${roughness}" step="0.1">
                        <input type="number" id="roughness-value-${id}" min="0" max="20" value="${roughness}" step="0.1">
                    </div>
                </div>
            `; 
            layersList.appendChild(div); 
            setupLayerControls(div, id); 
            updateLayerIndices(); 
        }
        
        function setupLayerControls(div, id) { 
            const c = [
                { s: `thickness-${id}`, v: `thickness-value-${id}` },
                { s: `film-density-${id}`, v: `film-density-value-${id}` },
                { s: `beta-${id}`, v: `beta-value-${id}` },
                { s: `roughness-${id}`, v: `roughness-value-${id}` }
            ]; 
            c.forEach(p => linkSliderToNumber(p.s, p.v)); 
            div.querySelector('.remove-layer-btn').addEventListener('click', () => { 
                div.remove(); 
                updateLayerIndices(); 
                updateChart(); 
            }); 
        }
        
        function linkSliderToNumber(sId, nId) { 
            const s = document.getElementById(sId), n = document.getElementById(nId); 
            if (!s||!n) return; 
            const st = parseFloat(s.step), p = st < 1 ? (st.toString().split('.')[1]||'').length : 0; 
            s.addEventListener('input', (e) => { 
                n.value = parseFloat(e.target.value).toFixed(p); 
                updateChart(); 
            }); 
            n.addEventListener('change', (e) => { 
                let v = parseFloat(e.target.value); 
                if (isNaN(v)) v = parseFloat(s.min); 
                s.value = Math.min(Math.max(v, s.min), s.max); 
                n.value = v.toFixed(p); 
                updateChart(); 
            }); 
        }
        
        function setupGlobalControls() { 
            linkSliderToNumber('substrate-density', 'substrate-density-value'); 
            linkSliderToNumber('substrate-beta', 'substrate-beta-value'); 
            linkSliderToNumber('wavelength', 'wavelength-value'); 
            document.getElementById('add-layer-btn').addEventListener('click', () => { 
                createLayer(); 
                updateChart(); 
            }); 
            document.getElementById('plot-type').addEventListener('change', updateChart); 
            document.getElementById('save-data-button').addEventListener('click', exportDataFile); 
        }
        
        function exportDataFile(){ 
            const layers = []; 
            document.querySelectorAll('.layer-container').forEach((el, i) => { 
                layers.push({ 
                    name: el.querySelector('.layer-name-input').value||`Layer ${i+1}`, 
                    thickness: +el.querySelector('input[id^="thickness-"]').value, 
                    density: +el.querySelector('input[id^="film-density-"]').value, 
                    beta: +el.querySelector('input[id^="beta-"]').value, 
                    roughness: +el.querySelector('input[id^="roughness-"]').value 
                }); 
            }); 
            const sub = { 
                density: +document.getElementById('substrate-density').value, 
                beta: +document.getElementById('substrate-beta').value 
            }; 
            const lambda = +document.getElementById('wavelength').value; 
            let file = `# Multi-Layer XRR Data\n#\n# Wavelength (A): ${lambda}\n# Substrate e- density (e-/A^3): ${sub.density}\n# Substrate beta (x 10^-7): ${sub.beta}\n#\n`; 
            layers.forEach(l => { 
                file += `# Layer: ${l.name}\n#   Thickness (A): ${l.thickness}\n#   e- density (e-/A^3): ${l.density}\n#   beta (x 10^-7): ${l.beta}\n#   Interface Roughness (A): ${l.roughness}\n`; 
            }); 
            file += `# ---\nQ (A^-1)\tReflectivity\n`; 
            calculatedData.forEach(row => file += `${row.q.toExponential(6)}\t${row.r_sq.toExponential(6)}\n`); 
            const blob = new Blob([file],{type:'text/plain;charset=utf-8;'}); 
            const link = document.createElement("a"), url = URL.createObjectURL(blob); 
            link.setAttribute("href",url); 
            link.setAttribute("download","xrr_multilayer.dat"); 
            link.style.visibility='hidden'; 
            document.body.appendChild(link); 
            link.click(); 
            document.body.removeChild(link); 
        }
        
        const resizer=document.getElementById('drag-handle'),leftPanel=document.getElementById('controls-panel'); 
        let isResizing = false; 
        function handlePanelResize(e){ 
            if(!isResizing) return; 
            const p=resizer.parentElement, w=e.clientX-p.getBoundingClientRect().left; 
            if(w > 300 && w < p.clientWidth-400) leftPanel.style.width=`${w}px`; 
        } 
        function stopPanelResize(){ 
            isResizing=false; 
            document.body.style.cursor='default'; 
            document.body.style.userSelect='auto'; 
            window.removeEventListener('mousemove',handlePanelResize); 
            window.removeEventListener('mouseup',stopPanelResize); 
        } 
        resizer.addEventListener('mousedown', e => { 
            e.preventDefault(); 
            isResizing=true; 
            document.body.style.cursor='col-resize'; 
            document.body.style.userSelect='none'; 
            window.addEventListener('mousemove',handlePanelResize); 
            window.addEventListener('mouseup',stopPanelResize); 
        });
        
        // --- Initialization ---
        initializeChart();
        setupGlobalControls();
        createLayer({ name: 'Layer 1', thickness: 62.8, density: 4.678, roughness: 0.0, beta: 0.0 }); 
        updateChart();
    });
</script>

</body>
</html>