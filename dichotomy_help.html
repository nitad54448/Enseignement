<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dichotomy Indexing - Technical Guide</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    <style>
        :root {
            --dark-bg: #111827;
            --medium-bg: #1f2937;
            --light-bg: #374151;
            --border-color: #4b5563;
            --primary-accent: #3b82f6;
            --text-light: #f3f4f6;
            --text-medium: #d1d5db;
            --text-dark: #9ca3af;
            --content-bg: #ffffff;
            --content-text: #1f2937;
            --content-heading: #111827;
            --code-bg: #f3f4f6;
            --code-text: #111827;
        }
        body {
            font-family: 'Inter', sans-serif; margin: 0; background-color: var(--content-bg);
            color: var(--content-text); line-height: 1.7; display: flex;
            height: 100vh; overflow: hidden;
        }
        #left-panel {
            width: 280px; flex-shrink: 0; background-color: var(--dark-bg);
            color: var(--text-medium); padding: 2rem; overflow-y: auto;
            border-right: 1px solid var(--border-color);
        }
        #left-panel .logo {
            font-size: 1.5rem; font-weight: 700; color: var(--text-light);
            margin-bottom: 2rem;
        }
        #left-panel .logo span { color: var(--primary-accent); }
        #toc { list-style: none; padding: 0; margin: 0; }
        #toc li a {
            display: block; color: var(--text-dark); text-decoration: none;
            padding: 0.6rem 1rem; border-radius: 0.375rem; font-weight: 500;
            font-size: 0.9rem; transition: background-color 0.2s, color 0.2s;
            border-left: 3px solid transparent;
        }
        #toc li a:hover { background-color: var(--medium-bg); color: var(--text-light); }
        #toc li a.active {
            background-color: var(--light-bg); color: var(--text-light);
            border-left-color: var(--primary-accent); font-weight: 600;
        }
        #main-content { flex-grow: 1; overflow-y: auto; padding: 3rem 4rem; }
        section {
            margin-bottom: 4rem; padding-top: 2rem; border-top: 1px solid #e5e7eb;
        }
        section:first-child { padding-top: 0; border-top: none; }
        h1, h2, h3, h4 {
            color: var(--content-heading); font-weight: 700; line-height: 1.3;
            margin-top: 1.5em; margin-bottom: 1em;
        }
        h1 { font-size: 2.5rem; }
        h2 { font-size: 2rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.5rem; }
        h3 { font-size: 1.5rem; }
        h4 { font-size: 1.2rem; }
        p, li { margin-bottom: 1rem; }
        ul, ol { padding-left: 1.5rem; }
        a { color: var(--primary-accent); text-decoration: none; font-weight: 500; }
        a:hover { text-decoration: underline; }
        code {
            font-family: 'Source Code Pro', monospace; background-color: var(--code-bg);
            color: var(--code-text); padding: 0.2em 0.4em;
            border-radius: 0.25rem; font-size: 0.9em;
        }
        pre {
            background-color: var(--code-bg); border-radius: 0.5rem; padding: 1rem;
            overflow-x: auto; font-size: 0.85rem; line-height: 1.5;
        }
        pre code { padding: 0; background: none; }
        blockquote {
            margin-left: 0; padding: 1rem 1.5rem; border-left: 4px solid var(--primary-accent);
            background-color: #f9fafb; color: #4b5563;
        }
        blockquote strong {
            display: block; margin-bottom: 0.5rem; font-weight: 600; color: #111827;
        }
        table {
            width: 100%; border-collapse: collapse; margin-bottom: 1.5rem; font-size: 0.9rem;
        }
        th, td { padding: 0.75rem 1rem; border: 1px solid #d1d5db; text-align: left; }
        th { background-color: #f3f4f6; font-weight: 600; }
        .footer {
            text-align: center; margin-top: 4rem; padding-top: 2rem;
            border-top: 1px solid #e5e7eb; font-size: 0.85rem; color: #6b7280;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #aaa; }
    </style>
</head>
<body>
    <aside id="left-panel">
        <div class="logo">Help Guide: <span>Dichotomy</span></div>
        <nav>
            <ul id="toc">
                <li><a href="#introduction" class="active">Introduction</a></li>
                <li><a href="#quick-start">Quick Start Guide</a></li>
                <li><a href="#ui">The User Interface</a></li>
                <li><a href="#peak-finding">Peak Finding</a></li>
                <li><a href="#indexing-method">The Indexing Method</a></li>
                <li><a href="#evaluating-solutions">Evaluating Solutions</a></li>
                <li><a href="#advanced-topics">Advanced Topics</a></li>
                <li><a href="#troubleshooting">Troubleshooting</a></li>
                <li><a href="#references">References</a></li>
            </ul>
        </nav>
    </aside>

    <main id="main-content">
        <section id="introduction">
            <h1>Introduction to Powder Indexing</h1>
            <p>Welcome to the comprehensive help guide for the Dichotomy Powder Indexing software. This document provides a full overview of the program's features, the underlying scientific principles, and practical advice for achieving reliable results.</p>
            
            <h3>What is Powder X-ray Diffraction?</h3>
            <p>
                Powder X-ray Diffraction (PXRD) is a powerful analytical technique used to determine the atomic and molecular structure of a crystal. When a finely powdered crystalline material is exposed to a monochromatic X-ray beam, the X-rays are scattered by the electrons of the atoms. Due to the periodic arrangement of atoms in the crystal lattice, constructive interference occurs at specific angles, producing a diffraction pattern of sharp peaks (or lines).
            </p>
            <p>
                The positions of these peaks are defined by <strong>Bragg's Law</strong>:
                $$ n\lambda = 2d \sin\theta $$
                where $n$ is an integer (the order of reflection), $\lambda$ is the wavelength of the X-rays, $d$ is the spacing between a specific set of atomic planes in the crystal, and $\theta$ is the angle of diffraction. Each peak in the pattern corresponds to a specific set of atomic planes with a unique $d$-spacing.
            </p>
            
            <h3>What is Unit Cell Indexing?</h3>
            <p>
                The goal of <em>ab initio</em> powder indexing is to determine the dimensions (lattice parameters $a, b, c$) and angles ($\alpha, \beta, \gamma$) of the crystal's fundamental building block—the <strong>unit cell</strong>—using only the positions of the diffraction peaks.
            </p>
            <p>
                This process is called "indexing" because it involves assigning a unique set of three integer Miller indices $(hkl)$ to each observed diffraction peak. These indices describe the orientation of the corresponding atomic planes within the crystal lattice. The relationship between the $d$-spacing, the Miller indices, and the cell parameters depends on the crystal system, as shown by the general quadratic form of Bragg's Law:
                $$ \frac{1}{d_{hkl}^2} = f(a, b, c, \alpha, \beta, \gamma, h, k, l) $$
                Indexing is often the most challenging step in structure determination from powder data, as it involves finding a small set of parameters (the cell geometry) that can account for all the observed peak positions. It is a prerequisite for any further structural analysis.
            </p>
            
            <h3>The Dichotomy Method</h3>
            <p>
                This software implements the <strong>Dichotomy Method</strong>, a powerful and widely-used algorithm for indexing developed by A. Boultif and D. Louër (2004). The method operates by systematically exploring the possible values for unit cell parameters. It does this by assuming that the first few diffraction lines (which have the largest $d$-spacings and thus occur at the lowest $2\theta$ angles) must correspond to simple crystal planes with small Miller indices (e.g., (100), (011), (200)).
            </p>
            <p>
                By assigning these low-integer indices to the first few peaks, it generates trial unit cells. The "dichotomy" aspect refers to its efficient approach of dividing the vast search space for solutions. By making logical assumptions about the first few peaks, it can rapidly test and discard large regions of possibilities, converging on valid solutions much faster than a pure brute-force approach. The algorithm is particularly robust and is considered one of the standard methods for powder indexing.
            </p>
        </section>

        <section id="quick-start">
            <h2>Quick Start Guide</h2>
            <p>Follow these steps to perform a basic indexing routine. This guide assumes you have a clean, single-phase powder pattern.</p>
            <ol>
                <li><strong>Load Data File:</strong> Click the <code>Select Data File</code> button and choose your powder diffraction data. The program supports numerous common formats (e.g., <code>.xy</code>, <code>.xrdml</code>, <code>.ras</code>). The chart will display your pattern.</li>
                <li><strong>Find Peaks:</strong> Navigate to the <strong>Peaks</strong> tab. Adjust the <code>Min peak (%)</code>, <code>Radius (pts)</code>, and <code>Points</code> (for smoothing) sliders until the automatically detected peaks (red markers on the chart) accurately represent your experimental data. Start with the defaults and adjust as needed.</li>
                <li><strong>Review Peaks:</strong> The peak table shows the list of found peaks. Carefully examine this list. Manually edit the 2θ position of any peak for greater accuracy or delete spurious ones (e.g., from noise or Kα2 contamination). Use <code>Ctrl + Click</code> on the chart to add any significant peaks that were missed. A minimum of 4 peaks is required, but 15-20 clean peaks is ideal.</li>
                <li><strong>Set Parameters:</strong> Switch to the <strong>Parameters</strong> tab.
                    <ul>
                        <li>Verify the X-ray <code>Wavelength (Å)</code> is correct for your experiment (e.g., 1.5406 for Cu Kα1).</li>
                        <li>Set a reasonable <code>Max Volume (Å³)</code> for your expected unit cell. This is a crucial parameter to constrain the search and eliminate unrealistic solutions. If you are unsure, you can estimate it based on the chemical formula.</li>
                        <li>Adjust the <code>2θ Error (°)</code> to reflect the quality and resolution of your data (e.g., 0.02° for high-resolution synchrotron, 0.05° for a typical laboratory diffractometer).</li>
                        <li>Select the crystal systems you wish to search. For a completely unknown sample, it's often wise to start with higher symmetry systems (cubic, tetragonal, hexagonal) first before moving to lower symmetries.</li>
                    </ul>
                </li>
                <li><strong>Start Indexing:</strong> Click the <code>Start Indexing</code> button. The progress bar will show the status as the program searches for solutions.</li>
                <li><strong>Analyze Solutions:</strong> Once finished, go to the <strong>Solutions</strong> tab. A table of potential solutions will be displayed, sorted by their figure of merit (M20). A high M20 value (e.g., > 20) indicates a very likely correct solution. Click on a solution to view its calculated peak positions (blue markers) on the chart and visually assess the fit with your observed peaks (red markers).</li>
            </ol>
        </section>
        
        <section id="ui">
            <h2>The User Interface</h2>
            <p>The application is divided into two main panels: the Controls Panel on the left and the Results Area on the right.</p>

            <h3>Controls Panel</h3>
            <p>This panel contains all inputs and controls for the indexing process, organized into three tabs for a clear workflow.</p>
            <h4>1. File Input & Help</h4>
            <ul>
                <li><strong>Select Data File:</strong> This button opens a file dialog to load your experimental data. Supported formats include two-column ASCII (<code>.xy</code>, <code>.csv</code>, <code>.txt</code>), Rigaku (<code>.ras</code>), Bruker (<code>.xrdml</code>, <code>.brml</code>), Philips (<code>.udf</code>, <code>.uxd</code>), and GSAS (<code>.esd</code>).</li>
                <li><strong>Help Icon (?):</strong> Displays a tooltip with basic usage instructions, chart interaction tips, and a link to this full help guide.</li>
            </ul>

            <h4>2. Peaks Tab</h4>
            <p>This tab is dedicated to finding and managing the list of diffraction peaks used for indexing. The quality of this list is paramount for success.</p>
            <ul>
                <li><strong>Peak Finding Sliders:</strong>
                    <ul>
                        <li><code>Min peak (%)</code>: Sets the minimum height threshold for a peak to be detected, relative to the most intense peak in the pattern. This slider uses a logarithmic scale for finer control over weak peaks. Lowering it helps detect smaller peaks but may also pick up more noise.</li>
                        <li><code>Radius (pts)</code>: Defines the window size (in data points) for the rolling-ball algorithm used to subtract the background. Larger values are suitable for patterns with a broad, amorphous background, while smaller values are better for patterns with a flatter background.</li>
                        <li><code>Points</code>: Sets the width for the Savitzky-Golay smoothing filter applied to the data before peak detection. Higher values provide more smoothing (good for noisy data) but can broaden peaks and merge closely spaced reflections.</li>
                    </ul>
                </li>
                <li><strong>2θ Range Sliders:</strong> These sliders (<code>2θ Min</code>, <code>2θ Max</code>) define the angular range in which peaks are detected. This is useful for excluding noisy regions at the start or end of the pattern, or for focusing on a specific area of interest.</li>
                <li><strong>Peak Table:</strong> A list of all detected peaks. You can manually edit the <code>2θ Obs (°)</code> values for higher precision or delete peaks using the 'X' button. The d-spacing is calculated automatically based on the current wavelength.</li>
            </ul>

            <h4>3. Parameters Tab</h4>
            <p>Here you define the core parameters for the Dichotomy search algorithm.</p>
            <ul>
                <li><strong>Wavelength (Å):</strong> The wavelength of the X-ray source. This is critical for correct d-spacing calculation. Common values are ~1.5406 Å for Cu Kα1, ~0.7093 Å for Mo Kα1, or shorter wavelengths for synchrotron sources.</li>
                <li><strong>Max Volume (Å³):</strong> The maximum acceptable unit cell volume for a solution. Setting a realistic value is one of the most effective ways to speed up the search and reduce the number of false solutions.</li>
                <li><strong>2θ Error (°):</strong> This defines the tolerance window for matching calculated peaks to observed peaks, reflecting the instrumental resolution and data quality. Use a smaller value (e.g., 0.01-0.02) for high-resolution data and a larger value (e.g., 0.04-0.06) for standard laboratory data.</li>
                <li><strong>Impurity Peaks:</strong> The number of allowed un-indexed peaks among the first 20 observed peaks when calculating the M(20) figure of merit. Set this to 1 or 2 if you suspect minor impurities.</li>
                <li><strong>Refine Zero-Point Error:</strong> If checked, the program will simultaneously refine a zero-point correction along with the lattice parameters. This is highly recommended for high-quality work.</li>
                <li><strong>Crystal Systems to Search:</strong> Checkboxes to select which symmetries to search for (Cubic, Tetragonal, Hexagonal, Orthorhombic, Monoclinic).</li>
            </ul>
            
            <h4>4. Solutions Tab</h4>
            <p>This tab displays the results of the indexing process.</p>
            <ul>
                <li><strong>Solutions Table:</strong> Lists all valid solutions found, showing their crystal system, refined lattice parameters, cell volume, and M(20) figure of merit. The table can be sorted by clicking on the headers.</li>
                <li><strong>Selection:</strong> Clicking on a row in the table selects that solution, overlaying its calculated peak positions on the chart for visual inspection. This is a critical step for validating a potential solution.</li>
            </ul>

            <h3>Results Area</h3>
            <p>This area provides a visual representation of your data and the indexing results.</p>
            <ul>
                <li><strong>Chart:</strong> Displays the powder diffraction pattern. The Y-axis uses a logarithmic scale to make weak peaks more visible.
                    <ul>
                        <li><strong>Experimental Data:</strong> The raw data shown as a line plot.</li>
                        <li><strong>Observed Peaks:</strong> Short red tick marks below the pattern indicate the positions of the peaks you are using for indexing.</li>
                        <li><strong>Calculated Peaks:</strong> When a solution is selected from the Solutions table, longer blue tick marks appear, showing the calculated peak positions for that unit cell. A good solution will have blue ticks that align almost perfectly with the red ticks.</li>
                    </ul>
                </li>
                <li><strong>Chart Interaction:</strong>
                    <ul>
                        <li><strong>Zoom:</strong> Use the mouse wheel over the chart. The zoom will be centered on your mouse cursor position, allowing for precise inspection of specific regions.</li>
                        <li><strong>Pan:</strong> Click and drag the chart to pan the view.</li>
                        <li><strong>Reset Zoom:</strong> Right-click anywhere on the chart to reset the zoom to the full pattern.</li>
                        <li><strong>Add Peak:</strong> Hold the <code>Ctrl</code> key and click on the pattern to manually add a peak at that 2θ position.</li>
                    </ul>
                </li>
            </ul>
        </section>

        <section id="peak-finding">
            <h2>Peak Finding in Detail</h2>
            <p>Accurate peak positions are the single most important input for a successful indexing. Garbage in, garbage out. This program uses a robust, multi-step process to identify peaks from the raw data.</p>
            
            <h4>The Algorithm Steps</h4>
            <ol>
                <li><strong>Background Subtraction:</strong> A "rolling ball" algorithm is used to estimate the background signal. Imagine a virtual ball of a specified <code>Radius</code> rolling along the bottom of your data. The path it traces forms the background curve, which is then subtracted from the raw data. This is particularly effective at removing broad features like amorphous humps.</li>
                <li><strong>Data Smoothing:</strong> To reduce high-frequency noise without significantly distorting the peaks, a Savitzky-Golay smoothing filter is applied to the background-subtracted data. This is a digital filter that fits a small window of adjacent data points to a polynomial, effectively smoothing the data while preserving the shape and position of the peaks better than a simple moving average. The <code>Points</code> slider controls the size of this window.</li>
                <li><strong>Peak Detection:</strong> The algorithm scans the smoothed data for local maxima (points that are higher than their immediate neighbors). A point is only considered a peak if its intensity is above the threshold set by the <code>Min peak (%)</code> slider and an adaptive noise-level calculation.</li>
                <li><strong>Position Refinement:</strong> The integer data point of the maximum is often not the true peak center. To find a more precise position, a parabola is fitted to the top three points of the detected maximum. The vertex of this fitted parabola provides a sub-pixel-accuracy estimate of the true peak position, which is crucial for high-precision indexing.</li>
            </ol>
            
            <h4>Practical Advice for Peak Finding</h4>
            <ul>
                <li>Start with default slider values and visually inspect the detected peaks on the chart.</li>
                <li>If weak but clear peaks are being missed, lower the <code>Min peak (%)</code> threshold. If you are picking up a lot of noise, increase it.</li>
                <li>If the background is not being subtracted well (especially for patterns with broad amorphous contributions), increase the <code>Radius</code>. For a pattern with a mostly flat background, a smaller radius is sufficient.</li>
                <li>If your data is very noisy, increase the smoothing <code>Points</code>. Be careful not to over-smooth, as this can merge adjacent peaks or shift their positions slightly.</li>
                <li><strong>Always visually inspect the final peak list.</strong> Remove any peaks that are clearly noise, artefacts (like Kα2 shoulders if they haven't been stripped), or belong to a known impurity phase. The quality of your indexing depends entirely on the quality of your peak list.</li>
            </ul>
        </section>

        <section id="indexing-method">
            <h2>The Indexing Method: Mathematical Foundations</h2>
            <p>The core of the program is the Dichotomy search algorithm, which aims to solve the fundamental equation of powder diffraction relating peak positions ($Q_{obs}$) to Miller indices ($h,k,l$) and unit cell parameters.</p>

            <h4>From 2θ to Q-space</h4>
            <p>The first step is to convert the list of observed 2θ peak positions into a list of $Q$ values. $Q$ is defined as the reciprocal of the d-spacing squared ($1/d^2$), and working in Q-space linearizes the indexing equations.</p>
            $$ Q_{obs} = \frac{1}{d^2} = \left( \frac{2\sin\theta}{\lambda} \right)^2 $$
            <p>The indexing problem is now to find unit cell parameters that generate a set of theoretical $Q_{calc}$ values that match the $Q_{obs}$ list.</p>
            
            <h4>The Principle of Dichotomy</h4>
            <p>
                The Dichotomy method works by assuming that the first few lines in the pattern (lowest 2θ, highest d-spacing) correspond to reflections with small Miller indices (e.g., (100), (110), (111)). The algorithm exhaustively tries all combinations of plausible (hkl) assignments for a small number of initial peaks.
            </p>
            <p>
                For each trial assignment, a set of linear equations is formed and solved to yield a trial unit cell. For example, in the orthorhombic system, the equation is:
                $$ Q_{hkl} = h^2\left(\frac{1}{a^2}\right) + k^2\left(\frac{1}{b^2}\right) + l^2\left(\frac{1}{c^2}\right) = h^2A + k^2B + l^2C $$
                where $A, B, C$ are the unknown reciprocal lattice parameters. If we assign three observed peaks ($Q_1, Q_2, Q_3$) to three sets of Miller indices ($(h_1k_1l_1), (h_2k_2l_2), (h_3k_3l_3)$), we get a system of three linear equations with three unknowns (A, B, C), which can be solved directly.
            </p>
            <p>
                Once a trial cell is generated, it is immediately tested by calculating all its theoretical reflections up to the 20th observed peak. If it fails to index a sufficient number of these peaks within the given tolerance, it is discarded. This rapid testing and discarding is what makes the method so efficient.
            </p>

            <h4>System-by-System Search Logic</h4>
            <ul>
                <li><strong>Cubic (1 parameter, $a$):</strong> The simplest case, requiring only one unknown ($A=1/a^2$). The ratio of Q-values for a cubic cell should correspond to ratios of integers ($h^2+k^2+l^2$). Each of the first few peaks is used to propose a trial value for $a$.</li>
                <li><strong>Tetragonal & Hexagonal (2 parameters, $a, c$):</strong> Requires two assigned peaks to solve for the two unknown reciprocal parameters ($A=1/a^2, C=1/c^2$). The program loops through pairs of observed peaks and assigns them all plausible low-integer (hkl) pairs to generate trial cells.</li>
                <li><strong>Orthorhombic (3 parameters, $a, b, c$):</strong> Requires three assigned peaks to solve for the three reciprocal parameters ($A, B, C$).</li>
                <li><strong>Monoclinic (4 parameters, $a, b, c, \beta$):</strong> The most complex case searched by this program. It requires four assigned peaks to solve for the four reciprocal parameters ($A, B, C, D$) in the equation: $Q_{hkl} = h^2A + k^2B + l^2C + hlD$.</li>
            </ul>
        </section>

        <section id="evaluating-solutions">
            <h2>Evaluating Solutions</h2>
            <p>The Dichotomy search often produces multiple candidate solutions. Distinguishing the correct one from spurious mathematical fits requires a reliable figure of merit and careful refinement.</p>
            
            <h3>The de Wolff Figure of Merit: M(20)</h3>
            <p>
                The primary metric used to rank solutions is the de Wolff Figure of Merit, M(20). It provides a single, robust value that assesses the quality of a fit by considering both the accuracy of the indexing and the completeness of the solution. The formula is:
                $$ M(N) = \frac{Q_N}{2 \cdot \overline{|\Delta Q|} \cdot N_{calc}} $$
                In this program, $N=20$, which is the standard number of peaks to use for the evaluation.
            </p>
            <ul>
                <li>$Q_N$ is the Q-value of the N-th (20th) <em>observed</em> peak.</li>
                <li>$\overline{|\Delta Q|}$ is the average absolute difference between observed and calculated Q-values ($\overline{|Q_{obs} - Q_{calc}|}$) for all indexed peaks up to $Q_N$. This term measures the accuracy of the fit. A smaller average difference leads to a higher M(20).</li>
                <li>$N_{calc}$ is the number of <em>calculated</em>, crystallographically unique theoretical peaks up to the position of $Q_N$. This term penalizes solutions that are "too dense"—that is, a cell that predicts many more lines than are actually observed. By correctly counting all symmetry-equivalent reflections that contribute to a single diffraction line, this value provides a crucial guard against cells that are sub-multiples of the true cell.</li>
            </ul>
            <h4>Interpretation of M(20) Values</h4>
            <table>
                <thead><tr><th>M(20) Value</th><th>Interpretation</th></tr></thead>
                <tbody>
                    <tr><td>> 20</td><td>The solution is very likely to be correct.</td></tr>
                    <tr><td>> 10</td><td>The solution is likely correct, especially if the volume is chemically sensible.</td></tr>
                    <tr><td>> 5</td><td>The solution is plausible and deserves further investigation (e.g., Le Bail fitting).</td></tr>
                    <tr><td>&lt; 5</td><td>The solution is possibly spurious or based on poor quality data and should be viewed with skepticism.</td></tr>
                </tbody>
            </table>
            <p>The program also accounts for a user-defined number of <code>Impurity Peaks</code>. These are peaks within the first 20 that are allowed to be un-indexed without invalidating the solution or penalizing the M(20) calculation.
            </p>

            <h3>Least-Squares Refinement</h3>
            <p>
                The initial trial cell from the Dichotomy search is a good first guess. To improve its accuracy, the program performs a linear least-squares refinement on every promising candidate. It takes all the peaks that were successfully indexed by the trial cell and uses them to re-calculate the reciprocal lattice parameters that minimize the overall difference between $Q_{obs}$ and $Q_{calc}$. This is achieved by solving the normal equations of the linear system in matrix form: $(M^T M)x = M^T q$. Here, $M$ is the matrix of squared Miller indices, $q$ is the vector of observed $Q$ values, and $x$ is the vector of reciprocal lattice parameters to be solved. This results in the final, high-precision lattice parameters reported in the solutions table.
            </p>

            <h3>Zero-Point Error Refinement</h3>
            <p>
                A "zero-point error" is a common instrumental artifact caused by a slight misalignment of the sample from the center of the goniometer. It results in a systematic shift of all peak positions ($\Delta 2\theta$), which can severely hamper or prevent successful indexing.
            </p>
            <p>
                When the <code>Refine Zero-Point Error</code> option is enabled, the program employs a robust two-step approach with a fallback mechanism to ensure stability.
            </p>
            <ol>
                <li><strong>Step 1: Baseline Cell Refinement.</strong> The program first performs a least-squares refinement on <strong>only the lattice parameters</strong>. This initial step provides a stable, high-quality "baseline" unit cell. This solution is always kept as a reliable fallback.</li>
                <li><strong>Step 2: Attempt Full Refinement.</strong> The program then uses the superior baseline cell from Step 1 to perform a more accurate re-indexing of the observed peaks. With this higher-quality set of (hkl) assignments, it attempts a second, more comprehensive least-squares refinement that solves for both the lattice parameters and the zero-point error simultaneously.</li>
                <li><strong>Fallback Logic.</strong> If this second, more complex refinement is successful and stable, the program uses this new, more accurate solution. However, if the full refinement fails for any reason (e.g., not enough stable peaks for the fit), the program **gracefully falls back** and uses the reliable baseline solution from Step 1.</li>
            </ol>
            <p>This method ensures that a valid solution is never discarded just because the zero-error refinement proves to be unstable. If the fallback occurs, the solution will be listed without a zero-point correction, and the PDF report will note that it could not be reliably refined.</p>
        </section>

        <section id="advanced-topics">
            <h2>Advanced Topics</h2>
            
            <h3>Advanced Search and Sieving Strategies</h3>
            <p>
                To improve the chances of finding the correct solution, especially in non-standard settings, the program employs several advanced search strategies. These are not just post-processing filters; they are integrated into the worker's search routine to generate new candidate cells.
            </p>
             <h4>1. Matrix-based Cell Transformations</h4>
            <p>The worker takes the initial set of promising solutions and applies a series of transformation matrices ($P$) to their metric tensors ($G$) to test for smaller, primitive cells or other common relationships ($G' = P^T G P$). Each new cell generated this way is treated as a fresh candidate and is subjected to a **full least-squares refinement and M(20) evaluation** to verify its quality.</p>
            <table>
                <thead><tr><th>Transformation Name</th><th>Purpose</th><th>Transformation Matrix ($P$)</th></tr></thead>
                <tbody>
                    <tr>
                        <td><code>fcc_prim</code></td>
                        <td>Finds the primitive rhombohedral cell within a Face-centered (F) cell.</td>
                        <td>$ \begin{pmatrix} 0 & 0.5 & 0.5 \\ 0.5 & 0 & 0.5 \\ 0.5 & 0.5 & 0 \end{pmatrix} $</td>
                    </tr>
                    <tr>
                        <td><code>bcc_prim</code></td>
                        <td>Finds the primitive cell within a Body-centered (I) cell.</td>
                        <td>$ \begin{pmatrix} -0.5 & 0.5 & 0.5 \\ 0.5 & -0.5 & 0.5 \\ 0.5 & 0.5 & -0.5 \end{pmatrix} $</td>
                    </tr>
                </tbody>
            </table>
            <h4>2. HKL Divisor Analysis</h4>
            <p>
                The worker examines the list of indexed Miller indices for a given solution. If all indices in one direction (e.g., all $h$ values) share a common integer divisor greater than 1, it may indicate that the true unit cell axis is smaller. For example, if all indexed reflections have an even $h$ index, the program will test a new cell with its $a$-axis halved. This new candidate is then fully refined and scored.
            </p>
            <h4>3. Orthorhombic to Hexagonal Check</h4>
            <p>
                A hexagonal lattice can be described by a C-centered orthorhombic cell where the ratio of two axes is approximately $\sqrt{3}$. The program specifically checks all orthorhombic solutions for this condition (e.g., $b/a \approx \sqrt{3}$). If found, it generates the equivalent hexagonal cell and passes it through the full refinement and evaluation pipeline.
            </p>
            <h4>4. Final Sieving</h4>
            <p>
                After the worker has completed all searches and returned a comprehensive list of fully refined solutions, a final sieving process is applied. The list is sorted, and if two solutions have very similar volumes, the one with higher symmetry and a better M(20) is preferred, and the lower-quality one is discarded as redundant. This helps to simplify the final solution list.
            </p>
        </section>
        
        <section id="troubleshooting">
            <h2>Troubleshooting & FAQ</h2>
            
            <h4>Why did I get no solutions?</h4>
            <ul>
                <li><strong>Poor Peak List:</strong> This is the most common reason. Ensure your peak list is accurate. Remove impurity peaks, check for missed peaks, and make sure the positions are precise. You need at least 4 peaks for the simplest system, but 15-20 clean peaks is a much better starting point.</li>
                <li><strong>Incorrect Parameters:</strong> Double-check the <code>Wavelength</code>. Ensure the <code>Max Volume</code> is large enough to contain your unit cell. An unrealistically small volume will cause the correct solution to be missed.</li>
                <li><strong>High Zero-Point Error:</strong> If your instrument is misaligned, the peak positions might be too shifted for the algorithm to succeed without correction. Try running the indexing again with the <code>Refine Zero-Point Error</code> box checked.</li>
                <li><strong>Sample is a Mixture:</strong> If the sample contains multiple crystalline phases, the peak list will be a combination from different unit cells, making indexing impossible without first isolating the peaks of a single phase.</li>
            </ul>

            <h4>Why is my M(20) value low even if the fit looks good?</h4>
            <ul>
                <li><strong>Incorrect Cell (Sub-multiple/Super-multiple):</strong> You may have found a cell that is a multiple or sub-multiple of the true cell. It will index some lines correctly but will be penalized in the M(20) calculation for either being too "empty" or too "dense" with calculated reflections. The program's use of unique HKLs for the $N_{calc}$ term helps to mitigate this, but it is not foolproof.</li>
                <li><strong>High Error / Low Resolution:</strong> If your peaks are very broad, the <code>2θ Error</code> might be set too tight, causing the program to incorrectly count peaks as "un-indexed." Try slightly increasing the error value.</li>
                <li><strong>The solution is simply wrong.</strong> A spurious solution can sometimes appear to fit a few lines by chance. Even with a decent M(20), visual inspection is key. If the calculated pattern (blue ticks) clearly misses major observed peaks (red ticks), the solution is incorrect.</li>
            </ul>
            
            <h4>What does "Derived from orth (b/a≈√3)" mean?</h4>
            <p>
                This indicates that the program first found a valid orthorhombic solution. During its advanced search phase, it noticed that the ratio of two lattice parameters (in this case, b/a) was very close to $\sqrt{3} \approx 1.732$. This is a special condition that often means the true symmetry is hexagonal. The program then tested this hypothesis, generated the equivalent hexagonal cell, and found it was also a valid (and higher-symmetry) solution, which was then added to the list.
            </p>
        </section>

        <section id="references">
            <h2>References</h2>
            <p>This program was developed by Nita Dragoe at Université Paris-Saclay (2024-2025) as a successor to a prior software, Powder 4, originally created by the same author in 1999-2000. The current version implements the dichotomy algorithm proposed by A. Boultif and D. Louër, building upon the foundational work of numerous crystallographers. For a deeper understanding of the methodology, consulting the original scientific papers is highly recommended.</p>
            <ol>
                <li>
                    <strong>The Dichotomy Method:</strong><br>
                    Boultif, A. & Louër, D. (2004). "Powder pattern indexing with the dichotomy method." <em>Journal of Applied Crystallography</em>, <strong>37</strong>, 724-731.
                </li>
                 <li>
                    <strong>The M(20) Figure of Merit:</strong><br>
                    de Wolff, P. M. (1968). "A Simplified Criterion for the Reliability of a Powder Pattern Indexing." <em>Journal of Applied Crystallography</em>, <strong>1</strong>, 108-113.
                </li>
                <li>
                    <strong>General Powder Diffraction Text:</strong><br>
                    Klug, H. P. & Alexander, L. E. (1974). <em>X-Ray Diffraction Procedures for Polycrystalline and Amorphous Materials</em>, 2nd ed. New York: Wiley-Interscience.
                </li>
                <li>
                    <strong>Alternative Indexing Methods:</strong><br>
                     Werner, P.-E., Eriksson, L., & Westdahl, M. (1985). "TREOR, a semi-exhaustive trial-and-error powder indexing program for all symmetries." <em>Journal of Applied Crystallography</em>, <strong>18</strong>, 367-370.<br>
                     Visser, J. W. (1969). "A fully automatic program for finding the unit cell from powder data." <em>Journal of Applied Crystallography</em>, <strong>2</strong>, 89-95.<br>
                     Le Bail, A. (2004). "Monte Carlo Indexing with McMaille". <em>Powder Diffraction</em>, <strong>19(3)</strong>, 249-254.<br>
                    </li>
            </ol>
            <div class="footer">
                <p>Help Guide updated on 14 Oct 2025 by an AI assistant.</p>
            </div>
        </section>

    </main>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const sections = document.querySelectorAll('section');
        const navLinks = document.querySelectorAll('#toc a');
        const mainContent = document.getElementById('main-content');

        // This observer handles highlighting when you scroll manually.
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.getAttribute('id');
                    
                    navLinks.forEach(link => {
                        link.classList.remove('active');
                    });

                    const activeLink = document.querySelector(`#toc a[href="#${id}"]`);
                    if (activeLink) {
                        activeLink.classList.add('active');
                    }
                }
            });
        }, { 
            root: mainContent, 
            rootMargin: "0px 0px -80% 0px" // Triggers when a section enters the top 20% of the view
        });

        sections.forEach(section => {
            observer.observe(section);
        });

        // This click handler provides an immediate highlight update when a link is clicked.
        navLinks.forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();

                // 1. Immediately remove active class from all links
                navLinks.forEach(l => l.classList.remove('active'));

                // 2. Immediately add active class to the clicked link
                this.classList.add('active');

                // 3. Scroll to the correct section
                const targetId = this.getAttribute('href');
                const targetSection = document.querySelector(targetId);
                
                targetSection.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            });
        });
    });
</script>

</body>
</html>