<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystallographic Direction Visualizer [uvw]</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background-color: #eef1f5;
            color: #333;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        .main-wrapper {
            padding: 20px;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-height: 0;
        }
        .panel {
             background-color: #fff;
             padding: 20px;
             border-radius: 10px;
             box-shadow: 0 4px 15px rgba(0,0,0,0.1);
             height: 100%;
             box-sizing: border-box;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-top: 0;
            margin-bottom: 20px;
            flex-shrink: 0;
        }
        h3 {
            margin-top: 15px; margin-bottom: 10px; border-bottom: 1px solid #4B5563;
            padding-bottom: 5px; font-size: 1em; font-weight: 600; color: #D1D5DB;
        }
        .page-container {
            display: flex;
            flex-direction: row;
            align-items: stretch;
            flex-grow: 1;
            min-height: 0;
            background-color: #101828;
        }
        .left-panel {
            flex: 0 0 300px;
            min-width: 200px;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            border-radius: 10px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: row;
            gap: 20px;
            min-width: 0;
            background-color: #eef1f5;
        }
        .right-panel .panel {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }
        .resizer {
            flex: 0 0 6px;
            background: #d1d5db;
            cursor: col-resize;
            border-left: 1px solid #b1b5bb;
            border-right: 1px solid #b1b5bb;
            transition: background-color 0.2s;
        }
        .resizer:hover {
            background: #9ca3af;
        }
        .controls-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
            flex-grow: 1;
        }
        .control-group, .input-group { display: flex; flex-direction: column; }
        label { margin-bottom: 8px; font-weight: 600; font-size: 0.9em;}
        select, input[type="range"], input[type="number"], button {
            font-size: 0.9em; box-sizing: border-box; width: 100%;
        }
        input[type="range"] { padding: 0; margin-top: 5px; margin-bottom: 8px;}
        .canvas-container { margin-bottom: 10px; flex-grow: 1; position: relative; }
        #threejs-container { width: 100%; height: 100%; }
        #threejs-container canvas { border-radius: 5px; }

        .legend {
            margin-top: 15px;
            padding: 12px;
            font-size: 0.9em;
            flex-shrink: 0;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            font-family: 'Courier New', Courier, monospace;
            line-height: 1.5;
        }
        footer {
            text-align: center;
            font-size: 0.8em;
            color: #555;
            padding: 5px 20px;
            flex-shrink: 0;
            background-color: #eef1f5;
        }
        .left-panel .panel {
             background: none; box-shadow: none; padding: 0;
        }
        .left-panel label {
            color: #D1D5DB;
        }
        .left-panel select, .left-panel input[type="number"] {
            background-color: #1F2937;
            border: 1px solid #4B5563;
            color: #F9FAFB;
            border-radius: 5px;
            padding: 9px;
        }
        .left-panel input[type="range"] {
            -webkit-appearance: none; appearance: none;
            background: transparent; cursor: pointer;
        }
        .left-panel input[type="range"]::-webkit-slider-runnable-track {
            background: #374151; height: 6px; border-radius: 3px;
        }
        .left-panel input[type="range"]::-moz-range-track {
            background: #374151; height: 6px; border-radius: 3px;
        }
        .left-panel input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; margin-top: -5px;
            background-color: #3B82F6; height: 16px; width: 16px; border-radius: 50%;
        }
         .left-panel input[type="range"]::-moz-range-thumb {
            border: none; background-color: #3B82F6;
            height: 16px; width: 16px; border-radius: 50%;
        }
        #resize-ghost {
            position: fixed; top: 0; height: 100vh; width: 4px;
            background-color: rgba(59, 130, 246, 0.5); display: none;
            z-index: 9999; cursor: col-resize;
        }
        .uvw-group { display: flex; gap: 8px; }
        .uvw-group .input-group { flex: 1; }
        .uvw-group input { text-align: center; }
    </style>
</head>
<body>

    <div class="main-wrapper">
        <h1>Crystallographic Direction Visualizer [uvw]</h1>
        <div class="page-container">
            <div class="left-panel" id="left-panel">
                <div class="controls-container">
                    <div class="control-group">
                        <label for="crystalSystem">Crystal System:</label>
                        <select id="crystalSystem">
                            <option value="cubic" selected>Cubic</option>
                            <option value="tetragonal">Tetragonal</option>
                            <option value="orthorhombic">Orthorhombic</option>
                            <option value="hexagonal">Hexagonal</option>
                            <option value="trigonal">Trigonal (Rhombohedral)</option>
                            <option value="monoclinic">Monoclinic</option>
                            <option value="triclinic">Triclinic</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label for="centering">Centering:</label>
                        <select id="centering"></select>
                    </div>

                    <h3>Direction Indices [u v w]</h3>
                    <div class="uvw-group">
                        <div class="input-group">
                            <label for="u" class="sr-only">u</label>
                            <input type="number" id="u" value="1" step="1" oninput="this.value = parseInt(this.value) || 0">
                        </div>
                        <div class="input-group">
                            <label for="v" class="sr-only">v</label>
                            <input type="number" id="v" value="1" step="1" oninput="this.value = parseInt(this.value) || 0">
                        </div>
                        <div class="input-group">
                            <label for="w" class="sr-only">w</label>
                            <input type="number" id="w" value="1" step="1" oninput="this.value = parseInt(this.value) || 0">
                        </div>
                    </div>

                    <h3>Display Options</h3>
                    <div class="control-group">
                       <label for="viewType">View Type:</label>
                       <select id="viewType">
                           <option value="perspective">Perspective (Iso)</option>
                           <option value="orthographic" selected>Orthographic</option>
                       </select>
                   </div>
                    <div class="control-group">
                       <label for="nodeSize">Node Size:</label>
                       <input type="range" id="nodeSize" min="0.05" max="0.4" step="0.01" value="0.15">
                   </div>
                </div>
            </div>
            <div class="resizer" id="draghandle"></div>
            <div class="right-panel">
                <div class="panel">
                    <div class="canvas-container" id="threejs-container"></div>
                    <div id="info" class="legend">Direction: [1 1 1]</div>
                </div>
            </div>
        </div>
    </div>
    <div id="resize-ghost"></div>

    <footer>
        <p>NitaD, Univ Paris-Saclay, version 4 juin 2025.</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script type="module">
        // --- Global Variables ---
        let scene, camera, renderer, controls, perspectiveCamera, orthographicCamera;
        let crystalGroup = new THREE.Group(); // Parent group for rotation
        let unitCellGroup = new THREE.Group();
        let latticeNodesGroup = new THREE.Group();
        let directionVectorGroup = new THREE.Group();
        const FONT_URL = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json';
        let font;

        // --- Data ---
        const centeringOptions = {
            triclinic: ["P"],
            monoclinic: ["P", "C"],
            orthorhombic: ["P", "C", "I", "F"],
            tetragonal: ["P", "I"],
            trigonal: ["P", "R"],
            hexagonal: ["P"],
            cubic: ["P", "I", "F"]
        };

        // --- DOM Elements ---
        const dom = {
            container: document.getElementById('threejs-container'),
            system: document.getElementById('crystalSystem'),
            centering: document.getElementById('centering'),
            info: document.getElementById('info'),
            viewType: document.getElementById('viewType'),
            nodeSize: document.getElementById('nodeSize'),
            uvw: {
                u: document.getElementById('u'),
                v: document.getElementById('v'),
                w: document.getElementById('w'),
            }
        };

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x777777);
            scene.add(crystalGroup); // Add parent group to scene
            crystalGroup.add(unitCellGroup, latticeNodesGroup, directionVectorGroup); // Add children to parent
            
            const container = dom.container;
            const aspect = container.clientWidth / container.clientHeight;

            // Cameras
            perspectiveCamera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
            perspectiveCamera.position.set(8, 7, 9);
            
            const frustumSize = 15;
            orthographicCamera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            orthographicCamera.position.set(8, 7, 9);
            
            camera = orthographicCamera // Set initial camera

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Font Loader
            const fontLoader = new THREE.FontLoader();
            fontLoader.load(FONT_URL, (loadedFont) => {
                font = loadedFont;
                updateCenteringOptions(); // Initial call
            });
            
            // Event Listeners
            dom.system.addEventListener('change', updateCenteringOptions);
            dom.centering.addEventListener('change', updateScene);
            Object.values(dom.uvw).forEach(input => input.addEventListener('input', updateScene));
            dom.viewType.addEventListener('change', switchCameraView);
            dom.nodeSize.addEventListener('input', updateScene);
            
            // Observe container resize
            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    const { width, height } = entry.contentRect;
                    if (width > 0 && height > 0) {
                        renderer.setSize(width, height);
                        const aspect = width / height;

                        perspectiveCamera.aspect = aspect;
                        perspectiveCamera.updateProjectionMatrix();

                        const frustumSize = 15;
                        orthographicCamera.left = frustumSize * aspect / -2;
                        orthographicCamera.right = frustumSize * aspect / 2;
                        orthographicCamera.top = frustumSize / 2;
                        orthographicCamera.bottom = frustumSize / -2;
                        orthographicCamera.updateProjectionMatrix();
                    }
                }
            });
            resizeObserver.observe(container);

            // Start Animation Loop
            animate();
        }

        // --- Core Functions ---
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // Labels face the camera, compensating for parent rotation
            unitCellGroup.children.forEach(child => {
                if (child.isMesh && child.geometry.type === 'TextGeometry') {
                    // CORRECTED: The order of multiplication is fixed here.
                    const invParentQuat = crystalGroup.quaternion.clone().invert();
                    child.quaternion.copy(invParentQuat).multiply(camera.quaternion);
                }
            });
            renderer.render(scene, camera);
        }

        function switchCameraView() {
            const currentPos = new THREE.Vector3();
            const currentQuat = new THREE.Quaternion();
            camera.getWorldPosition(currentPos);
            camera.getWorldQuaternion(currentQuat);

            const view = dom.viewType.value;
            if (view === 'orthographic') {
                camera = orthographicCamera;
            } else {
                camera = perspectiveCamera;
            }
            camera.position.copy(currentPos);
            camera.quaternion.copy(currentQuat);

            controls.object = camera;
            controls.update();
        }

        function clearScene() {
            // Reset parent group rotation before clearing children
            crystalGroup.quaternion.identity();

            [unitCellGroup, latticeNodesGroup, directionVectorGroup].forEach(group => {
                while(group.children.length > 0){ 
                    const obj = group.children[0];
                    group.remove(obj);
                    if(obj.geometry) obj.geometry.dispose();
                    if(obj.material) obj.material.dispose();
                }
            });
        }
        
        function updateScene() {
            clearScene();
            
            const system = dom.system.value;
            const centering = dom.centering.value;
            const params = getLatticeParameters(system);
            const { v_a, v_b, v_c } = getDirectVectors(params.a, params.b, params.c, params.alpha, params.beta, params.gamma);
            if (!v_a) return; 

            // Rotate the entire crystal group to align c-axis with world Y-axis
            const worldUp = new THREE.Vector3(0, 1, 0);
            const c_normalized = v_c.clone().normalize();
            if (c_normalized.length() > 0 && c_normalized.distanceTo(worldUp) > 0.001) {
                 const quaternion = new THREE.Quaternion().setFromUnitVectors(c_normalized, worldUp);
                 crystalGroup.quaternion.copy(quaternion);
            }

            drawUnitCell(v_a, v_b, v_c);
            drawLatticeNodes(v_a, v_b, v_c, centering, system);

            const u = parseInt(dom.uvw.u.value) || 0;
            const v = parseInt(dom.uvw.v.value) || 0;
            const w = parseInt(dom.uvw.w.value) || 0;
            drawDirectionVector(v_a, v_b, v_c, u, v, w);
            
            dom.info.innerHTML = `<b>Direction: [${u} ${v} ${w}]</b>`;
        }

        function updateCenteringOptions() {
            const system = dom.system.value;
            const options = centeringOptions[system];
            const currentCentering = dom.centering.value;
            dom.centering.innerHTML = '';
            options.forEach(opt => {
                const optionEl = document.createElement('option');
                optionEl.value = opt;
                optionEl.textContent = {P: "Primitive", I: "Body-centered (I)", F: "Face-centered (F)", C: "Base-centered (C)", R: "Rhombohedral (R)"}[opt];
                dom.centering.appendChild(optionEl);
            });
            if (options.includes(currentCentering)) {
                dom.centering.value = currentCentering;
            }
            updateScene();
        }

        function getLatticeParameters(system) {
            // Using representative, non-editable values for simplicity
            switch (system) {
                case "tetragonal":   return { a: 3, b: 3, c: 5, alpha: 90, beta: 90, gamma: 90 };
                case "orthorhombic": return { a: 3, b: 4, c: 5, alpha: 90, beta: 90, gamma: 90 };
                case "hexagonal":    return { a: 3, b: 3, c: 5, alpha: 90, beta: 90, gamma: 120 };
                case "trigonal":     return { a: 4, b: 4, c: 4, alpha: 80, beta: 80, gamma: 80 };
                case "monoclinic":   return { a: 3, b: 4, c: 5, alpha: 90, beta: 110, gamma: 90 };
                case "triclinic":    return { a: 3, b: 5, c: 4, alpha: 70, beta: 80, gamma: 110 };
                case "cubic":
                default:             return { a: 4, b: 4, c: 4, alpha: 90, beta: 90, gamma: 90 };
            }
        }
        
        function getDirectVectors(a, b, c, alpha, beta, gamma) {
            const toRad = Math.PI / 180;
            const alphaR = alpha * toRad, betaR = beta * toRad, gammaR = gamma * toRad;
            const cos_a = Math.cos(alphaR), cos_b = Math.cos(betaR), cos_g = Math.cos(gammaR);
            const sin_g = Math.sin(gammaR);

            const v_a = new THREE.Vector3(a, 0, 0);
            const v_b = new THREE.Vector3(b * cos_g, b * sin_g, 0);
            
            const V = a * b * c * Math.sqrt(1 - cos_a**2 - cos_b**2 - cos_g**2 + 2 * cos_a * cos_b * cos_g);
            if (Math.abs(a * b * sin_g) < 1e-9) return {}; 

            const cx = c * cos_b;
            const cy = c * (cos_a - cos_b * cos_g) / sin_g;
            const cz_squared = c*c - cx*cx - cy*cy;

            if (cz_squared < -1e-9) return {}; 
            const cz = cz_squared > 0 ? Math.sqrt(cz_squared) : 0;
            
            const v_c = new THREE.Vector3(cx, cy, cz);

            if (isNaN(v_c.x) || isNaN(v_c.y) || isNaN(v_c.z)) return {};
            return { v_a, v_b, v_c };
        }
        
        function drawUnitCell(v_a, v_b, v_c) {
            const material = new THREE.LineBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.8 });
            const o = new THREE.Vector3(0,0,0);
            const p1 = v_a.clone();
            const p2 = v_b.clone();
            const p3 = v_c.clone();
            const p4 = v_a.clone().add(v_b);
            const p5 = v_a.clone().add(v_c);
            const p6 = v_b.clone().add(v_c);
            const p7 = v_a.clone().add(v_b).add(v_c);
            
            const vertices = [o, p1, p2, p3, p4, p5, p6, p7];
            const edges = [0,1, 0,2, 0,3, 1,4, 1,5, 2,4, 2,6, 3,5, 3,6, 4,7, 5,7, 6,7];
            
            const geometry = new THREE.BufferGeometry().setFromPoints(vertices);
            geometry.setIndex(edges);
            unitCellGroup.add(new THREE.LineSegments(geometry, material));

            if (font) {
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const createLabel = (text, pos) => {
                    const geo = new THREE.TextGeometry(text, { font, size: 0.35, height: 0.02 });
                    geo.center();
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.copy(pos).multiplyScalar(1.2);
                    unitCellGroup.add(mesh);
                };
                createLabel('a', v_a); createLabel('b', v_b); createLabel('c', v_c);
            }
        }

        function drawLatticeNodes(v_a, v_b, v_c, centering, system) {
            const nodeRadius = parseFloat(dom.nodeSize.value); // Read from slider
            const material = new THREE.MeshStandardMaterial({ color: 0x4f46e5, roughness: 0.5 });
            
            let fractionalCoords = [
                new THREE.Vector3(0,0,0), new THREE.Vector3(1,0,0), new THREE.Vector3(0,1,0),
                new THREE.Vector3(0,0,1), new THREE.Vector3(1,1,0), new THREE.Vector3(1,0,1),
                new THREE.Vector3(0,1,1), new THREE.Vector3(1,1,1)
            ];

            switch (centering) {
                case 'I': fractionalCoords.push(new THREE.Vector3(0.5, 0.5, 0.5)); break;
                case 'F':
                    fractionalCoords.push(new THREE.Vector3(0.5, 0.5, 0), new THREE.Vector3(0.5, 0, 0.5), new THREE.Vector3(0, 0.5, 0.5));
                    fractionalCoords.push(new THREE.Vector3(1, 0.5, 0.5), new THREE.Vector3(0.5, 1, 0.5), new THREE.Vector3(0.5, 0.5, 1));
                    break;
                case 'C': fractionalCoords.push(new THREE.Vector3(0.5, 0.5, 0), new THREE.Vector3(0.5, 0.5, 1)); break;
                case 'R': if (system === 'trigonal') { fractionalCoords.push(new THREE.Vector3(2/3, 1/3, 1/3), new THREE.Vector3(1/3, 2/3, 2/3)); } break;
            }

            const uniquePositions = new Map();
            fractionalCoords.forEach(frac => {
                 const pos = new THREE.Vector3()
                    .addScaledVector(v_a, frac.x)
                    .addScaledVector(v_b, frac.y)
                    .addScaledVector(v_c, frac.z);
                 
                 const posKey = pos.toArray().map(c => c.toFixed(4)).join(',');
                 if(!uniquePositions.has(posKey)){
                    const sphere = new THREE.Mesh(new THREE.SphereGeometry(nodeRadius, 20, 20), material);
                    sphere.position.copy(pos);
                    latticeNodesGroup.add(sphere);
                    uniquePositions.set(posKey, true);
                 }
            });
        }

        function drawDirectionVector(v_a, v_b, v_c, u, v, w) {
            const origin = new THREE.Vector3(0, 0, 0);
            
            const direction = new THREE.Vector3()
                .addScaledVector(v_a, u)
                .addScaledVector(v_b, v)
                .addScaledVector(v_c, w);
            
            const length = direction.length();
            if (length < 1e-9) return; 

            const color = 0xd90429;
            const arrow = new THREE.ArrowHelper( direction.clone().normalize(), origin, length, color, length * 0.1, length * 0.06 );
            directionVectorGroup.add(arrow);
        }
        
        // --- Panel Resizer Logic ---
        const resizer = document.getElementById('draghandle');
        const leftPanel = document.getElementById('left-panel');
        const ghost = document.getElementById('resize-ghost');
        let isResizing = false;
        let finalWidth = 0;
        const pageContainer = document.querySelector('.page-container');
        resizer.addEventListener('mousedown', function(e) {
            e.preventDefault();
            isResizing = true;
            ghost.style.left = `${e.clientX}px`;
            ghost.style.display = 'block';
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', stopResize);
        });

        function handleMouseMove(e) {
            if (!isResizing) return;
            const newLeftWidth = e.clientX - pageContainer.getBoundingClientRect().left;
            finalWidth = newLeftWidth;
            ghost.style.left = `${e.clientX}px`;
        }

        function stopResize(e) {
            isResizing = false;
            ghost.style.display = 'none';
            document.body.style.cursor = 'default';
            document.body.style.userSelect = 'auto';
            if(finalWidth > 0) {
                 leftPanel.style.flexBasis = `${finalWidth}px`;
            }
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', stopResize);
        }

        // --- Start the application ---
        init();

    </script>
</body>
</html>