<!DOCTYPE html>
<html>
<head>
    <title>Méthodes expérimentales</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { margin: 0; font-family: Arial, sans-serif; overflow: hidden; display: flex; height: 100vh; }
        #appContainer { display: flex; width: 100%; height: 100%; }
        #controlsPanel {
            width: 400px;
            padding: 10px;
            background-color: #f4f4f4;
            border-right: 1px solid #ccc;
            font-size: 0.9em;
            overflow-y: auto;
            height: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        #controlsContent {
            flex-grow: 1;
            overflow-y: auto;
        }
        label, input, button, select { margin: 3px 0; vertical-align: middle; display: inline-block; }
        input[type=number] { width: 60px; padding: 4px; box-sizing: border-box; }
        input[type=range] { vertical-align: middle; width: 120px; }
        select {padding: 4px;}

        #visualizationContainer {
            flex-grow: 1;
            height: 100%;
            position: relative;
        }
        #visualizationCanvas { display: block; }
        .label {
            color: #ffffff; 
            font-family: sans-serif; 
            padding: 2px;
            font-size:0.8em;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
        }
        .info-section { margin-top: 8px; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid #ddd;}
        .info-section:last-child { border-bottom: none; padding-bottom: 0;}
        .hkl-input-group label, .rotation-input-group label, .disorder-group label, .laue-input-group label { display: inline-block; width: auto; margin-bottom: 5px; margin-right:5px;}
        .hkl-input-group input, .rotation-input-group input, .laue-input-group input { margin-right: 10px; }
        .block-label {display: block; margin-bottom: 5px; font-weight: bold;}
        #hklInfo { font-size: 0.9em; line-height: 1.4; }
        .footer-attribution {
            margin-top: auto;
            padding-top: 10px;
            font-size: 0.8em;
            text-align: center;
            color: #aaaaaa;
        }
    </style>
</head>
<body>
    <div id="appContainer">
        <div id="controlsPanel">
            <div id="controlsContent">
                <div class="info-section">
                    <span class="block-label">Méthode de Diffraction :</span>
                    <select id="diffractionMethod">
                        <option value="single" selected>Cristal Unique (Monochromatique)</option>
                        <option value="laue">Laue (Cristal Fixe)</option>
                        <option value="powder">Poudre (Multi-cristaux)</option>
                    </select>
                </div>
                
                <div class="info-section">
                    <input type="checkbox" id="showOnlyDiffracting" style="vertical-align: baseline;">
                    <label for="showOnlyDiffracting">Afficher uniquement les nœuds en diffraction</label>
                </div>

                <strong>Paramètres Maille Orthorhombique :</strong><br>
                <label for="a">a (Å):</label><input type="number" id="a" value="4.0" step="0.1" min="0.1">
                <label for="b" style="margin-left:5px;">b (Å):</label><input type="number" id="b" value="5.0" step="0.1" min="0.1">
                <label for="c" style="margin-left:5px;">c (Å):</label><input type="number" id="c" value="6.0" step="0.1" min="0.1">

                <div id="lambdaControls" class="info-section">
                    <span class="block-label">Longueur d'Onde λ (Å) :</span>
                    <input type="number" id="lambda" value="1.54" step="0.01" min="0.1">
                </div>

                <div id="laueControls" class="info-section" style="display: none;">
                    <span class="block-label">Gamme de Longueurs d'Onde (Å) :</span>
                    <div class="laue-input-group">
                        <label for="lambda_min">λ min:</label><input type="number" id="lambda_min" value="0.5" step="0.1" min="0.1"><br>
                        <label for="lambda_max">λ max:</label><input type="number" id="lambda_max" value="2.0" step="0.1" min="0.1">
                    </div>
                </div>
                
                <div id="powderControls" class="info-section" style="display: none;">
                    <span class="block-label">Paramètres Poudre :</span>
                    <label for="numCrystallites">Nb. Cristallites:</label>
                    <input type="number" id="numCrystallites" value="5" min="1" max="200" step="1">
                </div>


                <div class="info-section">
                    <span class="block-label">Type de Réseau de Bravais (Orthorhombique) :</span>
                    <select id="bravaisLattice">
                        <option value="P" selected>Primitif (P)</option>
                        <option value="C">Base centrée (C)</option>
                        <option value="I">Centré (I)</option>
                        <option value="F">Faces centrées (F)</option>
                    </select>
                </div>

                <div id="hklControls" class="info-section">
                    <span class="block-label">Domaine du Réseau Réciproque (hkl) :</span>
                    <div class="hkl-input-group">
                        <label for="h_min">h min:</label><input type="number" id="h_min" value="-3" step="1">
                        <label for="h_max" style="margin-left:5px;">h max:</label><input type="number" id="h_max" value="3" step="1"><br>
                        <label for="k_min">k min:</label><input type="number" id="k_min" value="-3" step="1">
                        <label for="k_max" style="margin-left:5px;">k max:</label><input type="number" id="k_max" value="3" step="1"><br>
                        <label for="l_min">l min:</label><input type="number" id="l_min" value="-3" step="1">
                        <label for="l_max" style="margin-left:5px;">l max:</label><input type="number" id="l_max" value="3" step="1">
                    </div>
                </div>

                <div id="rotationControls" class="info-section">
                    <span class="block-label">Rotation Cristal/Réseau Réciproque :</span>
                    <div class="rotation-input-group">
                        <label for="rotX">Rot X (°):</label><input type="number" id="rotX" value="0" step="1"><br>
                        <label for="rotY">Rot Y (°):</label><input type="number" id="rotY" value="0" step="1"><br>
                        <label for="rotZ">Rot Z (°):</label><input type="number" id="rotZ" value="0" step="1">
                    </div>
                </div>
                <div class="info-section disorder-group">
                    <span class="block-label">Niveau de Désordre :</span>
                    <input type="range" id="disorderSlider" min="0" max="1" step="0.01" value="0">
                    <span id="disorderValue">0.00</span>
                </div>

                <div class="info-section" id="hklInfo" style="font-weight:bold; margin-top:10px; height:auto; min-height:40px;">Point (hkl) cliqué : Aucun</div>

                <p style="font-size:0.9em; margin-top:10px;">
                    <b>Légende :</b><br>
                    Vert clair/Bleu : Points RR. Rouge : En condition de diffraction.<br>
                    Vert : Sphère(s) d'Ewald.<br>
                    Flèche Magenta : Vecteur k<sub>i</sub> incident.<br>
                    <span style="display:inline-block; width:10px; height:10px; background-color:#00AABB;"></span>
                    Cyan : Vecteur k<sub>f</sub> diffracté.<br>
                    Axes RR : a* (X-Rouge), b* (Y-Vert), c* (Z-Bleu).
                </p>
            </div>
            <div class="footer-attribution">
                NitaD, Univ Paris-Saclay, version 13 juin 2025
            </div>
        </div>
        <div id="visualizationContainer"></div>
    </div>

    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>

    <script>
        // --- Variables Globales ---
        let scene, camera, renderer, labelRenderer, controls;
        let ewaldSphereMesh, kIncidentVectorArrow;
        const reciprocalLatticePointsGroup = new THREE.Group();
        const powderCrystallitesGroup = new THREE.Group();
        const reciprocalAxesGroup = new THREE.Group();
        const axisLabelsGroup = new THREE.Group();
        let diffractionVectorsGroup;
        let laueSpheresGroup;
        let diffractionMethod = 'single';

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hklInfoDiv, disorderValueSpan;

        // --- Paramètres de Visualisation ---
        const RR_POINT_BASE_RADIUS = 0.008;
        const defaultPointColor = 0x0077ff;
        const powderPointColor = 0x99ff00;
        const intersectingPointColor = 0xff0000;
        const ewaldSphereColor = 0x33ff33;
        const kVectorColor = 0xff00ff;
        const diffractedVectorColor = 0x00AABB;
        const axisLineRadius = 0.005;
        const axisVisLength = 0.75;
        const disorderRadiusFactor = 1.25;
        const disorderMaxBFactor = 50;
        const disorderIntensityThreshold = 0.05;


        // --- Initialisation ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            hklInfoDiv = document.getElementById('hklInfo');
            disorderValueSpan = document.getElementById('disorderValue');

            const container = document.getElementById('visualizationContainer');
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(1.5, 1.5, 3.0);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(container.clientWidth, container.clientHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            container.appendChild(labelRenderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(5, 10, 7.5);
            scene.add(directionalLight1);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;

            diffractionVectorsGroup = new THREE.Group();
            laueSpheresGroup = new THREE.Group();
            scene.add(diffractionVectorsGroup);
            scene.add(laueSpheresGroup);
            scene.add(powderCrystallitesGroup);
            scene.add(reciprocalLatticePointsGroup);
            scene.add(reciprocalAxesGroup);
            scene.add(axisLabelsGroup);

            const inputsToWatch = ['a', 'b', 'c', 'lambda', 'lambda_min', 'lambda_max', 'numCrystallites',
                                 'h_min', 'h_max', 'k_min', 'k_max', 'l_min', 'l_max',
                                 'rotX', 'rotY', 'rotZ', 'disorderSlider', 'bravaisLattice', 'showOnlyDiffracting'];
            inputsToWatch.forEach(id => {
                document.getElementById(id)?.addEventListener('input', () => {
                    if (id === 'disorderSlider') {
                        disorderValueSpan.textContent = parseFloat(document.getElementById(id).value).toFixed(2);
                    }
                    updateVisualization();
                });
            });
            document.getElementById('bravaisLattice').addEventListener('change', updateVisualization);
            document.getElementById('diffractionMethod').addEventListener('change', handleMethodChange);
            document.getElementById('showOnlyDiffracting').addEventListener('change', updateVisualization);

            renderer.domElement.addEventListener('click', onCanvasClick, false);
            window.addEventListener('resize', onWindowResize, false);

            handleMethodChange();
            animate();
        }

        function handleMethodChange() {
            diffractionMethod = document.getElementById('diffractionMethod').value;
            const lambdaControls = document.getElementById('lambdaControls');
            const laueControls = document.getElementById('laueControls');
            const powderControls = document.getElementById('powderControls');
            const rotationControls = document.getElementById('rotationControls');
            const disorderControls = document.querySelector('.disorder-group');
            
            lambdaControls.style.display = 'none';
            laueControls.style.display = 'none';
            powderControls.style.display = 'none';
            rotationControls.style.display = 'none';
            disorderControls.style.display = 'none';
            
            reciprocalLatticePointsGroup.visible = false;
            powderCrystallitesGroup.visible = false;
            reciprocalAxesGroup.visible = false;
            axisLabelsGroup.visible = false;

            if (diffractionMethod === 'single') {
                lambdaControls.style.display = 'block';
                rotationControls.style.display = 'block';
                disorderControls.style.display = 'block';
                reciprocalLatticePointsGroup.visible = true;
                reciprocalAxesGroup.visible = true;
                axisLabelsGroup.visible = true;
            } else if (diffractionMethod === 'laue') {
                laueControls.style.display = 'block';
                disorderControls.style.display = 'block';
                reciprocalLatticePointsGroup.visible = true;
                reciprocalAxesGroup.visible = true;
                axisLabelsGroup.visible = true;
            } else if (diffractionMethod === 'powder') {
                lambdaControls.style.display = 'block';
                powderControls.style.display = 'block';
                powderCrystallitesGroup.visible = true;
            }
            updateVisualization();
        }


        function onCanvasClick(event) {
            const currentPoints = (diffractionMethod === 'powder') ? powderCrystallitesGroup.children : reciprocalLatticePointsGroup.children;
            if (currentPoints.length === 0) return;

            event.preventDefault();
            const canvasBounds = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - canvasBounds.left) / canvasBounds.width) * 2 - 1;
            mouse.y = -((event.clientY - canvasBounds.top) / canvasBounds.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(currentPoints, false);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                const { h, k, l } = clickedObject.userData;
                hklInfoDiv.textContent = `Point (hkl) cliqué : (${h}, ${k}, ${l})`;
            }
        }

        function updateVisualization() {
            const a = parseFloat(document.getElementById('a').value);
            const b = parseFloat(document.getElementById('b').value);
            const c = parseFloat(document.getElementById('c').value);
            const latticeType = document.getElementById('bravaisLattice').value;
            const h_min = parseInt(document.getElementById('h_min').value), h_max = parseInt(document.getElementById('h_max').value);
            const k_min = parseInt(document.getElementById('k_min').value), k_max = parseInt(document.getElementById('k_max').value);
            const l_min = parseInt(document.getElementById('l_min').value), l_max = parseInt(document.getElementById('l_max').value);
            
            if (isNaN(a) || isNaN(b) || isNaN(c) || a <= 0 || b <= 0 || c <= 0 ||
                isNaN(h_min) || isNaN(h_max) || isNaN(k_min) || isNaN(k_max) || isNaN(l_min) || isNaN(l_max)) {
                return;
            }

            clearSceneObjects();
            if(reciprocalAxesGroup.visible) drawReciprocalAxes();

            const allPoints = [];
            for (let h = h_min; h <= h_max; h++) {
                for (let k = k_min; k <= k_max; k++) {
                    for (let l = l_min; l <= l_max; l++) {
                        let allow = false;
                        if (latticeType === "P") allow = true;
                        else if (latticeType === "I") allow = (h + k + l) % 2 === 0;
                        else if (latticeType === "C") allow = (h + k) % 2 === 0;
                        else if (latticeType === "F") allow = (h%2 === k%2) && (k%2 === l%2);
                        if (allow) {
                            allPoints.push({ h, k, l, pos: new THREE.Vector3(h * (1/a), k * (1/b), l * (1/c)) });
                        }
                    }
                }
            }

            if (diffractionMethod === 'single' || diffractionMethod === 'laue') {
                runSingleCrystalAndLaue(allPoints);
            } else if (diffractionMethod === 'powder') {
                runPowder(allPoints);
            }
        }

        function runSingleCrystalAndLaue(points) {
            hklInfoDiv.textContent = 'Cliquez sur un point du réseau réciproque.';
            const showOnlyDiffracting = document.getElementById('showOnlyDiffracting').checked;
            
            let rotX = 0, rotY = 0, rotZ = 0;
            if (diffractionMethod === 'single') {
                rotX = parseFloat(document.getElementById('rotX').value) || 0;
                rotY = parseFloat(document.getElementById('rotY').value) || 0;
                rotZ = parseFloat(document.getElementById('rotZ').value) || 0;
            }
            const eulerRotation = new THREE.Euler(THREE.MathUtils.degToRad(rotX), THREE.MathUtils.degToRad(rotY), THREE.MathUtils.degToRad(rotZ), 'XYZ');
            const tempWorldPosition = new THREE.Vector3();

            if (diffractionMethod === 'single') {
                 const lambda = parseFloat(document.getElementById('lambda').value);
                 if (!isNaN(lambda) && lambda > 0) {
                    const ewaldRadius = 1 / lambda;
                    const ewaldSphereGeometry = new THREE.SphereGeometry(ewaldRadius, 64, 64);
                    const ewaldSphereMaterial = new THREE.MeshPhongMaterial({ color: ewaldSphereColor, opacity: 0.4, transparent: true, side: THREE.DoubleSide });
                    ewaldSphereMesh = new THREE.Mesh(ewaldSphereGeometry, ewaldSphereMaterial);
                    ewaldSphereMesh.position.set(0, 0, -ewaldRadius);
                    scene.add(ewaldSphereMesh);
                    createIncidentBeamArrow(ewaldRadius);
                 }
            }

            points.forEach(p => {
                if (p.h === 0 && p.k === 0 && p.l === 0) return;

                tempWorldPosition.copy(p.pos).applyEuler(eulerRotation);
                
                let isDiffracting = false;
                let diffractionData = {};

                if (diffractionMethod === 'single') {
                    if (ewaldSphereMesh) {
                        const disorderLevel = parseFloat(document.getElementById('disorderSlider').value);
                        const effectivePointScale = (1 + disorderLevel * disorderRadiusFactor);
                        const actualPointRadius = RR_POINT_BASE_RADIUS * effectivePointScale;
                        const distanceToSurface = Math.abs(tempWorldPosition.distanceTo(ewaldSphereMesh.position) - ewaldSphereMesh.geometry.parameters.radius);
                        if(distanceToSurface < actualPointRadius) {
                            isDiffracting = true;
                            diffractionData = { center: ewaldSphereMesh.position, radius: ewaldSphereMesh.geometry.parameters.radius };
                        }
                    }
                } else { // Laue method
                    const world_z = tempWorldPosition.z;
                    if (world_z < 0) {
                        const world_G_sq = tempWorldPosition.lengthSq();
                        const lambda_diff = -world_G_sq / (2 * world_z);
                        const lambda_min = parseFloat(document.getElementById('lambda_min').value);
                        const lambda_max = parseFloat(document.getElementById('lambda_max').value);
                        if (lambda_diff >= lambda_min && lambda_diff <= lambda_max) {
                           isDiffracting = true;
                           const R_diff = 1 / lambda_diff;
                           diffractionData = { center: new THREE.Vector3(0, 0, -R_diff), radius: R_diff };
                        }
                    }
                }

                if (isDiffracting) {
                    const pointMesh = createPointMesh(p, intersectingPointColor, 'MeshBasicMaterial');
                    if(pointMesh) {
                        pointMesh.position.copy(p.pos);
                        reciprocalLatticePointsGroup.add(pointMesh);
                        const direction = new THREE.Vector3().subVectors(tempWorldPosition, diffractionData.center).normalize();
                        const arrow = new THREE.ArrowHelper(direction, diffractionData.center, diffractionData.radius, diffractedVectorColor, diffractionData.radius * 0.1, diffractionData.radius * 0.05);
                        diffractionVectorsGroup.add(arrow);
                    }
                } else if (!showOnlyDiffracting) {
                    const pointMesh = createPointMesh(p, defaultPointColor, 'MeshPhongMaterial');
                     if(pointMesh) {
                        pointMesh.position.copy(p.pos);
                        reciprocalLatticePointsGroup.add(pointMesh);
                    }
                }
            });

            reciprocalLatticePointsGroup.setRotationFromEuler(eulerRotation);
            reciprocalAxesGroup.setRotationFromEuler(eulerRotation);
            axisLabelsGroup.setRotationFromEuler(eulerRotation);
            if (diffractionMethod === 'laue') createLaueSpheres();
        }

        function createPointMesh(p, color, materialType) {
            const { pos } = p;
            const disorderLevel = parseFloat(document.getElementById('disorderSlider').value);
            const G_hkl_val = pos.length();
            let intensityFactor = 1.0;
            if (G_hkl_val > 0) {
                const B_eff = disorderLevel * disorderMaxBFactor;
                intensityFactor = Math.exp(-B_eff / 2.0 * Math.pow(G_hkl_val, 2));
            }
            if (intensityFactor < disorderIntensityThreshold) return null;

            const effectivePointScale = (1 + disorderLevel * disorderRadiusFactor);
            const actualPointRadius = RR_POINT_BASE_RADIUS * effectivePointScale;
            
            const pointGeometry = new THREE.SphereGeometry(actualPointRadius, 10, 10);
            const pointMaterial = (materialType === 'MeshBasicMaterial') 
                ? new THREE.MeshBasicMaterial({ color: color })
                : new THREE.MeshPhongMaterial({ color: color, opacity: Math.max(0.1, intensityFactor), transparent: true });
            
            const pointMesh = new THREE.Mesh(pointGeometry, pointMaterial);
            pointMesh.userData = { h: p.h, k: p.k, l: p.l };
            return pointMesh;
        }

        function createLaueSpheres() {
            const lambda_min = parseFloat(document.getElementById('lambda_min').value);
            const lambda_max = parseFloat(document.getElementById('lambda_max').value);
            if(isNaN(lambda_min) || isNaN(lambda_max) || lambda_min <= 0 || lambda_max <= lambda_min) return;

            const R_min = 1/lambda_max, R_max = 1/lambda_min;
            const mat = new THREE.MeshPhongMaterial({ color: ewaldSphereColor, opacity: 0.15, transparent: true, side: THREE.DoubleSide }); 
            
            const numIntermediateSpheres = 5;
            for(let i=0; i <= numIntermediateSpheres; i++){
                const radius = R_min + (i/numIntermediateSpheres) * (R_max - R_min);
                const sphere = new THREE.Mesh(new THREE.SphereGeometry(radius, 64, 64), mat);
                sphere.position.set(0, 0, -radius);
                laueSpheresGroup.add(sphere);
            }
            const R_avg = (R_min + R_max) / 2.0;
            createIncidentBeamArrow(R_avg);
        }
        
        function runPowder(points) {
            hklInfoDiv.textContent = 'Simulation de Poudre : Multi-cristaux';
            const lambda = parseFloat(document.getElementById('lambda').value);
            const numCrystallites = parseInt(document.getElementById('numCrystallites').value);
            const showOnlyDiffracting = document.getElementById('showOnlyDiffracting').checked;

            if (isNaN(lambda) || lambda <= 0 || isNaN(numCrystallites) || numCrystallites < 1) return;
            
            const ewaldRadius = 1 / lambda;
            const pointRadius = RR_POINT_BASE_RADIUS * 0.8;

            const ewaldSphereGeometry = new THREE.SphereGeometry(ewaldRadius, 64, 64);
            const ewaldSphereMaterial = new THREE.MeshPhongMaterial({ color: ewaldSphereColor, opacity: 0.4, transparent: true, side: THREE.DoubleSide });
            ewaldSphereMesh = new THREE.Mesh(ewaldSphereGeometry, ewaldSphereMaterial);
            ewaldSphereMesh.position.set(0, 0, -ewaldRadius);
            scene.add(ewaldSphereMesh);
            createIncidentBeamArrow(ewaldRadius);
            
            for (let i = 0; i < numCrystallites; i++) {
                const randomEuler = new THREE.Euler(Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI);
                const randomRotation = new THREE.Quaternion().setFromEuler(randomEuler);
                
                points.forEach(p => {
                    if (p.h === 0 && p.k === 0 && p.l === 0) return;
                    
                    const worldPos = new THREE.Vector3().copy(p.pos).applyQuaternion(randomRotation);
                    const distanceToSurface = Math.abs(worldPos.distanceTo(ewaldSphereMesh.position) - ewaldRadius);
                    const isDiffracting = (distanceToSurface < pointRadius);

                    if (isDiffracting) {
                        const pointGeometry = new THREE.SphereGeometry(pointRadius, 8, 8);
                        const pointMaterial = new THREE.MeshBasicMaterial({ color: intersectingPointColor });
                        const pointMesh = new THREE.Mesh(pointGeometry, pointMaterial);
                        pointMesh.position.copy(worldPos);
                        pointMesh.userData = { h: p.h, k: p.k, l: p.l };
                        powderCrystallitesGroup.add(pointMesh);

                        const direction = new THREE.Vector3().subVectors(worldPos, ewaldSphereMesh.position).normalize();
                        const arrow = new THREE.ArrowHelper(direction, ewaldSphereMesh.position, ewaldRadius, diffractedVectorColor, ewaldRadius * 0.1, ewaldRadius * 0.05);
                        diffractionVectorsGroup.add(arrow);
                    } else if (!showOnlyDiffracting) {
                        const pointGeometry = new THREE.SphereGeometry(pointRadius, 8, 8);
                        const pointMaterial = new THREE.MeshBasicMaterial({ color: powderPointColor });
                        const pointMesh = new THREE.Mesh(pointGeometry, pointMaterial);
                        pointMesh.position.copy(worldPos);
                        pointMesh.userData = { h: p.h, k: p.k, l: p.l };
                        powderCrystallitesGroup.add(pointMesh);
                    }
                });
            }
        }


        function drawReciprocalAxes() {
            const geomAx = new THREE.CylinderGeometry(axisLineRadius, axisLineRadius, axisVisLength, 8);
            
            const matX = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const axMeshX = new THREE.Mesh(geomAx, matX);
            axMeshX.position.set(axisVisLength / 2, 0, 0);
            axMeshX.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1,0,0));
            reciprocalAxesGroup.add(axMeshX);
            axisLabelsGroup.add(createAxisLabel('a*', new THREE.Vector3(axisVisLength + 0.1, 0, 0), 'red'));

            const matY = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
            const axMeshY = new THREE.Mesh(geomAx.clone(), matY);
            axMeshY.position.set(0, axisVisLength / 2, 0);
            reciprocalAxesGroup.add(axMeshY);
            axisLabelsGroup.add(createAxisLabel('b*', new THREE.Vector3(0, axisVisLength + 0.1, 0), '#00ff00'));
            
            const matZ = new THREE.MeshPhongMaterial({ color: 0x0000ff });
            const axMeshZ = new THREE.Mesh(geomAx.clone(), matZ);
            axMeshZ.position.set(0, 0, axisVisLength / 2);
            axMeshZ.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0,0,1));
            reciprocalAxesGroup.add(axMeshZ);
            axisLabelsGroup.add(createAxisLabel('c*', new THREE.Vector3(0, 0, axisVisLength + 0.1), 'blue'));
        }

        function createIncidentBeamArrow(radius) {
            if (radius <= 0) return;
            const kVecOrigin = new THREE.Vector3(0, 0, -radius);
            const kVecDirection = new THREE.Vector3(0, 0, 1);
            const kVecHeadLength = Math.min(radius * 0.20, 0.15);
            const kVecHeadWidth = Math.min(radius * 0.10, 0.08);
            kIncidentVectorArrow = new THREE.ArrowHelper(kVecDirection, kVecOrigin, radius, kVectorColor, kVecHeadLength, kVecHeadWidth);
            scene.add(kIncidentVectorArrow);
        }

        function createAxisLabel(text, position, color = '#000000') {
            const div = document.createElement('div');
            div.className = 'label'; div.textContent = text; div.style.color = color;
            const label = new THREE.CSS2DObject(div);
            label.position.copy(position); return label;
        }

        function clearSceneObjects() {
            if (ewaldSphereMesh) { scene.remove(ewaldSphereMesh); ewaldSphereMesh.geometry.dispose(); ewaldSphereMesh.material.dispose(); ewaldSphereMesh = null; }
            if (kIncidentVectorArrow) { scene.remove(kIncidentVectorArrow); kIncidentVectorArrow.line.geometry.dispose(); kIncidentVectorArrow.line.material.dispose(); kIncidentVectorArrow.cone.geometry.dispose(); kIncidentVectorArrow.cone.material.dispose(); kIncidentVectorArrow = null; }
            disposeGroupChildren(reciprocalLatticePointsGroup);
            disposeGroupChildren(powderCrystallitesGroup);
            disposeGroupChildren(reciprocalAxesGroup);
            disposeGroupChildren(axisLabelsGroup, true);
            disposeGroupChildren(diffractionVectorsGroup);
            disposeGroupChildren(laueSpheresGroup);
        }

        function disposeGroupChildren(group, isCSS2D = false) {
            while (group.children.length > 0) {
                const object = group.children[0];
                if (!isCSS2D) {
                     if (object.type === 'ArrowHelper') {
                        if (object.line) { object.line.geometry.dispose(); object.line.material.dispose(); }
                        if (object.cone) { object.cone.geometry.dispose(); object.cone.material.dispose(); }
                    } else if (object.geometry) {
                        object.geometry.dispose();
                        if (object.material) {
                            if (Array.isArray(object.material)) { object.material.forEach(mat => mat.dispose()); }
                            else { object.material.dispose(); }
                        }
                    }
                }
                group.remove(object);
            }
        }

        function onWindowResize() {
            const container = document.getElementById('visualizationContainer');
            if (!container || container.clientWidth === 0 || container.clientHeight === 0) return;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            labelRenderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
}