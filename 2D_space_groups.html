<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Space Group Visualizer</title>
    <link href="./dist/output.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: #f0f0f0;
            color: #e5e7eb; /* Default light text for dark theme */
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        #app-container {
            display: flex;
            width: 100%;
            height: calc(100vh - 32px); /* Adjust height to make space for the footer */
        }
        #controls-panel {
            width: 350px;
            min-width: 300px;
            max-width: 600px;
            flex-shrink: 0;
            padding: 24px;
            background-color: #111827; /* Dark blue-gray */
            border-right: 1px solid #374151;
            overflow-y: auto;
            color: #d1d5db;
        }
        #drag-handle {
            width: 6px;
            cursor: col-resize;
            background-color: #374151;
            flex-shrink: 0;
            transition: background-color 0.2s;
        }
        #drag-handle:hover {
            background-color: #3b82f6;
        }
        #visualization-area {
            flex-grow: 1;
            position: relative;
            background-color: #ffffff;
            min-width: 0;
            display: flex;
            align-items: flex-start; /* Align to top */
            justify-content: center;
            padding: 1rem;
            color: #1f2937; /* Dark text for light theme */
            overflow-y: auto;
        }
        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1 / 1;
            margin: auto;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
        }
        .info-list {
            font-family: monospace;
            font-size: 0.8rem;
            text-align: left;
            padding: 0.5rem 1rem;
            background-color: #f8fafc;
            border-radius: 0.25rem;
            border: 1px solid #e2e8f0;
        }
        #notation-description ul {
            list-style-type: none;
            padding-left: 0;
        }
        #notation-description li {
            margin-bottom: 0.25rem;
        }

        /* Dark Theme Controls */
        #controls-panel h1 { font-size: 1.8em; margin-bottom: 8px; font-weight: 700; color: #ffffff; }
        #controls-panel p { font-size: 0.9em; margin-bottom: 24px; color: #9ca3af; }
        #controls-panel h2 { font-size: 1.25em; font-weight: 600; margin-bottom: 16px; border-bottom: 1px solid #374151; padding-bottom: 8px; color: #ffffff;}
        #controls-panel h3 { font-weight: 600; }
        #controls-panel label { display: block; margin-bottom: 8px; font-weight: 500; color: #9ca3af; }
        #controls-panel select, #controls-panel input[type="number"] {
            background-color: #374151;
            border: 1px solid #4b5563;
            color: #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.5rem;
        }
        #controls-panel input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 6px; background: #4b5563;
            border-radius: 3px; outline: none; opacity: 0.8; transition: opacity .2s;
        }
        #controls-panel input[type="range"]:hover { opacity: 1; }
        #controls-panel input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 18px; height: 18px; background: #3b82f6;
            cursor: pointer; border-radius: 50%;
        }
        #controls-panel input[type="range"]::-moz-range-thumb {
            width: 18px; height: 18px; background: #3b82f6;
            cursor: pointer; border-radius: 50%;
        }
        .control-group {
            margin-bottom: 1.5rem;
            padding: 1rem;
            border: 1px solid #374151;
            border-radius: 0.5rem;
            background-color: rgba(255, 255, 255, 0.05);
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">
            <h1>2D Space Groups</h1>
            <p>Select a group and place motifs to see the symmetry operations.</p>

            <div class="mb-6 flex items-center">
                <label for="space-group-select" class="text-base mr-4">Space Group</label>
                <select id="space-group-select" class="flex-grow p-2">
                    <option value="p1">p1</option>
                    <option value="p2">p2</option>
                    <option value="pm">pm</option>
                    <option value="pg">pg</option>
                    <option value="cm">cm</option>
                    <option value="p2mm">p2mm</option>
                    <option value="p2mg">p2mg</option>
                    <option value="p2gg">p2gg</option>
                    <option value="c2mm">c2mm</option>
                    <option value="p4">p4</option>
                    <option value="p4mm">p4mm</option>
                    <option value="p4gm">p4gm</option>
                    <option value="p3">p3</option>
                    <option value="p3m1">p3m1</option>
                    <option value="p31m">p31m</option>
                    <option value="p6">p6</option>
                    <option value="p6mm">p6mm</option>
                </select>
            </div>

            <div class="control-group">
                <div class="flex items-center mb-4">
                    <label for="motif1-shape" class="mr-4 font-semibold text-lg text-blue-400">Motif 1</label>
                    <select id="motif1-shape" class="p-1 flex-grow">
                        <option value="circle">Circle</option>
                        <option value="triangle">Triangle</option>
                        <option value="quadri">Quadri</option>
                        <option value="comma" selected>Comma</option>
                    </select>
                </div>
                <div>
                    <label class="block font-medium text-sm">Position (x, y)</label>
                    <div class="flex items-center">
                        <input type="range" id="motif1-x" min="0" max="1" step="0.01" value="0.2">
                        <input type="number" id="motif1-x-num" min="0" max="1" step="0.01" value="0.2" class="w-20 ml-3">
                    </div>
                    <div class="flex items-center mt-2">
                        <input type="range" id="motif1-y" min="0" max="1" step="0.01" value="0.3">
                        <input type="number" id="motif1-y-num" min="0" max="1" step="0.01" value="0.3" class="w-20 ml-3">
                    </div>
                </div>
            </div>

            <div class="control-group">
                <div class="flex justify-between items-center mb-3">
                     <h3 class="font-semibold text-lg text-red-400">Motif 2</h3>
                     <input type="checkbox" id="motif2-enable" class="h-5 w-5 rounded bg-gray-700 border-gray-600 text-blue-600 focus:ring-blue-500">
                </div>
                <div id="motif2-controls" class="hidden space-y-4">
                    <div class="flex items-center">
                        <label for="motif2-shape" class="mr-2 mb-0">Shape:</label>
                        <select id="motif2-shape" class="p-1 flex-grow">
                            <option value="circle">Circle</option>
                            <option value="triangle" selected>Triangle</option>
                            <option value="quadri">Quadri</option>
                            <option value="comma">Comma</option>
                        </select>
                    </div>
                    <div>
                        <label class="block font-medium text-sm">Position (x, y)</label>
                        <div class="flex items-center">
                            <input type="range" id="motif2-x" min="0" max="1" step="0.01" value="0.8">
                            <input type="number" id="motif2-x-num" min="0" max="1" step="0.01" value="0.8" class="w-20 ml-3">
                        </div>
                        <div class="flex items-center mt-2">
                            <input type="range" id="motif2-y" min="0" max="1" step="0.01" value="0.7">
                            <input type="number" id="motif2-y-num" min="0" max="1" step="0.01" value="0.7" class="w-20 ml-3">
                        </div>
                    </div>
                </div>
            </div>

            <div id="info-panel" class="mt-6 space-y-4">
                <div>
                    <h3 class="font-semibold mb-1 text-white">Cell System</h3>
                    <p class="text-sm"><span id="cell-type"></span></p>
                </div>
                <div>
                    <h3 class="font-semibold mb-1 text-white">Notation</h3>
                    <div id="notation-description" class="text-sm"></div>
                </div>
            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="visualization-area">
            <div class="w-full h-full grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div class="text-center flex flex-col">
                    <div> <h3 class="font-semibold mb-2 text-xl">Symmetry Elements</h3>
                        <div class="canvas-wrapper">
                            <canvas id="symmetry-canvas"></canvas>
                        </div>
                    </div>
                    <div class="mt-4"> <h3 class="font-semibold mb-1">Equivalent Positions</h3>
                        <div id="equivalent-positions" class="info-list"></div>
                    </div>
                </div>
                <div class="text-center flex flex-col">
                    <div> <h3 class="font-semibold mb-2 text-xl">Generated Pattern</h3>
                        <div class="canvas-wrapper">
                            <canvas id="motif-canvas"></canvas>
                        </div>
                    </div>
                     <div class="mt-4"> <h3 class="font-semibold mb-1">Generated Positions</h3>
                        <div id="generated-positions" class="info-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="fixed bottom-0 left-0 w-full bg-white shadow-md p-2 flex justify-between items-center text-xs text-gray-600 border-t z-10">
        <div class="px-4">
            Simple 2D space groups. For advanced symmetry see the
            <a href="https://www.cryst.ehu.es/" target="_blank" class="text-blue-600 hover:underline">Bilbao Crystallographic Server</a>.
        </div>
        <div class="px-4">
            NitaD, Univ Paris-Saclay, Aug 25, 2025
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const symmetryCanvas = document.getElementById('symmetry-canvas');
            const motifCanvas = document.getElementById('motif-canvas');
            const symCtx = symmetryCanvas.getContext('2d');
            const motifCtx = motifCanvas.getContext('2d');

            const spaceGroupSelect = document.getElementById('space-group-select');
            const cellTypeSpan = document.getElementById('cell-type');
            const notationDescriptionDiv = document.getElementById('notation-description');
            const equivalentPositionsDiv = document.getElementById('equivalent-positions');
            const generatedPositionsDiv = document.getElementById('generated-positions');

            const motif1Shape = document.getElementById('motif1-shape');
            const motif1X = document.getElementById('motif1-x');
            const motif1Y = document.getElementById('motif1-y');
            const motif1XNum = document.getElementById('motif1-x-num');
            const motif1YNum = document.getElementById('motif1-y-num');

            const motif2Enable = document.getElementById('motif2-enable');
            const motif2Controls = document.getElementById('motif2-controls');
            const motif2Shape = document.getElementById('motif2-shape');
            const motif2X = document.getElementById('motif2-x');
            const motif2Y = document.getElementById('motif2-y');
            const motif2XNum = document.getElementById('motif2-x-num');
            const motif2YNum = document.getElementById('motif2-y-num');

            // --- State ---
            let state = {
                spaceGroup: 'p1',
                motif1: { shape: 'comma', x: 0.2, y: 0.3, color: 'rgba(59, 130, 246, 0.8)' },
                motif2: { enabled: false, shape: 'triangle', x: 0.8, y: 0.7, color: 'rgba(220, 38, 38, 0.8)' }
            };

            // --- Crystallographic Data ---
            const spaceGroupInfo = {
                p1: { system: 'oblique', equiv: ['(x, y)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>1</b>: Onefold rotation (no rotational symmetry).</li></ul>' },
                p2: { system: 'oblique', equiv: ['(x, y)', '(-x, -y)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>2</b>: A twofold rotation axis perpendicular to the plane.</li></ul>' },
                pm: { system: 'rectangular', equiv: ['(x, y)', '(-x, y)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>m</b>: A mirror plane perpendicular to the x-axis.</li></ul>' },
                pg: { system: 'rectangular', equiv: ['(x, y)', '(-x, y+1/2)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>g</b>: A glide plane perpendicular to the x-axis, with translation along y.</li></ul>' },
                cm: { system: 'rectangular', equiv: ['(x, y)', '(-x, y)', '(x+1/2, y+1/2)', '(-x+1/2, y+1/2)'], description: '<ul><li><b>c</b>: Centered unit cell.</li><li><b>m</b>: A mirror plane perpendicular to the x-axis.</li></ul>' },
                p2mm: { system: 'rectangular', equiv: ['(x, y)', '(-x, y)', '(x, -y)', '(-x, -y)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>2</b>: A twofold rotation axis perpendicular to the plane.</li><li><b>m (1st)</b>: A mirror plane perpendicular to the x-axis.</li><li><b>m (2nd)</b>: A mirror plane perpendicular to the y-axis.</li></ul>' },
                p2mg: { system: 'rectangular', equiv: ['(x, y)', '(-x, -y)', '(-x+1/2, y)', '(x+1/2, -y)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>2</b>: A twofold rotation axis perpendicular to the plane.</li><li><b>m</b>: A mirror plane perpendicular to the x-axis.</li><li><b>g</b>: A glide plane perpendicular to the y-axis, with translation along x.</li></ul>' },
                p2gg: { system: 'rectangular', equiv: ['(x, y)', '(-x, -y)', '(x+1/2, -y+1/2)', '(-x+1/2, y+1/2)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>2</b>: A twofold rotation axis perpendicular to the plane.</li><li><b>g (1st)</b>: A glide plane perpendicular to the x-axis, with translation along y.</li><li><b>g (2nd)</b>: A glide plane perpendicular to the y-axis, with translation along x.</li></ul>' },
                c2mm: { system: 'rectangular', equiv: ['(x,y)', '(-x,y)', '(x,-y)', '(-x,-y)', '(x+1/2,y+1/2)', '(-x+1/2,y+1/2)', '(x+1/2,-y+1/2)', '(-x+1/2,-y+1/2)'], description: '<ul><li><b>c</b>: Centered unit cell.</li><li><b>2</b>: A twofold rotation axis perpendicular to the plane.</li><li><b>m (1st)</b>: A mirror plane perpendicular to the x-axis.</li><li><b>m (2nd)</b>: A mirror plane perpendicular to the y-axis.</li></ul>' },
                p4: { system: 'square', equiv: ['(x, y)', '(-y, x)', '(-x, -y)', '(y, -x)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>4</b>: A fourfold rotation axis perpendicular to the plane.</li></ul>' },
                p4mm: { system: 'square', equiv: ['(x,y)', '(-y,x)', '(-x,-y)', '(y,-x)', '(-x,y)', '(y,x)', '(x,-y)', '(-y,-x)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>4</b>: A fourfold rotation axis perpendicular to the plane.</li><li><b>m (1st)</b>: Mirror planes perpendicular to the x and y axes.</li><li><b>m (2nd)</b>: Mirror planes along the diagonals.</li></ul>' },
                p4gm: { system: 'square', equiv: ['(x,y)', '(-x,-y)', '(-y,x)', '(y,-x)', '(-x+1/2,y+1/2)', '(x+1/2,-y+1/2)', '(y+1/2,x+1/2)', '(-y+1/2,-x+1/2)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>4</b>: A fourfold rotation axis perpendicular to the plane.</li><li><b>g</b>: Glide planes perpendicular to the x and y axes.</li><li><b>m</b>: Mirror planes along the diagonals.</li></ul>' },
                p3: { system: 'hexagonal', equiv: ['(x, y)', '(-y, x-y)', '(y-x, -x)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>3</b>: A threefold rotation axis perpendicular to the plane.</li></ul>' },
                p3m1: { system: 'hexagonal', equiv: ['(x,y)', '(-y,x-y)', '(y-x,-x)', '(x-y,-y)', '(-x,y-x)', '(y,x)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>3</b>: A threefold rotation axis perpendicular to the plane.</li><li><b>m</b>: Mirror planes along the cell axes.</li><li><b>1</b>: No symmetry between the axes.</li></ul>' },
                p31m: { system: 'hexagonal', equiv: ['(x,y)', '(-y,x-y)', '(y-x,-x)', '(y,x)', '(x-y,-y)', '(-x,y-x)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>3</b>: A threefold rotation axis perpendicular to the plane.</li><li><b>1</b>: No symmetry along the cell axes.</li><li><b>m</b>: Mirror planes between the cell axes.</li></ul>' },
                p6: { system: 'hexagonal', equiv: ['(x,y)', '(-y,x-y)', '(y-x,-x)', '(-x,-y)', '(y,y-x)', '(x-y,x)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>6</b>: A sixfold rotation axis perpendicular to the plane.</li></ul>' },
                p6mm: { system: 'hexagonal', equiv: ['(x,y)', '(-y,x-y)', '(y-x,-x)', '(-x,-y)', '(y,y-x)', '(x-y,x)', '(y,x)', '(x-y,-y)', '(-x,y-x)', '(-y,-x)', '(y-x,y)', '(x,x-y)'], description: '<ul><li><b>p</b>: Primitive unit cell.</li><li><b>6</b>: A sixfold rotation axis perpendicular to the plane.</li><li><b>m (1st)</b>: Mirror planes along the cell axes.</li><li><b>m (2nd)</b>: Mirror planes between the cell axes.</li></ul>' }
            };

            const cellParams = {
                oblique: { a: 1, b: 0.8, gamma: 110 * Math.PI / 180 },
                rectangular: { a: 1, b: 0.7, gamma: 90 * Math.PI / 180 },
                square: { a: 1, b: 1, gamma: 90 * Math.PI / 180 },
                hexagonal: { a: 1, b: 1, gamma: 120 * Math.PI / 180 }
            };

            // --- Layout and Drawing Functions ---
            function resizeCanvases() {
                [symmetryCanvas, motifCanvas].forEach(canvas => {
                    const wrapper = canvas.parentElement;
                    const size = wrapper.clientWidth; // Base size on width only for consistency
                    canvas.width = size;
                    canvas.height = size;
                });
                draw();
            }

            function setCellTransform(ctx, params) {
                const { a, b, gamma } = params;
                const size = ctx.canvas.width;
                const margin = 0.15 * size; // Increased margin for labels
                const availableSize = size - 2 * margin;

                const p0 = { x: 0, y: 0 };
                const p1 = { x: a, y: 0 };
                const p2 = { x: a + b * Math.cos(gamma), y: b * Math.sin(gamma) };
                const p3 = { x: b * Math.cos(gamma), y: b * Math.sin(gamma) };

                const minX = Math.min(p0.x, p1.x, p2.x, p3.x);
                const maxX = Math.max(p0.x, p1.x, p2.x, p3.x);
                const minY = Math.min(p0.y, p1.y, p2.y, p3.y);
                const maxY = Math.max(p0.y, p1.y, p2.y, p3.y);

                const bboxWidth = maxX - minX;
                const bboxHeight = maxY - minY;

                const scale = Math.min(availableSize / bboxWidth, availableSize / bboxHeight);

                const translateX = margin - minX * scale + (availableSize - bboxWidth * scale) / 2;
                const translateY = margin - minY * scale + (availableSize - bboxHeight * scale) / 2;
                
                const translation = { x: translateX, y: translateY + bboxHeight * scale };

                ctx.resetTransform();
                ctx.translate(translation.x, translation.y);
                ctx.scale(1, -1);

                return {
                    transform: [scale * a, 0, scale * b * Math.cos(gamma), scale * b * Math.sin(gamma), 0, 0],
                    scale: scale,
                    translation: translation
                };
            }
            
            function fractionalToCanvas(fx, fy, transformInfo) {
                const cell_m = transformInfo.transform;
                const T = transformInfo.translation;

                // Apply cell transform (vectors)
                let cx = cell_m[0] * fx + cell_m[2] * fy;
                let cy = cell_m[1] * fx + cell_m[3] * fy;

                // Apply y-flip
                cy = -cy;

                // Apply translation
                cx += T.x;
                cy += T.y;

                return { x: cx, y: cy };
            }

            function drawAxes(ctx, transformInfo) {
                const origin = fractionalToCanvas(0, 0, transformInfo);
                const x_end = fractionalToCanvas(1, 0, transformInfo);
                const y_end = fractionalToCanvas(0, 1, transformInfo);

                ctx.save();
                ctx.resetTransform(); // Work in raw canvas coordinates
                const fontSize = 14;
                ctx.font = `italic ${fontSize}px sans-serif`;
                ctx.fillStyle = '#1e293b'; // A dark slate color
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Direction vectors for offsetting labels
                const x_vec = { x: x_end.x - origin.x, y: x_end.y - origin.y };
                const y_vec = { x: y_end.x - origin.x, y: y_end.y - origin.y };
                const x_mag = Math.sqrt(x_vec.x**2 + x_vec.y**2);
                const y_mag = Math.sqrt(y_vec.x**2 + y_vec.y**2);
                const x_unit = x_mag > 0 ? { x: x_vec.x / x_mag, y: x_vec.y / x_mag } : {x:0, y:0};
                const y_unit = y_mag > 0 ? { x: y_vec.x / y_mag, y: y_vec.y / y_mag } : {x:0, y:0};

                const offset = fontSize;

                // Offset for '0' is away from the corner interior
                const o_offset_x = (-x_unit.x - y_unit.x) * offset * 0.6;
                const o_offset_y = (-x_unit.y - y_unit.y) * offset * 0.6;
                ctx.fillText('0', origin.x + o_offset_x, origin.y + o_offset_y);

                // Offset for 'x' is along the x-axis direction
                ctx.fillText('x', x_end.x + x_unit.x * offset, x_end.y + x_unit.y * offset);

                // Offset for 'y' is along the y-axis direction
                ctx.fillText('y', y_end.x + y_unit.x * offset, y_end.y + y_unit.y * offset);

                ctx.restore();
            }

            function applyCellTransform(ctx, transform) {
                 ctx.transform(transform[0], transform[1], transform[2], transform[3], transform[4], transform[5]);
            }

            function drawUnitCell(ctx, transform) {
                ctx.save();
                applyCellTransform(ctx, transform.transform);
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 0.01;
                ctx.beginPath();
                ctx.moveTo(0, 0); ctx.lineTo(1, 0); ctx.lineTo(1, 1); ctx.lineTo(0, 1); ctx.closePath();
                ctx.stroke();
                ctx.restore();
            }

            function drawCellGrid(ctx, transform) {
                ctx.save();
                applyCellTransform(ctx, transform.transform);
                ctx.strokeStyle = '#cbd5e1';
                ctx.lineWidth = 0.005;
                ctx.setLineDash([0.02, 0.02]);
                ctx.beginPath();
                ctx.moveTo(0.5, 0); ctx.lineTo(0.5, 1);
                ctx.moveTo(0, 0.5); ctx.lineTo(1, 0.5);
                ctx.stroke();
                ctx.restore();
            }

            function drawMotif(ctx, motif, angle = 0, mirror = false) {
                const motifSize = 0.05;
                ctx.save();
                ctx.rotate(angle * Math.PI / 180);

                if (mirror === 'x') ctx.scale(1, -1);
                else if (mirror === 'y') ctx.scale(-1, 1);
                else if (mirror === 'xy') ctx.transform(0, 1, 1, 0, 0, 0);
                else if (mirror === 'x-y') ctx.transform(0, -1, -1, 0, 0, 0);

                ctx.fillStyle = motif.color;
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 0.005;

                switch (motif.shape) {
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(0, 0, motifSize * 0.8, 0, 2 * Math.PI);
                        ctx.stroke();
                        if (mirror) {
                            ctx.beginPath();
                            ctx.arc(motifSize * 0.15, -motifSize * 0.15, motifSize * 0.3, Math.PI * 0.4, Math.PI * 1.6);
                            ctx.stroke();
                        }
                        break;
                    case 'triangle': ctx.beginPath(); ctx.moveTo(0, -motifSize); ctx.lineTo(-motifSize, motifSize); ctx.lineTo(motifSize, motifSize); ctx.closePath(); ctx.fill(); ctx.stroke(); break;
                    //le quadri ne sert pas Ã  grand chose
                    case 'quadri': ctx.fillRect(-motifSize, -motifSize, motifSize * 2, motifSize * 2); ctx.strokeRect(-motifSize, -motifSize, motifSize * 2, motifSize * 2); break;
                    case 'comma': ctx.beginPath(); ctx.arc(0, 0, motifSize, 0, Math.PI, false); ctx.arc(0, -motifSize/2, motifSize/2, Math.PI, 0, true); ctx.closePath(); ctx.fill(); ctx.stroke(); break;
                }

                ctx.restore();
            }

            function drawSymmetryElements(ctx, transform) {
                const sg = state.spaceGroup;
                ctx.save();
                applyCellTransform(ctx, transform.transform);

                const lw = 0.01;
                const r = 0.05;

                const draw2Fold = (x, y) => {
                    ctx.fillStyle = '#ff00ff';
                    ctx.beginPath();
                    ctx.ellipse(x, y, r, r*0.6, 0, 0, 2 * Math.PI);
                    ctx.fill();
                };
                const draw4Fold = (x, y) => {
                    ctx.fillStyle = '#ff00ff';
                    ctx.beginPath();
                    ctx.rect(x - r, y - r, r*2, r*2);
                    ctx.fill();
                };
                const draw3Fold = (x, y) => {
                    ctx.fillStyle = '#ff00ff';
                    ctx.beginPath();
                    ctx.moveTo(x, y + r);
                    ctx.lineTo(x - r*0.866, y - r*0.5);
                    ctx.lineTo(x + r*0.866, y - r*0.5);
                    ctx.closePath();
                    ctx.fill();
                };
                const draw6Fold = (x, y) => {
                    ctx.fillStyle = '#ff00ff';
                    ctx.beginPath();
                    for(let i=0; i<6; i++) {
                        ctx.lineTo(x + r * Math.cos(Math.PI/3 * i), y + r * Math.sin(Math.PI/3 * i));
                    }
                    ctx.closePath();
                    ctx.fill();
                };
                const drawMirror = (x1, y1, x2, y2) => {
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = lw;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                };
                const drawGlide = (x1, y1, x2, y2) => {
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = lw;
                    ctx.setLineDash([0.05, 0.05]);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                };

                const elements = {
                    p1: [],
                    p2: [
                        {type: '2fold', at: [[0,0], [0.5,0], [1,0], [0,0.5], [0.5,0.5], [1,0.5], [0,1], [0.5,1], [1,1]]}
                    ],
                    pm: [
                        {type: 'mirror', from: [0,0], to: [0,1]},
                        {type: 'mirror', from: [0.5,0], to: [0.5,1]},
                        {type: 'mirror', from: [1,0], to: [1,1]}
                    ],
                    pg: [
                        {type: 'glide', from: [0,0], to: [0,1]},
                        {type: 'glide', from: [0.5,0], to: [0.5,1]},
                        {type: 'glide', from: [1,0], to: [1,1]}
                    ],
                    cm: [
                        {type: 'mirror', from: [0,0], to: [0,1]},
                        {type: 'mirror', from: [0.5,0], to: [0.5,1]},
                        {type: 'mirror', from: [1,0], to: [1,1]},
                        {type: 'glide', from: [0.25,0], to: [0.25,1]},
                        {type: 'glide', from: [0.75,0], to: [0.75,1]}
                    ],
                    p2mm: [
                        {type: '2fold', at: [[0,0], [0.5,0], [1,0], [0,0.5], [0.5,0.5], [1,0.5], [0,1], [0.5,1], [1,1]]},
                        {type: 'mirror', from: [0,0], to: [0,1]},
                        {type: 'mirror', from: [0.5,0], to: [0.5,1]},
                        {type: 'mirror', from: [1,0], to: [1,1]},
                        {type: 'mirror', from: [0,0], to: [1,0]},
                        {type: 'mirror', from: [0,0.5], to: [1,0.5]},
                        {type: 'mirror', from: [0,1], to: [1,1]}
                    ],
                    p2mg: [
                        {type: '2fold', at: [[0,0], [0.5,0], [0,0.5], [0.5,0.5], [1,0], [0,1], [1,1], [1,0.5], [0.5,1]]},
                        {type: 'mirror', from: [0.25,0], to: [0.25,1]},
                        {type: 'mirror', from: [0.75,0], to: [0.75,1]},
                        {type: 'glide', from: [0,0], to: [1,0]},
                        {type: 'glide', from: [0,0.5], to: [1,0.5]},
                        {type: 'glide', from: [0,1], to: [1,1]}
                    ],
                    p2gg: [
                        {type: '2fold', at: [[0,0], [0.5,0.5], [0.5,0], [0,0.5], [1,0], [0,1], [1,1], [1,0.5], [0.5,1]]},
                        {type: 'glide', from: [0.25,0], to: [0.25,1]},
                        {type: 'glide', from: [0.75,0], to: [0.75,1]},
                        {type: 'glide', from: [0,0.25], to: [1,0.25]},
                        {type: 'glide', from: [0,0.75], to: [1,0.75]}
                    ],
                    c2mm: [
                        {type: '2fold', at: [[0,0], [0.5,0], [1,0], [0,0.5], [0.5,0.5], [1,0.5], [0,1], [0.5,1], [1,1], [0.25,0.25], [0.25,0.75], [0.75,0.25], [0.75,0.75]]},
                        {type: 'mirror', from: [0,0], to: [0,1]},
                        {type: 'mirror', from: [0.5,0], to: [0.5,1]},
                        {type: 'mirror', from: [1,0], to: [1,1]},
                        {type: 'mirror', from: [0,0], to: [1,0]},
                        {type: 'mirror', from: [0,0.5], to: [1,0.5]},
                        {type: 'mirror', from: [0,1], to: [1,1]},
                        {type: 'glide', from: [0.25,0], to: [0.25,1]},
                        {type: 'glide', from: [0.75,0], to: [0.75,1]},
                        {type: 'glide', from: [0,0.25], to: [1,0.25]},
                        {type: 'glide', from: [0,0.75], to: [1,0.75]}
                    ],
                    p4: [
                        {type: '4fold', at: [[0,0], [0.5,0.5], [1,1], [1,0], [0,1]]},
                        {type: '2fold', at: [[0.5,0], [0,0.5], [0.5,1], [1,0.5]]}
                    ],
                    p4mm: [
                        {type: '4fold', at: [[0,0], [0.5,0.5], [1,1], [1,0], [0,1]]},
                        {type: '2fold', at: [[0.5,0], [0,0.5], [0.5,1], [1,0.5]]},
                        {type: 'mirror', from: [0,0], to: [1,0]},
                        {type: 'mirror', from: [0,0.5], to: [1,0.5]},
                        {type: 'mirror', from: [0,1], to: [1,1]},
                        {type: 'mirror', from: [0,0], to: [0,1]},
                        {type: 'mirror', from: [0.5,0], to: [0.5,1]},
                        {type: 'mirror', from: [1,0], to: [1,1]},
                        {type: 'mirror', from: [0,0], to: [1,1]},
                        {type: 'mirror', from: [0,1], to: [1,0]}
                    ],
                    p4gm: [
                        {type: '4fold', at: [[0,0], [0.5,0.5], [1,1], [1,0], [0,1]]},
                        {type: '2fold', at: [[0.5,0], [0,0.5], [0.5,1], [1,0.5]]},
                        {type: 'glide', from: [0.25, 0], to: [0.25, 1]},
                        {type: 'glide', from: [0.75, 0], to: [0.75, 1]},
                        {type: 'glide', from: [0, 0.25], to: [1, 0.25]},
                        {type: 'glide', from: [0, 0.75], to: [1, 0.75]},
                        {type: 'mirror', from: [0, 0.5], to: [0.5, 0]},
                        {type: 'mirror', from: [0.5, 1], to: [1, 0.5]},
                        {type: 'mirror', from: [0.5, 0], to: [1, 0.5]},
                        {type: 'mirror', from: [0.5, 1], to: [0, 0.5]},
                        {type: 'glide', from: [0,0], to: [1,1]},
                        {type: 'glide', from: [0,1], to: [1,0]}
                    ],
                    p3: [
                        {type: '3fold', at: [[0,0], [1/3, 2/3], [2/3, 1/3], [1,1], [1,0], [0,1]]}
                    ],
                    p3m1: [
                        {type: '3fold', at: [[0,0], [1,0], [0,1], [1,1], [1/3, 2/3], [2/3, 1/3]]},
                        {type: 'mirror', from: [0, 0], to: [0.5, 1]},
                        {type: 'mirror', from: [0.5, 0], to: [1, 1]},
                        {type: 'mirror', from: [0, 0.5], to: [1,1]},
                        {type: 'mirror', from: [0, 0], to: [1, 0.5]},
                        {type: 'mirror', from: [0, 1], to: [1, 0]}
                    ],
                    p31m: [
                        {type: '3fold', at: [[0,0], [1/3, 2/3], [2/3, 1/3], [1,1], [1,0], [0,1]]},
                        {type: 'mirror', from: [0,0], to: [1,0]},
                        {type: 'mirror', from: [0,1], to: [1,1]},
                        {type: 'mirror', from: [1,0], to: [1,1]},
                        {type: 'mirror', from: [0,0], to: [0,1]},
                        {type: 'mirror', from: [0,0], to: [1,1]},
                        {type: 'glide', from: [0.5, 0], to: [0.5, 1]},
                        {type: 'glide', from: [0, 0.5], to: [1, 0.5]},
                        {type: 'glide', from: [0, 0.5], to: [0.5, 1]},
                        {type: 'glide', from: [0.5, 0], to: [1, 0.5]}
                    ],
                    p6: [
                        {type: '6fold', at: [[0,0], [1,0], [0,1], [1,1]]},
                        {type: '3fold', at: [[1/3, 2/3], [2/3, 1/3]]},
                        {type: '2fold', at: [[0.5,0], [0,0.5], [0.5,0.5], [1,0.5], [0.5,1]]}
                    ],
                    p6mm: [
                        {type: '6fold', at: [[0,0], [1,0], [0,1], [1,1]]},
                        {type: '3fold', at: [[1/3, 2/3], [2/3, 1/3]]},
                        {type: '2fold', at: [[0.5,0], [0,0.5], [0.5,0.5], [1,0.5], [0.5,1]]},
                        {type: 'mirror', from: [0,0], to: [0.5,1]},
                        {type: 'mirror', from: [0.5,0], to: [1,1]},
                        {type: 'mirror', from: [0,0], to: [1,1]},
                        {type: 'mirror', from: [0,0.5], to: [1,1]},
                        {type: 'mirror', from: [0,1], to: [1,0]},
                        {type: 'mirror', from: [0,0], to: [1,0.5]}
                    ]
                };

                const sgElements = elements[sg] || [];
                sgElements.forEach(el => {
                    if (el.at) {
                        el.at.forEach(pos => {
                            if (el.type === '2fold') draw2Fold(pos[0], pos[1]);
                            if (el.type === '4fold') draw4Fold(pos[0], pos[1]);
                            if (el.type === '3fold') draw3Fold(pos[0], pos[1]);
                            if (el.type === '6fold') draw6Fold(pos[0], pos[1]);
                        });
                    } else if (el.from && el.to) {
                        if (el.type === 'mirror') drawMirror(el.from[0], el.from[1], el.to[0], el.to[1]);
                        if (el.type === 'glide') drawGlide(el.from[0], el.from[1], el.to[0], el.to[1]);
                    }
                });
                ctx.restore();
            }

            function getSymmetryOperations(spaceGroup) {
                const ops = {
                    p1: (x, y) => [{x, y}],
                    p2: (x, y) => [{x, y}, {x: -x, y: -y, a: 180}],
                    pm: (x, y) => [{x, y}, {x: -x, y, m: 'y'}],
                    pg: (x, y) => [{x, y}, {x: -x, y: y + 0.5, m: 'y'}],
                    cm: (x, y) => [{x, y}, {x: -x, y, m: 'y'}, {x: x + 0.5, y: y + 0.5}, {x: -x + 0.5, y: y + 0.5, m: 'y'}],
                    p2mm: (x, y) => [{x, y}, {x: -x, y, m: 'y'}, {x, y: -y, m: 'x'}, {x: -x, y: -y, a: 180}],
                    p2mg: (x, y) => [{x, y}, {x: -x, y: -y, a: 180}, {x: -x + 0.5, y, m: 'y'}, {x: x + 0.5, y: -y, m: 'x'}],
                    p2gg: (x, y) => [{x, y}, {x: -x, y: -y, a: 180}, {x: -x + 0.5, y: y + 0.5, m: 'y'}, {x: x + 0.5, y: -y + 0.5, m: 'x'}],
                    c2mm: (x, y) => [{x, y}, {x:-x,y,m:'y'}, {x,y:-y,m:'x'}, {x:-x,y:-y, a: 180}, {x:x+0.5,y:y+0.5}, {x:-x+0.5,y:y+0.5,m:'y'}, {x:x+0.5,y:-y+0.5,m:'x'}, {x:-x+0.5,y:-y+0.5, a: 180}],                    p4: (x, y) => [{x, y}, {x: -y, y: x, a: 90}, {x: -x, y: -y, a: 180}, {x: y, y: -x, a: 270}],
                    //erreur dans le groupe c2mm; correction le 22 sept 2025
                    p4mm: (x, y) => [{x, y}, {x: -y, y: x, a: 90}, {x: -x, y: -y, a: 180}, {x: y, y: -x, a: 270}, {x: -x, y, m: 'y'}, {x: y, y: x, m: 'xy'}, {x, y: -y, m: 'x'}, {x: -y, y: -x, m: 'x-y'}],
                    p4gm: (x, y) => [{x:x, y:y}, {x:-x, y:-y, a:180}, {x:-y, y:x, a:90}, {x:y, y:-x, a:270}, {x:-x+0.5, y:y+0.5, m:'y'}, {x:x+0.5, y:-y+0.5, m:'x'}, {x:y+0.5, y:x+0.5, m:'xy'}, {x:-y+0.5, y:-x+0.5, m:'x-y'}],
                    p3: (x, y) => [{x,y}, {x: -y, y: x-y, a:120}, {x: y-x, y: -x, a:240}],
                    p3m1: (x, y) => [{x:x, y:y}, {x:-y, y:x-y, a:120}, {x:y-x, y:-x, a:240}, {x:x-y, y:-y, m:'x'}, {x:-x, y:y-x, m:'y'}, {x:y, y:x, m:'xy'}],
                    p31m: (x, y) => [{x:x, y:y}, {x:-y, y:x-y, a:120}, {x:y-x, y:-x, a:240}, {x:y, y:x, m:'xy'}, {x:x-y, y:-y, m:'x'}, {x:-x, y:y-x, m:'y'}],
                    p6: (x, y) => [{x:x, y:y}, {x:-y, y:x-y, a:120}, {x:y-x, y:-x, a:240}, {x:-x, y:-y, a:180}, {x:y, y:y-x, a:60}, {x:x-y, y:x, a:300}],
                    p6mm: (x, y) => [{x:x, y:y}, {x:-y, y:x-y, a:120}, {x:y-x, y:-x, a:240}, {x:-x, y:-y, a:180}, {x:y, y:y-x, a:60}, {x:x-y, y:x, a:300}, {x:y, y:x, m:'xy'}, {x:x-y, y:-y, m:'x'}, {x:-x, y:y-x, m:'y'}, {x:-y, y:-x, m:'x-y'}, {x:y-x, y:y, m:'?'}, {x:x, y:x-y, m:'?'}]
                };
                return ops[spaceGroup];
            }

            function draw() {
                const info = spaceGroupInfo[state.spaceGroup];
                const params = cellParams[info.system];

                [symCtx, motifCtx].forEach(ctx => {
                    ctx.save();
                    ctx.resetTransform();
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    ctx.restore();
                });

                const symTransform = setCellTransform(symCtx, params);
                const motifViewTransform = setCellTransform(motifCtx, params);

                // Draw Symmetry Canvas Content
                drawUnitCell(symCtx, symTransform);
                drawSymmetryElements(symCtx, symTransform);
                drawAxes(symCtx, symTransform);

                // Draw Motif Canvas Content
                drawUnitCell(motifCtx, motifViewTransform);
                if (info.system !== 'oblique') {
                    drawCellGrid(motifCtx, motifViewTransform);
                }

                const opFunc = getSymmetryOperations(state.spaceGroup);
                if (!opFunc) return;

                const motifsToDraw = [];
                const m1_x = state.motif1.x % 1;
                const m1_y = state.motif1.y % 1;
                motifsToDraw.push({
                    ...state.motif1,
                    x: m1_x < 0 ? m1_x + 1 : m1_x,
                    y: m1_y < 0 ? m1_y + 1 : m1_y
                });

                if (state.motif2.enabled) {
                    const m2_x = state.motif2.x % 1;
                    const m2_y = state.motif2.y % 1;
                    motifsToDraw.push({
                        ...state.motif2,
                        x: m2_x < 0 ? m2_x + 1 : m2_x,
                        y: m2_y < 0 ? m2_y + 1 : m2_y
                    });
                }

                let generatedPositionsHTML = '';

                motifCtx.save();
                applyCellTransform(motifCtx, motifViewTransform.transform);

                motifsToDraw.forEach((motif, index) => {
                    if (!motif) return;
                    const operations = opFunc(motif.x, motif.y);

                    if (operations) {
                        const uniquePositions = new Set();
                        operations.forEach(op => {
                            let centralX = op.x % 1;
                            let centralY = op.y % 1;
                            if (centralX < 0) centralX += 1;
                            if (centralY < 0) centralY += 1;
                            const posString = `${centralX.toFixed(3)}, ${centralY.toFixed(3)}`;
                            uniquePositions.add(posString);
                        });
                        uniquePositions.forEach(pos => {
                             generatedPositionsHTML += `<div style="color: ${motif.color};">(${pos})</div>`;
                        });
                    }

                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            operations.forEach(op => {
                                let opX = op.x + dx;
                                let opY = op.y + dy;

                                motifCtx.save();
                                motifCtx.translate(opX, opY);
                                drawMotif(motifCtx, motif, op.a, op.m);
                                motifCtx.restore();
                            });
                        }
                    }
                });

                motifCtx.restore();
                generatedPositionsDiv.innerHTML = generatedPositionsHTML;
                
                // Draw axes on top of the generated pattern
                drawAxes(motifCtx, motifViewTransform);
            }

            // --- Event Handlers ---
            function updateStateFromUI() {
                state.spaceGroup = spaceGroupSelect.value;
                const info = spaceGroupInfo[state.spaceGroup];
                cellTypeSpan.textContent = info.system.charAt(0).toUpperCase() + info.system.slice(1);
                notationDescriptionDiv.innerHTML = info.description;
                equivalentPositionsDiv.innerHTML = info.equiv.map(p => `<div>${p}</div>`).join('');

                state.motif1.shape = motif1Shape.value;
                state.motif1.x = parseFloat(motif1X.value);
                state.motif1.y = parseFloat(motif1Y.value);
                motif1XNum.value = motif1X.value;
                motif1YNum.value = motif1Y.value;

                state.motif2.enabled = motif2Enable.checked;
                motif2Controls.style.display = state.motif2.enabled ? 'block' : 'none';
                if (state.motif2.enabled) {
                    state.motif2.shape = motif2Shape.value;
                    state.motif2.x = parseFloat(motif2X.value);
                    state.motif2.y = parseFloat(motif2Y.value);
                    motif2XNum.value = motif2X.value;
                    motif2YNum.value = motif2Y.value;
                }
                draw();
            }

            function setupEventListeners() {
                spaceGroupSelect.addEventListener('change', updateStateFromUI);
                motif1Shape.addEventListener('change', updateStateFromUI);
                motif1X.addEventListener('input', () => { motif1XNum.value = motif1X.value; updateStateFromUI(); });
                motif1Y.addEventListener('input', () => { motif1YNum.value = motif1Y.value; updateStateFromUI(); });
                motif1XNum.addEventListener('input', (e) => { motif1X.value = e.target.value; updateStateFromUI(); });
                motif1YNum.addEventListener('input', (e) => { motif1Y.value = e.target.value; updateStateFromUI(); });

                motif2Enable.addEventListener('change', updateStateFromUI);
                motif2Shape.addEventListener('change', updateStateFromUI);
                motif2X.addEventListener('input', () => { motif2XNum.value = motif2X.value; updateStateFromUI(); });
                motif2Y.addEventListener('input', () => { motif2YNum.value = motif2Y.value; updateStateFromUI(); });
                motif2XNum.addEventListener('input', (e) => { motif2X.value = e.target.value; updateStateFromUI(); });
                motif2YNum.addEventListener('input', (e) => { motif2Y.value = e.target.value; updateStateFromUI(); });

                window.addEventListener('resize', resizeCanvases);
            }

            // --- Resizer Logic ---
            const resizer = document.getElementById('drag-handle');
            const leftPanel = document.getElementById('controls-panel');
            let isResizing = false;

            resizer.addEventListener('mousedown', e => {
                e.preventDefault();
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', stopResize);
            });

            function handleMouseMove(e) {
                if (!isResizing) return;
                const container = resizer.parentElement;
                const newLeftWidth = e.clientX - container.getBoundingClientRect().left;
                if (newLeftWidth > 300 && newLeftWidth < container.clientWidth - 400) {
                    leftPanel.style.width = `${newLeftWidth}px`;
                    resizeCanvases();
                }
            }

            function stopResize() {
                isResizing = false;
                document.body.style.cursor = 'default';
                document.body.style.userSelect = 'auto';
                window.removeEventListener('mousemove', handleMouseMove);
                window.removeEventListener('mouseup', stopResize);
            }


            // --- Initialization ---
            setupEventListeners();
            const ro = new ResizeObserver(resizeCanvases);
            ro.observe(document.getElementById('visualization-area'));
            updateStateFromUI();
        });
    </script>
</body>
</html>