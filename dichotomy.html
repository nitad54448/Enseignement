<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dichotomy Powder Indexing</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
 
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>

    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        :root {
            --dark-bg: #111827;
            --medium-bg: #1f2937;
            --light-bg: #374151;
            --border-color: #4b5563;
            --primary-accent: #1a73e8;
            --primary-accent-hover: #1765cc;
            --text-light: #e5e7eb;
            --text-medium: #d1d5db;
            --text-dark: #9ca3af;
            --success-green: #16a34a;
            --error-red: #dc2626;
            --led-gray: #6b7280;
        }

        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f9fafb; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #app-container { display: flex; width: 100%; flex-grow: 1; min-height: 0; }
        
        #controls-panel { 
            width: 400px; min-width: 300px; max-width: 700px; flex-shrink: 0; 
            padding: 24px; background-color: var(--dark-bg); border-right: 1px solid var(--light-bg); 
            overflow-y: visible; color: var(--text-medium); display: flex; flex-direction: column;
            position: relative;
            z-index: 20;
        }
        
        #drag-handle { width: 6px; cursor: col-resize; background-color: var(--light-bg); flex-shrink: 0; transition: background-color: 0.2s; }
        #drag-handle:hover, #drag-handle:active { background-color: var(--primary-accent); }
        
        #results-area { 
            flex-grow: 1; position: relative; background-color: #ffffff; 
            min-width: 0; display: flex; flex-direction: column; 
            padding: 1.5rem; color: var(--medium-bg);
            z-index: 10;
        }

        .control-group { margin-bottom: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--light-bg); }
        .control-group:first-child { border-top: none; padding-top: 0; }
        .control-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-dark); font-size: 0.875rem; }
        .control-input, .control-select { width: 100%; background-color: var(--light-bg); border: 1px solid var(--border-color); color: var(--text-light); border-radius: 0.35rem; padding: 0.5rem 0.75rem; transition: all 0.2s ease; box-sizing: border-box; }
        .control-input:focus, .control-select:focus { outline: none; border-color: var(--primary-accent); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); }
 
        .btn-like {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.6rem 1rem;
            border-radius: 0.375rem;
            font-weight: 600;
            font-size: 1rem;
            text-align: center;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s;
        }

        .btn {
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }

        .btn-primary { background-color: var(--primary-accent); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: var(--primary-accent-hover); }
        .btn-secondary { background-color: var(--light-bg); color: var(--text-light); border-color: var(--border-color); }
        .btn-secondary:hover:not(:disabled) { background-color: #4a5568; }
        .btn:disabled { background-color: var(--border-color); cursor: not-allowed; opacity: 0.7; }

        .file-input-label {
            background-color: var(--border-color);
            color: var(--text-medium);
        }
        .file-input-label:hover { background-color: #6b7280; }
        .file-input-label.error { border: 1px solid var(--error-red); color: var(--error-red); }
        .parameter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
        .checkbox-label { display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; color: var(--text-medium); cursor: pointer;}

        input[type="checkbox"] {
            accent-color: var(--primary-accent);
            transform: scale(1.1);
            vertical-align: middle; 
        }
        .hidden { display: none !important; }

        /* Tab Styles */
        .tab-buttons { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 1rem; }
        .tab-btn { flex: 1; padding: 0.75rem 0.5rem; background: none; border: none; color: var(--text-dark); font-weight: 600; cursor: pointer; border-bottom: 2px solid transparent; transition: all 0.2s; font-size: 0.9rem; display: flex; align-items: center; justify-content: center; gap: 8px;}
        .tab-btn:hover { color: var(--text-light); }
        .tab-btn.active { color: var(--primary-accent); border-bottom-color: var(--primary-accent); }
        .tab-content-panels { flex-grow: 1; min-height: 0; position: relative; }
        .tab-content-panel { display: none; flex-direction: column; height: 100%; overflow-y: auto; padding-right: 8px; margin-right: -8px;}
        .tab-content-panel.active { display: flex; }
        .tab-content-panel::-webkit-scrollbar { width: 6px; }
        .tab-content-panel::-webkit-scrollbar-track { background: var(--dark-bg); }
        .tab-content-panel::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
        .tab-content-panel::-webkit-scrollbar-thumb:hover { background: var(--light-bg); }
        #solutions-tab-content .control-group { flex-grow: 1; display: flex; flex-direction: column; margin-bottom: 0;}
        #solutions-table-container { flex-grow: 1; overflow-y: auto; background-color: var(--medium-bg); border-radius: 0.375rem; border: 1px solid var(--border-color); }

        /* --- LED Indicator Styles --- */
        .led-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transition: background-color 0.3s ease;
        }
        .led-indicator.gray { background-color: var(--led-gray); }
        .led-indicator.green { background-color: var(--success-green); box-shadow: 0 0 5px var(--success-green);}
        .led-indicator.red { background-color: var(--error-red); box-shadow: 0 0 5px var(--error-red); }

        #peak-table-container {
            overflow-y: auto;
            background-color: var(--medium-bg);
            border-radius: 0.375rem;
            border: 1px solid var(--border-color);
            margin-top: 1rem;
        }
        .peak-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        .peak-table th, .peak-table td { padding: 0.5rem; text-align: right; border-bottom: 1px solid var(--border-color); }
        .peak-table th { background-color: #2a3547; font-weight: 600; text-align: center; position: sticky; top: 0; }
        .peak-table input { width: 100%; background: transparent; border: none; color: var(--text-light); text-align: right; padding: 2px; border-radius: 2px; }
        .peak-table input:focus { background-color: var(--light-bg); outline: 1px solid var(--primary-accent); }
        .peak-table th, .peak-table td, .peak-table input { text-align: center; }
        .delete-peak-btn { background: none; border: none; color: var(--text-dark); cursor: pointer; font-weight: bold; }
        .delete-peak-btn:hover { color: var(--error-red); }

        .solutions-table { width: 100%; border-collapse: collapse; font-size: 0.75rem; }
        .solutions-table th, .solutions-table td { padding: 0.5rem; text-align: left; border-bottom: 1px solid var(--border-color); vertical-align: middle;}
        .solutions-table th { background-color: #2a3547; font-weight: 600; position: sticky; top: 0;}
        .solutions-table th[data-sort] { cursor: pointer; } 
        .solutions-table th[data-sort]:hover { background-color: var(--light-bg); }
        .solutions-table th.sort-asc::after,
        .solutions-table th.sort-desc::after {
            content: ''; display: inline-block; margin-left: 5px; width: 0; height: 0;
            border-left: 4px solid transparent; border-right: 4px solid transparent;
        }
        .solutions-table th.sort-asc::after { border-bottom: 4px solid var(--text-light); }
        .solutions-table th.sort-desc::after { border-top: 4px solid var(--text-light); }
        .solutions-table td:nth-child(4), .solutions-table td:nth-child(5) { text-align: right; } /* Align Vol and M20 right */

        .solutions-table tbody tr { cursor: pointer; transition: background-color: 0.2s; }
        .solutions-table tbody tr:hover { background-color: var(--light-bg); }
        .solutions-table tbody tr.selected { background-color: var(--primary-accent); color: white;}

        .bottom-actions { margin-top: auto; padding-top: 1rem; border-top: 1px solid var(--light-bg); }

        #status-box {
            position: fixed; bottom: 20px; right: 20px; padding: 12px 20px; border-radius: 6px;
            color: white; font-size: 0.8rem; font-weight: 500; z-index: 1000;
            opacity: 0; visibility: hidden; transform: translateY(20px);
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        #status-box.show { opacity: 1; visibility: visible; transform: translateY(0); }
        #status-box.success { background-color: var(--success-green); }
        #status-box.error { background-color: var(--error-red); }
        #status-box.info { background-color: var(--border-color); }

        /* --- Help Tooltip Styles --- */
        .help-tooltip-container { position: relative; display: inline-block; }
        .help-icon {
            display: flex; align-items: center; justify-content: center; width: 28px; height: 28px;
            background-color: var(--border-color); color: var(--text-light); border-radius: 50%;
            font-weight: bold; font-size: 1rem; cursor: help; transition: background-color: 0.2s;
        }
        .help-icon:hover { background-color: #6b7280; }
        .tooltip-content {
            visibility: hidden; opacity: 0; width: 320px; background-color: var(--light-bg);
            color: var(--text-medium); text-align: left; border-radius: 0.375rem; padding: 1rem;
            position: absolute; z-index: 1001;
            top: -15px; 
            left: 115%; 
            margin-left: 10px; 
            transition: opacity 0.3s; font-size: 0.8rem; border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }
        .tooltip-content::after {
            content: ""; position: absolute;
            top: 20px; 
            right: 100%;
            margin-top: -5px; 
            border-width: 5px; border-style: solid;
            border-color: transparent var(--light-bg) transparent transparent;
        }
        .help-tooltip-container:hover .tooltip-content { visibility: visible; opacity: 1; }
        .tooltip-content h4 { color: var(--text-light); font-size: 0.9rem; margin-top: 0; margin-bottom: 0.5rem; font-weight: 600; }
        .tooltip-content p { margin-top: 0; margin-bottom: 0.75rem; line-height: 1.4; }
        .tooltip-content p:last-child { margin-bottom: 0; }
        .tooltip-content hr { border: none; border-top: 1px solid var(--border-color); margin: 0.75rem 0; }

        /* --- Compact Slider Styles --- */
        .slider-group {
            display: grid;
            grid-template-columns: minmax(100px, auto) 1fr;
            gap: 12px;
            align-items: center;
            margin-bottom: 1rem;
        }
        .slider-group:last-child {
            margin-bottom: 0;
        }
        .slider-group > .control-label {
            margin-bottom: 0;
            font-size: 0.875rem;
            white-space: nowrap;
        }
        .slider-value-track {
            grid-column: 2;
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
            align-items: center;
        }
        .slider-value-track > * {
            grid-column: 1;
            grid-row: 1;
        }
        .slider-value-display {
            text-align: center;
            color: var(--text-dark);
            font-weight: 500;
            font-size: 0.8rem;
            pointer-events: none;
        }
        input[type="range"].custom-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 32px;
            background: var(--medium-bg);
            border-radius: 6px;
            outline: none;
            padding: 0;
            margin: 0;
        }
        input[type="range"].custom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            background: var(--primary-accent);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--text-light);
            box-sizing: border-box;
            box-shadow: 0 2px 4px rgba(0,0,0,0.25);
        }
        input[type="range"].custom-slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            background: var(--primary-accent);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--text-light);
            box-sizing: border-box;
            box-shadow: 0 2px 4px rgba(0,0,0,0.25);
        }
        input[type="range"].custom-slider:disabled {
            background: var(--light-bg);
        }
        input[type="range"].custom-slider:disabled::-webkit-slider-thumb {
            background: var(--border-color);
        }
        input[type="range"].custom-slider:disabled::-moz-range-thumb {
            background: var(--border-color);
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">

            <div class="control-group">
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <label for="file-input" class="file-input-label btn-like" style="flex-grow: 1;">
                        <span id="file-name">Select Data File</span>
                    </label>
                     <div class="help-tooltip-container">
                        <span class="help-icon" aria-label="Help and usage information">?</span>
<div class="tooltip-content">
    <h4>Powder XRD Indexing</h4>
    <p>Determine unit cell parameters using the <a href="dichotomy_help.html" target="_blank" style="color: red;">Dichotomy method</a>. Based on the method of A. Boultif & D. Louer, J. Appl. Cryst. 37, 724-731 (2004).</p>
    <p>This is a simplified version for educational purposes. For real stuff use the original code or other indexing programs.</p>
    <hr>
    <h4>Supported File Formats:</h4>
    <p>Generic 2-column (2&theta; intensity), .xrdml, .brml, .ras, .uxd, .udf, GSAS .esd</p>
    <hr>
    <h4>Chart Interaction:</h4>
    <p><b>Zoom:</b> Use the mouse wheel over the plot, X-axis, or Y-axis. Right-click to reset zoom.</p>
    <p><b>Pan:</b> Click and drag the chart to pan.</p>
    <p><b>Add Peak:</b> Hold <b>Ctrl</b> and click on the chart to manually add a peak at that position.</p>
</div>
                    </div>
                </div>
                <input type="file" id="file-input" class="hidden" accept=".xy,.csv,.txt,.xrdml,.brml,.ras,.esd,.std,.udf,.gsa">
            </div>

            <div class="tab-buttons">
                <button class="tab-btn active" data-tab="peaks">Peaks</button>
                <button class="tab-btn" data-tab="parameters">Parameters</button>
                <button class="tab-btn" data-tab="solutions">
                    Solutions
                    <span id="solutions-led" class="led-indicator gray" aria-label="Solutions status indicator"></span>
                </button>
            </div>

            <div class="tab-content-panels">
                <div id="peaks-tab-content" class="tab-content-panel active">
                     <div class="control-group" style="width: 100%; flex-grow: 1; display: flex; flex-direction: column;">
                        <div id="peak-controls" class="hidden" style="display: flex; flex-direction: column; flex-grow: 1;">
                            
                            <div class="slider-group">
                                <label class="control-label">Min peak (%)</label>
                                <div class="slider-value-track">
                                    <input type="range" id="peak-threshold-slider" class="custom-slider" min="0" max="100" value="56">
                                    <span id="peak-threshold-value" class="slider-value-display">2.0</span>
                                </div>
                            </div>
                            
                            <div class="slider-group">
                                <label class="control-label">Radius (pts)</label>
                                <div class="slider-value-track">
                                    <input type="range" id="ball-radius-slider" class="custom-slider" min="1" max="200" value="40" step="1">
                                    <span id="ball-radius-value" class="slider-value-display">40</span>
                                </div>
                            </div>
                            
                            <div class="slider-group">
                                <label class="control-label">Points</label>
                                <div class="slider-value-track">
                                    <input type="range" id="smoothing-width-slider" class="custom-slider" min="1" max="100" value="10" step="1">
                                    <span id="smoothing-width-value" class="slider-value-display">10</span>
                                </div>
                            </div>

                            <div style="border-top: 1px solid var(--border-color); margin: 1.5rem 0;"></div>

                            <div class="slider-group">
                                <label class="control-label">2θ Min</label>
                                <div class="slider-value-track">
                                    <input type="range" id="tth-min-slider" class="custom-slider" disabled>
                                    <span id="tth-min-value" class="slider-value-display">-</span>
                                </div>
                            </div>
                            <div class="slider-group">
                                <label class="control-label">2θ Max</label>
                                <div class="slider-value-track">
                                    <input type="range" id="tth-max-slider" class="custom-slider" disabled>
                                    <span id="tth-max-value" class="slider-value-display">-</span>
                                </div>
                            </div>
                            
                            <div id="peak-table-container" class="hidden" style="flex-grow: 1; min-height: 0;">
                                <table class="peak-table">
                                    <thead><tr><th>#</th><th>2θ Obs (°)</th><th>d (Å)</th><th>Del</th></tr></thead>
                                    <tbody id="peak-list-body"></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="parameters-tab-content" class="tab-content-panel">
                    <div class="control-group" style="width: 100%;">
                        <div id="indexing-controls" class="hidden">
                            <div class="parameter-grid">
                                <div>
                                    <label for="wavelength" class="control-label">Wavelength (Å)</label>
                                    <input type="number" id="wavelength" value="1.54178" step="0.00001" min="0.1" class="control-input">
                                </div>
                                <div>
                                    <label for="max-volume" class="control-label">Max Volume (Å³)</label>
                                    <input type="number" id="max-volume" value="1000" step="100" min="60" max="12000" class="control-input">
                                </div>
                            </div>
                            <div class="parameter-grid" style="margin-top: 1rem;">
                                <div>
                                    <label for="tth-error" class="control-label">2θ Error (°)</label>
                                    <input type="number" id="tth-error" value="0.05" step="0.005" min="0.001" class="control-input">
                                </div>
                                <div>
                                    <label for="impurity-peaks" class="control-label">Impurity Peaks</label>
                                    <input type="number" id="impurity-peaks" value="0" min="0" max="5" step="1" class="control-input">
                                </div>
                            </div>
                            
                            <!-- Zero Refinement Checkbox -->
                            <div style="margin-top: 1.5rem;">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="refine-zero-checkbox"> Refine Zero-Point Error
                                </label>
                            </div>

                            <label class="control-label" style="margin-top: 1.5rem; margin-bottom: 1rem;">Crystal Systems to Search:</label>
                            <div class="parameter-grid">
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="cubic" checked> Cubic</label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="tetragonal" checked> Tetragonal</label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="hexagonal" checked> Hexagonal</label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="orthorhombic" > Orthorhombic</label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="monoclinic" > Monoclinic</label>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="solutions-tab-content" class="tab-content-panel">
                    <div class="control-group" style="width: 100%;">
                         <div id="solutions-table-container">
                            <table class="solutions-table">
                                <thead><tr>
                                    <th data-sort="system">Sys.</th>
                                    <th>Parameters (Å)</th>
                                    <th>Angles (°)</th>
                                    <th data-sort="volume">Vol</th>
                                    <th data-sort="m20">M(20)</th>
                                </tr></thead>
                                <tbody id="solutions-table-body"></tbody>
                            </table>
                         </div>
                    </div>
                </div>
            </div>

            <div class="bottom-actions">
                <div id="progress-bar-container" class="hidden" style="width: 100%; background-color: var(--light-bg); border-radius: 9999px; height: 0.625rem; margin-bottom: 0.5rem;">
                    <div id="progress-bar" style="background-color: var(--primary-accent); height: 0.625rem; border-radius: 9999px; width: 0%; transition: width 0.2s;"></div>
                </div>
                <div style="display: flex; gap: 0.5rem;">
                    <button id="start-indexing-button" class="btn btn-primary btn-like" style="flex: 1;" disabled>Find Peaks to Start</button>
                    <button id="report-button" class="btn btn-secondary btn-like" style="flex: 1;" disabled>Generate PDF Report</button>
                </div>
            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="results-area">
             <div id="placeholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #6b7280;">
                <svg xmlns="http://www.w3.org/2000/svg" style="width: 4rem; height: 4rem; margin-bottom: 1rem;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                <h2 style="font-size: 1.5rem; font-weight: 600;">Awaiting Data</h2>
                <p>Load a data file to begin indexing.</p>
            </div>
            <div id="results-container" style="width: 100%; height: 100%; display: none; flex-direction: column; position: relative;">
                <canvas id="xrd-chart"></canvas>
            </div>
            <div style="position: absolute; bottom: 0.5rem; right: 1rem; font-size: 0.7rem; color: #9ca3af;">
                NitaD, Univ Paris-Saclay, 21 Sept 2025
            </div>
        </div>
    </div>

    <div id="status-box"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const ui = {
                fileInput: document.getElementById('file-input'),
                fileInputLabel: document.querySelector('.file-input-label'),
                fileName: document.getElementById('file-name'),
                peakControls: document.getElementById('peak-controls'),
                peakThresholdSlider: document.getElementById('peak-threshold-slider'),
                peakThresholdValue: document.getElementById('peak-threshold-value'),
                peakTableContainer: document.getElementById('peak-table-container'),
                peakListBody: document.getElementById('peak-list-body'),
                indexingControls: document.getElementById('indexing-controls'),
                wavelength: document.getElementById('wavelength'),
                tthError: document.getElementById('tth-error'),
                maxVolume: document.getElementById('max-volume'),
                impurityPeaksInput: document.getElementById('impurity-peaks'),
                refineZeroCheckbox: document.getElementById('refine-zero-checkbox'), // rajouté le 21 sept, pour l'instant c'est itératif.. à voir
                systemCheckboxes: document.querySelectorAll('.system-checkbox'),
                startIndexingButton: document.getElementById('start-indexing-button'),
                reportButton: document.getElementById('report-button'),
                progressBar: document.getElementById('progress-bar'),
                progressBarContainer: document.getElementById('progress-bar-container'),
                solutionsTableBody: document.getElementById('solutions-table-body'),
                solutionsTableHeaders: document.querySelectorAll('#solutions-table-container th'),
                solutionsLed: document.getElementById('solutions-led'),
                chartCanvas: document.getElementById('xrd-chart'),
                placeholder: document.getElementById('placeholder'),
                resultsContainer: document.getElementById('results-container'),
                tthMinSlider: document.getElementById('tth-min-slider'),
                tthMaxSlider: document.getElementById('tth-max-slider'),
                tthMinValue: document.getElementById('tth-min-value'),
                tthMaxValue: document.getElementById('tth-max-value'),
                ballRadiusSlider: document.getElementById('ball-radius-slider'),
                ballRadiusValue: document.getElementById('ball-radius-value'),
                smoothingWidthSlider: document.getElementById('smoothing-width-slider'),
                smoothingWidthValue: document.getElementById('smoothing-width-value'),
                statusBar: document.getElementById('status-box'),
                tabButtonsContainer: document.querySelector('.tab-buttons'),
                tabButtons: document.querySelectorAll('.tab-btn'),
                tabPanels: document.querySelectorAll('.tab-content-panel')
            };
            

ui.solutionsTableHeaders.forEach(header => {
    header.addEventListener('click', () => {
        const column = header.dataset.sort;
        if (!column) return;

        // This block handles updating the sort direction
        if (sortState.column === column) {
            // If clicking the same column, toggle the direction
            sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
        } else {
            // If clicking a new column, set it and default to descending
            sortState.column = column;
            sortState.direction = (column === 'm20' || column === 'volume') ? 'desc' : 'asc';
        }

        // The rest of the function sorts and updates the display
        sortSolutions();

        const selectedSystems = Array.from(ui.systemCheckboxes)
                                     .filter(cb => cb.checked)
                                     .map(cb => cb.value);
        displayedSolutions = solutions.filter(sol => selectedSystems.includes(sol.system));

        updateSolutionsTable();
    });
});


ui.systemCheckboxes.forEach(checkbox => {
    checkbox.addEventListener('change', () => {
        // Get the currently selected systems
        const selectedSystems = Array.from(ui.systemCheckboxes)
                                     .filter(cb => cb.checked)
                                     .map(cb => cb.value);
        
        // Filter the master list and update the displayed list
        displayedSolutions = solutions.filter(sol => selectedSystems.includes(sol.system));
        
        // Refresh the table
        updateSolutionsTable();
    });
});

            // --- LOGARITHMIC SLIDER CONFIGURATION ---
            const minPeak = 0.1;
            const maxPeak = 20;
            const minLog = Math.log(minPeak);
            const maxLog = Math.log(maxPeak);
            const scale = (maxLog - minLog) / 100;

            function valueToLogSlider(value) {
                if (value <= 0) return 0;
                return (Math.log(value) - minLog) / scale;
            }

            function logSliderToValue(position) {
                return Math.exp(minLog + scale * position);
            }

            // --- DEBOUNCE UTILITY ---
            const debounce = (func, delay) => {
                let timeout;
                return function(...args) {
                    const context = this;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            };
            const debouncedFindPeaks = debounce(findPeaks, 250);

            // --- INITIALIZE LOG SLIDER ---
            const initialPeakThreshold = 2.0;
            ui.peakThresholdSlider.value = valueToLogSlider(initialPeakThreshold);
            ui.peakThresholdValue.textContent = initialPeakThreshold.toFixed(1);

            // --- TAB SWITCHING --
            ui.tabButtonsContainer.addEventListener('click', (e) => {
                const clickedTab = e.target.closest('.tab-btn');
                if (!clickedTab || clickedTab.disabled) return;

                const tabTarget = clickedTab.dataset.tab;

                ui.tabButtons.forEach(btn => btn.classList.remove('active'));
                ui.tabPanels.forEach(panel => panel.classList.remove('active'));

                clickedTab.classList.add('active');
                document.getElementById(`${tabTarget}-tab-content`).classList.add('active');
            });

            let statusTimeout;
            const showStatus = (message, type = 'info', duration = 4000) => {
                if (!ui.statusBar) {
                    console.warn(`Status bar element (#status-box) not found. Message: "${message}"`);
                    return;
                }
                if (statusTimeout) clearTimeout(statusTimeout);
                ui.statusBar.textContent = message;
                ui.statusBar.className = `show ${type}`;
                statusTimeout = setTimeout(() => {
                    if (ui.statusBar) {
                        ui.statusBar.classList.remove('show');
                    }
                }, duration);
            };

            let fullExperimentalData = { tth: [], intensity: [] };
            let pickedPeaks = [];
            let solutions = [];
            let displayedSolutions = [];
            let selectedSolution = null;
            let currentHklList = [];
            let xrdChart;
            let isIndexing = false;
            let activeWorkers = [];
            let sortState = { column: 'm20', direction: 'desc' };
            let workerURL = null; // To hold the reusable worker URL

            // --- WORKER SETUP (Create blob URL once) ---
            const setupWorker = () => {
                try {
                    const workerScript = document.getElementById('indexing-worker').textContent;
                    const blob = new Blob([workerScript], { type: 'application/javascript' });
                    workerURL = URL.createObjectURL(blob);
                } catch (error) {
                    console.error("Failed to create worker blob URL:", error);
                    showStatus("Critical error: Could not initialize indexing engine.", "error", 10000);
                }
            };
            setupWorker();

            // ---------- METRIC TENSOR HELPERS ----------
            //j'aurais du faire V=sqrt(det G) mais bon... ça marche aussi
            // --- SYSTEMATIC ABSENCE ANALYSIS HELPERS -

const max_hkl_analysis = 10;
// Data for space group determination
const spaceGroupData = {
    cubic: { 'P': { 'Pm-3m': { c: [] }, 'Pn-3n': { c: ['0kl:k+l=2n', 'hhl:l=2n'] }, 'Pm-3n': { c: ['hk0:h+k=2n'] }, 'Pa-3': { c: ['hk0:h=2n'] }, 'Pn-3m': { c: ['hhl:l=2n'] } }, 'I': { 'Im-3m': { c: [] }, 'Ia-3': { c: ['0kl:k=2n'] }, 'Ia-3d': { c: ['0kl:k=2n,l=2n', 'hhl:2h+l=4n'] } }, 'F': { 'Fm-3m': { c: [] }, 'Fd-3m': { c: ['0kl:k+l=4n'] }, 'Fm-3c': { c: ['hhl:l=2n'] } } },
    tetragonal: { 'P': { 'P4/mmm': { c: [] }, 'P4/mcc': { c: ['hhl:l=2n', '0kl:l=2n'] }, 'P4/nmm': { c: ['hk0:h+k=2n'] }, 'P4/ncc': { c: ['hk0:h+k=2n', '0kl:l=2n'] }, 'P4_2/mcm': { c: ['0kl:l=2n', 'hhl:l=2n'] }, 'P4_2/mnm': { c: ['0kl:k+l=2n', 'h00:h=2n'] }, 'P4_2/nmc': { c: ['hk0:h+k=2n', 'h0l:l=2n'] }, 'P4_2/nbc': { c: ['hk0:h+k=2n', '0kl:k=2n'] } }, 'I': { 'I4/mmm': { c: [] }, 'I4/mcm': { c: ['0kl:l=2n', 'hhl:l=2n'] }, 'I4_1/a': { c: ['hkl:2h+l=4n'] }, 'I4_1/amd': { c: ['hkl:2h+l=4n', 'hk0:h=2n,k=2n'] }, 'I4_1/acd': { c: ['hkl:2h+l=4n', 'hk0:h=2n,k=2n', '0kl:k=2n,l=2n'] } } },
    hexagonal: { 'P': { 'P6/mmm': { c: [] }, 'P6/mcc': { c: ['h-hl:l=2n', '00l:l=2n'] }, 'P6_3/mmc': { c: ['00l:l=2n'] }, 'P6_3/mcm': { c: ['h-hl:l=2n', '00l:l=2n'] }, 'P-3': { c: [] }, 'P-3m1': { c: [] }, 'P-31m': { c: [] }, }, 'R': { 'R-3': { c: [] }, 'R-3m': { c: [] }, 'R-3c': { c: ['h-hl:l=2n'] } } },
    orthorhombic: { 'P': { 'Pmmm': { c: [] }, 'Pnnn': { c: ['0kl:k+l=2n', 'h0l:h+l=2n', 'hk0:h+k=2n'] }, 'Pccm': { c: ['h0l:l=2n', '0kl:l=2n'] }, 'Pban': { c: ['0kl:k=2n', 'h0l:h=2n'] }, 'Pccn': { c: ['h0l:l=2n', '0kl:k=2n'] }, 'Pbcm': { c: ['0kl:k=2n', 'h0l:l=2n'] }, 'Pnnm': { c: ['hk0:h+k=2n'] }, 'Pnma': { c: ['0kl:k+l=2n', 'hk0:h=2n'] }, 'Pbca': { c: ['0kl:k=2n', 'h0l:l=2n', 'hk0:h=2n'] }, 'P2_12_12_1': { c: ['h00:h=2n', '0k0:k=2n', '00l:l=2n'] } }, 'C': { 'Cmmm': { c: [] }, 'Cmcm': { c: ['h0l:l=2n'] }, 'Cmce': { c: ['0kl:l=2n', 'h0l:h+l=2n'] }, 'Cccm': { c: ['h0l:l=2n'] }, 'Ccce': { c: ['h0l:l=2n', 'hhl:l=2n'] }, }, 'I': { 'Immm': { c: [] }, 'Ibam': { c: ['0kl:k=2n'] }, 'Ibca': { c: ['0kl:k=2n', 'h0l:l=2n'] }, 'Imma': { c: ['0kl:k+l=2n'] } }, 'F': { 'Fmmm': { c: [] }, 'Fddd': { c: ['0kl:k+l=4n', 'h0l:h+l=4n', 'hk0:h+k=4n'] } } },
    monoclinic: { 'P': { 'P2/m': { c: [] }, 'P2_1/m': { c: ['0k0:k=2n'] }, 'P2/c': { c: ['h0l:l=2n'] }, 'P2_1/c': { c: ['h0l:l=2n', '0k0:k=2n'] } }, 'C': { 'C2/m': { c: [] }, 'C2/c': { c: ['h0l:l=2n'] } } }
};

function generateHKL_for_analysis(params, lambda, maxTth) { 
    const { a, b: b_in, c: c_in, beta: beta_in, system } = params;
    const b = b_in ?? a;
    const c = c_in ?? a;
    const beta = beta_in ?? 90;
    const reflections = [];
    for (let h = -max_hkl_analysis; h <= max_hkl_analysis; h++) { 
        for (let k = -max_hkl_analysis; k <= max_hkl_analysis; k++) { 
            for (let l = -max_hkl_analysis; l <= max_hkl_analysis; l++) {
                if (h === 0 && k === 0 && l === 0) continue; 
                let inv_d_sq = 0;
                switch (system) {
                    case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                    case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                    case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                    case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                    case 'monoclinic': 
                        const sinBeta = Math.sin(beta*Math.PI/180); 
                        const cosBeta = Math.cos(beta*Math.PI/180); 
                        inv_d_sq = (1/(sinBeta*sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + k*k/(b*b); 
                        break;
                }
                if (inv_d_sq > 0) { 
                    const d = 1/Math.sqrt(inv_d_sq); 
                    const sinThetaSq = (lambda*lambda/4)*inv_d_sq; 
                    if (sinThetaSq <= 1) { 
                        const tth = 2*Math.asin(Math.sqrt(sinThetaSq))*(180/Math.PI); 
                        if(tth <= maxTth*1.05) reflections.push({ tth, h, k, l, d }); 
                    } 
                }
            }
        }
    } 
    return reflections.sort((a, b) => a.tth - b.tth);
};

function analyzeSystematicAbsences(solution, obs_peaks, wavelength, tthError) { 
    const { system } = solution;
    const all_hkls = generateHKL_for_analysis(solution, wavelength, Math.max(...obs_peaks.map(p=>p.tth)));
    const obs_hkl_list = []; const used_peaks = new Set();
    const corrected_obs_peaks = obs_peaks.map(p => ({...p, tth: p.tth - (solution.zero_correction || 0) }));
    corrected_obs_peaks.forEach(peak => { peak.d = wavelength / (2 * Math.sin(peak.tth * Math.PI / 360)); });

    const q_from_tth = (tth) => (4 * Math.pow(Math.sin(tth * Math.PI / 360), 2)) / (wavelength*wavelength);

    all_hkls.forEach(hkl => {
        let bestMatch = null; let minDiff = Infinity;
        corrected_obs_peaks.forEach((peak, index) => {
            if (used_peaks.has(index)) return;
            const diff = Math.abs(hkl.d - peak.d);
            if (diff < minDiff) { minDiff = diff; bestMatch = { peak, index }; }
        });
        if (bestMatch) {
            const q_o = q_from_tth(bestMatch.peak.tth);
            const d_theta = tthError * Math.PI / 360;
            const q_tolerance = ((8 * Math.sin(bestMatch.peak.tth * Math.PI/360) * Math.cos(bestMatch.peak.tth * Math.PI/360)) / (wavelength * wavelength)) * d_theta;
            const d_tolerance = Math.abs(1/Math.sqrt(q_o + q_tolerance) - 1/Math.sqrt(q_o - q_tolerance)) / 2;
            if (minDiff < d_tolerance * 1.5) { // Use 1.5x tolerance for matching
                obs_hkl_list.push(hkl); 
                used_peaks.add(bestMatch.index); 
            }
        }
    });
    
    let centering = 'Primitive (P)';
    if (obs_hkl_list.length >= 3) {
         if (system === 'cubic' || system === 'tetragonal' || system === 'orthorhombic') {
            const violates_I = obs_hkl_list.some(({h,k,l}) => (h+k+l) % 2 !== 0);
            const violates_F = obs_hkl_list.some(({h,k,l}) => !((h%2===k%2)&&(k%2===l%2)));
            if (!violates_F) centering = 'Face (F)'; else if (!violates_I) centering = 'Body (I)';
         }
        if ((system === 'orthorhombic' || system === 'monoclinic') && centering === 'Primitive (P)' && !obs_hkl_list.some(({h,k,l}) => (h+k) % 2 !== 0)) centering = 'C-Face (C)';
        if (system === 'hexagonal' && (!obs_hkl_list.some(({h,k,l}) => (-h+k+l)%3!==0) || !obs_hkl_list.some(({h,k,l}) => (h-k+l)%3!==0))) centering = 'Rhombohedral (R)';
    }

    const centerChar = centering.charAt(centering.indexOf('(')+1);
    const foundConditions = new Set();
    const check = (filter, rule) => { const subset = obs_hkl_list.filter(filter); return subset.length === 0 || !subset.some(rule); };
    if (check(p => p.h !== 0 && p.k===0 && p.l===0, p => p.h%2 !== 0)) foundConditions.add('h00:h=2n'); if (check(p => p.k !== 0 && p.h===0 && p.l===0, p => p.k%2 !== 0)) foundConditions.add('0k0:k=2n'); if (check(p => p.l !== 0 && p.h===0 && p.k===0, p => p.l%2 !== 0)) foundConditions.add('00l:l=2n'); if (check(p => p.h!==0 && p.k!==0 && p.l===0, p => (p.h+p.k)%2 !== 0)) foundConditions.add('hk0:h+k=2n'); if (check(p => p.k!==0 && p.l!==0 && p.h===0, p => (p.k+p.l)%2 !== 0)) foundConditions.add('0kl:k+l=2n'); if (check(p => p.h!==0 && p.l!==0 && p.k===0, p => (p.h+p.l)%2 !== 0)) foundConditions.add('h0l:h+l=2n');
    if (system === 'monoclinic' && check(p => p.h!==0 && p.l!==0 && p.k===0, p => p.l%2 !== 0)) foundConditions.add('h0l:l=2n'); if (check(p => p.h===p.k && p.l!==0, p => p.l%2 !== 0)) foundConditions.add('hhl:l=2n'); if (check(p => p.h===-p.k && p.l!==0, p => p.l%2 !== 0)) foundConditions.add('h-hl:l=2n');
    
    const sg_block = spaceGroupData[system]?.[centerChar] || {};
    const possibleSpaceGroups = Object.keys(sg_block);
    const probableSpaceGroups = possibleSpaceGroups.filter(sg => (sg_block[sg].c || []).every(cond => foundConditions.has(cond)));
    
    return { centering, conditions: Array.from(foundConditions), possibleSpaceGroups, probableSpaceGroups };
};



/**
 * Calculates the metric tensor G from cell parameters.
 * G = [ a*a, a*b*cos(g), a*c*cos(b) ]
 * [ a*b*cos(g), b*b, b*c*cos(a) ]
 * [ a*c*cos(b), b*c*cos(a), c*c ]
 * @param {object} cell - An object with a, b, c, alpha, beta, gamma.
 * @returns {number[][]} The 3x3 metric tensor.
 */
function metricFromCell(cell) {
    const deg2rad = Math.PI / 180;
    const a = cell.a;
    const b = cell.b ?? cell.a;
    const c = cell.c ?? cell.a;
    const alpha = (cell.alpha ?? 90) * deg2rad;
    const beta  = (cell.beta  ?? 90) * deg2rad;
    const gamma = (cell.gamma ?? 90) * deg2rad;
    const ca = Math.cos(alpha), cb = Math.cos(beta), cg = Math.cos(gamma);
    return [
        [a*a, a*b*cg, a*c*cb],
        [a*b*cg, b*b, b*c*ca],
        [a*c*cb, b*c*ca, c*c]
    ];
}

/* Standardize symmetry*/

/**
 * Reorders cell parameters to match crystallographic conventions for the system.
 * e.g., for tetragonal, ensures the unique axis is 'c'.
 * e.g., for orthorhombic, sorts axes as a < b < c.
 * @param {object} cell - A solution object
 * @returns {object} The standardized solution object
 */
function standardizeCell(cell) {
    const { a, b, c } = cell;
    const tol = 0.02;
    const eq = (v1, v2) => Math.abs(v1 - v2) < tol;
    
    // Create a copy to modify
    const newCell = { ...cell };

    switch (cell.system) {
        case 'tetragonal': {
            const axes = [a, b, c];
            let uniqueAxis, repeatedAxis;

            if (eq(axes[0], axes[1])) {
                uniqueAxis = axes[2];
                repeatedAxis = axes[0];
            } else if (eq(axes[0], axes[2])) {
                uniqueAxis = axes[1];
                repeatedAxis = axes[0];
            } else { // b and c must be equal
                uniqueAxis = axes[0];
                repeatedAxis = axes[1];
            }
            newCell.a = repeatedAxis;
            newCell.b = repeatedAxis;
            newCell.c = uniqueAxis;
            break;
        }
        case 'orthorhombic': {
            // Sort axes by length according to convention a < b < c
            const sortedAxes = [a, b, c].sort((x, y) => x - y);
            newCell.a = sortedAxes[0];
            newCell.b = sortedAxes[1];
            newCell.c = sortedAxes[2];
            break;
        }
        case 'cubic': {
            newCell.b = newCell.a;
            newCell.c = newCell.a;
            break;
        }
    }
    return newCell;
}

/** Get symmetry**
 * Determines the highest possible crystal system based on cell parameters.
 * @param {number} a - cell parameter a
 * @param {number} b - cell parameter b
 * @param {number} c - cell parameter c
 * @param {number} alpha - cell angle alpha
 * @param {number} beta - cell angle beta
 * @param {number} gamma - cell angle gamma
 * @param {number} tol - Tolerance for comparing lengths and angles
 * @returns {string} The name of the crystal system.
 */
function getSymmetry(a, b, c, alpha, beta, gamma, tol = 0.02) {
    const eq = (v1, v2) => Math.abs(v1 - v2) < tol;
    const is90 = (v) => Math.abs(v - 90) < tol;
    const is120 = (v) => Math.abs(v - 120) < tol;

    const angles90 = is90(alpha) && is90(beta) && is90(gamma);

    if (angles90) {
        if (eq(a, b) && eq(b, c)) return 'cubic';
        // Check all permutations for tetragonal (e.g., a=b, a=c, or b=c)
        if (eq(a, b) || eq(b, c) || eq(a, c)) return 'tetragonal';
        return 'orthorhombic';
    }
    if (is90(alpha) && is90(beta) && is120(gamma)) return 'hexagonal';
    if (is90(alpha) && is90(gamma) && !is90(beta)) return 'monoclinic';
    if (is90(beta) && is90(gamma) && !is90(alpha)) return 'monoclinic';
    if (is90(alpha) && is90(beta) && !is90(gamma)) return 'monoclinic';
    
    return 'triclinic'; // Default
}

/**
 * Calculates cell parameters from a metric tensor G.
 * @param {number[][]} G - The 3x3 metric tensor.
 * @returns {object} An object with a, b, c, alpha, beta, gamma.
 */
function cellFromMetric(G) {
    const a = Math.sqrt(G[0][0]), b = Math.sqrt(G[1][1]), c = Math.sqrt(G[2][2]);
    const clamp = v => Math.max(-1, Math.min(1, v)); // Prevent Math.acos domain errors
    const ca = clamp(G[1][2] / (b*c));
    const cb = clamp(G[0][2] / (a*c));
    const cg = clamp(G[0][1] / (a*b));
    const alpha = Math.acos(ca) * 180 / Math.PI;
    const beta  = Math.acos(cb) * 180 / Math.PI;
    const gamma = Math.acos(cg) * 180 / Math.PI;
    return { a, b, c, alpha, beta, gamma };
}

function transpose(M){ return M[0].map((_,i) => M.map(r => r[i])); }

function matMul(A,B){
    const r=A.length, c=B[0].length, k=A[0].length;
    const C = Array.from({length:r}, () => Array(c).fill(0));
    for(let i=0; i<r; i++) for(let j=0; j<c; j++) for(let t=0; t<k; t++) C[i][j] += A[i][t] * B[t][j];
    return C;
}


// HELPER for finding the greatest common divisor (GCD)
function gcd(a, b) {
    return b === 0 ? a : gcd(b, a % b);
}

function gcdOfList(arr) {
    if (!arr || arr.length === 0) return 1;
    return arr.reduce((acc, val) => gcd(acc, val), arr[0]);
}

// HELPER to get the list of indexed HKLs for a given solution
function findIndexedPeaksForSolution(solution, observedPeaks, wavelength, tthError) {
    const maxTth = Math.max(...observedPeaks.map(p => p.tth));
    const theoreticalHKLs = generateHKL(maxTth, { ...solution, lambda: wavelength }, solution.system);
    if (!theoreticalHKLs || theoreticalHKLs.length === 0) return [];

    const indexedPeaks = [];
    const usedTheoreticalPeaks = new Set();

    for (const obsPeak of observedPeaks) {
        let bestMatch = null;
        let minDiff = Infinity;

        // Find the closest theoretical peak
        for (let i = 0; i < theoreticalHKLs.length; i++) {
            if (usedTheoreticalPeaks.has(i)) continue;
            const diff = Math.abs(obsPeak.tth - theoreticalHKLs[i].tth);
            if (diff < minDiff) {
                minDiff = diff;
                bestMatch = { ...theoreticalHKLs[i], originalIndex: i };
            }
        }
        
        // If the match is within the 2-theta error tolerance, accept it
        if (bestMatch && minDiff < tthError) {
            indexedPeaks.push({ h: bestMatch.h, k: bestMatch.k, l: bestMatch.l });
            usedTheoreticalPeaks.add(bestMatch.originalIndex);
        }
    }
    return indexedPeaks;
}


/**
 * Calculates M(20) figure of merit for a candidate cell.
 * This is a re-implementation of the worker's logic for the main thread.
 */
function calcM20_from_qcalc(q_calc_sorted, pickedPeaksArr, tthErrorDeg, wavelength, impurity_peaks) {
    if (!pickedPeaksArr || pickedPeaksArr.length === 0) return 0;
    const N_FOR_M20 = Math.min(20, pickedPeaksArr.length);

    const tth_obs_rad = new Float64Array(pickedPeaksArr.map(p => p.tth * Math.PI / 360));
    const peaks_sorted_by_q = pickedPeaksArr.map((p, i) => ({ tth: p.tth, q: p.q, original_index: i }))
                                          .sort((a,b) => a.q - b.q);
    const q_obs = peaks_sorted_by_q.map(p => p.q);
    const original_indices = peaks_sorted_by_q.map(p => p.original_index);

    const get_q_tolerance = (original_peak_index) => {
        const theta = tth_obs_rad[original_peak_index];
        const d_theta = tthErrorDeg * Math.PI / 360;
        return ((8 * Math.sin(theta) * Math.cos(theta)) / (wavelength * wavelength)) * d_theta;
    };

    const binarySearchClosest = (arr, target) => {
        let low = 0, high = arr.length - 1;
        if (arr.length === 0) return -1;
        if (target <= arr[low]) return low;
        if (target >= arr[high]) return high;
        while (low <= high) {
            const mid = Math.floor((low + high) / 2);
            if (arr[mid] === target) return mid;
            if (arr[mid] < target) low = mid + 1;
            else high = mid - 1;
        }
        if (low >= arr.length) return arr.length - 1;
        if (high < 0) return 0;
        return (arr[low] - target) < (target - arr[high]) ? low : high;
    };

    if (!q_calc_sorted || q_calc_sorted.length === 0) return 0;
    let N_indexed = 0, sum_delta_q = 0;
    for (let i = 0; i < N_FOR_M20; i++) {
        const q_o = q_obs[i];
        const tol = get_q_tolerance(original_indices[i]);
        const closest_idx = binarySearchClosest(q_calc_sorted, q_o);
        const diff = Math.abs(q_o - q_calc_sorted[closest_idx]);
        if (diff < tol) { N_indexed++; sum_delta_q += diff; }
    }

    const unindexed_peaks = N_FOR_M20 - N_indexed;
    if (unindexed_peaks > (impurity_peaks || 0)) return 0;
    if (N_indexed === 0) return 0;

    const q_n = q_obs[N_FOR_M20 - 1];
    let N_calc = 0;
    for (let i = 0; i < q_calc_sorted.length; i++) {
        if (q_calc_sorted[i] > q_n * 1.05) break;
        N_calc++;
    }
    if (N_calc === 0) return 0;
    const avg_delta_q = sum_delta_q / N_indexed;
    if (avg_delta_q === 0) return 0;
    return q_n / (2 * avg_delta_q * N_calc);
}

// Transformation matrices (P) to test for smaller/primitive cells.
const cellTransforms = [
    // Primitive cells from centered supercells
    { name: 'fcc_prim', P: [[0, 0.5, 0.5], [0.5, 0, 0.5], [0.5, 0.5, 0]] },
    { name: 'bcc_prim', P: [[-0.5, 0.5, 0.5], [0.5, -0.5, 0.5], [0.5, 0.5, -0.5]] },
    { name: 'c_prim',   P: [[0.5, 0.5, 0], [-0.5, 0.5, 0], [0, 0, 1]] },
    // Simple axis divisions to find smaller cells
    { name: 'div2_a', P: [[0.5, 0, 0], [0, 1, 0], [0, 0, 1]] },
    { name: 'div2_b', P: [[1, 0, 0], [0, 0.5, 0], [0, 0, 1]] },
    { name: 'div2_c', P: [[1, 0, 0], [0, 1, 0], [0, 0, 0.5]] }, 
    // Diagonal transform, useful for some orthorhombic/monoclinic relations
    { name: 'diag_ab', P: [[0.5, -0.5, 0], [0.5, 0.5, 0], [0, 0, 1]] }
];

/**
 * Takes an array of solutions, applies transformations to find smaller/primitive
 * cells, scores them, and adds valid new candidates to the list.
 */

 function addDerivedTransformedCandidates(solutionsArr, maxTth) {
    if (!pickedPeaks || pickedPeaks.length < 4) return solutionsArr;
    const wavelength = parseFloat(ui.wavelength.value);
    const tthErrorDeg = parseFloat(ui.tthError.value);
    const impurity_peaks = parseInt(ui.impurityPeaksInput.value, 10);
    const min_m20_threshold = 5.0;

    let newCandidates = [];
    const allCurrentSolutions = () => solutionsArr.concat(newCandidates);

    // --- 1: Matrix Transformations 
    for (const tf of cellTransforms) {
        for (const sol of solutionsArr.slice()) {
            try {
                const G = metricFromCell(sol);
                const Pt = transpose(tf.P);
                const Gprime = matMul(matMul(Pt, G), tf.P);
                const candCell = cellFromMetric(Gprime);

                if (!(candCell.a > 0.5 && candCell.b > 0.5 && candCell.c > 0.5)) continue;
                
                const newSystem = getSymmetry(candCell.a, candCell.b, candCell.c, candCell.alpha, candCell.beta, candCell.gamma);
                let vol = 0;
                switch(newSystem) {
                    case 'cubic':       vol = candCell.a ** 3; break;
                    case 'tetragonal':  vol = candCell.a ** 2 * candCell.c; break;
                    case 'hexagonal':   vol = candCell.a ** 2 * candCell.c * (Math.sqrt(3) / 2); break;
                    case 'orthorhombic':vol = candCell.a * candCell.b * candCell.c; break;
                    case 'monoclinic':  vol = candCell.a * candCell.b * candCell.c * Math.sin(candCell.beta * Math.PI / 180); break;
                }
                if (vol < 20) continue;

                const refl = generateHKL(maxTth, {...candCell, lambda: wavelength}, newSystem);
                if (!refl || refl.length === 0) continue;
                
                const q_calc_sorted = new Float64Array(refl.map(r => 1 / (r.d * r.d))).sort((a, b) => a - b);
                const m20 = calcM20_from_qcalc(q_calc_sorted, pickedPeaks, tthErrorDeg, wavelength, impurity_peaks);

                if (m20 >= min_m20_threshold) {
                    const exists = allCurrentSolutions().some(s => Math.abs(s.volume - vol) < 0.1 && Math.abs(s.a - candCell.a) < 1e-3);
                    if (!exists) {
                        let derived = { a: candCell.a, b: candCell.b, c: candCell.c, alpha: candCell.alpha, beta: candCell.beta, gamma: candCell.gamma, system: newSystem, volume: vol, m20: m20, analysis: { centering: 'Derived', conditions: [`from ${tf.name}`], possibleSpaceGroups: [], probableSpaceGroups: [] } };
                        derived = standardizeCell(derived);
                        newCandidates.push(derived);
                    }
                }
            } catch (err) { /* ignore errors */ }
        }
    }
    
    // --- 2: HKL Divisor Analysis ---
    for (const sol of allCurrentSolutions().slice()) {
        const indexedPeaks = findIndexedPeaksForSolution(sol, pickedPeaks, wavelength, tthErrorDeg);
        if (indexedPeaks.length < 5) continue;
        const h_indices = indexedPeaks.map(p => Math.abs(p.h)).filter(h => h > 0);
        const k_indices = indexedPeaks.map(p => Math.abs(p.k)).filter(k => k > 0);
        const l_indices = indexedPeaks.map(p => Math.abs(p.l)).filter(l => l > 0);
        const h_div = h_indices.length > 3 ? gcdOfList(h_indices) : 1;
        const k_div = k_indices.length > 3 ? gcdOfList(k_indices) : 1;
        const l_div = l_indices.length > 3 ? gcdOfList(l_indices) : 1;
        if (h_div > 1 || k_div > 1 || l_div > 1) {
            const candCell = { system: sol.system, a: sol.a / h_div, b: (sol.b ?? sol.a) / k_div, c: (sol.c ?? sol.a) / l_div, alpha: sol.alpha ?? 90, beta: sol.beta ?? 90, gamma: sol.gamma ?? (sol.system === 'hexagonal' ? 120 : 90) };
            const newSystem = getSymmetry(candCell.a, candCell.b, candCell.c, candCell.alpha, candCell.beta, candCell.gamma);
            let vol = 0;
            switch(newSystem) {
                case 'cubic':       vol = candCell.a ** 3; break;
                case 'tetragonal':  vol = candCell.a ** 2 * candCell.c; break;
                case 'hexagonal':   vol = candCell.a ** 2 * candCell.c * (Math.sqrt(3) / 2); break;
                case 'orthorhombic':vol = candCell.a * candCell.b * candCell.c; break;
                case 'monoclinic':  vol = candCell.a * candCell.b * candCell.c * Math.sin(candCell.beta * Math.PI / 180); break;
            }
            const refl = generateHKL(maxTth, {...candCell, lambda: wavelength}, newSystem);
            if (!refl || refl.length === 0) continue;
            const q_calc_sorted = new Float64Array(refl.map(r => 1 / (r.d * r.d))).sort((a, b) => a - b);
            const m20 = calcM20_from_qcalc(q_calc_sorted, pickedPeaks, tthErrorDeg, wavelength, impurity_peaks);
            if (m20 >= min_m20_threshold) {
                const exists = allCurrentSolutions().some(s => Math.abs(s.volume - vol) < 0.1 && Math.abs(s.a - candCell.a) < 1e-3);
                if (!exists) {
                     let derived = { a: candCell.a, b: candCell.b, c: candCell.c, alpha: candCell.alpha, beta: candCell.beta, gamma: candCell.gamma, system: newSystem, volume: vol, m20: m20, analysis: { centering: 'Derived', conditions: [`hkl div (${h_div},${k_div},${l_div})`], possibleSpaceGroups: [], probableSpaceGroups: [] } };
                     derived = standardizeCell(derived);
                     newCandidates.push(derived);
                }
            }
        }
    }

    // --- 3: Orthorhombic to Hexagonal Check 
    const sqrt3 = Math.sqrt(3);
    const ortho_tol = 0.03; // Allow up to 3% deviation from the ideal ratio
    for (const sol of allCurrentSolutions().slice()) {
        if (sol.system === 'orthorhombic') {
            const axes = { a: sol.a, b: sol.b, c: sol.c };
            const pairs = [['a','b','c'], ['a','c','b'], ['b','c','a']]; // [axis1, axis2, unique_axis]

            for (const [ax1, ax2, unique_ax] of pairs) {
                const ratio = axes[ax2] / axes[ax1];
                if (Math.abs(ratio / sqrt3 - 1) < ortho_tol) {
                    // This is a hexagonal candidate
                    const candCell = {
                        system: 'hexagonal', a: axes[ax1], b: axes[ax1], c: axes[unique_ax],
                        alpha: 90, beta: 90, gamma: 120
                    };
                    
                    const vol = candCell.a ** 2 * candCell.c * (sqrt3 / 2);
                    const refl = generateHKL(maxTth, {...candCell, lambda: wavelength}, 'hexagonal');
                    if (!refl || refl.length === 0) continue;

                    const q_calc_sorted = new Float64Array(refl.map(r => 1 / (r.d * r.d))).sort((a, b) => a - b);
                    const m20 = calcM20_from_qcalc(q_calc_sorted, pickedPeaks, tthErrorDeg, wavelength, impurity_peaks);

                    if (m20 >= min_m20_threshold) {
                        const exists = allCurrentSolutions().some(s => Math.abs(s.volume - vol) < 0.1 && s.system === 'hexagonal');
                        if (!exists) {
                             let derived = { ...candCell, volume: vol, m20: m20, analysis: { centering: 'Derived', conditions: [`from orth (${ax2}/${ax1}≈√3)`], possibleSpaceGroups: [], probableSpaceGroups: [] } };
                             newCandidates.push(derived);
                        }
                    }
                }
            }
        }
    }

    return solutionsArr.concat(newCandidates);
}


            const inputsToValidate = [
                { id: 'wavelength', el: ui.wavelength, default: 1.541780 },
                { id: 'max-volume', el: ui.maxVolume, default: 1000 },
                { id: 'tth-error', el: ui.tthError, default: 0.05 },
                { id: 'impurity-peaks', el: ui.impurityPeaksInput, default: 0 },
            ];

            // Setup input validation
            inputsToValidate.forEach(({ id, el, default: defaultValue }) => {
                if (el) {
                    el.addEventListener('blur', () => {
                        const min = parseFloat(el.min);
                        const max = parseFloat(el.max);
                        let value = parseFloat(el.value);

                        if (isNaN(value)) {
                            el.value = defaultValue;
                            return;
                        }
                        
                        if (!isNaN(min) && value < min) el.value = min;
                        if (!isNaN(max) && value > max) el.value = max;
                    });
                } else {
                    console.error(`Initialization Error: The element with id="${id}" was not found. Input validation will not be applied to it.`);
                }
            });

            if (ui.wavelength) {
                ui.wavelength.addEventListener('change', () => {
                    if (pickedPeaks.length > 0) {
                        recalculatePeakValues();
                        updatePeakTable();
                    }
                });
            }

            // --- FILE PARSING LOGIC ---
            const parseDataFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                const tth = [], intensity = [];
                lines.forEach(line => {
                    if (line.startsWith('#') || line.startsWith('//') || line.trim() === '') return;
                    const parts = line.trim().split(/[\s,;]+/);
                    if (parts.length >= 2) {
                        const x = parseFloat(parts[0]);
                        const y = parseFloat(parts[1]);
                        if (!isNaN(x) && !isNaN(y)) {
                            tth.push(x);
                            intensity.push(y);
                        }
                    }
                });
                return { tth, intensity };
            };

            const parseXrdmlFile = (xmlString) => {
                 const parser = new DOMParser();
                 const xmlDoc = parser.parseFromString(xmlString, "application/xml");
                 if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing XRDML file."); }

                 let wavelength = null;
                 const kAlpha1Node = xmlDoc.querySelector("kAlpha1");
                 if (kAlpha1Node?.textContent) wavelength = parseFloat(kAlpha1Node.textContent);

                 const intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts");
                 if (!intensityNode) throw new Error("Could not find <intensities> or <counts> in XRDML file.");
                 const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number);

                 const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]');
                 if (!positionsNode) throw new Error("Could not find <positions> in XRDML file.");
                 const startPosNode = positionsNode.querySelector("startPosition");
                 const endPosNode = positionsNode.querySelector("endPosition");

                 if (!startPosNode || !endPosNode) throw new Error("Could not find start/end positions in XRDML.");
                 const startPos = parseFloat(startPosNode.textContent);
                 const endPos = parseFloat(endPosNode.textContent);
                 const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * (endPos - startPos) / (intensity.length - 1));

                 return { tth, intensity, wavelength };
            };
            
            const parseBrukerBrmlFile = (xmlString) => {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, "application/xml");
                if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing BRML file."); }

                let wavelength = null;
                const wlNode = xmlDoc.querySelector('usedWavelength');
                if (wlNode) {
                    const kAlpha1 = wlNode.getAttribute('kAlpha1');
                    if (kAlpha1) wavelength = parseFloat(kAlpha1);
                }
                
                const intensityNode = xmlDoc.querySelector("dataPoints > counts");
                if (!intensityNode) throw new Error("No <counts> data found in BRML file.");
                const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number);

                const startPosNode = xmlDoc.querySelector('startPosition[axis="TwoTheta"]');
                const stepSizeNode = xmlDoc.querySelector('increment[axis="TwoTheta"]');
                if (!startPosNode || !stepSizeNode) throw new Error("Could not find scan parameters in BRML file.");

                const startPos = parseFloat(startPosNode.textContent);
                const stepSize = parseFloat(stepSizeNode.textContent);
                
                const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * stepSize);

                return { tth, intensity, wavelength };
            };

            const parseRigakuRasFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                const tth = [], intensity = [];
                let inDataSection = false;
                let wavelength = null;

                for (const line of lines) {
                    const upperLine = line.toUpperCase();
                    if (upperLine.startsWith('*WAVE_LENGTH') || upperLine.startsWith('*MEAS_COND_XG_WAVE_LENGTH')) {
                        const parts = line.trim().split(/\s+/);
                        if (parts.length > 1) {
                            const wl = parseFloat(parts[1]);
                            if (!isNaN(wl)) wavelength = wl;
                        }
                    }
                    if (upperLine.startsWith('*RAS_INT_START')) {
                        inDataSection = true;
                        continue;
                    }
                    if (upperLine.startsWith('*RAS_INT_END')) {
                        break;
                    }
                    if (inDataSection) {
                        const parts = line.trim().split(/[\s,]+/);
                        if (parts.length >= 2) {
                            const x = parseFloat(parts[0]);
                            const y = parseFloat(parts[1]);
                            if (!isNaN(x) && !isNaN(y)) {
                                tth.push(x);
                                intensity.push(y);
                            }
                        }
                    }
                }
                if (tth.length === 0) throw new Error("No data found in RAS file data section.");
                return { tth, intensity, wavelength };
            };

            const parseGsasEsdFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                let wavelength = null;
                let startTth, stepSize;
                let dataStartIndex = -1;

                lines.forEach((line, index) => {
                    const upperLine = line.toUpperCase();
                    if (upperLine.includes('WAVELENGTH')) {
                        const match = line.match(/wavelength\s+([0-9.]+)/i);
                        if (match && match[1]) {
                            wavelength = parseFloat(match[1]);
                        }
                    }
                    if (upperLine.startsWith('BANK')) {
                        const parts = line.trim().split(/\s+/);
                        if (parts.length >= 6 && parts[4].toUpperCase() === 'CONST') {
                            startTth = parseFloat(parts[5]) / 100.0;
                            stepSize = parseFloat(parts[6]) / 100.0;
                            dataStartIndex = index + 1;
                        }
                    }
                });

                if (startTth === undefined || stepSize === undefined) {
                    throw new Error("GSAS Parse Error: Could not find a valid 'BANK' line with CONST scan parameters.");
                }
                if (dataStartIndex !== -1 && lines[dataStartIndex]?.toUpperCase().includes('STD')) {
                    dataStartIndex++;
                }
                if (dataStartIndex === -1 || dataStartIndex >= lines.length) {
                    throw new Error("GSAS Parse Error: Found scan parameters but no subsequent data lines.");
                }
                
                const intensity = [];
                for (let i = dataStartIndex; i < lines.length; i++) {
                    const parts = lines[i].trim().split(/\s+/);
                    for (let j = 1; j < parts.length; j += 2) {
                        const val = parseFloat(parts[j]);
                        if (!isNaN(val)) {
                            intensity.push(val);
                        }
                    }
                }

                if (intensity.length === 0) {
                    throw new Error("GSAS Parse Error: No intensity data could be parsed.");
                }
                const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize);
                return { tth, intensity, wavelength };
            };

            const parseUxdFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                const intensity = [];
                let startTth, stepSize, wavelength;
                let inDataSection = false;

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (inDataSection) {
                        const parts = trimmedLine.split(/\s+/);
                        parts.forEach(part => {
                            const val = parseFloat(part);
                            if (!isNaN(val)) {
                                intensity.push(val);
                            }
                        });
                    } else {
                        if (trimmedLine.toUpperCase().startsWith('_START=')) {
                            startTth = parseFloat(trimmedLine.substring(7));
                        } else if (trimmedLine.toUpperCase().startsWith('_STEPSIZE=')) {
                            stepSize = parseFloat(trimmedLine.substring(10));
                        } else if (trimmedLine.toUpperCase().startsWith('_WL1=')) {
                            wavelength = parseFloat(trimmedLine.substring(5));
                        } else if (trimmedLine.toUpperCase() === '_COUNTS') {
                            inDataSection = true;
                        }
                    }
                }

                if (startTth === undefined || stepSize === undefined) {
                    throw new Error("Could not find _START and _STEPSIZE parameters in UXD file.");
                }
                if (intensity.length === 0) {
                    throw new Error("No intensity data found after _COUNTS in UXD file.");
                }
                const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize);
                return { tth, intensity, wavelength };
            };

            const parsePhilipsUdfFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                const tth = [], intensity = [];
                let inDataSection = false;
                let wavelength = null;

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (trimmedLine.toUpperCase().startsWith('LAMBDA')) {
                        const parts = trimmedLine.split('=');
                        if (parts.length > 1) wavelength = parseFloat(parts[1]);
                    }
                    if (trimmedLine.toUpperCase() === '[DATA]') {
                        inDataSection = true;
                        continue;
                    }
                    if (trimmedLine.startsWith('[') && trimmedLine.toUpperCase() !== '[DATA]') {
                        inDataSection = false;
                    }
                    if (inDataSection) {
                        const parts = trimmedLine.split(/,/).map(p => p.trim());
                        if(parts.length >= 2) {
                            const x = parseFloat(parts[0]);
                            const y = parseFloat(parts[1]);
                            if (!isNaN(x) && !isNaN(y)) {
                                tth.push(x);
                                intensity.push(y);
                            }
                        }
                    }
                }
                if (tth.length === 0) throw new Error("No [Data] section found in UDF file.");
                return { tth, intensity, wavelength };
            };

            const detectAndParseFile = (fileName, fileContent) => {
                const name = fileName.toLowerCase();
                const lines = fileContent.trim().split(/\r?\n/);
                const firstLine = lines.length > 0 ? lines[0].trim() : '';

                if (name.endsWith('.uxd') || firstLine.startsWith('_FILEVERSION')) return parseUxdFile(fileContent);
                if (name.endsWith('.xrdml') || (fileContent.includes('<?xml') && fileContent.includes('<xrdMeasurement'))) return parseXrdmlFile(fileContent);
                if (name.endsWith('.brml') || (fileContent.includes('<?xml') && fileContent.includes('<RawDataFile'))) return parseBrukerBrmlFile(fileContent);
                if (name.endsWith('.ras') || fileContent.toUpperCase().includes('*RAS_HEADER_START')) return parseRigakuRasFile(fileContent);
                if (name.endsWith('.udf')) return parsePhilipsUdfFile(fileContent);
                if (lines.length > 2 && lines[1].toUpperCase().includes('BANK')) return parseGsasEsdFile(fileContent);
                return parseDataFile(fileContent);
            };

            ui.fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                ui.fileInputLabel.classList.remove('error');
                const reader = new FileReader();
                reader.onload = (evt) => {
                    try {
                        const parsedData = detectAndParseFile(file.name, evt.target.result);
                        if (!parsedData || parsedData.tth.length === 0) throw new Error("No valid data points could be parsed from the file.");
                        fullExperimentalData = parsedData;
                        const maxIntensity = Math.max(...fullExperimentalData.intensity);
                        if (maxIntensity > 0) fullExperimentalData.intensity = fullExperimentalData.intensity.map(y => y / maxIntensity * 1000);
                        solutions = [];
                        updateSolutionsTable();
                        ui.solutionsLed.className = 'led-indicator gray';
                        if (parsedData.wavelength) ui.wavelength.value = parsedData.wavelength.toFixed(5);
                        selectedSolution = null;
                        currentHklList = [];
                        ui.fileName.textContent = file.name;
                        ui.placeholder.style.display = 'none';
                        ui.resultsContainer.style.display = 'flex';
                        ui.peakControls.classList.remove('hidden');
                        ui.indexingControls.classList.remove('hidden');
                        initializeChart();
                        setupTthSliders();
                        findPeaks();
                        showStatus(`File "${file.name}" loaded successfully.`, 'success');
                    } catch (error) {
                        showStatus(`Error reading file: ${error.message}`, 'error');
                        ui.fileInputLabel.classList.add('error');
                        console.error(error);
                    }
                };
                reader.onerror = () => {
                     showStatus('Error: Could not read the selected file.', 'error');
                     ui.fileInputLabel.classList.add('error');
                };
                reader.readAsText(file);
            });

            const setupTthSliders = () => {
                if (fullExperimentalData.tth.length === 0) return;
                const min = fullExperimentalData.tth[0];
                const max = fullExperimentalData.tth[fullExperimentalData.tth.length - 1];
                const step = (max - min) / 2000;
                [ui.tthMinSlider, ui.tthMaxSlider].forEach(el => { el.disabled = false; Object.assign(el, { min, max, step }); });
                const initialMin = Math.floor(min);
                const initialMax = Math.ceil(max);
                ui.tthMinSlider.value = initialMin;
                ui.tthMaxSlider.value = initialMax;
                ui.tthMinValue.textContent = initialMin.toFixed(2);
                ui.tthMaxValue.textContent = initialMax.toFixed(2);
                updatePlotRange(true);
            };

            const updatePlotRange = (updateYScale = false) => {
                if(!xrdChart) return;
                const min = parseFloat(ui.tthMinSlider.value);
                const max = parseFloat(ui.tthMaxSlider.value);
                xrdChart.options.scales.x.min = min;
                xrdChart.options.scales.x.max = max;
                if (updateYScale) {
                    const visibleIntensities = fullExperimentalData.intensity.filter((_, index) => {
                        const tth = fullExperimentalData.tth[index];
                        return tth >= min && tth <= max;
                    });
                    if (visibleIntensities.length > 0) {
                        const yMaxInRange = Math.max(...visibleIntensities);
                        xrdChart.options.scales.y.min = -yMaxInRange * 0.05;
                        xrdChart.options.scales.y.max = yMaxInRange * 1.1;
                    } else {
                        const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
                        xrdChart.options.scales.y.min = -yMax * 0.05;
                        xrdChart.options.scales.y.max = yMax * 1.1;
                    }
                }
                xrdChart.update('none');
                updateAllMarkers();
            };

            ui.tthMinSlider.addEventListener('input', () => {
                let minVal = parseFloat(ui.tthMinSlider.value);
                let maxVal = parseFloat(ui.tthMaxSlider.value);
                if (minVal >= maxVal) { minVal = maxVal - parseFloat(ui.tthMinSlider.step); ui.tthMinSlider.value = minVal; }
                ui.tthMinValue.textContent = minVal.toFixed(2);
                updatePlotRange();
            });
             ui.tthMaxSlider.addEventListener('input', () => {
                let minVal = parseFloat(ui.tthMinSlider.value);
                let maxVal = parseFloat(ui.tthMaxSlider.value);
                if (maxVal <= minVal) { maxVal = minVal + parseFloat(ui.tthMaxSlider.step); ui.tthMaxSlider.value = maxVal; }
                ui.tthMaxValue.textContent = maxVal.toFixed(2);
                updatePlotRange();
            });
            
            ui.ballRadiusSlider.addEventListener('input', () => { ui.ballRadiusValue.textContent = ui.ballRadiusSlider.value; debouncedFindPeaks(); });
            ui.smoothingWidthSlider.addEventListener('input', () => { ui.smoothingWidthValue.textContent = ui.smoothingWidthSlider.value; debouncedFindPeaks(); });
            ui.peakThresholdSlider.addEventListener('input', () => { const value = logSliderToValue(parseFloat(ui.peakThresholdSlider.value)); ui.peakThresholdValue.textContent = value.toFixed(1); debouncedFindPeaks(); });

            const rollingBallBackground = (y, radius, smoothingWidth) => {
                const n = y.length;
                if (n === 0 || radius <= 0) return new Array(n).fill(0);
                let smoothed_y = y;
                if (smoothingWidth > 1) {
                    smoothed_y = new Array(n);
                    const halfWidth = Math.floor(smoothingWidth / 2);
                    for (let i = 0; i < n; i++) {
                        const start = Math.max(0, i - halfWidth);
                        const end = Math.min(n, i + halfWidth + 1);
                        let sum = 0;
                        for (let j = start; j < end; j++) sum += y[j];
                        smoothed_y[i] = sum / (end - start);
                    }
                }
                const eroded = new Array(n);
                for (let i = 0; i < n; i++) {
                    const start = Math.max(0, i - radius);
                    const end = Math.min(n, i + radius + 1);
                    let min = Infinity;
                    for (let j = start; j < end; j++) if (smoothed_y[j] < min) min = smoothed_y[j];
                    eroded[i] = min;
                }
                const background = new Array(n);
                for (let i = 0; i < n; i++) {
                    const start = Math.max(0, i - radius);
                    const end = Math.min(n, i + radius + 1);
                    let max = -Infinity;
                    for (let j = start; j < end; j++) if (eroded[j] > max) max = eroded[j];
                    background[i] = max;
                }
                return background;
            };

            const savitzkyGolay = (data, windowSize = 9, polyOrder = 2) => {
                const n = data.length; if (n === 0) return [];
                windowSize = Math.max(3, windowSize); if (windowSize % 2 === 0) windowSize += 1; windowSize = Math.min(windowSize, n);
                const halfWindow = Math.floor(windowSize / 2);
                const result = new Array(n);
                const coefficients = (windowSize === 9 && polyOrder === 2) ? [-0.0909, 0.0606, 0.1687, 0.2333, 0.2545, 0.2333, 0.1687, 0.0606, -0.0909] : (() => { const weights = []; for (let i = -halfWindow; i <= halfWindow; i++) weights.push(1 - Math.abs(i) / (halfWindow + 1)); const sum = weights.reduce((a, b) => a + b, 0); return weights.map(w => w / sum); })();
                for (let i = 0; i < n; i++) {
                    let smoothedValue = 0;
                    for (let j = -halfWindow; j <= halfWindow; j++) {
                        let idx = i + j;
                        if (idx < 0) idx = Math.abs(idx);
                        else if (idx >= n) idx = n - 1 - (idx - (n - 1));
                        smoothedValue += data[idx] * coefficients[j + halfWindow];
                    }
                    result[i] = smoothedValue;
                }
                return result;
            };

            function findPeaks() {
                if (!fullExperimentalData || !fullExperimentalData.intensity || fullExperimentalData.intensity.length < 5) return;
                const { intensity, tth } = fullExperimentalData; const n = tth.length;
                const minTth = parseFloat(ui.tthMinSlider.value) || tth[0];
                const maxTth = parseFloat(ui.tthMaxSlider.value) || tth[n - 1];
                const minHeightPercent = logSliderToValue(parseFloat(ui.peakThresholdSlider.value)) || 2;
                const ballRadius = parseInt(ui.ballRadiusSlider.value, 10);
                const smoothingWidth = parseInt(ui.smoothingWidthSlider.value, 10);
                const background = rollingBallBackground(intensity, ballRadius, smoothingWidth);
                const backgroundCorrected = intensity.map((y, i) => Math.max(0, y - background[i]));
                const windowSize = Math.max(5, Math.min(11, Math.floor(n / 100)));
                const smoothed = savitzkyGolay(backgroundCorrected, windowSize, 2);
                const maxCorrectedIntensity = Math.max(...backgroundCorrected) || 1;
                const minAbsoluteHeight = (minHeightPercent / 100) * maxCorrectedIntensity;
                const calculateNoiseLevel = (data) => { const n_s = data.length; if (n_s < 10) return 0; const sample = []; for (let i = 0; i < n_s; i += Math.max(1, Math.floor(n_s / 100))) sample.push(data[i]); sample.sort((a, b) => a - b); const median = sample[Math.floor(sample.length / 2)]; const deviations = sample.map(x => Math.abs(x - median)); deviations.sort((a, b) => a - b); return deviations[Math.floor(deviations.length / 2)] * 1.4826; };
                const adaptiveThreshold = Math.max(minAbsoluteHeight, calculateNoiseLevel(backgroundCorrected) * 3);
                const localMaxIndices = [];
                for (let i = 1; i < n - 1; i++) {
                    const current = smoothed[i]; if (current < adaptiveThreshold) continue;
                    if (current > smoothed[i - 1] && current > smoothed[i + 1]) localMaxIndices.push(i);
                    else if (current === smoothed[i + 1] && current > smoothed[i - 1]) { let plateauEnd = i + 1; while (plateauEnd < n - 1 && Math.abs(smoothed[plateauEnd] - current) < maxCorrectedIntensity * 0.001) plateauEnd++; if (plateauEnd < n && smoothed[plateauEnd] < current) localMaxIndices.push(Math.round((i + plateauEnd - 1) / 2)); i = plateauEnd - 1; }
                }
                const candidates = localMaxIndices.filter(idx => tth[idx] >= minTth && tth[idx] <= maxTth && backgroundCorrected[idx] >= adaptiveThreshold)
                    .map(idx => ({ idx, tth: tth[idx], height: smoothed[idx], backgroundCorrectedHeight: backgroundCorrected[idx] }));
                const refinedPeaks = [];
                for (const peak of candidates) {
                    const { idx } = peak; let refinedTth = peak.tth;
                    if (idx > 0 && idx < n - 1) { const y1 = smoothed[idx - 1], y2 = smoothed[idx], y3 = smoothed[idx + 1]; const denominator = 2 * (y1 - 2 * y2 + y3); if (Math.abs(denominator) > 1e-10) { const delta = (y1 - y3) / denominator; if (Math.abs(delta) < 1.0) { const stepSize = idx < n - 1 ? tth[idx + 1] - tth[idx] : tth[idx] - tth[idx - 1]; refinedTth = tth[idx] + delta * stepSize; } } }
                    refinedPeaks.push({ ...peak, tth: refinedTth });
                }
                refinedPeaks.sort((a, b) => a.tth - b.tth);
                const finalPeaks = []; const mergeThreshold = 0.02;
                for (const peak of refinedPeaks) {
                    if (finalPeaks.length === 0 || Math.abs(peak.tth - finalPeaks[finalPeaks.length - 1].tth) >= mergeThreshold) finalPeaks.push(peak);
                    else if (peak.height > finalPeaks[finalPeaks.length - 1].height) finalPeaks[finalPeaks.length - 1] = peak;
                }
                const lambda = parseFloat(ui.wavelength.value) || 1.54178;
                pickedPeaks = finalPeaks.map(p => { const d = lambda / (2 * Math.sin(p.tth * Math.PI / 360)); return { tth: p.tth, d: d, q: 1 / (d * d) }; });
                updatePeakTable(); updateStartIndexingButtonState();
            };

            const recalculatePeakValues = () => {
                const lambda = parseFloat(ui.wavelength.value);
                pickedPeaks.forEach(peak => { peak.d = lambda / (2 * Math.sin(peak.tth * Math.PI / 360)); peak.q = 1 / (peak.d * peak.d); });
            };

            const updatePeakTable = () => {
                ui.peakListBody.innerHTML = '';
                pickedPeaks.forEach((peak, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `<td>${index + 1}</td><td><input type="number" class="peak-tth-input" value="${peak.tth.toFixed(4)}" data-index="${index}" step="0.0001"></td><td><input type="number" class="peak-d-input" value="${peak.d.toFixed(5)}" data-index="${index}" disabled></td><td><button class="delete-peak-btn" data-index="${index}">X</button></td>`;
                    ui.peakListBody.appendChild(row);
                });
                ui.peakTableContainer.classList.toggle('hidden', pickedPeaks.length === 0);
                updateAllMarkers();
            };
            
            const updateStartIndexingButtonState = () => {
                const needed = 4 - pickedPeaks.length;
                if (needed > 0) { ui.startIndexingButton.disabled = true; ui.startIndexingButton.textContent = `Need ${needed} more peak${needed > 1 ? 's' : ''}`; } 
                else { ui.startIndexingButton.disabled = false; ui.startIndexingButton.textContent = 'Start Indexing'; }
            };

            ui.peakListBody.addEventListener('change', (e) => {
                if (e.target.classList.contains('peak-tth-input')) {
                    const index = parseInt(e.target.dataset.index); const tth = parseFloat(e.target.value); const lambda = parseFloat(ui.wavelength.value);
                    const d = lambda / (2 * Math.sin(tth * Math.PI / 360)); const q = 1 / (d*d);
                    pickedPeaks[index] = {tth, d, q};
                    e.target.closest('tr').querySelector('.peak-d-input').value = d.toFixed(5);
                    updateAllMarkers(); updateStartIndexingButtonState();
                }
            });
             ui.peakListBody.addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-peak-btn')) { const index = parseInt(e.target.dataset.index); pickedPeaks.splice(index, 1); updatePeakTable(); updateStartIndexingButtonState(); }
            });
            
            const setUIState = (indexing) => {
                isIndexing = indexing; document.body.style.cursor = indexing ? 'wait' : 'default';
                const controlsToDisable = [ ui.fileInput, ui.peakThresholdSlider, ui.tthMinSlider, ui.tthMaxSlider, ui.ballRadiusSlider, ui.smoothingWidthSlider, ui.wavelength, ui.tthError, ui.maxVolume, ui.impurityPeaksInput, ui.refineZeroCheckbox, ...ui.systemCheckboxes, ...ui.tabButtons ];
                controlsToDisable.forEach(el => { if (el) el.disabled = indexing; });
                ui.peakListBody.querySelectorAll('input, button').forEach(el => { el.disabled = indexing; });
                ui.fileInputLabel.style.pointerEvents = indexing ? 'none' : 'auto'; ui.fileInputLabel.style.opacity = indexing ? '0.7' : '1';
                if (indexing) {
                    ui.startIndexingButton.disabled = true; ui.startIndexingButton.textContent = 'Indexing...'; ui.reportButton.textContent = 'Stop'; ui.reportButton.disabled = false;
                    ui.progressBarContainer.classList.remove('hidden'); ui.progressBar.style.width = '0%';
                } else {
                    updateStartIndexingButtonState(); ui.reportButton.textContent = 'Generate PDF Report'; ui.reportButton.disabled = (solutions.length === 0);
                    ui.progressBarContainer.classList.add('hidden'); ui.progressBar.style.width = '0%';
                    if (fullExperimentalData.tth.length > 0) { ui.tthMinSlider.disabled = false; ui.tthMaxSlider.disabled = false; }
                }
            };
            
            const applyFinalSieve = (solutions) => {
                if (solutions.length <= 1) return solutions;
                showStatus('Applying final sieve to results...', 'info', 2000);
                const symmetryOrder = { 'cubic': 5, 'hexagonal': 4, 'tetragonal': 4, 'orthorhombic': 3, 'monoclinic': 2 };
                solutions.sort((a, b) => a.volume - b.volume);
                const toKeep = new Array(solutions.length).fill(true);
                for (let i = 0; i < solutions.length; i++) {
                    if (!toKeep[i]) continue;
                    for (let j = i + 1; j < solutions.length; j++) {
                        if (!toKeep[j]) continue;
                        const vol_i = solutions[i].volume; const vol_j = solutions[j].volume;
                        if (vol_j > vol_i * 1.01) break;
                        const sym_i = symmetryOrder[solutions[i].system]; const sym_j = symmetryOrder[solutions[j].system];
                        if (sym_i > sym_j) toKeep[j] = false;
                        else if (sym_j > sym_i) { toKeep[i] = false; break; } 
                        else { if (solutions[i].m20 >= solutions[j].m20) toKeep[j] = false; else { toKeep[i] = false; break; } }
                    }
                }
                const filteredSolutions = solutions.filter((_, index) => toKeep[index]);
                const numDiscarded = solutions.length - filteredSolutions.length;
                if (numDiscarded > 0) showStatus(`Sieve discarded ${numDiscarded} redundant solution(s).`, 'success');
                return filteredSolutions.slice(0, 50);
            };

            const startIndexing = () => {
                if (pickedPeaks.length < 4) { showStatus("Please find at least 4 peaks before starting indexing.", 'error'); return; }
                const systemsToSearch = Array.from(ui.systemCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
                if (systemsToSearch.length === 0) { showStatus("Please select at least one crystal system to search.", 'error'); return; }
                if (!workerURL) { showStatus("Error: Indexing engine is not available.", "error"); return; }
                setUIState(true); solutions = []; selectedSolution = null; currentHklList = []; activeWorkers = [];
                updateSolutionsTable(); showStatus(`Indexing started for ${systemsToSearch.length} system(s)...`, 'info');
                const baseParams = {
                    peaks: pickedPeaks,
                    wavelength: parseFloat(ui.wavelength.value),
                    tth_error: parseFloat(ui.tthError.value),
                    max_volume: parseFloat(ui.maxVolume.value),
                    impurity_peaks: parseInt(ui.impurityPeaksInput.value, 10),
                    refineZero: ui.refineZeroCheckbox.checked, // Added
                };
                let completedWorkers = 0; const totalWorkers = systemsToSearch.length;
                systemsToSearch.forEach(system => {
                    const worker = new Worker(workerURL);
                    activeWorkers.push(worker);
                    worker.onmessage = (e) => {
                        const { type, payload } = e.data;
                        if (type === 'solution') solutions.push(payload);
                        else if (type === 'done') {
                            completedWorkers++;
                            ui.progressBar.style.width = `${(completedWorkers / totalWorkers) * 100}%`;
                            worker.terminate();
                            activeWorkers = activeWorkers.filter(w => w !== worker);
                            if (completedWorkers === totalWorkers) {
                               
                               const maxTthForHkl = xrdChart.scales.x.max || Math.max(...pickedPeaks.map(p => p.tth));
                                solutions = addDerivedTransformedCandidates(solutions, maxTthForHkl); //cherche avec les transformations du det de Gram
                               
                                solutions = applyFinalSieve(solutions); 
                                
                                    solutions.forEach(sol => {
        //  re-run analysis 
            sol.analysis = analyzeSystematicAbsences(sol, pickedPeaks, parseFloat(ui.wavelength.value), parseFloat(ui.tthError.value));

    });
                                
                                
                                
                                setUIState(false);
                                displayedSolutions = [...solutions];
                                updateSolutionsTable();

                                if (solutions.length > 0) { showStatus(`Indexing complete. Found ${solutions.length} potential solution(s).`, 'success'); ui.solutionsLed.className = 'led-indicator green'; } 
                                else { showStatus('Indexing finished, but no valid solutions were found.', 'info'); ui.solutionsLed.className = 'led-indicator red'; }
                            }
                        }
                    };
                    worker.postMessage({ ...baseParams, systemToSearch: system });
                });
            };

            ui.startIndexingButton.addEventListener('click', startIndexing);

            ui.reportButton.addEventListener('click', () => {
                if (isIndexing) {
                    activeWorkers.forEach(w => w.terminate()); activeWorkers = [];
                    setUIState(false); showStatus('Indexing stopped by user.', 'info');
                } else { generatePDFReport(); }
            });
            
const sortSolutions = () => {
    const { column, direction } = sortState;
    const dir = direction === 'asc' ? 1 : -1;

    solutions.sort((a, b) => {
        if (column === 'system') {
            return (a.system || '').localeCompare(b.system || '') * dir;
        } else {
            // ---  ROBUST COMPARISON LOGIC ---
            let valA = a[column];
            let valB = b[column];

            // Treat any non-numeric, null, or undefined values as negative infinity for sorting
            if (isNaN(valA) || valA == null) valA = -Infinity;
            if (isNaN(valB) || valB == null) valB = -Infinity;
            
            return (valA - valB) * dir;
            // --- but why should I get a Nan ? ---
        }
    });
};


            const updateSolutionsTable = () => {
                ui.solutionsTableBody.innerHTML = '';
                displayedSolutions.forEach((sol, index) => {
                    const row = document.createElement('tr'); row.dataset.index = index; 
                    let paramsCell = '', anglesCell = '';
                    switch(sol.system) {
                        case 'cubic': paramsCell = `a = ${sol.a.toFixed(4)}`; anglesCell = `90, 90, 90`; break;
                        case 'tetragonal': paramsCell = `a = ${sol.a.toFixed(4)}, c = ${sol.c.toFixed(4)}`; anglesCell = `90, 90, 90`; break;
                        case 'hexagonal': paramsCell = `a = ${sol.a.toFixed(4)}, c = ${sol.c.toFixed(4)}`; anglesCell = `90, 90, 120`; break;
                        case 'orthorhombic': paramsCell = `a = ${sol.a.toFixed(4)}<br>b = ${sol.b.toFixed(4)}<br>c = ${sol.c.toFixed(4)}`; anglesCell = `90, 90, 90`; break;
                        case 'monoclinic': paramsCell = `a = ${sol.a.toFixed(4)}<br>b = ${sol.b.toFixed(4)}<br>c = ${sol.c.toFixed(4)}`; anglesCell = `90, ${sol.beta.toFixed(3)}, 90`; break;
                        default: paramsCell = `${sol.a.toFixed(4)}`; anglesCell = `-`;
                    }
                    if (sol.zero_correction) { // Added
                        anglesCell += `<br><span style="font-size:0.9em; color: var(--text-dark);">(Z=${sol.zero_correction.toFixed(4)}°)</span>`;
                    }
                    row.innerHTML = `<td>${sol.system.substring(0,4)}</td><td>${paramsCell}</td><td>${anglesCell}</td><td>${sol.volume.toFixed(2)}</td><td>${sol.m20.toFixed(2)}</td>`;
                    ui.solutionsTableBody.appendChild(row);
                });
                
                ui.solutionsTableHeaders.forEach(h => {
    h.classList.remove('sort-asc', 'sort-desc');
    if (h.dataset.sort === sortState.column) {
       h.classList.add(sortState.direction === 'asc' ? 'sort-asc' : 'sort-desc');
    }
});

            };


            ui.solutionsTableBody.addEventListener('click', (e) => {
                const row = e.target.closest('tr'); if (!row) return;
                document.querySelectorAll('#solutions-table-body tr').forEach(r => r.classList.remove('selected'));
                row.classList.add('selected');
                const index = parseInt(row.dataset.index);
                selectedSolution = displayedSolutions[index];
                const lambda = parseFloat(ui.wavelength.value);
                const maxTth = xrdChart.options.scales.x.max || Math.max(...pickedPeaks.map(p => p.tth));
                currentHklList = generateHKL(maxTth, {...selectedSolution, lambda}, selectedSolution.system);
                updateAllMarkers();
            });

            Chart.register({ id: 'verticalCursorLine', afterDraw: chart => { if (chart.tooltip?._active?.length) { let x = chart.tooltip._active[0].element.x; let yAxis = chart.scales.y; let ctx = chart.ctx; ctx.save(); ctx.beginPath(); ctx.moveTo(x, yAxis.top); ctx.lineTo(x, yAxis.bottom); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)'; ctx.setLineDash([4, 4]); ctx.stroke(); ctx.restore(); } } });
            Chart.register({ id: 'legendMargin', beforeInit(chart) { const originalFit = chart.legend.fit; chart.legend.fit = function() { originalFit.bind(chart.legend)(); this.height += 15; }; } });

            
const initializeChart = () => {
    if (xrdChart) xrdChart.destroy();
    const experimentalPoints = fullExperimentalData.tth.map((t, i) => ({ x: t, y: Math.max(0, fullExperimentalData.intensity[i]) }));
    const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
    xrdChart = new Chart(ui.chartCanvas, {
        type: 'line',
        data: {
            datasets: [
                {
                    label: 'Intensity',
                    data: experimentalPoints,
                    borderColor: 'rgba(107, 114, 128, 0.7)',
                    showLine: true, 
                    borderWidth: 0.75,
                    pointRadius: 1.5, 
                    pointHoverRadius: 4,
                    pointBackgroundColor: 'rgba(107, 114, 128, 0.7)'
                },
                {
                    type: 'bar',
                    label: 'Observed Peaks',
                    data: [],
                    backgroundColor: 'rgba(239, 68, 68, 0.7)',
                    barThickness: 1
                },
                {
                    type: 'bar',
                    label: 'Calculated Peaks',
                    data: [],
                    backgroundColor: 'rgba(59, 130, 246, 0.9)',
                    barThickness: 1
                }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false, animation: false,
            // NOTE: The old 'interaction' block has been removed to fix panning.
            scales: {
                x: { type: 'linear', title: { display: true, text: '2-theta (degrees)' } },
                y: { title: { display: true, text: 'Intensity (a.u.)' }, min: -yMax * 0.05, max: yMax * 1.1, suggestedMin: 0 }
            },
            plugins: {
                zoom: {
                    pan: {
                        enabled: true,
                        mode: 'xy',
                        threshold: 5,
                        onPanComplete: () => { updateAllMarkers(); }
                    },
                    zoom: {
                        wheel: { enabled: false }, // IMPORTANT: The plugin's wheel handler is disabled.
                        pinch: { enabled: true },
                        drag: { enabled: false },
                        onZoomComplete: () => { updateAllMarkers(); } // This is for pinch-zoom
                    }
                },
                legend: { position: 'top' },
                tooltip: {
                    callbacks: {
                        title: function(tooltipItems) {
                            if (!tooltipItems.length) return '';
                            const tth = tooltipItems[0].parsed.x;
                            let title = `2θ: ${tth.toFixed(3)}°`;
                            if (currentHklList && currentHklList.length > 0) {
                                let closestPeak = null;
                                let minDiff = Infinity;
                                for (const hkl of currentHklList) {
                                    const diff = Math.abs(tth - hkl.tth);
                                    if (diff < minDiff) { minDiff = diff; closestPeak = hkl; }
                                }
                                const tolerance = parseFloat(ui.tthError.value) || 0.05;
                                if (closestPeak && minDiff < tolerance) {
                                    title += `, HKL: (${closestPeak.h},${closestPeak.l},${closestPeak.k})`;
                                }
                            }
                            return title;
                        },
                        label: function(context) {
                            const datasetLabel = context.dataset.label || '';
                            if (datasetLabel === 'Observed Peaks' || datasetLabel === 'Calculated Peaks') return null;
                            let label = datasetLabel ? `${datasetLabel}: ` : '';
                            if (context.parsed.y !== null) { label += Math.round(context.parsed.y); }
                            return label;
                        }
                    }
                }
            }
        }
    });
};


ui.chartCanvas.addEventListener('wheel', e => {
    e.preventDefault(); // This stops the page from scrolling.
    if (!xrdChart || !xrdChart.chartArea) return;

    const { left, right, top, bottom } = xrdChart.chartArea;
    const { x, y } = e; // Use event coordinates for the focal point
    const zoomDirection = e.deltaY < 0 ? 1.1 : 0.9; // 1.1 zooms in, 0.9 zooms out

    const zoomOptions = {
        x: 1, // Default to no zoom on this axis
        y: 1, // Default to no zoom on this axis
    };

    if (e.offsetY > bottom && e.offsetX > left && e.offsetX < right) {
        // Cursor is over the X-axis scale
        zoomOptions.x = zoomDirection;
    } else if (e.offsetX < left && e.offsetY > top && e.offsetY < bottom) {
        // Cursor is over the Y-axis scale
        zoomOptions.y = zoomDirection;
    } else if (e.offsetX >= left && e.offsetX <= right && e.offsetY >= top && e.offsetY <= bottom) {
        // Cursor is in the main chart area
        zoomOptions.x = zoomDirection;
        zoomOptions.y = zoomDirection;
    } else {
        // Cursor is outside the relevant areas, do nothing.
        return;
    }

    // Programmatically call the zoom plugin with our precise instructions
    xrdChart.zoom(zoomOptions, 'none');
    updateAllMarkers(); // Manually update markers after zoom
});

const updateAllMarkers = () => {
    if (!xrdChart) return;

    // Get the current visible range of the x-axis
    const xMin = xrdChart.scales.x.min;
    const xMax = xrdChart.scales.x.max;

    const yMin = xrdChart.scales.y.min;
    const yMax = xrdChart.scales.y.max;
    const yRange = yMax - yMin;
    const markerHeight = yRange * 0.02;

    // Filter observed peaks to only include those within the visible range
    const visibleObsPeaks = pickedPeaks.filter(p => p.tth >= xMin && p.tth <= xMax);
    xrdChart.data.datasets[1].data = visibleObsPeaks.map(p => ({ x: p.tth, y: [yMin, yMin + markerHeight] }));

    if (selectedSolution) {
        const calculatedBottom = yMin + markerHeight * 1.2;
        const calculatedTop = calculatedBottom + markerHeight;

        // Also filter calculated peaks to only include those within the visible range
        const visibleCalcPeaks = currentHklList.filter(hkl => hkl.tth >= xMin && hkl.tth <= xMax);
        xrdChart.data.datasets[2].data = visibleCalcPeaks.map(hkl => ({ x: hkl.tth, y: [calculatedBottom, calculatedTop] }));
    } else {
        xrdChart.data.datasets[2].data = [];
    }

    xrdChart.update('none');
};

            const generateHKL = (maxTth, params, system) => {
                 const { a, b, c, beta, lambda } = params; if (!a || !lambda) return []; const reflections = [];
                 const d_min = lambda / (2 * Math.sin(maxTth * Math.PI / 360)); const q_max_limit = (1 / (d_min * d_min)) * 1.05;
                 const h_max = Math.ceil(a / d_min); const k_max = b ? Math.ceil(b / d_min) : h_max; const l_max = c ? Math.ceil(c / d_min) : h_max;
                 for (let h = 0; h <= h_max; h++) { for (let k = 0; k <= k_max; k++) { if ((system === 'cubic' || system === 'tetragonal' || system === 'hexagonal') && k > h) continue; for (let l = 0; l <= l_max; l++) { if (system === 'cubic' && l > k) continue; if (h === 0 && k === 0 && l === 0) continue; let inv_d_sq = 0;
                     switch (system) {
                         case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                         case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                         case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                         case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                         case 'monoclinic': const sinBeta = Math.sin(beta*Math.PI/180); const cosBeta = Math.cos(beta*Math.PI/180); inv_d_sq = (1/(sinBeta*sinBeta))*(h*h/(a*a)+l*l/(c*c)-2*h*l*cosBeta/(a*c))+k*k/(b*b); break;
                     }
                     if (inv_d_sq <= 0 || inv_d_sq > q_max_limit) continue; const sinThetaSq = (lambda*lambda/4)*inv_d_sq;
                     if (sinThetaSq <= 1) { const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI); reflections.push({tth, h, k, l, d: 1/Math.sqrt(inv_d_sq)}); }
                 }}}
                 return reflections.sort((a, b) => a.tth - b.tth);
             };

            const resizer = document.getElementById('drag-handle'); const leftPanel = document.getElementById('controls-panel');
            resizer.addEventListener('mousedown', (e) => { e.preventDefault(); document.body.style.cursor = 'col-resize';
                const moveHandler = (moveEvent) => { if (moveEvent.clientX > 350 && moveEvent.clientX < window.innerWidth - 350) { leftPanel.style.width = `${moveEvent.clientX}px`; } };
                const upHandler = () => { document.body.style.cursor = 'default'; window.removeEventListener('mousemove', moveHandler); window.removeEventListener('mouseup', upHandler); };
                window.addEventListener('mousemove', moveHandler); window.addEventListener('mouseup', upHandler);
            });
            
            ui.chartCanvas.addEventListener('contextmenu', e => { e.preventDefault(); if (xrdChart) { xrdChart.resetZoom('none'); updateAllMarkers(); } });
            ui.chartCanvas.addEventListener('click', (e) => {
                if (!e.ctrlKey || !xrdChart) return;
                const rect = xrdChart.canvas.getBoundingClientRect(); const x = e.clientX - rect.left;
                if (x < xrdChart.chartArea.left || x > xrdChart.chartArea.right) return;
                const tth = xrdChart.scales.x.getValueForPixel(x); if (!tth) return;
                const lambda = parseFloat(ui.wavelength.value); if (isNaN(lambda)) { showStatus('Wavelength is not a valid number.', 'error'); return; }
                const sin_theta = Math.sin(tth * Math.PI / 360); if (sin_theta <= 0) return;
                const d = lambda / (2 * sin_theta); const q = 1 / (d * d);
                pickedPeaks.push({ tth, d, q }); pickedPeaks.sort((a, b) => a.tth - b.tth);
                updatePeakTable(); updateStartIndexingButtonState(); showStatus(`Peak added at ${tth.toFixed(3)}°`, 'success', 2000);
            });

            const generatePDFReport = async () => {
                if (displayedSolutions.length === 0) { showStatus("No solutions found to generate a report.", 'info'); return; }
                ui.reportButton.textContent = 'Generating...'; ui.reportButton.disabled = true; document.body.style.cursor = 'wait';
                try {
                    const { jsPDF } = window.jspdf; const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                    const margin = 15; let yPos = 20;
                    const now = new Date(); const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                    doc.setFontSize(18); doc.text('Powder Indexing Report', 105, yPos, { align: 'center' }); yPos += 10;
                    doc.setFontSize(10); doc.text(`Generated: ${timestamp}`, margin, yPos); yPos += 5; doc.text(`Data File: ${ui.fileName.textContent}`, margin, yPos); yPos += 10;
                    showStatus('Rendering chart for PDF...', 'info', 3000);
                    const canvas = await html2canvas(ui.chartCanvas, { backgroundColor: '#ffffff', scale: 2 });
                    
                    
const imgData = canvas.toDataURL('image/png');
const imgProps = doc.getImageProperties(imgData);
const pdfWidth = doc.internal.pageSize.getWidth();
const availableWidth = pdfWidth - 2 * margin;

// Calculate initial height while preserving the on-screen aspect ratio
let imgHeight = (imgProps.height * availableWidth) / imgProps.width;
let imgWidth = availableWidth;

// If the chart is excessively wide (e.g., wider than 4:3), constrain its width
const maxAspectRatio = 4 / 3;
if (imgWidth / imgHeight > maxAspectRatio) {
    imgWidth = imgHeight * maxAspectRatio;
}

// Center the chart horizontally on the page
const xOffset = margin + (availableWidth - imgWidth) / 2;

doc.addImage(imgData, 'PNG', xOffset, yPos, imgWidth, imgHeight);
yPos += imgHeight + 10;


                    doc.addPage(); yPos = 20; doc.setFontSize(14); doc.text('Indexing Solutions Summary', margin, yPos); yPos += 8; doc.setFont('courier', 'normal'); doc.setFontSize(9);
                    doc.text('Sys  M(20)   Volume(A^3)  a(A)      b(A)      c(A)      alpha  beta   gamma', margin, yPos); yPos += 5;
                    displayedSolutions.forEach(sol => {
                        if (yPos > 280) { doc.addPage(); yPos = 20; }
                        const line = `${sol.system.substring(0,4).padEnd(5)}${sol.m20.toFixed(2).padStart(6)}  ${sol.volume.toFixed(2).padStart(10)}  ${sol.a.toFixed(4).padStart(8)}  ${(sol.b ? sol.b.toFixed(4) : '-').padStart(8)}  ${(sol.c ? sol.c.toFixed(4) : '-').padStart(8)}  ${(sol.alpha ? sol.alpha.toFixed(2) : '90.00').padStart(6)} ${(sol.beta ? sol.beta.toFixed(2) : '90.00').padStart(6)} ${(sol.gamma ? sol.gamma.toFixed(2) : '90.00').padStart(6)}`;
                        doc.text(line, margin, yPos); yPos += 5;
                    });
                    const lambda = parseFloat(ui.wavelength.value);
                    displayedSolutions.forEach((sol, solIndex) => {
                        doc.addPage(); yPos = 20; doc.setFont('helvetica', 'bold'); doc.setFontSize(12);
                        doc.text(`Details for Solution #${solIndex+1}: ${sol.system}, M(20) = ${sol.m20.toFixed(2)}`, margin, yPos); yPos += 7;
                        doc.setFont('courier', 'normal'); doc.setFontSize(9);
                        let paramsLine = `a=${sol.a.toFixed(4)}`; if(sol.b) paramsLine += `, b=${sol.b.toFixed(4)}`; if(sol.c) paramsLine += `, c=${sol.c.toFixed(4)}`; paramsLine += ` (A)`; if(sol.alpha && sol.system !== 'cubic') paramsLine += `, alpha=${sol.alpha.toFixed(2)}`; if(sol.beta && sol.system !== 'cubic') paramsLine += `, beta=${sol.beta.toFixed(2)}`; if(sol.gamma && sol.system !== 'cubic') paramsLine += `, gamma=${sol.gamma.toFixed(2)}`; if(sol.zero_correction) paramsLine += `, Zero Error=${sol.zero_correction.toFixed(4)}°`;
                        doc.text(paramsLine, margin, yPos); yPos += 7;
                        doc.setFont('helvetica', 'bold'); doc.text(`Suggested Centering:`, margin, yPos); doc.setFont('courier', 'normal'); doc.text(sol.analysis.centering, margin + 45, yPos); yPos += 5;
                        if (sol.analysis.conditions.length > 0) { doc.setFont('helvetica', 'bold'); doc.text(`Reflection Conditions:`, margin, yPos); doc.setFont('courier', 'normal'); doc.text(sol.analysis.conditions.join(', '), margin + 45, yPos); yPos += 5; }
                        if (sol.analysis.possibleSpaceGroups.length > 0) {
                            doc.setFont('helvetica', 'bold'); doc.text(`Space Groups:`, margin, yPos); let currentX = margin + 45; const probableSet = new Set(sol.analysis.probableSpaceGroups); const allGroups = sol.analysis.possibleSpaceGroups; const pageRightMargin = doc.internal.pageSize.getWidth() - margin;
                            allGroups.forEach((sg, index) => { doc.setFont('courier', probableSet.has(sg) ? 'bold' : 'normal'); const text = sg + (index < allGroups.length - 1 ? ', ' : ''); if (currentX + doc.getTextWidth(text) > pageRightMargin && currentX > margin + 45) { yPos += 4; currentX = margin + 45; } doc.text(text, currentX, yPos); currentX += doc.getTextWidth(text); }); yPos += 4;
                        }
                        yPos += 3; doc.setFont('courier', 'normal'); doc.text(' h  k  l |   d_cal(A) 2t_calc   d_obs(A)  2t_obs    d(2t)', margin, yPos); yPos += 5;
                        const hklList = generateHKL(Math.max(...pickedPeaks.map(p=>p.tth)), {...sol, lambda}, sol.system);
                        const usedObsPeaks = new Set(); const tth_err = parseFloat(ui.tthError.value);
                        const corrected_tth_obs = pickedPeaks.map(p => ({ ...p, tth_corr: p.tth - (sol.zero_correction || 0) }));
                        hklList.slice(0, 30).forEach(hkl => {
                            if (yPos > 280) { doc.addPage(); yPos = 20; }
                            let bestMatch = null; let minDiff = Infinity;
                            corrected_tth_obs.forEach((peak, index) => { if (usedObsPeaks.has(index)) return; const diff = Math.abs(hkl.tth - peak.tth_corr); if (diff < minDiff) { minDiff = diff; bestMatch = { peak, index }; } });
                            let d_obs_str = '-', tth_obs_str = '-', tth_diff_str = '-';
                            let tth_calc = '-'; if (hkl.d > 0 && lambda/(2*hkl.d) < 1) tth_calc = (2 * Math.asin(lambda / (2 * hkl.d)) * 180 / Math.PI).toFixed(3);
                            if (bestMatch && minDiff < tth_err * 2) {
                                d_obs_str = pickedPeaks[bestMatch.index].d.toFixed(5); tth_obs_str = pickedPeaks[bestMatch.index].tth.toFixed(3);
                                if (tth_calc !== '-') { const tth_diff = parseFloat(tth_calc) - bestMatch.peak.tth_corr; tth_diff_str = tth_diff.toFixed(3); }
                                usedObsPeaks.add(bestMatch.index);
                            }
                            const line = `${String(hkl.h).padStart(2)} ${String(hkl.k).padStart(2)} ${String(hkl.l).padStart(2)} | ${hkl.d.toFixed(5).padStart(9)} ${String(tth_calc).padStart(7)}  ${d_obs_str.padStart(9)}  ${tth_obs_str.padStart(7)} ${tth_diff_str.padStart(7)}`;
                            doc.text(line, margin, yPos); yPos += 5;
                        });
                    });
                    const filename = `Indexing-Report-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}.pdf`;
                    doc.save(filename); showStatus('PDF report generated and saved.', 'success');
                } catch (error) { console.error("Failed to generate PDF:", error); showStatus("An error occurred during PDF generation.", 'error'); } 
                finally { ui.reportButton.textContent = 'Generate PDF Report'; ui.reportButton.disabled = (solutions.length === 0); document.body.style.cursor = 'default'; }
            };
            
            window.addEventListener('beforeunload', () => { if (workerURL) URL.revokeObjectURL(workerURL); });
        });
    </script>
    
<script id="indexing-worker" type="text/javascript">
self.onmessage = function(e) {
    const { peaks, wavelength, tth_error, max_volume, systemToSearch, impurity_peaks, refineZero } = e.data;
    
    let foundSolutions = [];
    const foundSolutionMap = new Map();

    const q_from_tth_local = (tth) => {
        const sin_theta = Math.sin(tth * Math.PI / 360);
        return (4 * sin_theta * sin_theta) / (wavelength * wavelength);
    };
    
    const tth_obs_deg = new Float64Array(peaks.map(p => p.tth));
    const peaks_sorted_by_q = peaks.map((p, i) => ({...p, original_index: i}))
                                 .sort((a,b) => a.q - b.q);
    const q_obs = new Float64Array(peaks_sorted_by_q.map(p => p.q));
    const original_indices = peaks_sorted_by_q.map(p => p.original_index);

    const tth_obs_rad = new Float64Array(peaks.map(p => p.tth * Math.PI / 360));
    const N_FOR_M20 = Math.min(20, peaks.length);

    const d_min = wavelength / (2 * Math.sin(peaks.map(p => p.tth).sort((a,b)=>b-a)[0] * Math.PI / 360));
    const q_max = 1 / (d_min * d_min);

    const min_lattice_param = 2.70;
    const max_lattice_param = 40.0;
    const min_m20 = 2.0;
    
    const tetra_hexa_i_depth = Math.min(10, peaks.length);
    const tetra_hexa_j_depth = Math.min(10, peaks.length);
    const max_hkl_low_angle_search = 5;

    const max_hkl_analysis = 10;
    const spaceGroupData = { /* space group data is unchanged */ 
        cubic: { 'P': { 'Pm-3m': { c: [] }, 'Pn-3n': { c: ['0kl:k+l=2n', 'hhl:l=2n'] }, 'Pm-3n': { c: ['hk0:h+k=2n'] }, 'Pa-3': { c: ['hk0:h=2n'] }, 'Pn-3m': { c: ['hhl:l=2n'] } }, 'I': { 'Im-3m': { c: [] }, 'Ia-3': { c: ['0kl:k=2n'] }, 'Ia-3d': { c: ['0kl:k=2n,l=2n', 'hhl:2h+l=4n'] } }, 'F': { 'Fm-3m': { c: [] }, 'Fd-3m': { c: ['0kl:k+l=4n'] }, 'Fm-3c': { c: ['hhl:l=2n'] } } },
        tetragonal: { 'P': { 'P4/mmm': { c: [] }, 'P4/mcc': { c: ['hhl:l=2n', '0kl:l=2n'] }, 'P4/nmm': { c: ['hk0:h+k=2n'] }, 'P4/ncc': { c: ['hk0:h+k=2n', '0kl:l=2n'] }, 'P4_2/mcm': { c: ['0kl:l=2n', 'hhl:l=2n'] }, 'P4_2/mnm': { c: ['0kl:k+l=2n', 'h00:h=2n'] }, 'P4_2/nmc': { c: ['hk0:h+k=2n', 'h0l:l=2n'] }, 'P4_2/nbc': { c: ['hk0:h+k=2n', '0kl:k=2n'] } }, 'I': { 'I4/mmm': { c: [] }, 'I4/mcm': { c: ['0kl:l=2n', 'hhl:l=2n'] }, 'I4_1/a': { c: ['hkl:2h+l=4n'] }, 'I4_1/amd': { c: ['hkl:2h+l=4n', 'hk0:h=2n,k=2n'] }, 'I4_1/acd': { c: ['hkl:2h+l=4n', 'hk0:h=2n,k=2n', '0kl:k=2n,l=2n'] } } },
        hexagonal: { 'P': { 'P6/mmm': { c: [] }, 'P6/mcc': { c: ['h-hl:l=2n', '00l:l=2n'] }, 'P6_3/mmc': { c: ['00l:l=2n'] }, 'P6_3/mcm': { c: ['h-hl:l=2n', '00l:l=2n'] }, 'P-3': { c: [] }, 'P-3m1': { c: [] }, 'P-31m': { c: [] }, }, 'R': { 'R-3': { c: [] }, 'R-3m': { c: [] }, 'R-3c': { c: ['h-hl:l=2n'] } } },
        orthorhombic: { 'P': { 'Pmmm': { c: [] }, 'Pnnn': { c: ['0kl:k+l=2n', 'h0l:h+l=2n', 'hk0:h+k=2n'] }, 'Pccm': { c: ['h0l:l=2n', '0kl:l=2n'] }, 'Pban': { c: ['0kl:k=2n', 'h0l:h=2n'] }, 'Pccn': { c: ['h0l:l=2n', '0kl:k=2n'] }, 'Pbcm': { c: ['0kl:k=2n', 'h0l:l=2n'] }, 'Pnnm': { c: ['hk0:h+k=2n'] }, 'Pnma': { c: ['0kl:k+l=2n', 'hk0:h=2n'] }, 'Pbca': { c: ['0kl:k=2n', 'h0l:l=2n', 'hk0:h=2n'] }, 'P2_12_12_1': { c: ['h00:h=2n', '0k0:k=2n', '00l:l=2n'] } }, 'C': { 'Cmmm': { c: [] }, 'Cmcm': { c: ['h0l:l=2n'] }, 'Cmce': { c: ['0kl:l=2n', 'h0l:h+l=2n'] }, 'Cccm': { c: ['h0l:l=2n'] }, 'Ccce': { c: ['h0l:l=2n', 'hhl:l=2n'] }, }, 'I': { 'Immm': { c: [] }, 'Ibam': { c: ['0kl:k=2n'] }, 'Ibca': { c: ['0kl:k=2n', 'h0l:l=2n'] }, 'Imma': { c: ['0kl:k+l=2n'] } }, 'F': { 'Fmmm': { c: [] }, 'Fddd': { c: ['0kl:k+l=4n', 'h0l:h+l=4n', 'hk0:h+k=4n'] } } },
        monoclinic: { 'P': { 'P2/m': { c: [] }, 'P2_1/m': { c: ['0k0:k=2n'] }, 'P2/c': { c: ['h0l:l=2n'] }, 'P2_1/c': { c: ['h0l:l=2n', '0k0:k=2n'] } }, 'C': { 'C2/m': { c: [] }, 'C2/c': { c: ['h0l:l=2n'] } } }
    };

    const get_q_tolerance = (original_peak_index) => {
        const theta = tth_obs_rad[original_peak_index];
        const d_theta = tth_error * Math.PI / 360;
        return ((8 * Math.sin(theta) * Math.cos(theta)) / (wavelength * wavelength)) * d_theta;
    };

    const binarySearchClosest = (arr, target) => {
        let low = 0, high = arr.length - 1;
        if (target <= arr[low]) return low;
        if (target >= arr[high]) return high;
        while (low <= high) {
            let mid = Math.floor((low + high) / 2);
            if (arr[mid] === target) return mid;
            if (arr[mid] < target) low = mid + 1;
            else high = mid - 1;
        }
        return (arr[low] - target) < (target - arr[high]) ? low : high;
    };

    const calculateM20 = (q_calc_sorted) => {
        if (q_calc_sorted.length === 0) return 0;
        let N_indexed = 0; let sum_delta_q = 0;
        for (let i = 0; i < N_FOR_M20; i++) {
            const q_o = q_obs[i];
            const tolerance = get_q_tolerance(original_indices[i]);
            const closest_idx = binarySearchClosest(q_calc_sorted, q_o);
            const diff = Math.abs(q_o - q_calc_sorted[closest_idx]);
            if (diff < tolerance) { N_indexed++; sum_delta_q += diff; }
        }
        const unindexed_peaks = N_FOR_M20 - N_indexed;
        if (unindexed_peaks > impurity_peaks) return 0;
        if (N_indexed === 0) return 0;
        const q_n = q_obs[N_FOR_M20 - 1];
        let N_calc = 0;
        for (let i = 0; i < q_calc_sorted.length; i++) {
            if (q_calc_sorted[i] > q_n * 1.05) break;
            N_calc++;
        }
        if (N_calc === 0) return 0;
        const avg_delta_q = sum_delta_q / N_indexed;
        if (avg_delta_q === 0) return 0;
        return q_n / (2 * avg_delta_q * N_calc);
    };
    
    const analyzeSystematicAbsences = (solution, obs_peaks) => { 
        const { system } = solution;
        const all_hkls = generateHKL_for_analysis(solution, wavelength, Math.max(...obs_peaks.map(p=>p.tth)));
        const obs_hkl_list = []; const used_peaks = new Set();
        const corrected_obs_peaks = obs_peaks.map(p => ({...p, tth: p.tth - (solution.zero_correction || 0)}));
        corrected_obs_peaks.forEach(peak => {
            peak.d = wavelength / (2 * Math.sin(peak.tth * Math.PI / 360));
        });

        all_hkls.forEach(hkl => {
            let bestMatch = null; let minDiff = Infinity;
            corrected_obs_peaks.forEach((peak, index) => {
                if (used_peaks.has(index)) return;
                const diff = Math.abs(hkl.d - peak.d);
                if (diff < minDiff) { minDiff = diff; bestMatch = { peak, index }; }
            });
            if (bestMatch) {
                const tolerance = get_q_tolerance(bestMatch.index);
                const d_tolerance = Math.abs(1/Math.sqrt(q_from_tth_local(bestMatch.peak.tth) + tolerance) - 1/Math.sqrt(q_from_tth_local(bestMatch.peak.tth) - tolerance)) / 2;
                if (minDiff < d_tolerance) { obs_hkl_list.push(hkl); used_peaks.add(bestMatch.index); }
            }
        });
        let centering = 'Primitive (P)';
        if (obs_hkl_list.length >= 3) {
             if (system === 'cubic' || system === 'tetragonal' || system === 'orthorhombic') {
                const violates_I = obs_hkl_list.some(({h,k,l}) => (h+k+l) % 2 !== 0);
                const violates_F = obs_hkl_list.some(({h,k,l}) => !((h%2===k%2)&&(k%2===l%2)));
                if (!violates_F) centering = 'Face (F)'; else if (!violates_I) centering = 'Body (I)';
             }
            if ((system === 'orthorhombic' || system === 'monoclinic') && centering === 'Primitive (P)' && !obs_hkl_list.some(({h,k,l}) => (h+k) % 2 !== 0)) centering = 'C-Face (C)';
            if (system === 'hexagonal' && (!obs_hkl_list.some(({h,k,l}) => (-h+k+l)%3!==0) || !obs_hkl_list.some(({h,k,l}) => (h-k+l)%3!==0))) centering = 'Rhombohedral (R)';
        }
        const centerChar = centering.charAt(centering.indexOf('(')+1);
        const foundConditions = new Set();
        const check = (filter, rule) => { const subset = obs_hkl_list.filter(filter); return subset.length === 0 || !subset.some(rule); };
        if (check(p => p.h !== 0 && p.k===0 && p.l===0, p => p.h%2 !== 0)) foundConditions.add('h00:h=2n'); if (check(p => p.k !== 0 && p.h===0 && p.l===0, p => p.k%2 !== 0)) foundConditions.add('0k0:k=2n'); if (check(p => p.l !== 0 && p.h===0 && p.k===0, p => p.l%2 !== 0)) foundConditions.add('00l:l=2n'); if (check(p => p.h!==0 && p.k!==0 && p.l===0, p => (p.h+p.k)%2 !== 0)) foundConditions.add('hk0:h+k=2n'); if (check(p => p.k!==0 && p.l!==0 && p.h===0, p => (p.k+p.l)%2 !== 0)) foundConditions.add('0kl:k+l=2n'); if (check(p => p.h!==0 && p.l!==0 && p.k===0, p => (p.h+p.l)%2 !== 0)) foundConditions.add('h0l:h+l=2n');
        if (system === 'monoclinic' && check(p => p.h!==0 && p.l!==0 && p.k===0, p => p.l%2 !== 0)) foundConditions.add('h0l:l=2n'); if (check(p => p.h===p.k && p.l!==0, p => p.l%2 !== 0)) foundConditions.add('hhl:l=2n'); if (check(p => p.h===-p.k && p.l!==0, p => p.l%2 !== 0)) foundConditions.add('h-hl:l=2n');
        const sg_block = spaceGroupData[system]?.[centerChar] || {};
        const possibleSpaceGroups = Object.keys(sg_block);
        const probableSpaceGroups = possibleSpaceGroups.filter(sg => (sg_block[sg].c || []).every(cond => foundConditions.has(cond)));
        return { centering, conditions: Array.from(foundConditions), possibleSpaceGroups, probableSpaceGroups };
    };

    const generateHKL_for_analysis = (params, lambda, maxTth) => { 
        const { a, b, c, beta, system } = params; const reflections = [];
        for (let h = -max_hkl_analysis; h <= max_hkl_analysis; h++) { 
            for (let k = -max_hkl_analysis; k <= max_hkl_analysis; k++) { 
                for (let l = -max_hkl_analysis; l <= max_hkl_analysis; l++) {
                    if (h === 0 && k === 0 && l === 0) continue; 
                    let inv_d_sq = 0;
                    switch (system) {
                        case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                        case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                        case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                        case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                        case 'monoclinic': 
                            const sinBeta = Math.sin(beta*Math.PI/180); 
                            const cosBeta = Math.cos(beta*Math.PI/180); 
                            inv_d_sq = (1/(sinBeta*sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + k*k/(b*b); 
                            break;
                    }
                    if (inv_d_sq > 0) { 
                        const d = 1/Math.sqrt(inv_d_sq); 
                        const sinThetaSq = (lambda*lambda/4)*inv_d_sq; 
                        if (sinThetaSq <= 1) { 
                            const tth = 2*Math.asin(Math.sqrt(sinThetaSq))*(180/Math.PI); 
                            if(tth <= maxTth*1.05) reflections.push({ tth, h, k, l, d }); 
                        } 
                    }
                }
            }
        } 
        return reflections.sort((a, b) => a.tth - b.tth);
    };

    const solveLeastSquares = (M, q_vec) => {
        const num_eq = M.length; if (num_eq === 0) return null;
        const num_params = M[0].length; if (num_eq < num_params) return null;
        const MT = Array(num_params).fill(0).map(() => Array(num_eq).fill(0));
        for (let i = 0; i < num_params; i++) for (let j = 0; j < num_eq; j++) MT[i][j] = M[j][i];
        const MTM = Array(num_params).fill(0).map(() => Array(num_params).fill(0));
        for (let i = 0; i < num_params; i++) for (let j = 0; j < num_params; j++) { let sum = 0; for (let k = 0; k < num_eq; k++) sum += MT[i][k] * M[k][j]; MTM[i][j] = sum; }
        
        let det;
        if (num_params === 1) { det = MTM[0][0]; }
        else if (num_params === 2) { det = MTM[0][0] * MTM[1][1] - MTM[0][1] * MTM[1][0]; }
        else if (num_params === 3) { det = MTM[0][0]*(MTM[1][1]*MTM[2][2] - MTM[2][1]*MTM[1][2]) - MTM[0][1]*(MTM[1][0]*MTM[2][2] - MTM[1][2]*MTM[2][0]) + MTM[0][2]*(MTM[1][0]*MTM[2][1] - MTM[1][1]*MTM[2][0]); } 
        else if (num_params === 4) { const m = MTM; det = m[0][0]*(m[1][1]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])+m[1][3]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])) - m[0][1]*(m[1][0]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])) + m[0][2]*(m[1][0]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])-m[1][1]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][1]-m[2][1]*m[3][0])) - m[0][3]*(m[1][0]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])-m[1][1]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])+m[1][2]*(m[2][0]*m[3][1]-m[2][1]*m[3][0])); } 
        else { return null; }
        if (Math.abs(det) < 1e-9) return null;

        const invDet = 1.0 / det;
        const MTM_inv = Array(num_params).fill(0).map(() => Array(num_params).fill(0));
        if (num_params === 1) { MTM_inv[0][0] = 1.0 / det; }
        else if (num_params === 2) { MTM_inv[0][0] = MTM[1][1] * invDet; MTM_inv[0][1] = -MTM[0][1] * invDet; MTM_inv[1][0] = -MTM[1][0] * invDet; MTM_inv[1][1] = MTM[0][0] * invDet; }
        else if (num_params === 3) { MTM_inv[0][0] = (MTM[1][1]*MTM[2][2] - MTM[2][1]*MTM[1][2])*invDet; MTM_inv[0][1] = (MTM[0][2]*MTM[2][1] - MTM[0][1]*MTM[2][2])*invDet; MTM_inv[0][2] = (MTM[0][1]*MTM[1][2] - MTM[0][2]*MTM[1][1])*invDet; MTM_inv[1][0] = (MTM[1][2]*MTM[2][0] - MTM[1][0]*MTM[2][2])*invDet; MTM_inv[1][1] = (MTM[0][0]*MTM[2][2] - MTM[0][2]*MTM[2][0])*invDet; MTM_inv[1][2] = (MTM[0][2]*MTM[1][0] - MTM[0][0]*MTM[1][2])*invDet; MTM_inv[2][0] = (MTM[1][0]*MTM[2][1] - MTM[2][0]*MTM[1][1])*invDet; MTM_inv[2][1] = (MTM[0][1]*MTM[2][0] - MTM[0][0]*MTM[2][1])*invDet; MTM_inv[2][2] = (MTM[0][0]*MTM[1][1] - MTM[0][1]*MTM[1][0])*invDet; } 
        else if (num_params === 4) { const m = MTM; MTM_inv[0][0] = (m[1][1]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])+m[1][3]*(m[2][1]*m[3][2]-m[2][2]*m[3][1]))*invDet; MTM_inv[0][1] = -(m[0][1]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[0][2]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])+m[0][3]*(m[2][1]*m[3][2]-m[2][2]*m[3][1]))*invDet; MTM_inv[0][2] = (m[0][1]*(m[1][2]*m[3][3]-m[1][3]*m[3][2])-m[0][2]*(m[1][1]*m[3][3]-m[1][3]*m[3][1])+m[0][3]*(m[1][1]*m[3][2]-m[1][2]*m[3][1]))*invDet; MTM_inv[0][3] = -(m[0][1]*(m[1][2]*m[2][3]-m[1][3]*m[2][2])-m[0][2]*(m[1][1]*m[2][3]-m[1][3]*m[2][1])+m[0][3]*(m[1][1]*m[2][2]-m[1][2]*m[2][1]))*invDet; MTM_inv[1][0] = -(m[1][0]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][2]-m[2][2]*m[3][0]))*invDet; MTM_inv[1][1] = (m[0][0]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[0][2]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[0][3]*(m[2][0]*m[3][2]-m[2][2]*m[3][0]))*invDet; MTM_inv[1][2] = -(m[0][0]*(m[1][2]*m[3][3]-m[1][3]*m[3][2])-m[0][2]*(m[1][0]*m[3][3]-m[1][3]*m[3][0])+m[0][3]*(m[1][0]*m[3][2]-m[1][2]*m[3][0]))*invDet; MTM_inv[1][3] = (m[0][0]*(m[1][2]*m[2][3]-m[1][3]*m[2][2])-m[0][2]*(m[1][0]*m[2][3]-m[1][3]*m[2][0])+m[0][3]*(m[1][0]*m[2][2]-m[1][2]*m[2][0]))*invDet; MTM_inv[2][0] = (m[1][0]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])-m[1][1]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet; MTM_inv[2][1] = -(m[0][0]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])-m[0][1]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[0][3]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet; MTM_inv[2][2] = (m[0][0]*(m[1][1]*m[3][3]-m[1][3]*m[3][1])-m[0][1]*(m[1][0]*m[3][3]-m[1][3]*m[3][0])+m[0][3]*(m[1][0]*m[3][1]-m[1][1]*m[3][0]))*invDet; MTM_inv[2][3] = -(m[0][0]*(m[1][1]*m[2][3]-m[1][3]*m[2][1])-m[0][1]*(m[1][0]*m[2][3]-m[1][3]*m[2][0])+m[0][3]*(m[1][0]*m[2][1]-m[1][1]*m[2][0]))*invDet; MTM_inv[3][0] = -(m[1][0]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])-m[1][1]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])+m[1][2]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet; MTM_inv[3][1] = (m[0][0]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])-m[0][1]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])+m[0][2]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet; MTM_inv[3][2] = -(m[0][0]*(m[1][1]*m[3][2]-m[1][2]*m[3][1])-m[0][1]*(m[1][0]*m[3][2]-m[1][2]*m[3][0])+m[0][2]*(m[1][0]*m[3][1]-m[1][1]*m[3][0]))*invDet; MTM_inv[3][3] = (m[0][0]*(m[1][1]*m[2][2]-m[1][2]*m[2][1])-m[0][1]*(m[1][0]*m[2][2]-m[1][2]*m[2][0])+m[0][2]*(m[1][0]*m[2][1]-m[1][1]*m[2][0]))*invDet; }
        
        const MTq = Array(num_params).fill(0);
        for (let i = 0; i < num_params; i++) { let sum = 0; for (let j = 0; j < num_eq; j++) sum += MT[i][j] * q_vec[j]; MTq[i] = sum; }
        const x = Array(num_params).fill(0);
        for (let i = 0; i < num_params; i++) { let sum = 0; for (let j = 0; j < num_params; j++) sum += MTM_inv[i][j] * MTq[j]; x[i] = sum; }
        return x;
    };

    const hkl_search_list_cache = {};
    const get_hkl_search_list = (system) => {
        if (hkl_search_list_cache[system]) return hkl_search_list_cache[system];
        const hkl_triplets = []; const max_h = (system === 'monoclinic' ? 5 : 7);
        for (let h = 0; h <= max_h; h++) for (let k = 0; k <= max_h; k++) for (let l = 0; l <= max_h; l++) {
            if (h === 0 && k === 0 && l === 0) continue;
            hkl_triplets.push([h, k, l]);
        }
        hkl_triplets.sort((a, b) => (a[0]**2 + a[1]**2 + a[2]**2) - (b[0]**2 + b[1]**2 + b[2]**2));
        hkl_search_list_cache[system] = hkl_triplets;
        return hkl_triplets;
    };

    // This is the single-shot refinement function used for the initial broad search.
    const refineAndTestSolution = (initialParams) => {
        let { a, b, c, beta, system } = initialParams;
        if (a < min_lattice_param || a > max_lattice_param || (b && (b < min_lattice_param || b > max_lattice_param)) || (c && (c < min_lattice_param || c > max_lattice_param))) return;
        if (system === 'monoclinic' && beta < 90.0) beta = 180.0 - beta;

        const hkl_search_list = get_hkl_search_list(system);
        const indexed_pairs = [];
        for (let i = 0; i < N_FOR_M20; i++) {
            const q_o = q_obs[i];
            const tolerance = get_q_tolerance(original_indices[i]);
            let best_match = null, min_diff = Infinity;
            for (const hkl of hkl_search_list) {
                let q_calc = 0;
                const [h,k,l] = hkl;
                switch (system) {
                    case 'cubic': q_calc = (h*h + k*k + l*l) / (a*a); break;
                    case 'tetragonal': q_calc = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                    case 'hexagonal': q_calc = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                    case 'orthorhombic': q_calc = h*h/(a*a) + k*k/(b*b) + l*l/(c*c); break;
                    case 'monoclinic': 
                        const sinBeta = Math.sin(beta * Math.PI / 180);
                        const cosBeta = Math.cos(beta * Math.PI / 180);
                        q_calc = (1/(sinBeta*sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + k*k/(b*b);
                        break;
                }
                const diff = Math.abs(q_calc - q_o);
                if (diff < min_diff) { min_diff = diff; best_match = hkl; }
                if (q_calc > q_o + tolerance * 2) break; // Optimization
            }
            if (min_diff < tolerance) indexed_pairs.push({ q_obs: q_o, hkl: best_match });
        }
        
        const min_indexed_peaks = { cubic: 4, tetragonal: 5, hexagonal: 5, orthorhombic: 6, monoclinic: 7 };
        if (indexed_pairs.length < min_indexed_peaks[system]) return;
        
        let M = [], q_vec = [], refined_params = null, num_params = 0;
        q_vec = indexed_pairs.map(p => p.q_obs);
        switch (system) {
            case 'cubic':
                num_params = 1; let sum_q_s = 0;
                indexed_pairs.forEach(p => { sum_q_s += p.q_obs / (p.hkl[0]**2 + p.hkl[1]**2 + p.hkl[2]**2); });
                refined_params = [ sum_q_s / indexed_pairs.length ];
                break;
            case 'tetragonal': num_params = 2; M = indexed_pairs.map(p => [p.hkl[0]**2 + p.hkl[1]**2, p.hkl[2]**2]); break;
            case 'hexagonal': num_params = 2; M = indexed_pairs.map(p => [(4/3)*(p.hkl[0]**2 + p.hkl[0]*p.hkl[1] + p.hkl[1]**2), p.hkl[2]**2]); break;
            case 'orthorhombic': num_params = 3; M = indexed_pairs.map(p => [p.hkl[0]**2, p.hkl[1]**2, p.hkl[2]**2]); break;
            case 'monoclinic': num_params = 4; M = indexed_pairs.map(p => [p.hkl[0]**2, p.hkl[1]**2, p.hkl[2]**2, p.hkl[0]*p.hkl[2]]); break;
        }
        if (num_params > 1) refined_params = solveLeastSquares(M, q_vec);
        if (!refined_params || refined_params.some(p => p <= 0)) return;

        let final_cell = { system, alpha: 90, gamma: 90 };
        switch(system) {
            case 'cubic': final_cell.a = 1/Math.sqrt(refined_params[0]); final_cell.beta = 90; break;
            case 'tetragonal': final_cell.a = 1/Math.sqrt(refined_params[0]); final_cell.c = 1/Math.sqrt(refined_params[1]); final_cell.beta = 90; break;
            case 'hexagonal': final_cell.a = 1/Math.sqrt(refined_params[0]); final_cell.c = 1/Math.sqrt(refined_params[1]); final_cell.beta = 90; final_cell.gamma = 120; break;
            case 'orthorhombic': final_cell.a = 1/Math.sqrt(refined_params[0]); final_cell.b = 1/Math.sqrt(refined_params[1]); final_cell.c = 1/Math.sqrt(refined_params[2]); final_cell.beta = 90; break;
            case 'monoclinic':
                const [A, B, C, D] = refined_params;
                if (D**2 >= 4 * A * C) return;
                const cosBeta = -D / (2 * Math.sqrt(A * C));
                const betaRad = Math.acos(cosBeta);
                final_cell.beta = betaRad * 180 / Math.PI;
                if (final_cell.beta < 80 || final_cell.beta > 140) return;
                const sinBetaSq = 1 - cosBeta**2;
                final_cell.a = 1/Math.sqrt(A * sinBetaSq); final_cell.b = 1/Math.sqrt(B); final_cell.c = 1/Math.sqrt(C * sinBetaSq);
                break;
        }
        
        let volume = 0;
        switch(system){
            case 'cubic': volume = final_cell.a**3; break;
            case 'tetragonal': volume = final_cell.a**2 * final_cell.c; break;
            case 'hexagonal': volume = final_cell.a**2 * final_cell.c * Math.sqrt(3)/2; break;
            case 'orthorhombic': volume = final_cell.a * final_cell.b * final_cell.c; break;
            case 'monoclinic': volume = final_cell.a * final_cell.b * final_cell.c * Math.sin(final_cell.beta * Math.PI / 180); break;
        }
        if (volume > max_volume || volume < 20) return;
        final_cell.volume = volume;

        const q_calc = new Set();
        const h_max = Math.ceil(final_cell.a / d_min);
        const k_max = final_cell.b ? Math.ceil(final_cell.b / d_min) : h_max;
        const l_max = final_cell.c ? Math.ceil(final_cell.c / d_min) : h_max;
        const q_limit = q_max * 1.05;

        for (let h = 0; h <= h_max; h++) { for (let k = 0; k <= k_max; k++) { if ((system === 'cubic' || system === 'tetragonal' || system === 'hexagonal') && k > h) continue; for (let l = 0; l <= l_max; l++) { if (system === 'cubic' && l > k) continue; if (h === 0 && k === 0 && l === 0) continue; let q = 0;
            switch (system) {
                case 'cubic': { q = (h*h + k*k + l*l) / (final_cell.a**2); break; }
                case 'tetragonal': { q = (h*h + k*k)/(final_cell.a**2) + (l*l)/(final_cell.c**2); break; }
                case 'hexagonal': { q = (4/3)*(h*h + h*k + k*k)/(final_cell.a**2) + (l*l)/(final_cell.c**2); break; }
                case 'orthorhombic': { q = h*h/(final_cell.a**2) + k*k/(final_cell.b**2) + l*l/(final_cell.c**2); break; }
                case 'monoclinic': { const sinBeta = Math.sin(final_cell.beta * Math.PI/180); const cosBeta = Math.cos(final_cell.beta * Math.PI/180); q = (1/(sinBeta**2)) * (h*h/(final_cell.a**2) + l*l/(final_cell.c**2) - 2*h*l*cosBeta/(final_cell.a*final_cell.c)) + k*k/(final_cell.b**2); break; }
            }
            if (q > q_limit) { if (l>0) break; if (k>0) {l=l_max+1; continue;} if (h>0) {k=k_max+1;l=l_max+1; continue;} }
            if (q > 0) q_calc.add(q);
        }}}
        
        const q_calc_sorted = new Float64Array(Array.from(q_calc)).sort((x, y) => x - y);
        const m20 = calculateM20(q_calc_sorted);

        if (m20 > min_m20) {
            final_cell.m20 = m20;
            final_cell.analysis = {};
            
            let key; const P = 2;
            switch(system) {
                case 'cubic': key = `${system}_${final_cell.a.toFixed(P)}`; break;
                case 'tetragonal': case 'hexagonal': key = `${system}_${final_cell.a.toFixed(P)}_${final_cell.c.toFixed(P)}`; break;
                case 'orthorhombic': key = `${system}_${[final_cell.a,final_cell.b,final_cell.c].sort().map(p => p.toFixed(P)).join('_')}`; break;
                case 'monoclinic': key = `${system}_${volume.toFixed(2)}_${final_cell.beta.toFixed(2)}`; break;
            }

            const existingSolutionData = foundSolutionMap.get(key);
            if (!existingSolutionData || final_cell.m20 > existingSolutionData.m20) {
                 if (!existingSolutionData) {
                    foundSolutions.push(final_cell);
                    foundSolutionMap.set(key, { m20: final_cell.m20, index: foundSolutions.length - 1 });
                } else {
                    foundSolutions[existingSolutionData.index] = final_cell;
                    existingSolutionData.m20 = final_cell.m20;
                }
            }
        }
    };
    
    // NEW function to iteratively refine a single candidate solution
    const refineSolutionWithZeroError = (initialSolution) => {
        let last_params = { ...initialSolution };
        let total_zero_correction = 0.0;
        const max_iterations = 5;
        const convergence_threshold = 0.0001;

        for (let iter = 0; iter < max_iterations; iter++) {
            let { a, b, c, beta, system } = last_params;
            const current_tth_obs_deg = tth_obs_deg.map(tth => tth - total_zero_correction);
            const current_q_obs = current_tth_obs_deg.map(tth => q_from_tth_local(tth));

            const hkl_search_list = get_hkl_search_list(system);
            const indexed_pairs = [];
            for (let i = 0; i < N_FOR_M20; i++) {
                const q_o = current_q_obs[original_indices[i]];
                const tolerance = get_q_tolerance(original_indices[i]);
                let best_match = null, min_diff = Infinity;
                for (const hkl of hkl_search_list) {
                    let q_calc = 0; const [h,k,l] = hkl;
                    switch (system) {
                         case 'cubic': q_calc = (h*h + k*k + l*l) / (a*a); break;
                         case 'tetragonal': q_calc = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                         case 'hexagonal': q_calc = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                         case 'orthorhombic': q_calc = h*h/(a*a) + k*k/(b*b) + l*l/(c*c); break;
                         case 'monoclinic': 
                            const sinBeta = Math.sin(beta * Math.PI / 180); const cosBeta = Math.cos(beta * Math.PI / 180);
                            q_calc = (1/(sinBeta*sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + k*k/(b*b); break;
                    }
                    const diff = Math.abs(q_calc - q_o);
                    if (diff < min_diff) { min_diff = diff; best_match = hkl; }
                    if (q_calc > q_o + tolerance * 2) break;
                }
                if (min_diff < tolerance) indexed_pairs.push({ q_obs: q_o, hkl: best_match });
            }
            
            const min_indexed_peaks = { cubic: 4, tetragonal: 5, hexagonal: 5, orthorhombic: 6, monoclinic: 7 };
            if (indexed_pairs.length < min_indexed_peaks[system]) return null;
            
            let M = [], q_vec = [], refined_params = null, num_params = 0;
            q_vec = indexed_pairs.map(p => p.q_obs);
            switch (system) {
                 case 'cubic': num_params = 1; let sum_q_s = 0; indexed_pairs.forEach(p => { sum_q_s += p.q_obs / (p.hkl[0]**2 + p.hkl[1]**2 + p.hkl[2]**2); }); refined_params = [ sum_q_s / indexed_pairs.length ]; break;
                 case 'tetragonal': num_params = 2; M = indexed_pairs.map(p => [p.hkl[0]**2 + p.hkl[1]**2, p.hkl[2]**2]); break;
                 case 'hexagonal': num_params = 2; M = indexed_pairs.map(p => [(4/3)*(p.hkl[0]**2 + p.hkl[0]*p.hkl[1] + p.hkl[1]**2), p.hkl[2]**2]); break;
                 case 'orthorhombic': num_params = 3; M = indexed_pairs.map(p => [p.hkl[0]**2, p.hkl[1]**2, p.hkl[2]**2]); break;
                 case 'monoclinic': num_params = 4; M = indexed_pairs.map(p => [p.hkl[0]**2, p.hkl[1]**2, p.hkl[2]**2, p.hkl[0]*p.hkl[2]]); break;
            }
            if (num_params > 1) refined_params = solveLeastSquares(M, q_vec);
            if (!refined_params || refined_params.some(p => p <= 0)) return null;

            let refined_cell = { system, alpha: 90, gamma: 90 };
            switch(system) {
                case 'cubic': refined_cell.a = 1/Math.sqrt(refined_params[0]); refined_cell.beta = 90; break;
                case 'tetragonal': refined_cell.a = 1/Math.sqrt(refined_params[0]); refined_cell.c = 1/Math.sqrt(refined_params[1]); refined_cell.beta = 90; break;
                case 'hexagonal': refined_cell.a = 1/Math.sqrt(refined_params[0]); refined_cell.c = 1/Math.sqrt(refined_params[1]); refined_cell.beta = 90; refined_cell.gamma = 120; break;
                case 'orthorhombic': refined_cell.a = 1/Math.sqrt(refined_params[0]); refined_cell.b = 1/Math.sqrt(refined_params[1]); refined_cell.c = 1/Math.sqrt(refined_params[2]); refined_cell.beta = 90; break;
                case 'monoclinic': const [A, B, C, D] = refined_params; if (D**2 >= 4 * A * C) return null; const cosBeta = -D / (2 * Math.sqrt(A * C)); const betaRad = Math.acos(cosBeta); refined_cell.beta = betaRad * 180 / Math.PI; if (refined_cell.beta < 80 || refined_cell.beta > 140) return null; const sinBetaSq = 1 - cosBeta**2; refined_cell.a = 1/Math.sqrt(A * sinBetaSq); refined_cell.b = 1/Math.sqrt(B); refined_cell.c = 1/Math.sqrt(C * sinBetaSq); break;
            }
            last_params = { ...refined_cell };

            let sum_delta_2theta = 0; let matched_count = 0;
            const temp_q_calc_list = generateHKL_for_analysis(refined_cell, wavelength, tth_obs_deg[tth_obs_deg.length - 1]);
            if(temp_q_calc_list.length === 0) break;
            const temp_q_calc_sorted = temp_q_calc_list.map(h => h.d > 0 ? 1/(h.d*h.d) : 0).sort((x,y)=>x-y);
            for (let i = 0; i < N_FOR_M20; i++) {
                const q_o_original = q_obs[i];
                const tth_o_original = tth_obs_deg[original_indices[i]];
                const tolerance = get_q_tolerance(original_indices[i]);
                const closest_idx = binarySearchClosest(temp_q_calc_sorted, q_o_original);
                const diff = Math.abs(q_o_original - temp_q_calc_sorted[closest_idx]);
                if (diff < tolerance) {
                    const q_c = temp_q_calc_sorted[closest_idx];
                    const tth_c = (2 * Math.asin(Math.sqrt(q_c) * wavelength / 2)) * 180 / Math.PI;
                    sum_delta_2theta += (tth_o_original - tth_c);
                    matched_count++;
                }
            }
            
            if (matched_count < 4) break; 
            const iter_correction = sum_delta_2theta / matched_count;
            total_zero_correction += iter_correction;

            if (Math.abs(iter_correction) < convergence_threshold) break;
        }

        let final_cell = last_params;
        let volume = 0;
        switch(final_cell.system){
            case 'cubic': volume = final_cell.a**3; break;
            case 'tetragonal': volume = final_cell.a**2 * final_cell.c; break;
            case 'hexagonal': volume = final_cell.a**2 * final_cell.c * Math.sqrt(3)/2; break;
            case 'orthorhombic': volume = final_cell.a * final_cell.b * final_cell.c; break;
            case 'monoclinic': volume = final_cell.a * final_cell.b * final_cell.c * Math.sin(final_cell.beta * Math.PI / 180); break;
        }
        if (volume > max_volume || volume < 20) return null;
        final_cell.volume = volume;

        const q_calc = new Set();
        const h_max = Math.ceil(final_cell.a / d_min); const k_max = final_cell.b ? Math.ceil(final_cell.b / d_min) : h_max; const l_max = final_cell.c ? Math.ceil(final_cell.c / d_min) : h_max;
        const q_limit = q_max * 1.05;
        for (let h = 0; h <= h_max; h++) { for (let k = 0; k <= k_max; k++) { if ((final_cell.system === 'cubic' || final_cell.system === 'tetragonal' || final_cell.system === 'hexagonal') && k > h) continue; for (let l = 0; l <= l_max; l++) { if (final_cell.system === 'cubic' && l > k) continue; if (h === 0 && k === 0 && l === 0) continue; let q = 0;
            switch (final_cell.system) {
                case 'cubic': q = (h*h + k*k + l*l) / (final_cell.a**2); break;
                case 'tetragonal': q = (h*h + k*k)/(final_cell.a**2) + (l*l)/(final_cell.c**2); break;
                case 'hexagonal': q = (4/3)*(h*h + h*k + k*k)/(final_cell.a**2) + (l*l)/(final_cell.c**2); break;
                case 'orthorhombic': q = h*h/(final_cell.a**2) + k*k/(final_cell.b**2) + l*l/(final_cell.c**2); break;
                case 'monoclinic': const sinBeta = Math.sin(final_cell.beta * Math.PI/180); const cosBeta = Math.cos(final_cell.beta * Math.PI/180); q = (1/(sinBeta**2)) * (h*h/(final_cell.a**2) + l*l/(final_cell.c**2) - 2*h*l*cosBeta/(final_cell.a*final_cell.c)) + k*k/(final_cell.b**2); break;
            }
            if (q > q_limit) { if (l>0) break; if (k>0) {l=l_max+1; continue;} if (h>0) {k=k_max+1;l=l_max+1; continue;} }
            if (q > 0) q_calc.add(q);
        }}}
        
        const q_calc_sorted = new Float64Array(Array.from(q_calc)).sort((x, y) => x - y);
        const m20 = calculateM20(q_calc_sorted);

        if (m20 > min_m20) {
            final_cell.m20 = m20;
            final_cell.zero_correction = total_zero_correction;
            final_cell.analysis = {};
            return final_cell;
        }
        return null;
    };

    const indexCubic = () => {
        const h_max = 8;
        for (let i = 0; i < Math.min(peaks.length, 10); i++) {
            for (let h = 1; h <= h_max; h++) for (let k = 0; k <= h; k++) for (let l = 0; l <= k; l++) {
                const S = h * h + k * k + l * l; if (S === 0) continue;
                refineAndTestSolution({a: Math.sqrt(S / q_obs[i]), system: 'cubic'});
            }
        }
    };

    const indexTetragonal = () => {
        for (let i = 0; i < tetra_hexa_i_depth; i++) for (let j = i + 1; j < tetra_hexa_j_depth; j++) {
            for (let h1 = 0; h1 <= max_hkl_low_angle_search; h1++) for (let k1 = 0; k1 <= h1; k1++) for (let l1 = 0; l1 <= max_hkl_low_angle_search; l1++) {
                if (h1 === 0 && k1 === 0 && l1 === 0) continue; const S1 = h1*h1 + k1*k1;
                for (let h2 = 0; h2 <= max_hkl_low_angle_search; h2++) for (let k2 = 0; k2 <= h2; k2++) for (let l2 = 0; l2 <= max_hkl_low_angle_search; l2++) {
                    if (h2 === 0 && k2 === 0 && l2 === 0) continue; const S2 = h2*h2 + k2*k2;
                    const det = S1 * l2*l2 - S2 * l1*l1; if (Math.abs(det) < 1e-6) continue;
                    const a_sq_inv = (q_obs[i] * l2*l2 - q_obs[j] * l1*l1) / det;
                    const c_sq_inv = (q_obs[j] * S1 - q_obs[i] * S2) / det;
                    if (a_sq_inv > 0 && c_sq_inv > 0) refineAndTestSolution({a: 1/Math.sqrt(a_sq_inv), c: 1/Math.sqrt(c_sq_inv), system: 'tetragonal'});
                }
            }
        }
    };

    const indexHexagonal = () => {
        for (let i = 0; i < tetra_hexa_i_depth; i++) for (let j = i + 1; j < tetra_hexa_j_depth; j++) {
            for (let h1 = 0; h1 <= max_hkl_low_angle_search; h1++) for (let k1 = 0; k1 <= h1; k1++) for (let l1 = 0; l1 <= max_hkl_low_angle_search; l1++) {
                if(h1 === 0 && k1 === 0 && l1 === 0) continue; const S1 = h1*h1 + h1*k1 + k1*k1;
                for(let h2 = 0; h2 <= max_hkl_low_angle_search; h2++) for(let k2 = 0; k2 <= h2; k2++) for(let l2 = 0; l2 <= max_hkl_low_angle_search; l2++) {
                    if(h2 === 0 && k2 === 0 && l2 === 0) continue; const S2 = h2*h2 + h2*k2 + k2*k2;
                    const det = S1*l2*l2 - S2*l1*l1; if(Math.abs(det) < 1e-6) continue;
                    const a_term = (q_obs[i]*l2*l2 - q_obs[j]*l1*l1) / det;
                    const c_inv = (q_obs[j]*S1 - q_obs[i]*S2) / det;
                    if(a_term > 0 && c_inv > 0) refineAndTestSolution({a: Math.sqrt(4/(3*a_term)), c: Math.sqrt(1/c_inv), system: 'hexagonal'});
                }
            }
        }
    };
    
    const indexOrthorhombic = () => {
        const max_peaks_basis = Math.min(12, q_obs.length); const basis_hkls = get_hkl_search_list('orthorhombic').slice(0, 30);
        for (let i=0; i<max_peaks_basis-2; i++) for (let j=i+1; j<max_peaks_basis-1; j++) for (let k=j+1; k<max_peaks_basis; k++) {
            for (let n1=0; n1<basis_hkls.length-2; n1++) for (let n2=n1+1; n2<basis_hkls.length-1; n2++) for (let n3=n2+1; n3<basis_hkls.length; n3++) {
                const M = [basis_hkls[n1], basis_hkls[n2], basis_hkls[n3]].map(hkl => [hkl[0]**2, hkl[1]**2, hkl[2]**2]);
                const solution = solveLeastSquares(M, [q_obs[i], q_obs[j], q_obs[k]]); 
                if (!solution || solution.some(s => s <=0)) continue; 
                refineAndTestSolution({ a: 1/Math.sqrt(solution[0]), b: 1/Math.sqrt(solution[1]), c: 1/Math.sqrt(solution[2]), system: 'orthorhombic' });
            }
        }
    };
    
    const indexMonoclinic = () => {
        const max_peaks_basis = Math.min(12, q_obs.length); const basis_hkls = get_hkl_search_list('monoclinic').slice(0, 35);
        for (let i=0; i<max_peaks_basis-3; i++) for (let j=i+1; j<max_peaks_basis-2; j++) for (let k=j+1; k<max_peaks_basis-1; k++) for (let l=k+1; l<max_peaks_basis; l++) {
            for (let n1=0; n1<basis_hkls.length-3; n1++) for (let n2=n1+1; n2<basis_hkls.length-2; n2++) for (let n3=n2+1; n3<basis_hkls.length-1; n3++) for (let n4=n3+1; n4<basis_hkls.length; n4++) {
                const hkl_basis = [basis_hkls[n1], basis_hkls[n2], basis_hkls[n3], basis_hkls[n4]]; 
                const M = hkl_basis.map(hkl => [hkl[0]**2, hkl[1]**2, hkl[2]**2, hkl[0]*hkl[2]]); 
                const solution = solveLeastSquares(M, [q_obs[i], q_obs[j], q_obs[k], q_obs[l]]); 
                if (!solution) continue; const [A, B, C, D] = solution; 
                if (A <= 0 || B <= 0 || C <= 0 || D**2 >= 4 * A * C) continue;
                const cosBeta = -D / (2 * Math.sqrt(A * C)); const beta = Math.acos(cosBeta) * 180 / Math.PI;
                const sinBetaSq = 1 - cosBeta**2;
                refineAndTestSolution({ a: 1/Math.sqrt(A*sinBetaSq), b: 1/Math.sqrt(B), c: 1/Math.sqrt(C*sinBetaSq), beta, system: 'monoclinic' }); 
            }
        }
    };

    // --- MAIN WORKER LOGIC ---

    // 1. Run the fast, broad search first
    if (systemToSearch === 'cubic') indexCubic();
    if (systemToSearch === 'tetragonal') indexTetragonal();
    if (systemToSearch === 'hexagonal') indexHexagonal();
    if (systemToSearch === 'orthorhombic') indexOrthorhombic();
    if (systemToSearch === 'monoclinic') indexMonoclinic();
    
    // 2. If requested, refine the good candidates found in the first step
    if (refineZero && foundSolutions.length > 0) {
        const refinedSolutionsList = [];
        for (const candidate of foundSolutions) {
            const refined = refineSolutionWithZeroError(candidate);
            if (refined) {
                refinedSolutionsList.push(refined);
            }
        }
        
        // Re-check for duplicates after refinement
        const finalUniqueSolutions = [];
        const finalSolutionMap = new Map();
        for (const sol of refinedSolutionsList) {
             let key; const P = 2;
            switch(sol.system) {
                case 'cubic': key = `${sol.system}_${sol.a.toFixed(P)}`; break;
                case 'tetragonal': case 'hexagonal': key = `${sol.system}_${sol.a.toFixed(P)}_${sol.c.toFixed(P)}`; break;
                case 'orthorhombic': key = `${sol.system}_${[sol.a,sol.b,sol.c].sort().map(p => p.toFixed(P)).join('_')}`; break;
                case 'monoclinic': key = `${sol.system}_${sol.volume.toFixed(2)}_${sol.beta.toFixed(2)}`; break;
            }
            const existing = finalSolutionMap.get(key);
            if (!existing || sol.m20 > existing.m20) {
                 if (existing) { // Found a better version of an existing solution
                     const idx = finalUniqueSolutions.findIndex(s => s === existing.original);
                     if(idx > -1) finalUniqueSolutions[idx] = sol;
                 } else {
                     finalUniqueSolutions.push(sol);
                 }
                 finalSolutionMap.set(key, { m20: sol.m20, original: sol });
            }
        }
        foundSolutions = finalUniqueSolutions;
    }
    
    // 3. Send final list of solutions (refined or not) back to the main thread
    foundSolutions.forEach(solution => {
        if (solution) self.postMessage({ type: 'solution', payload: solution });
    });
    
    self.postMessage({ type: 'done' });
};
</script>
</body>
</html>

