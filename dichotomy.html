<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Powder Indexing by Dichotomy Method</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        :root {
            --dark-bg: #111827;
            --medium-bg: #1f2937;
            --light-bg: #374151;
            --border-color: #4b5563;
            --primary-accent: #3b82f6;
            --primary-accent-hover: #2563eb;
            --text-light: #e5e7eb;
            --text-medium: #d1d5db;
            --text-dark: #9ca3af;
            --success-green: #16a34a;
            --error-red: #dc2626;
        }

        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f9fafb; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #app-container { display: flex; width: 100%; flex-grow: 1; min-height: 0; }
        #controls-panel { width: 450px; min-width: 350px; max-width: 600px; flex-shrink: 0; padding: 24px; background-color: var(--dark-bg); border-right: 1px solid var(--light-bg); overflow-y: auto; color: var(--text-medium); display: flex; flex-direction: column; }
        #drag-handle { width: 6px; cursor: col-resize; background-color: var(--light-bg); flex-shrink: 0; transition: background-color: 0.2s; }
        #drag-handle:hover, #drag-handle:active { background-color: var(--primary-accent); }
        #results-area { flex-grow: 1; position: relative; background-color: #ffffff; min-width: 0; display: flex; flex-direction: column; padding: 1.5rem; color: var(--medium-bg); }
        .control-group { margin-bottom: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--light-bg); }
        .control-group:first-child { border-top: none; padding-top: 0; }
        .control-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-dark); font-size: 0.875rem; }
        .control-input, .control-select { width: 100%; background-color: var(--light-bg); border: 1px solid var(--border-color); color: var(--text-light); border-radius: 0.375rem; padding: 0.5rem 0.75rem; transition: all 0.2s ease; box-sizing: border-box; }
        .control-input:focus, .control-select:focus { outline: none; border-color: var(--primary-accent); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); }
        .btn { padding: 0.6rem 1rem; border-radius: 0.375rem; font-weight: 600; transition: background-color: 0.2s; cursor: pointer; border: none; text-align: center;}
        .btn-primary { background-color: var(--primary-accent); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: var(--primary-accent-hover); }
        .btn-secondary { background-color: var(--border-color); color: white; }
        .btn-secondary:hover:not(:disabled) { background-color: #6b7280; }
        .btn:disabled { background-color: var(--border-color); cursor: not-allowed; opacity: 0.7; }
        .file-input-label { display: block; padding: 0.75rem 1rem; background-color: var(--border-color); color: var(--text-medium); border-radius: 0.375rem; text-align: center; cursor: pointer; transition: background-color: 0.2s; }
        .file-input-label:hover { background-color: #6b7280; }
        .parameter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
        .checkbox-label { display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; color: var(--text-medium); cursor: pointer;}
        .hidden { display: none !important; }
        #peak-table-container { max-height: 200px; overflow-y: auto; background-color: var(--medium-bg); border-radius: 0.375rem; border: 1px solid var(--border-color); margin-top: 1rem;}
        .peak-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        .peak-table th, .peak-table td { padding: 0.5rem; text-align: right; border-bottom: 1px solid var(--border-color); }
        .peak-table th { background-color: #2a3547; font-weight: 600; text-align: center; }
        .peak-table input { width: 100%; background: transparent; border: none; color: var(--text-light); text-align: right; padding: 2px; border-radius: 2px; }
        .peak-table input:focus { background-color: var(--light-bg); outline: 1px solid var(--primary-accent); }
        .delete-peak-btn { background: none; border: none; color: var(--text-dark); cursor: pointer; font-weight: bold; }
        .delete-peak-btn:hover { color: var(--error-red); }
        #solutions-table-container { flex-grow: 1; overflow-y: auto; background-color: var(--medium-bg); border-radius: 0.375rem; border: 1px solid var(--border-color); margin-top: 1rem;}
        .solutions-table { width: 100%; border-collapse: collapse; font-size: 0.75rem; }
        .solutions-table th, .solutions-table td { padding: 0.5rem; text-align: left; border-bottom: 1px solid var(--border-color); }
        .solutions-table th { background-color: #2a3547; font-weight: 600;}
        .solutions-table tbody tr { cursor: pointer; transition: background-color: 0.2s; }
        .solutions-table tbody tr:hover { background-color: var(--light-bg); }
        .solutions-table tbody tr.selected { background-color: var(--primary-accent); color: white;}

        #status-box {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            color: white;
            font-size: 0.8rem; 
            font-weight: 500;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transform: translateY(20px);
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        #status-box.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        #status-box.success { background-color: var(--success-green); }
        #status-box.error { background-color: var(--error-red); }
        #status-box.info { background-color: var(--border-color); }

    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">
            <h1 style="font-size: 1.5rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">Powder XRD Indexing</h1>
            <p style="font-size: 0.875rem; color: var(--text-dark); margin-bottom: 1.5rem;">Determine unit cell parameters using the Dichotomy method. Based on the method of A. Boultif & D. Louer, J. Appl. Cryst. 37, 724-731 (2004). This is a simplified version to be used for educational purposes or simple systems. For real stuff use the original code or other indexing programs.</p>

            <div class="control-group">
                <h2 style="font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem;">1. Load Data</h2>
                <label for="file-input" class="file-input-label">
                    <span id="file-name">Select .xy, .csv or .xrdml File</span>
                </label>
                <input type="file" id="file-input" class="hidden" accept=".xy,.csv,.txt,.xrdml">
            </div>

            <div class="control-group">
                <h2 style="font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem;">2. Find Peaks</h2>
                <div id="peak-controls" class="hidden">
                    <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                        <button id="find-peaks-button" class="btn btn-secondary" style="flex-grow: 1;">Find Peaks</button>
                        <label for="peak-threshold-input" class="control-label" style="margin-bottom: 0; white-space: nowrap;">Min %:</label>
                        <input type="number" id="peak-threshold-input" class="control-input" value="2" min="0.1" max="50" step="0.1" style="width: 6rem;">
                    </div>
                    <div style="margin-top: 1rem;">
                        <label class="control-label">2θ Range for Peak Finding</label>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <input type="number" id="tth-min-input" class="control-input" style="width: 6rem; text-align: center;" disabled>
                            <div style="flex-grow: 1;">
                                <input type="range" id="tth-min-slider" disabled style="width: 100%;">
                                <input type="range" id="tth-max-slider" disabled style="width: 100%;">
                            </div>
                            <input type="number" id="tth-max-input" class="control-input" style="width: 6rem; text-align: center;" disabled>
                        </div>
                    </div>
                    <div id="peak-table-container" class="hidden">
                        <table class="peak-table">
                            <thead><tr><th>#</th><th>2θ Obs (°)</th><th>d (Å)</th><th>Del</th></tr></thead>
                            <tbody id="peak-list-body"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h2 style="font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem;">3. Indexing Parameters</h2>
                <div id="indexing-controls" class="hidden">
                     <div class="parameter-grid">
                        <div>
                            <label for="wavelength" class="control-label">Wavelength (Å)</label>
                            <input type="number" id="wavelength" value="1.54056" step="0.00001" min="0.1" class="control-input">
                        </div>
                        <div>
                            <label for="max-volume" class="control-label">Max Volume (Å³)</label>
                            <input type="number" id="max-volume" value="1000" step="100" min="100" class="control-input">
                        </div>
                    </div>
                    <div class="parameter-grid" style="margin-top: 1rem;">
                        <div>
                            <label for="tth-error" class="control-label">2θ Error (°)</label>
                            <input type="number" id="tth-error" value="0.05" step="0.005" min="0.001" class="control-input">
                        </div>
                        <div>
                            <label for="impurity-peaks" class="control-label">Impurity Peaks</label>
                            <input type="number" id="impurity-peaks" value="1" min="0" max="4" step="1" class="control-input">
                        </div>
                    </div>
                    <label class="control-label" style="margin-top: 1rem;">Crystal Systems to Search:</label>
                    <div class="parameter-grid">
                        <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="cubic" checked> Cubic</label>
                        <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="tetragonal" checked> Tetragonal</label>
                        <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="hexagonal" checked> Hexagonal</label>
                        <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="orthorhombic" > Orthorhombic</label>
                        <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="monoclinic" > Monoclinic</label>
                    </div>
                </div>
            </div>

            <div style="margin-top: auto; padding-top: 1rem;">
                <div id="progress-bar-container" class="hidden" style="width: 100%; background-color: var(--light-bg); border-radius: 9999px; height: 0.625rem; margin-bottom: 0.5rem;">
                    <div id="progress-bar" style="background-color: var(--primary-accent); height: 0.625rem; border-radius: 9999px; width: 0%; transition: width 0.2s;"></div>
                </div>
                <div style="display: flex; gap: 0.5rem;">
                    <button id="start-indexing-button" class="btn btn-primary" style="flex: 1; font-size: 1rem;" disabled>Find Peaks to Start</button>
                    <button id="report-button" class="btn btn-secondary" style="flex: 1; font-size: 1rem;" disabled>Generate PDF Report</button>
                </div>
            </div>

            <div class="control-group" style="display: flex; flex-direction: column; flex-grow: 1; min-height: 250px;">
                 <h2 style="font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem;">4. Solutions</h2>
                 <div id="solutions-table-container">
                    <table class="solutions-table">
                        <thead><tr><th>Sys.</th><th>a,b,c (Å)</th><th>α,β,γ (°)</th><th>Vol</th><th>M(20)</th></tr></thead>
                        <tbody id="solutions-table-body"></tbody>
                    </table>
                 </div>
            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="results-area">
             <div id="placeholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #6b7280;">
                <svg xmlns="http://www.w3.org/2000/svg" style="width: 4rem; height: 4rem; margin-bottom: 1rem;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                <h2 style="font-size: 1.5rem; font-weight: 600;">Awaiting Data</h2>
                <p>Load a data file to begin indexing.</p>
            </div>
            <div id="results-container" style="width: 100%; height: 100%; display: none; flex-direction: column; position: relative;">
                <canvas id="xrd-chart"></canvas>
            </div>
            <div style="position: absolute; bottom: 0.5rem; right: 1rem; font-size: 0.75rem; color: #9ca3af;">
                NitaD, Univ Paris-Saclay, 14 Sept 2025
            </div>
        </div>
    </div>

    <div id="status-box"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const ui = {
                fileInput: document.getElementById('file-input'),
                fileName: document.getElementById('file-name'),
                peakControls: document.getElementById('peak-controls'),
                peakThresholdInput: document.getElementById('peak-threshold-input'),
                findPeaksButton: document.getElementById('find-peaks-button'),
                peakTableContainer: document.getElementById('peak-table-container'),
                peakListBody: document.getElementById('peak-list-body'),
                indexingControls: document.getElementById('indexing-controls'),
                wavelength: document.getElementById('wavelength'),
                tthError: document.getElementById('tth-error'),
                maxVolume: document.getElementById('max-volume'),
                impurityPeaksInput: document.getElementById('impurity-peaks'),
                systemCheckboxes: document.querySelectorAll('.system-checkbox'),
                startIndexingButton: document.getElementById('start-indexing-button'),
                reportButton: document.getElementById('report-button'),
                progressBar: document.getElementById('progress-bar'),
                progressBarContainer: document.getElementById('progress-bar-container'),
                solutionsTableBody: document.getElementById('solutions-table-body'),
                chartCanvas: document.getElementById('xrd-chart'),
                placeholder: document.getElementById('placeholder'),
                resultsContainer: document.getElementById('results-container'),
                tthMinSlider: document.getElementById('tth-min-slider'),
                tthMaxSlider: document.getElementById('tth-max-slider'),
                tthMinInput: document.getElementById('tth-min-input'),
                tthMaxInput: document.getElementById('tth-max-input'),
                statusBar: document.getElementById('status-box'),
            };

            let statusTimeout;
            const showStatus = (message, type = 'info', duration = 4000) => {
                if (!ui.statusBar) {
                    console.warn(`Status bar element (#status-box) not found. Message: "${message}"`);
                    return;
                }
                if (statusTimeout) clearTimeout(statusTimeout);
                ui.statusBar.textContent = message;
                ui.statusBar.className = `show ${type}`;
                statusTimeout = setTimeout(() => {
                    if (ui.statusBar) {
                        ui.statusBar.classList.remove('show');
                    }
                }, duration);
            };

            let fullExperimentalData = { tth: [], intensity: [] };
            let pickedPeaks = [];
            let solutions = [];
            let selectedSolution = null;
            let currentHklList = [];
            let xrdChart;
            let isIndexing = false;
            let activeWorkers = [];

            const inputsToValidate = [
                { id: 'wavelength', el: ui.wavelength, default: 1.54056 },
                { id: 'max-volume', el: ui.maxVolume, default: 2000 },
                { id: 'tth-error', el: ui.tthError, default: 0.05 },
                { id: 'impurity-peaks', el: ui.impurityPeaksInput, default: 0 },
                { id: 'peak-threshold-input', el: ui.peakThresholdInput, default: 2 },
            ];

            // Setup input validation
            inputsToValidate.forEach(({ id, el, default: defaultValue }) => {
                if (el) {
                    el.addEventListener('blur', () => {
                        const min = parseFloat(el.min);
                        const max = parseFloat(el.max);
                        let value = parseFloat(el.value);

                        if (isNaN(value)) {
                            el.value = defaultValue;
                            return;
                        }
                        if (el.step == 2 && value % 2 === 0) { // Ensure window is odd
                            value += 1;
                            el.value = value;
                        }

                        if (!isNaN(min) && value < min) el.value = min;
                        if (!isNaN(max) && value > max) el.value = max;
                    });
                } else {
                    console.error(`Initialization Error: The element with id="${id}" was not found. Input validation will not be applied to it.`);
                }
            });

            // Wavelength change requires recalculating d-spacing and Q
            if (ui.wavelength) {
                ui.wavelength.addEventListener('change', () => {
                    if (pickedPeaks.length > 0) {
                        recalculatePeakValues();
                        updatePeakTable();
                    }
                });
            }


            const parseDataFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                const tth = [], intensity = [];
                lines.forEach(line => {
                    if (line.startsWith('#') || line.startsWith('//')) return;
                    const parts = line.trim().split(/[\s,;]+/);
                    if (parts.length >= 2) {
                        const x = parseFloat(parts[0]);
                        const y = parseFloat(parts[1]);
                        if (!isNaN(x) && !isNaN(y)) {
                            tth.push(x);
                            intensity.push(y);
                        }
                    }
                });
                return { tth, intensity };
            };

            const parseXrdmlFile = (xmlString) => {
                 const parser = new DOMParser();
                 const xmlDoc = parser.parseFromString(xmlString, "application/xml");
                 if (xmlDoc.querySelector("parsererror")) { console.error("Error parsing XRDML"); return null; }

                 let wavelength = 1.5406;
                 const kAlpha1Node = xmlDoc.querySelector("kAlpha1");
                 if (kAlpha1Node?.textContent) wavelength = parseFloat(kAlpha1Node.textContent);

                 const intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts");
                 const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number);

                 const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]');
                 const startPos = parseFloat(positionsNode.querySelector("startPosition").textContent);
                 const endPos = parseFloat(positionsNode.querySelector("endPosition").textContent);
                 const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * (endPos - startPos) / (intensity.length - 1));

                 return { tth, intensity, wavelength };
            };

            ui.fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    let parsedData;
                    if (file.name.toLowerCase().endsWith('.xrdml')) {
                        parsedData = parseXrdmlFile(evt.target.result);
                    } else {
                        parsedData = parseDataFile(evt.target.result);
                    }

                    if (!parsedData || parsedData.tth.length === 0) {
                        showStatus('Error: No valid data could be parsed from the file.', 'error');
                        return;
                    }

                    fullExperimentalData = parsedData;
                    const maxIntensity = Math.max(...fullExperimentalData.intensity);
                    if (maxIntensity > 0) {
                         fullExperimentalData.intensity = fullExperimentalData.intensity.map(y => y / maxIntensity * 1000);
                    }

                    solutions = [];
                    updateSolutionsTable();

                    if (parsedData.wavelength) {
                        ui.wavelength.value = parsedData.wavelength.toFixed(5);
                    }

                    selectedSolution = null;
                    currentHklList = [];
                    ui.fileName.textContent = file.name;
                    ui.placeholder.style.display = 'none';
                    ui.resultsContainer.style.display = 'flex';
                    ui.peakControls.classList.remove('hidden');
                    ui.indexingControls.classList.remove('hidden');
                    initializeChart();
                    setupTthSliders();
                    showStatus(`File "${file.name}" loaded successfully.`, 'success');
                };
                reader.readAsText(file);
            });

            const setupTthSliders = () => {
                if (fullExperimentalData.tth.length === 0) return;
                const min = fullExperimentalData.tth[0];
                const max = fullExperimentalData.tth[fullExperimentalData.tth.length - 1];
                const step = (max - min) / 2000;

                [ui.tthMinSlider, ui.tthMaxSlider, ui.tthMinInput, ui.tthMaxInput].forEach(el => {
                    el.disabled = false;
                });

                Object.assign(ui.tthMinSlider, { min, max, step, value: min });
                Object.assign(ui.tthMaxSlider, { min, max, step, value: max });

                ui.tthMinInput.value = Math.floor(min);
                ui.tthMaxInput.value = Math.ceil(max);

                updatePlotRange();
            };

            const updatePlotRange = () => {
                if(!xrdChart) return;
                const min = parseFloat(ui.tthMinInput.value);
                const max = parseFloat(ui.tthMaxInput.value);
                xrdChart.options.scales.x.min = min;
                xrdChart.options.scales.x.max = max;

                const visibleIntensities = fullExperimentalData.intensity.filter((intensity, index) => {
                    const tth = fullExperimentalData.tth[index];
                    return tth >= min && tth <= max;
                });

                if (visibleIntensities.length > 0) {
                    const yMaxInRange = Math.max(...visibleIntensities);
                    xrdChart.options.scales.y.min = -yMaxInRange * 0.25;
                    xrdChart.options.scales.y.max = yMaxInRange * 1.1;
                } else {
                    const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
                    xrdChart.options.scales.y.min = -yMax * 0.25;
                    xrdChart.options.scales.y.max = yMax * 1.1;
                }

                xrdChart.update('none');
            };

            ui.tthMinSlider.addEventListener('input', () => {
                let minVal = parseFloat(ui.tthMinSlider.value);
                let maxVal = parseFloat(ui.tthMaxSlider.value);
                if (minVal >= maxVal) {
                    minVal = maxVal - parseFloat(ui.tthMinSlider.step);
                    ui.tthMinSlider.value = minVal;
                }
                ui.tthMinInput.value = Math.round(minVal);
                updatePlotRange();
                findPeaks();
            });
             ui.tthMaxSlider.addEventListener('input', () => {
                let minVal = parseFloat(ui.tthMinSlider.value);
                let maxVal = parseFloat(ui.tthMaxSlider.value);
                if (maxVal <= minVal) {
                    maxVal = minVal + parseFloat(ui.tthMaxSlider.step);
                    ui.tthMaxSlider.value = maxVal;
                }
                ui.tthMaxInput.value = Math.round(maxVal);
                updatePlotRange();
                findPeaks();
            });
            ui.tthMinInput.addEventListener('change', () => { if(!ui.tthMinSlider.disabled) {ui.tthMinSlider.value = ui.tthMinInput.value; updatePlotRange(); findPeaks();} });
            ui.tthMaxInput.addEventListener('change', () => { if(!ui.tthMaxSlider.disabled) {ui.tthMaxSlider.value = ui.tthMaxInput.value; updatePlotRange(); findPeaks();} });

            const savitzkyGolay = (data, windowSize, polyOrder) => {
                const halfWindow = Math.floor(windowSize / 2);
                const numPoints = data.length;
                const result = new Array(numPoints).fill(0);

                const coeffs = getSGCoefficients(windowSize, polyOrder);
                if (!coeffs) {
                    showStatus('Invalid Savitzky-Golay parameters.', 'error');
                    return data;
                }

                for (let i = 0; i < numPoints; i++) {
                    let sum = 0;
                    for (let j = -halfWindow; j <= halfWindow; j++) {
                        const dataIndex = i + j;
                        // Use reflection for boundary conditions
                        let reflectedIndex = dataIndex;
                        if (dataIndex < 0) reflectedIndex = -dataIndex;
                        if (dataIndex >= numPoints) reflectedIndex = numPoints - 1 - (dataIndex - (numPoints - 1));

                        sum += data[reflectedIndex] * coeffs[j + halfWindow];
                    }
                    result[i] = sum;
                }
                return result;
            };

            const getSGCoefficients = (windowSize, polyOrder) => {
                 // Pre-computed coefficients for the 2nd derivative, which is used for peak finding.
                if (windowSize === 5 && polyOrder === 2) return [0.142857, -0.0714286, -0.142857, -0.0714286, 0.142857];
                if (windowSize === 7 && polyOrder === 2) return [0.0714286, 0, -0.047619, -0.0714286, -0.047619, 0, 0.0714286];
                if (windowSize === 9 && (polyOrder === 2 || polyOrder === 3)) return [0.0384615, 0.0128205, -0.00769231, -0.0230769, -0.0333333, -0.0230769, -0.00769231, 0.0128205, 0.0384615];
                if (windowSize === 11 && (polyOrder === 2 || polyOrder === 3)) return [ 0.025175, 0.006993, -0.00559, -0.01399, -0.01958, -0.02308, -0.01958, -0.01399, -0.00559, 0.006993, 0.025175];

                console.warn(`No precomputed SG coefficients for window=${windowSize}, order=${polyOrder}.`);
                return null;
            };


            const findPeaks = () => {
                const intensity = fullExperimentalData.intensity;
                if (intensity.length < 5) return;

                const sgWindow = 9; // Fixed value
                const sgOrder = 2;  // Fixed value

                const minTth = parseFloat(ui.tthMinInput.value);
                const maxTth = parseFloat(ui.tthMaxInput.value);

                let thresholdPercent = parseFloat(ui.peakThresholdInput.value);
                if (isNaN(thresholdPercent) || thresholdPercent < 0.1 || thresholdPercent > 50) {
                    thresholdPercent = 2; ui.peakThresholdInput.value = 2;
                }
                const threshold = (thresholdPercent / 100) * Math.max(...intensity);

                const secondDerivative = savitzkyGolay(intensity, sgWindow, sgOrder);

                pickedPeaks = [];
                for (let i = 1; i < secondDerivative.length - 1; i++) {
                    const tth = fullExperimentalData.tth[i];
                    if (tth < minTth || tth > maxTth) continue;

                    // A peak in the data corresponds to a local minimum in the 2nd derivative that is also negative.
                    if (secondDerivative[i] < secondDerivative[i-1] &&
                        secondDerivative[i] < secondDerivative[i+1] &&
                        secondDerivative[i] < 0) {

                        if(intensity[i] > threshold) {
                            const lambda = parseFloat(ui.wavelength.value);
                            const d = lambda / (2 * Math.sin(tth * Math.PI / 360));
                            const q = 1 / (d * d);
                            pickedPeaks.push({ tth, d, q });
                        }
                    }
                }

                updatePeakTable();
                if (pickedPeaks.length > 0) {
                    ui.startIndexingButton.disabled = false;
                    ui.startIndexingButton.textContent = 'Start Indexing';
                } else {
                    ui.startIndexingButton.disabled = true;
                    ui.startIndexingButton.textContent = 'No Peaks Found in Range';
                }
            };

            const recalculatePeakValues = () => {
                const lambda = parseFloat(ui.wavelength.value);
                pickedPeaks.forEach(peak => {
                    peak.d = lambda / (2 * Math.sin(peak.tth * Math.PI / 360));
                    peak.q = 1 / (peak.d * peak.d);
                });
            };

            const updatePeakTable = () => {
                ui.peakListBody.innerHTML = '';
                pickedPeaks.forEach((peak, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td><input type="number" class="peak-tth-input" value="${peak.tth.toFixed(4)}" data-index="${index}" step="0.0001"></td>
                        <td><input type="number" class="peak-d-input" value="${peak.d.toFixed(5)}" data-index="${index}" disabled></td>
                        <td><button class="delete-peak-btn" data-index="${index}">X</button></td>
                    `;
                    ui.peakListBody.appendChild(row);
                });
                ui.peakTableContainer.classList.toggle('hidden', pickedPeaks.length === 0);
                updateAllMarkers();
            };

            ui.findPeaksButton.addEventListener('click', () => {
                findPeaks();
                showStatus(`${pickedPeaks.length} peaks found in the specified range.`, 'info');
            });
            ui.peakThresholdInput.addEventListener('change', findPeaks);

            ui.peakListBody.addEventListener('change', (e) => {
                if (e.target.classList.contains('peak-tth-input')) {
                    const index = parseInt(e.target.dataset.index);
                    const tth = parseFloat(e.target.value);
                    const lambda = parseFloat(ui.wavelength.value);
                    const d = lambda / (2 * Math.sin(tth * Math.PI / 360));
                    const q = 1 / (d*d);
                    pickedPeaks[index] = {tth, d, q};
                    e.target.closest('tr').querySelector('.peak-d-input').value = d.toFixed(5);
                    updateAllMarkers();
                }
            });
             ui.peakListBody.addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-peak-btn')) {
                    const index = parseInt(e.target.dataset.index);
                    pickedPeaks.splice(index, 1);
                    updatePeakTable();
                }
            });

            const startIndexing = () => {
                if (pickedPeaks.length < 4) {
                    showStatus("Please find at least 4 peaks before starting indexing.", 'error');
                    return;
                }

                const systemsToSearch = Array.from(ui.systemCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
                if (systemsToSearch.length === 0) {
                    showStatus("Please select at least one crystal system to search.", 'error');
                    return;
                }

                setUIState(true);
                solutions = [];
                selectedSolution = null;
                currentHklList = [];
                activeWorkers = [];
                updateSolutionsTable();
                showStatus(`Indexing started for ${systemsToSearch.length} system(s)...`, 'info');

                const baseParams = {
                    peaks: pickedPeaks,
                    wavelength: parseFloat(ui.wavelength.value),
                    tth_error: parseFloat(ui.tthError.value),
                    max_volume: parseFloat(ui.maxVolume.value),
                    impurity_peaks: parseInt(ui.impurityPeaksInput.value, 10),
                };

                const workerScript = document.getElementById('indexing-worker').textContent;
                const blob = new Blob([workerScript], { type: 'application/javascript' });
                const workerURL = URL.createObjectURL(blob);

                let completedWorkers = 0;
                const totalWorkers = systemsToSearch.length;

                systemsToSearch.forEach(system => {
                    const worker = new Worker(workerURL);
                    activeWorkers.push(worker);

                    worker.onmessage = (e) => {
                        const { type, payload } = e.data;
                        if (type === 'solution') {
                             const newSolution = payload;
                             const DUPLICATE_TOLERANCE = 0.001;
                             let isDuplicate = solutions.some(existing => {
                                 if (existing.system !== newSolution.system) return false;
                                 switch(existing.system) {
                                     case 'cubic': return Math.abs(existing.a - newSolution.a) / existing.a < DUPLICATE_TOLERANCE;
                                     case 'tetragonal': case 'hexagonal':
                                         return Math.abs(existing.a - newSolution.a) / existing.a < DUPLICATE_TOLERANCE &&
                                                Math.abs(existing.c - newSolution.c) / existing.c < DUPLICATE_TOLERANCE;
                                     case 'orthorhombic':
                                         const exParams = [existing.a, existing.b, existing.c].sort((x,y)=>x-y);
                                         const newParams = [newSolution.a, newSolution.b, newSolution.c].sort((x,y)=>x-y);
                                         return exParams.every((p, idx) => Math.abs(p - newParams[idx]) / p < DUPLICATE_TOLERANCE);
                                     case 'monoclinic':
                                          return Math.abs(existing.volume - newSolution.volume) / existing.volume < DUPLICATE_TOLERANCE &&
                                                 Math.abs(existing.beta - newSolution.beta) / existing.beta < DUPLICATE_TOLERANCE;
                                     default: return false;
                                 }
                             });
                             if (!isDuplicate) {
                                 solutions.push(newSolution);
                                 solutions.sort((a, b) => b.m20 - a.m20);
                                 updateSolutionsTable();
                             }
                        } else if (type === 'done') {
                            completedWorkers++;
                            ui.progressBar.style.width = `${(completedWorkers / totalWorkers) * 100}%`;
                            worker.terminate();
                            activeWorkers = activeWorkers.filter(w => w !== worker);

                            if (completedWorkers === totalWorkers) {
                                URL.revokeObjectURL(workerURL);
                                setUIState(false);
                                if (solutions.length > 0) {
                                    showStatus(`Indexing complete. Found ${solutions.length} potential solution(s).`, 'success');
                                } else {
                                    showStatus('Indexing finished, but no valid solutions were found.', 'info');
                                }
                            }
                        }
                    };
                    worker.postMessage({ ...baseParams, systemToSearch: system });
                });
            };

            ui.startIndexingButton.addEventListener('click', startIndexing);

            ui.reportButton.addEventListener('click', () => {
                if (isIndexing) {
                    activeWorkers.forEach(w => w.terminate());
                    activeWorkers = [];
                    setUIState(false);
                    showStatus('Indexing stopped by user.', 'info');
                } else {
                    generatePDFReport();
                }
            });

            const setUIState = (indexing) => {
                isIndexing = indexing;
                document.body.style.cursor = indexing ? 'wait' : 'default';

                const controlsToDisable = [
                    ui.fileInput, ui.findPeaksButton, ui.peakThresholdInput,
                    ui.tthMinSlider, ui.tthMaxSlider, ui.tthMinInput, ui.tthMaxInput,
                    ui.wavelength, ui.tthError, ui.maxVolume,
                    ui.impurityPeaksInput, ...ui.systemCheckboxes,
                ];

                controlsToDisable.forEach(el => {
                    if (el) el.disabled = indexing;
                });

                ui.peakListBody.querySelectorAll('input, button').forEach(el => {
                    el.disabled = indexing;
                });

                const fileLabel = document.querySelector('.file-input-label');
                if (fileLabel) {
                    fileLabel.style.pointerEvents = indexing ? 'none' : 'auto';
                    fileLabel.style.opacity = indexing ? '0.7' : '1';
                }

                if (indexing) {
                    ui.startIndexingButton.disabled = true;
                    ui.startIndexingButton.textContent = 'Indexing...';
                    ui.reportButton.textContent = 'Stop';
                    ui.reportButton.disabled = false;
                    ui.progressBarContainer.classList.remove('hidden');
                    ui.progressBar.style.width = '0%';
                } else {
                    ui.startIndexingButton.disabled = (pickedPeaks.length === 0);
                    ui.startIndexingButton.textContent = 'Start Indexing';
                    ui.reportButton.textContent = 'Generate PDF Report';
                    ui.reportButton.disabled = (solutions.length === 0);
                    ui.progressBarContainer.classList.add('hidden');
                    ui.progressBar.style.width = '0%';
                    if (fullExperimentalData.tth.length > 0) {
                        ui.tthMinSlider.disabled = false;
                        ui.tthMaxSlider.disabled = false;
                        ui.tthMinInput.disabled = false;
                        ui.tthMaxInput.disabled = false;
                    }
                }
            };

            const updateSolutionsTable = () => {
                ui.solutionsTableBody.innerHTML = '';
                solutions.slice(0, 20).forEach((sol, index) => {
                    const row = document.createElement('tr');
                    row.dataset.index = index;

                    let cell_params1 = `${sol.a.toFixed(4)}`;
                    if(sol.b) cell_params1 += `, ${sol.b.toFixed(4)}`;
                    if(sol.c) cell_params1 += `, ${sol.c.toFixed(4)}`;

                    const cell_params2 = `${sol.alpha ? sol.alpha.toFixed(2) : '90'}, ${sol.beta ? sol.beta.toFixed(2) : '90'}, ${sol.gamma ? sol.gamma.toFixed(2) : '90'}`;

                    row.innerHTML = `
                        <td>${sol.system.substring(0,4)}</td>
                        <td>${cell_params1}</td>
                        <td>${cell_params2}</td>
                        <td>${sol.volume.toFixed(2)}</td>
                        <td>${sol.m20.toFixed(2)}</td>
                    `;
                    ui.solutionsTableBody.appendChild(row);
                });
            };

            ui.solutionsTableBody.addEventListener('click', (e) => {
                const row = e.target.closest('tr');
                if (!row) return;

                document.querySelectorAll('#solutions-table-body tr').forEach(r => r.classList.remove('selected'));
                row.classList.add('selected');

                const index = parseInt(row.dataset.index);
                selectedSolution = solutions[index];

                const lambda = parseFloat(ui.wavelength.value);
                const maxTth = xrdChart.options.scales.x.max || Math.max(...pickedPeaks.map(p => p.tth));
                currentHklList = generateHKL(maxTth, {...selectedSolution, lambda}, selectedSolution.system);

                updateAllMarkers();
            });

            // --- Chart.js Vertical Line Plugin ---
            const verticalCursorLine = {
                id: 'verticalCursorLine',
                afterDraw: chart => {
                    if (chart.tooltip?._active?.length) {
                        let x = chart.tooltip._active[0].element.x;
                        let yAxis = chart.scales.y;
                        let ctx = chart.ctx;
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(x, yAxis.top);
                        ctx.lineTo(x, yAxis.bottom);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)';
                        ctx.setLineDash([4, 4]);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            };
            Chart.register(verticalCursorLine);
            // --- End Plugin ---

            const initializeChart = () => {
                if (xrdChart) xrdChart.destroy();
                const experimentalPoints = fullExperimentalData.tth.map((t, i) => ({ x: t, y: fullExperimentalData.intensity[i] }));
                const yMax = Math.max(...fullExperimentalData.intensity);

                xrdChart = new Chart(ui.chartCanvas, {
                    type: 'line',
                    data: {
                        datasets: [
                            {
                                label: 'Experimental',
                                data: experimentalPoints,
                                borderColor: 'rgba(107, 114, 128, 0.7)',
                                borderWidth: 1.5,
                                pointRadius: 0
                            },
                            {
                                type: 'bar',
                                label: 'Observed Peaks',
                                data: [],
                                backgroundColor: 'rgba(239, 68, 68, 0.7)',
                                barThickness: 1
                            },
                            {
                                type: 'bar',
                                label: 'Calculated Peaks',
                                data: [],
                                backgroundColor: 'rgba(59, 130, 246, 0.9)',
                                barThickness: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false, animation: false,
                        interaction: {
                            intersect: false,
                            mode: 'index',
                        },
                        scales: {
                            x: { type: 'linear', title: { display: true, text: '2-theta (degrees)' } },
                            y: { title: { display: true, text: 'Intensity (a.u.)' }, min: -yMax * 0.15, max: yMax * 1.1 }
                        },
                        plugins: {
                            legend: { position: 'top' },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        if (!tooltipItems.length) return '';
                                        const tth = tooltipItems[0].parsed.x;
                                        let title = `2θ: ${tth.toFixed(3)}°`;

                                        if (currentHklList && currentHklList.length > 0) {
                                            let closestPeak = null;
                                            let minDiff = Infinity;

                                            for (const hkl of currentHklList) {
                                                const diff = Math.abs(tth - hkl.tth);
                                                if (diff < minDiff) {
                                                    minDiff = diff;
                                                    closestPeak = hkl;
                                                }
                                            }
                                            
                                            const tolerance = parseFloat(ui.tthError.value) || 0.05;
                                            if (closestPeak && minDiff < tolerance) {
                                                title += `, HKL: (${closestPeak.h},${closestPeak.k},${closestPeak.l})`;
                                            }
                                        }
                                        return title;
                                    },
                                    label: function(context) {
                                        const datasetLabel = context.dataset.label || '';
                                        if (datasetLabel === 'Observed Peaks' || datasetLabel === 'Calculated Peaks') {
                                            return null;
                                        }
                                        let label = datasetLabel ? `${datasetLabel}: ` : '';
                                        if (context.parsed.y !== null) {
                                            label += Math.round(context.parsed.y);
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
            };

            const updateAllMarkers = () => {
                if (!xrdChart) return;

                const minX = xrdChart.options.scales.x.min;
                const maxX = xrdChart.options.scales.x.max;
                const visibleIntensities = fullExperimentalData.intensity.filter((_, index) => {
                    const tth = fullExperimentalData.tth[index];
                    return tth >= minX && tth <= maxX;
                });
                const yMax = visibleIntensities.length > 0 ? Math.max(...visibleIntensities) : (Math.max(...fullExperimentalData.intensity) || 1000);
                const markerHeight = yMax * 0.04;

                xrdChart.data.datasets[1].data = pickedPeaks.map(p => ({ x: p.tth, y: [-markerHeight * 0.25, -markerHeight * 1.25] }));

                if (selectedSolution) {
                    xrdChart.data.datasets[2].data = currentHklList.map(hkl => ({ x: hkl.tth, y: [-markerHeight * 1.5, -markerHeight * 2.5] }));
                } else {
                    xrdChart.data.datasets[2].data = [];
                }

                xrdChart.update('none');
            }

             const generateHKL = (maxTth, params, system) => {
                 const { a, b, c, alpha, beta, gamma, lambda } = params;
                 if (!a || !lambda) return [];
                 const reflections = [];
                 const maxIndex = 10;

                 for (let h = 0; h <= maxIndex; h++) {
                     for (let k = 0; k <= maxIndex; k++) {
                         for (let l = 0; l <= maxIndex; l++) {
                             if (system === 'cubic' && (k > h || l > k)) continue;
                             if ((system === 'tetragonal' || system === 'hexagonal') && k > h) continue;
                            if (h === 0 && k === 0 && l === 0) continue;
                             let inv_d_sq = 0;
                             switch (system) {
                                 case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                                 case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                                 case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                                 case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                                 case 'monoclinic': 
                                     const sinBeta = Math.sin(beta * Math.PI / 180);
                                     const cosBeta = Math.cos(beta * Math.PI / 180);
                                     inv_d_sq = (1 / (sinBeta * sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + k*k/(b*b);
                                     break;
                             }
                             if (inv_d_sq <= 0) continue;
                             const sinThetaSq = (lambda*lambda / 4) * inv_d_sq;
                             if (sinThetaSq <= 1) {
                                 const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                                 if (tth <= maxTth * 1.05) {
                                     reflections.push({tth, h, k, l, d: 1/Math.sqrt(inv_d_sq)});
                                 }
                             }
                         }
                     }
                 }
                 return reflections.sort((a, b) => a.tth - b.tth);
             };


            const resizer = document.getElementById('drag-handle');
            const leftPanel = document.getElementById('controls-panel');
            resizer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                document.body.style.cursor = 'col-resize';
                const moveHandler = (moveEvent) => {
                    if (moveEvent.clientX > 350 && moveEvent.clientX < window.innerWidth - 350) {
                        leftPanel.style.width = `${moveEvent.clientX}px`;
                    }
                };
                const upHandler = () => {
                    document.body.style.cursor = 'default';
                    window.removeEventListener('mousemove', moveHandler);
                    window.removeEventListener('mouseup', upHandler);
                };
                window.addEventListener('mousemove', moveHandler);
                window.addEventListener('mouseup', upHandler);
            });

            const generatePDFReport = async () => {
                if (solutions.length === 0) {
                    showStatus("No solutions found to generate a report.", 'info');
                    return;
                }

                ui.reportButton.textContent = 'Generating...';
                ui.reportButton.disabled = true;
                document.body.style.cursor = 'wait';

                try {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                    const margin = 15;
                    let yPos = 20;

                    const now = new Date();
                    const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                    doc.setFontSize(18);
                    doc.text('Powder Indexing Report', 105, yPos, { align: 'center' });
                    yPos += 10;
                    doc.setFontSize(10);
                    doc.text(`Generated: ${timestamp}`, margin, yPos);
                    yPos += 5;
                    doc.text(`Data File: ${ui.fileName.textContent}`, margin, yPos);
                    yPos += 10;

                    const canvas = await html2canvas(ui.chartCanvas, { backgroundColor: '#ffffff' });
                    const imgData = canvas.toDataURL('image/png');
                    const imgProps = doc.getImageProperties(imgData);
                    const pdfWidth = doc.internal.pageSize.getWidth();
                    const imgWidth = pdfWidth - 2 * margin;
                    const imgHeight = (imgProps.height * imgWidth) / imgProps.width;
                    doc.addImage(imgData, 'PNG', margin, yPos, imgWidth, imgHeight);
                    yPos += imgHeight + 10;

                    doc.addPage();
                    yPos = 20;
                    doc.setFontSize(14);
                    doc.text('Indexing Solutions Summary', margin, yPos);
                    yPos += 8;
                    doc.setFont('courier', 'normal');
                    doc.setFontSize(9);
                    doc.text('Sys  M(20)   Volume(A^3)  a(A)      b(A)      c(A)      alpha  beta   gamma', margin, yPos);
                    yPos += 5;
                    solutions.slice(0, 20).forEach(sol => {
                        if (yPos > 280) { doc.addPage(); yPos = 20; }
                        const line = `${sol.system.substring(0,4).padEnd(5)}` +
                                    `${sol.m20.toFixed(2).padStart(6)}  ` +
                                    `${sol.volume.toFixed(2).padStart(10)}  ` +
                                    `${sol.a.toFixed(4).padStart(8)}  ` +
                                    `${(sol.b ? sol.b.toFixed(4) : '-').padStart(8)}  ` +
                                    `${(sol.c ? sol.c.toFixed(4) : '-').padStart(8)}  ` +
                                    `${(sol.alpha ? sol.alpha.toFixed(2) : '90.00').padStart(6)} ` +
                                    `${(sol.beta ? sol.beta.toFixed(2) : '90.00').padStart(6)} ` +
                                    `${(sol.gamma ? sol.gamma.toFixed(2) : '90.00').padStart(6)}`;
                        doc.text(line, margin, yPos);
                        yPos += 5;
                    });

                    const lambda = parseFloat(ui.wavelength.value);
                    solutions.forEach((sol, solIndex) => {
                        doc.addPage();
                        yPos = 20;
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(12);
                        doc.text(`Details for Solution #${solIndex+1}: ${sol.system}, M(20) = ${sol.m20.toFixed(2)}`, margin, yPos);
                        yPos += 7;

                        doc.setFont('courier', 'normal');
                        doc.setFontSize(9);
                        let paramsLine = `a=${sol.a.toFixed(4)}`;
                        if(sol.b) paramsLine += `, b=${sol.b.toFixed(4)}`;
                        if(sol.c) paramsLine += `, c=${sol.c.toFixed(4)}`;
                        paramsLine += ` (A)`;
                        if(sol.alpha && sol.system !== 'cubic') paramsLine += `, alpha=${sol.alpha.toFixed(2)}`;
                        if(sol.beta && sol.system !== 'cubic') paramsLine += `, beta=${sol.beta.toFixed(2)}`;
                        if(sol.gamma && sol.system !== 'cubic') paramsLine += `, gamma=${sol.gamma.toFixed(2)}`;
                        doc.text(paramsLine, margin, yPos);
                        yPos += 7;

                        doc.setFont('helvetica', 'bold');
                        doc.text(`Suggested Centering:`, margin, yPos);
                        doc.setFont('courier', 'normal');
                        doc.text(sol.analysis.centering, margin + 45, yPos);
                        yPos += 5;

                        if (sol.analysis.conditions.length > 0) {
                            doc.setFont('helvetica', 'bold');
                            doc.text(`Reflection Conditions:`, margin, yPos);
                            doc.setFont('courier', 'normal');
                            doc.text(sol.analysis.conditions.join(', '), margin + 45, yPos);
                            yPos += 5;
                        }

                        if (sol.analysis.possibleSpaceGroups.length > 0) {
                            doc.setFont('helvetica', 'bold');
                            doc.text(`Space Groups:`, margin, yPos);
                            let currentX = margin + 45;
                            const probableSet = new Set(sol.analysis.probableSpaceGroups);
                            const allGroups = sol.analysis.possibleSpaceGroups;
                            const pageRightMargin = doc.internal.pageSize.getWidth() - margin;

                            allGroups.forEach((sg, index) => {
                                doc.setFont('courier', probableSet.has(sg) ? 'bold' : 'normal');
                                const text = sg + (index < allGroups.length - 1 ? ', ' : '');
                                if (currentX + doc.getTextWidth(text) > pageRightMargin && currentX > margin + 45) {
                                    yPos += 4;
                                    currentX = margin + 45;
                                }
                                doc.text(text, currentX, yPos);
                                currentX += doc.getTextWidth(text);
                            });
                            yPos += 4;
                        }
                        yPos += 3;

                        doc.setFont('courier', 'normal');
                        doc.text(' h  k  l |   d_cal(A) 2t_calc   d_obs(A)  2t_obs', margin, yPos);
                        yPos += 5;

                        const hklList = generateHKL(Math.max(...pickedPeaks.map(p=>p.tth)), {...sol, lambda}, sol.system);
                        const usedObsPeaks = new Set();
                        const tth_err = parseFloat(ui.tthError.value);

                        hklList.slice(0, 30).forEach(hkl => {
                            if (yPos > 280) { doc.addPage(); yPos = 20; }

                            let bestMatch = null;
                            let minDiff = Infinity;
                            pickedPeaks.forEach((peak, index) => {
                                if (usedObsPeaks.has(index)) return;
                                const diff = Math.abs(hkl.d - peak.d);
                                if (diff < minDiff) {
                                    minDiff = diff;
                                    bestMatch = { peak, index };
                                }
                            });

                            let d_obs_str = '-';
                            let tth_obs_str = '-';
                            if (bestMatch) {
                                const d_err_plus = lambda / (2 * Math.sin((bestMatch.peak.tth - tth_err) * Math.PI / 360));
                                const d_err_minus = lambda / (2 * Math.sin((bestMatch.peak.tth + tth_err) * Math.PI / 360));
                                if (minDiff < Math.abs(d_err_plus - d_err_minus)) {
                                    d_obs_str = bestMatch.peak.d.toFixed(5);
                                    tth_obs_str = bestMatch.peak.tth.toFixed(3);
                                    usedObsPeaks.add(bestMatch.index);
                                }
                            }

                            let tth_calc = '-';
                            if (hkl.d > 0 && lambda/(2*hkl.d) < 1) {
                                tth_calc = (2 * Math.asin(lambda / (2 * hkl.d)) * 180 / Math.PI).toFixed(3);
                            }

                            const line = `${String(hkl.h).padStart(2)} ${String(hkl.k).padStart(2)} ${String(hkl.l).padStart(2)} | ` +
                                         `${hkl.d.toFixed(5).padStart(9)} ` +
                                         `${String(tth_calc).padStart(7)}  ` +
                                         `${d_obs_str.padStart(9)}  ` +
                                         `${tth_obs_str.padStart(7)}`;
                            doc.text(line, margin, yPos);
                            yPos += 5;
                        });
                    });


                    const filename = `Indexing-Report-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}.pdf`;
                    doc.save(filename);
                    showStatus('PDF report generated and saved.', 'success');

                } catch (error) {
                    console.error("Failed to generate PDF:", error);
                    showStatus("An error occurred during PDF generation.", 'error');
                } finally {
                    ui.reportButton.textContent = 'Generate PDF Report';
                    ui.reportButton.disabled = (solutions.length === 0);
                    document.body.style.cursor = 'default';
                }
            };
        });
    </script>
    
    <script id="indexing-worker" type="text/javascript">
        self.onmessage = function(e) {
            const { peaks, wavelength, tth_error, max_volume, systemToSearch, impurity_peaks } = e.data;
            const DUPLICATE_TOLERANCE = 0.002; // 0.2% tolerance for considering solutions identical
            const foundSolutions = [];

            const q_from_tth_local = (tth) => {
                const d = wavelength / (2 * Math.sin(tth * Math.PI / 360));
                return 1 / (d * d);
            };

            const q_obs = peaks.map(p => q_from_tth_local(p.tth));
            const tth_obs = peaks.map(p => p.tth);
            const N_FOR_M20 = Math.min(20, peaks.length);
            
            // Search depth parameters
            const max_hkl_indexing = 15;
            const cubic_search_depth = 15;
            const tetra_hexa_i_depth = 15;
            const tetra_hexa_j_depth = 15;
            const max_hkl_analysis = 10;
            const min_m20 = 1.0;
            const min_lattice_param = 2.7;


            const spaceGroupData = {
    cubic: {
        'P': {
            'Pm-3m': { c: [] },
            'Pn-3n': { c: ['0kl:k+l=2n', 'hhl:l=2n'] },
            'Pm-3n': { c: ['hk0:h+k=2n'] },
            'Pa-3': { c: ['hk0:h=2n'] },
            'Pn-3m': { c: ['hhl:l=2n'] }
        },
        'I': {
            'Im-3m': { c: [] },
            'Ia-3': { c: ['0kl:k=2n'] },
            'Ia-3d': { c: ['0kl:k=2n,l=2n', 'hhl:2h+l=4n'] }
        },
        'F': {
            'Fm-3m': { c: [] },
            'Fd-3m': { c: ['0kl:k+l=4n'] },
            'Fm-3c': { c: ['hhl:l=2n'] }
        }
    },
    tetragonal: {
        'P': {
            'P4/mmm': { c: [] },
            'P4/mcc': { c: ['hhl:l=2n', '0kl:l=2n'] },
            'P4/nmm': { c: ['hk0:h+k=2n'] },
            'P4_2/mcm': { c: ['0kl:l=2n', 'hhl:l=2n'] },
            'P4_2/mnm': { c: ['0kl:k+l=2n', 'h00:h=2n'] }
        },
        'I': {
            'I4/mmm': { c: [] },
            'I4/mcm': { c: ['0kl:l=2n', 'hhl:l=2n'] },
            'I4_1/amd': { c: ['hkl:2h+l=4n', 'hk0:h=2n,k=2n'] },
            'I4_1/acd': { c: ['hkl:2h+l=4n', 'hk0:h=2n,k=2n', '0kl:k=2n,l=2n'] }
        }
    },
    hexagonal: {
        'P': {
            'P6/mmm': { c: [] },
            'P6/mcc': { c: ['h-hl:l=2n', '00l:l=2n'] },
            'P6_3/mmc': { c: ['00l:l=2n'] },
            'P6_3/mcm': { c: ['h-hl:l=2n', '00l:l=2n'] }
        },
        'R': {
            'R-3m': { c: [] },
            'R-3c': { c: ['h-hl:l=2n'] }
        }
    },
    orthorhombic: {
        'P': {
            'Pmmm': { c: [] },
            'Pnnn': { c: ['0kl:k+l=2n', 'h0l:h+l=2n', 'hk0:h+k=2n'] },
            'Pccn': { c: ['h0l:l=2n', '0kl:k=2n'] },
            'Pbca': { c: ['0kl:k=2n', 'h0l:l=2n', 'hk0:h=2n'] },
            'Pnma': { c: ['0kl:k+l=2n', 'hk0:h=2n'] }
        },
        'I': {
            'Immm': { c: [] },
            'Ibca': { c: ['0kl:k=2n', 'h0l:l=2n'] },
            'Imma': { c: ['0kl:k+l=2n'] }
        },
        'F': {
            'Fmmm': { c: [] },
            'Fddd': { c: ['0kl:k+l=4n', 'h0l:h+l=4n', 'hk0:h+k=4n'] }
        },
        'C': {
            'Cmmm': { c: [] },
            'Cmce': { c: ['0kl:l=2n', 'h0l:h+l=2n'] },
            'Cccm': { c: ['h0l:l=2n'] }
        }
    },
    monoclinic: {
        'P': {
            'P2/m': { c: [] },
            'P2_1/m': { c: ['0k0:k=2n'] },
            'P2/c': { c: ['h0l:l=2n'] },
            'P2_1/c': { c: ['h0l:l=2n', '0k0:k=2n'] }
        },
        'C': {
            'C2/m': { c: [] },
            'C2/c': { c: ['h0l:l=2n'] }
        }
    }
};


            const q_from_tth = (tth) => {
                const d = wavelength / (2 * Math.sin(tth * Math.PI / 360));
                return 1 / (d * d);
            };

            const get_q_tolerance = (tth) => {
                const q_plus = q_from_tth(tth + tth_error);
                const q_minus = q_from_tth(tth - tth_error);
                return Math.abs(q_plus - q_minus) / 2;
            };

            const calculateM20 = (q_calc_sorted) => {
                let N_indexed = 0;
                let sum_delta_q = 0;
                for(let i=0; i < N_FOR_M20; i++){
                    const q_o = q_obs[i];
                    const tolerance = get_q_tolerance(tth_obs[i]);
                    let min_diff = Infinity;
                    let found = false;
                    for(const q_c of q_calc_sorted){
                        const diff = Math.abs(q_o - q_c);
                        if(diff < tolerance){
                           min_diff = Math.min(min_diff, diff);
                           found = true;
                        }
                    }
                    if(found) {
                        N_indexed++;
                        sum_delta_q += min_diff;
                    }
                }

                const unindexed_peaks = N_FOR_M20 - N_indexed;
                if (unindexed_peaks > impurity_peaks) return 0;

                if (N_indexed === 0) return 0;

                const q_n = q_obs[N_FOR_M20 - 1];
                const N_calc = q_calc_sorted.filter(q => q <= q_n * 1.05).length;
                if (N_calc === 0) return 0;
                const avg_delta_q = sum_delta_q / N_indexed;
                if (avg_delta_q === 0) return 0;

                return q_n / (2 * avg_delta_q * N_calc);
            };

            const testSolution = (params) => {
                const {a, b, c, alpha, beta, gamma, system} = params;


                                // For monoclinic, ensure beta is obtuse
                if (system === 'monoclinic' && beta < 90.0) {
                    const beta_rad = beta * Math.PI / 180;
                    const a_new = Math.sqrt(a*a + c*c + 2*a*c*Math.cos(beta_rad));
                    const beta_new = 180.0 - beta;
                    
                    // Update the parameters for the rest of the function
                    a = a_new;
                    beta = beta_new;
                }


                if (a < min_lattice_param || (b && b < min_lattice_param) || (c && c < min_lattice_param)) {
                    return;
                }

                let volume = 0;
                switch(system){
                    case 'cubic': volume = a*a*a; break;
                    case 'tetragonal': volume = a*a*c; break;
                    case 'hexagonal': volume = a*a*c * Math.sqrt(3)/2; break;
                    case 'orthorhombic': volume = a*b*c; break;
                    case 'monoclinic': volume = a*b*c*Math.sin(beta * Math.PI / 180); break;
                }
                if (volume > max_volume || volume < 1) return;

                const q_calc = new Set();
                for (let h = 0; h <= max_hkl_indexing; h++) {
                    for (let k = 0; k <= max_hkl_indexing; k++) {
                        for (let l = 0; l <= max_hkl_indexing; l++) {
                             if (system === 'cubic' && (k > h || l > k)) continue;
                             if ((system === 'tetragonal' || system === 'hexagonal') && k > h) continue;
                            if (h === 0 && k === 0 && l === 0) continue;
                            let q = 0;
                            switch (system) {
                                case 'cubic': q = (h*h + k*k + l*l) / (a*a); break;
                                case 'tetragonal': q = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                                case 'hexagonal': q = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                                case 'orthorhombic': q = h*h/(a*a) + k*k/(b*b) + l*l/(c*c); break;
                                case 'monoclinic':
                                     const sinBeta = Math.sin(beta * Math.PI / 180);
                                     const cosBeta = Math.cos(beta * Math.PI / 180);
                                     q = (1/(sinBeta*sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + k*k/(b*b);
                                     break;
                            }
                            if(q > 0) q_calc.add(q);
                        }
                    }
                }
                const q_calc_sorted = Array.from(q_calc).sort((x, y) => x - y);
                const m20 = calculateM20(q_calc_sorted);

                if (m20 > min_m20) {
                    const analysis = analyzeSystematicAbsences(params, peaks);
                    const newSolution = {...params, volume, m20, analysis};

                    let isDuplicate = foundSolutions.some(existing => {
                        if (existing.system !== system) return false;
                        if (system === 'cubic') {
                            return Math.abs(a - existing.a) / a < DUPLICATE_TOLERANCE;
                        } else if (system === 'tetragonal' || system === 'hexagonal') {
                            return Math.abs(a - existing.a) / a < DUPLICATE_TOLERANCE && Math.abs(c - existing.c) / c < DUPLICATE_TOLERANCE;
                        } else if (system === 'orthorhombic') {
                            const newParams = [a, b, c].sort((x,y) => x-y);
                            const existingParams = [existing.a, existing.b, existing.c].sort((x,y) => x-y);
                            return newParams.every((p, idx) => Math.abs(p - existingParams[idx]) / p < DUPLICATE_TOLERANCE);
                        } else if (system === 'monoclinic') {
                            return Math.abs(volume - existing.volume) / volume < DUPLICATE_TOLERANCE && Math.abs(beta - existing.beta) / beta < DUPLICATE_TOLERANCE;
                        }
                        return false;
                    });

                    if (!isDuplicate) {
                        foundSolutions.push(newSolution);
                        self.postMessage({ type: 'solution', payload: newSolution });
                    }
                }
            };

            const analyzeSystematicAbsences = (solution, obs_peaks) => {
                const { system } = solution;
                const all_hkls = generateHKL_for_analysis(solution, wavelength, Math.max(...obs_peaks.map(p=>p.tth)));
                const obs_hkl_list = [];
                const used_peaks = new Set();
                all_hkls.forEach(hkl => {
                    let bestMatch = null; let minDiff = Infinity;
                    obs_peaks.forEach((peak, index) => {
                        if (used_peaks.has(index)) return;
                        const diff = Math.abs(hkl.d - peak.d);
                        if (diff < minDiff) { minDiff = diff; bestMatch = { peak, index }; }
                    });
                    if (bestMatch) {
                        const tolerance = get_q_tolerance(bestMatch.peak.tth);
                        const d_tolerance = Math.abs(1/Math.sqrt(bestMatch.peak.q + tolerance) - 1/Math.sqrt(bestMatch.peak.q - tolerance)) / 2;
                        if (minDiff < d_tolerance) {
                           obs_hkl_list.push(hkl); used_peaks.add(bestMatch.index);
                        }
                    }
                });

                let centering = 'Primitive (P)';
                if (obs_hkl_list.length >= 3) {
                     if (system === 'cubic' || system === 'tetragonal' || system === 'orthorhombic') {
                        const violates_I = obs_hkl_list.some(({h,k,l}) => (h+k+l) % 2 !== 0);
                        const violates_F = obs_hkl_list.some(({h,k,l}) => !((h%2===k%2)&&(k%2===l%2)));
                        if (!violates_F) centering = 'Face (F)';
                        else if (!violates_I) centering = 'Body (I)';
                     }
                    if ((system === 'orthorhombic' || system === 'monoclinic') && centering === 'Primitive (P)' && !obs_hkl_list.some(({h,k,l}) => (h+k) % 2 !== 0)) centering = 'C-Face (C)';
                    if (system === 'hexagonal' && (!obs_hkl_list.some(({h,k,l}) => (-h+k+l)%3!==0) || !obs_hkl_list.some(({h,k,l}) => (h-k+l)%3!==0))) centering = 'Rhombohedral (R)';
                }
                const centerChar = centering.charAt(centering.indexOf('(')+1);

                const foundConditions = new Set();
                const check = (filter, rule) => {
                    const subset = obs_hkl_list.filter(filter);
                    return subset.length === 0 || !subset.some(rule);
                };
                if (check(p => p.h !== 0 && p.k===0 && p.l===0, p => p.h%2 !== 0)) foundConditions.add('h00:h=2n');
                if (check(p => p.k !== 0 && p.h===0 && p.l===0, p => p.k%2 !== 0)) foundConditions.add('0k0:k=2n');
                if (check(p => p.l !== 0 && p.h===0 && p.k===0, p => p.l%2 !== 0)) foundConditions.add('00l:l=2n');
                if (check(p => p.h!==0 && p.k!==0 && p.l===0, p => (p.h+p.k)%2 !== 0)) foundConditions.add('hk0:h+k=2n');
                if (check(p => p.k!==0 && p.l!==0 && p.h===0, p => (p.k+p.l)%2 !== 0)) foundConditions.add('0kl:k+l=2n');
                if (check(p => p.h!==0 && p.l!==0 && p.k===0, p => (p.h+p.l)%2 !== 0)) foundConditions.add('h0l:h+l=2n');
                 if (system === 'monoclinic' && check(p => p.h!==0 && p.l!==0 && p.k===0, p => p.l%2 !== 0)) foundConditions.add('h0l:l=2n');
                if (check(p => p.h===p.k && p.l!==0, p => p.l%2 !== 0)) foundConditions.add('hhl:l=2n');
                if (check(p => p.h===-p.k && p.l!==0, p => p.l%2 !== 0)) foundConditions.add('h-hl:l=2n');

                const sg_block = spaceGroupData[system]?.[centerChar] || {};
                const possibleSpaceGroups = Object.keys(sg_block);
                const probableSpaceGroups = possibleSpaceGroups.filter(sg =>
                    (sg_block[sg].c || []).every(cond => foundConditions.has(cond))
                );

                return { centering, conditions: Array.from(foundConditions), possibleSpaceGroups, probableSpaceGroups };
            };

            const generateHKL_for_analysis = (params, lambda, maxTth) => {
                 const { a, b, c, beta, system } = params;
                 const reflections = [];
                 for (let h = -max_hkl_analysis; h <= max_hkl_analysis; h++) {
                     for (let k = -max_hkl_analysis; k <= max_hkl_analysis; k++) {
                         for (let l = -max_hkl_analysis; l <= max_hkl_analysis; l++) {
                             if (h === 0 && k === 0 && l === 0) continue;
                             let inv_d_sq = 0;
                             switch (system) {
                                 case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                                 case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                                 case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                                 case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                                 case 'monoclinic':
                                     const sinBeta = Math.sin(beta * Math.PI / 180);
                                     const cosBeta = Math.cos(beta * Math.PI / 180);
                                     inv_d_sq = (1/(sinBeta*sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + k*k/(b*b);
                                     break;
                             }
                             if (inv_d_sq > 0) {
                                  const d = 1 / Math.sqrt(inv_d_sq);
                                  const sinThetaSq = (lambda * lambda / 4) * inv_d_sq;
                                  if (sinThetaSq <= 1) {
                                     const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                                     if(tth <= maxTth*1.05) reflections.push({ tth, h, k, l, d });
                                  }
                             }
                         }
                     }
                 }
                 return reflections.sort((a, b) => a.tth - b.tth);
            };

            const indexCubic = () => {
                for (let i = 0; i < Math.min(cubic_search_depth, q_obs.length); i++) {
                    for (let h = 1; h <= max_hkl_indexing; h++) {
                        for (let k = 0; k <= h; k++) {
                            for (let l = 0; l <= k; l++) {
                                const S = h * h + k * k + l * l;
                                if (S === 0) continue;
                                testSolution({a: Math.sqrt(S / q_obs[i]), system: 'cubic', alpha: 90, beta: 90, gamma: 90});
                            }
                        }
                    }
                }
            };
            const indexTetragonal = () => {
                for (let i = 0; i < Math.min(tetra_hexa_i_depth, q_obs.length); i++) {
                    for (let j = i + 1; j < Math.min(tetra_hexa_j_depth, q_obs.length); j++) {
                        for (let h1 = 0; h1 <= max_hkl_indexing; h1++) {
                            for (let k1 = 0; k1 <= h1; k1++) {
                                for (let l1 = 0; l1 <= max_hkl_indexing; l1++) {
                                    if (h1 === 0 && k1 === 0 && l1 === 0) continue;
                                    const S1 = h1*h1 + k1*k1;
                                    for (let h2 = 0; h2 <= max_hkl_indexing; h2++) {
                                        for (let k2 = 0; k2 <= h2; k2++) {
                                            for (let l2 = 0; l2 <= max_hkl_indexing; l2++) {
                                                if (h2 === 0 && k2 === 0 && l2 === 0) continue;
                                                const S2 = h2*h2 + k2*k2;
                                                const det = S1 * l2*l2 - S2 * l1*l1;
                                                if (Math.abs(det) < 1e-6) continue;
                                                const a_sq_inv = (q_obs[i] * l2*l2 - q_obs[j] * l1*l1) / det;
                                                const c_sq_inv = (q_obs[j] * S1 - q_obs[i] * S2) / det;
                                                if (a_sq_inv > 0 && c_sq_inv > 0) {
                                                    testSolution({a: 1/Math.sqrt(a_sq_inv), c: 1/Math.sqrt(c_sq_inv), system: 'tetragonal', alpha: 90, beta: 90, gamma: 90});
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
            const indexHexagonal = () => {
                for (let i = 0; i < Math.min(tetra_hexa_i_depth, q_obs.length); i++) {
                    for (let j = i + 1; j < Math.min(tetra_hexa_j_depth, q_obs.length); j++) {
                        for (let h1 = 0; h1 <= max_hkl_indexing; h1++) {
                            for (let k1 = 0; k1 <= h1; k1++) {
                                for (let l1 = 0; l1 <= max_hkl_indexing; l1++) {
                                    if(h1 === 0 && k1 === 0 && l1 === 0) continue;
                                    const S1 = h1*h1 + h1*k1 + k1*k1;
                                    for(let h2 = 0; h2 <= max_hkl_indexing; h2++) {
                                        for(let k2 = 0; k2 <= h2; k2++) {
                                            for(let l2 = 0; l2 <= max_hkl_indexing; l2++) {
                                                if(h2 === 0 && k2 === 0 && l2 === 0) continue;
                                                const S2 = h2*h2 + h2*k2 + k2*k2;
                                                const det = S1*l2*l2 - S2*l1*l1;
                                                if(Math.abs(det) < 1e-6) continue;
                                                const a_term = (q_obs[i]*l2*l2 - q_obs[j]*l1*l1) / det;
                                                const c_inv = (q_obs[j]*S1 - q_obs[i]*S2) / det;
                                                if(a_term > 0 && c_inv > 0) {
                                                    testSolution({a: Math.sqrt(4/(3*a_term)), c: Math.sqrt(1/c_inv), system: 'hexagonal', alpha: 90, beta: 90, gamma: 120});
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
            
            // --- Helper for matrix operations for Orthorhombic and Monoclinic ---
            // Solves M * x = q for x using the pseudoinverse method.
            const solveLeastSquares = (M, q_vec) => {
                const num_eq = M.length;
                if (num_eq === 0) return null;
                const num_params = M[0].length;
                if (num_eq < num_params) return null;

                // Transpose M
                const MT = Array(num_params).fill(0).map(() => Array(num_eq).fill(0));
                for (let i = 0; i < num_params; i++) {
                    for (let j = 0; j < num_eq; j++) {
                        MT[i][j] = M[j][i];
                    }
                }
                
                // M^T * M
                const MTM = Array(num_params).fill(0).map(() => Array(num_params).fill(0));
                for (let i = 0; i < num_params; i++) {
                    for (let j = 0; j < num_params; j++) {
                        let sum = 0;
                        for (let k = 0; k < num_eq; k++) sum += MT[i][k] * M[k][j];
                        MTM[i][j] = sum;
                    }
                }

                // Invert MTM
                let det;
                if (num_params === 3) {
                    det = MTM[0][0]*(MTM[1][1]*MTM[2][2] - MTM[2][1]*MTM[1][2]) -
                          MTM[0][1]*(MTM[1][0]*MTM[2][2] - MTM[1][2]*MTM[2][0]) +
                          MTM[0][2]*(MTM[1][0]*MTM[2][1] - MTM[1][1]*MTM[2][0]);
                } else if (num_params === 4) {
                    const m = MTM;
                    det = m[0][0]*(m[1][1]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])+m[1][3]*(m[2][1]*m[3][2]-m[2][2]*m[3][1]))
                        - m[0][1]*(m[1][0]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][2]-m[2][2]*m[3][0]))
                        + m[0][2]*(m[1][0]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])-m[1][1]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))
                        - m[0][3]*(m[1][0]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])-m[1][1]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])+m[1][2]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]));
                } else { return null; }

                if (Math.abs(det) < 1e-9) return null;
                const invDet = 1.0 / det;
                const MTM_inv = Array(num_params).fill(0).map(() => Array(num_params).fill(0));

                if (num_params === 3) {
                     MTM_inv[0][0] = (MTM[1][1]*MTM[2][2] - MTM[2][1]*MTM[1][2])*invDet;
                     MTM_inv[0][1] = (MTM[0][2]*MTM[2][1] - MTM[0][1]*MTM[2][2])*invDet;
                     MTM_inv[0][2] = (MTM[0][1]*MTM[1][2] - MTM[0][2]*MTM[1][1])*invDet;
                     MTM_inv[1][0] = (MTM[1][2]*MTM[2][0] - MTM[1][0]*MTM[2][2])*invDet;
                     MTM_inv[1][1] = (MTM[0][0]*MTM[2][2] - MTM[0][2]*MTM[2][0])*invDet;
                     MTM_inv[1][2] = (MTM[0][2]*MTM[1][0] - MTM[0][0]*MTM[1][2])*invDet;
                     MTM_inv[2][0] = (MTM[1][0]*MTM[2][1] - MTM[2][0]*MTM[1][1])*invDet;
                     MTM_inv[2][1] = (MTM[0][1]*MTM[2][0] - MTM[0][0]*MTM[2][1])*invDet;
                     MTM_inv[2][2] = (MTM[0][0]*MTM[1][1] - MTM[0][1]*MTM[1][0])*invDet;
                } else { // 4x4 adjugate
                    const m = MTM;
                    MTM_inv[0][0] = (m[1][1]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])+m[1][3]*(m[2][1]*m[3][2]-m[2][2]*m[3][1]))*invDet;
                    MTM_inv[0][1] = -(m[0][1]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[0][2]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])+m[0][3]*(m[2][1]*m[3][2]-m[2][2]*m[3][1]))*invDet;
                    MTM_inv[0][2] = (m[0][1]*(m[1][2]*m[3][3]-m[1][3]*m[3][2])-m[0][2]*(m[1][1]*m[3][3]-m[1][3]*m[3][1])+m[0][3]*(m[1][1]*m[3][2]-m[1][2]*m[3][1]))*invDet;
                    MTM_inv[0][3] = -(m[0][1]*(m[1][2]*m[2][3]-m[1][3]*m[2][2])-m[0][2]*(m[1][1]*m[2][3]-m[1][3]*m[2][1])+m[0][3]*(m[1][1]*m[2][2]-m[1][2]*m[2][1]))*invDet;
                    MTM_inv[1][0] = -(m[1][0]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][2]-m[2][2]*m[3][0]))*invDet;
                    MTM_inv[1][1] = (m[0][0]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[0][2]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[0][3]*(m[2][0]*m[3][2]-m[2][2]*m[3][0]))*invDet;
                    MTM_inv[1][2] = -(m[0][0]*(m[1][2]*m[3][3]-m[1][3]*m[3][2])-m[0][2]*(m[1][0]*m[3][3]-m[1][3]*m[3][0])+m[0][3]*(m[1][0]*m[3][2]-m[1][2]*m[3][0]))*invDet;
                    MTM_inv[1][3] = (m[0][0]*(m[1][2]*m[2][3]-m[1][3]*m[2][2])-m[0][2]*(m[1][0]*m[2][3]-m[1][3]*m[2][0])+m[0][3]*(m[1][0]*m[2][2]-m[1][2]*m[2][0]))*invDet;
                    MTM_inv[2][0] = (m[1][0]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])-m[1][1]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet;
                    MTM_inv[2][1] = -(m[0][0]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])-m[0][1]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[0][3]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet;
                    MTM_inv[2][2] = (m[0][0]*(m[1][1]*m[3][3]-m[1][3]*m[3][1])-m[0][1]*(m[1][0]*m[3][3]-m[1][3]*m[3][0])+m[0][3]*(m[1][0]*m[3][1]-m[1][1]*m[3][0]))*invDet;
                    MTM_inv[2][3] = -(m[0][0]*(m[1][1]*m[2][3]-m[1][3]*m[2][1])-m[0][1]*(m[1][0]*m[2][3]-m[1][3]*m[2][0])+m[0][3]*(m[1][0]*m[2][1]-m[1][1]*m[2][0]))*invDet;
                    MTM_inv[3][0] = -(m[1][0]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])-m[1][1]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])+m[1][2]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet;
                    MTM_inv[3][1] = (m[0][0]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])-m[0][1]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])+m[0][2]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet;
                    MTM_inv[3][2] = -(m[0][0]*(m[1][1]*m[3][2]-m[1][2]*m[3][1])-m[0][1]*(m[1][0]*m[3][2]-m[1][2]*m[3][0])+m[0][2]*(m[1][0]*m[3][1]-m[1][1]*m[3][0]))*invDet;
                    MTM_inv[3][3] = (m[0][0]*(m[1][1]*m[2][2]-m[1][2]*m[2][1])-m[0][1]*(m[1][0]*m[2][2]-m[1][2]*m[2][0])+m[0][2]*(m[1][0]*m[2][1]-m[1][1]*m[2][0]))*invDet;
                }

                // M^T * q
                const MTq = Array(num_params).fill(0);
                 for (let i = 0; i < num_params; i++) {
                    let sum = 0;
                    for (let j = 0; j < num_eq; j++) sum += MT[i][j] * q_vec[j];
                    MTq[i] = sum;
                }

                // x = (M^T * M)^-1 * (M^T * q)
                const x = Array(num_params).fill(0);
                 for (let i = 0; i < num_params; i++) {
                    let sum = 0;
                    for (let j = 0; j < num_params; j++) sum += MTM_inv[i][j] * MTq[j];
                    x[i] = sum;
                }
                return x;
            };

            const indexOrthorhombic = () => {
                const max_peaks_basis = Math.min(15, q_obs.length);
                const min_indexed_for_fit = 6;
                const max_hkl_main = 6;

                const hkl_triplets = [];
                for (let h = 0; h <= max_hkl_main; h++) for (let k = 0; k <= max_hkl_main; k++) for (let l = 0; l <= max_hkl_main; l++) {
                    if (h === 0 && k === 0 && l === 0) continue;
                    hkl_triplets.push([h, k, l]);
                }
                hkl_triplets.sort((a, b) => (a[0]**2 + a[1]**2 + a[2]**2) - (b[0]**2 + b[1]**2 + b[2]**2));
                
                const basis_hkls = hkl_triplets.slice(0, 30);

                for (let i = 0; i < max_peaks_basis - 2; i++) {
                    for (let j = i + 1; j < max_peaks_basis - 1; j++) {
                        for (let k = j + 1; k < max_peaks_basis; k++) {
                            for (let n1 = 0; n1 < basis_hkls.length - 2; n1++) {
                                for (let n2 = n1 + 1; n2 < basis_hkls.length - 1; n2++) {
                                    for (let n3 = n2 + 1; n3 < basis_hkls.length; n3++) {
                                        
                                        const hkl_basis = [basis_hkls[n1], basis_hkls[n2], basis_hkls[n3]];
                                        const M = hkl_basis.map(hkl => [hkl[0]**2, hkl[1]**2, hkl[2]**2]);
                                        const q_vec = [q_obs[i], q_obs[j], q_obs[k]];
                                        const solution = solveLeastSquares(M, q_vec);
                                        
                                        if (!solution || solution.some(s => s <=0)) continue;
                                        
                                        const rough_params = {a: 1/Math.sqrt(solution[0]), b: 1/Math.sqrt(solution[1]), c: 1/Math.sqrt(solution[2])};
                                        if (rough_params.a * rough_params.b * rough_params.c > max_volume) continue;
                                        
                                        // Tentatively index
                                        const indexed_pairs = [];
                                        const used_q_indices = new Set();
                                        for (let peak_idx = 0; peak_idx < Math.min(20, q_obs.length); peak_idx++) {
                                            if (used_q_indices.has(peak_idx)) continue;
                                            const current_q_obs = q_obs[peak_idx];
                                            const tolerance = get_q_tolerance(tth_obs[peak_idx]) * 10;
                                            let best_match = null; let min_diff = Infinity;
                                            for (const hkl of hkl_triplets) {
                                                const q_calc = hkl[0]**2/(rough_params.a**2) + hkl[1]**2/(rough_params.b**2) + hkl[2]**2/(rough_params.c**2);
                                                const diff = Math.abs(q_calc - current_q_obs);
                                                if (diff < tolerance && diff < min_diff) { min_diff = diff; best_match = hkl; }
                                                if (q_calc > current_q_obs + tolerance) break;
                                            }
                                            if (best_match) { indexed_pairs.push({ q_obs: current_q_obs, hkl: best_match }); used_q_indices.add(peak_idx); }
                                        }

                                        if (indexed_pairs.length >= min_indexed_for_fit) {
                                            const M_refine = indexed_pairs.map(p => [p.hkl[0]**2, p.hkl[1]**2, p.hkl[2]**2]);
                                            const q_refine = indexed_pairs.map(p => p.q_obs);
                                            const refined_solution = solveLeastSquares(M_refine, q_refine);
                                            
                                            if (refined_solution && refined_solution.every(s => s > 0)) {
                                                testSolution({ a: 1/Math.sqrt(refined_solution[0]), b: 1/Math.sqrt(refined_solution[1]), c: 1/Math.sqrt(refined_solution[2]), system: 'orthorhombic', alpha: 90, beta: 90, gamma: 90 });
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };

            const indexMonoclinic = () => {
                const max_peaks_basis = Math.min(12, q_obs.length);
                const min_indexed_for_fit = 8;
                const max_hkl_main = 5;
                const TOLERANCE_FACTOR_MONO = 50;

                const hkl_quadruplets = [];
                for (let h = 0; h <= max_hkl_main; h++) {
                    for (let k = 0; k <= max_hkl_main; k++) {
                        for (let l = 0; l <= max_hkl_main; l++) {
                            if (h === 0 && k === 0 && l === 0) continue;
                            hkl_quadruplets.push([h, k, l]);
                        }
                    }
                }
                hkl_quadruplets.sort((a, b) => (a[0]**2 + a[1]**2 + a[2]**2) - (b[0]**2 + b[1]**2 + b[2]**2));

                const basis_hkls = hkl_quadruplets.slice(0, 25);

                // Try different beta angles
                for (let beta = 95; beta <= 125; beta += 5) {
                    const sinBeta = Math.sin(beta * Math.PI / 180);
                    const cosBeta = Math.cos(beta * Math.PI / 180);

                    for (let i = 0; i < max_peaks_basis - 3; i++) {
                        for (let j = i + 1; j < max_peaks_basis - 2; j++) {
                            for (let k = j + 1; k < max_peaks_basis - 1; k++) {
                                for (let l = k + 1; l < max_peaks_basis; l++) {
                                    for (let n1 = 0; n1 < basis_hkls.length - 3; n1++) {
                                        for (let n2 = n1 + 1; n2 < basis_hkls.length - 2; n2++) {
                                            for (let n3 = n2 + 1; n3 < basis_hkls.length - 1; n3++) {
                                                for (let n4 = n3 + 1; n4 < basis_hkls.length; n4++) {
                                                    
                                                    const hkl_basis = [basis_hkls[n1], basis_hkls[n2], basis_hkls[n3], basis_hkls[n4]];
                                                    const M = hkl_basis.map(hkl => [
                                                        hkl[0]**2,
                                                        hkl[1]**2,
                                                        hkl[2]**2,
                                                        -2 * hkl[0] * hkl[2] * cosBeta
                                                    ]);
                                                    const q_vec = [q_obs[i], q_obs[j], q_obs[k], q_obs[l]];
                                                    const solution = solveLeastSquares(M, q_vec);
                                                    
                                                    if (!solution || solution.some((s, idx) => idx < 3 ? s <= 0 : false)) continue;
                                                    
                                                    const a_sq_inv = solution[0] / (sinBeta * sinBeta);
                                                    const b_sq_inv = solution[1];
                                                    const c_sq_inv = solution[2] / (sinBeta * sinBeta);
                                                    const cross_term = solution[3] / (sinBeta * sinBeta);
                                                    
                                                    if (a_sq_inv <= 0 || b_sq_inv <= 0 || c_sq_inv <= 0) continue;
                                                    
                                                    const rough_params = {
                                                        a: 1/Math.sqrt(a_sq_inv), 
                                                        b: 1/Math.sqrt(b_sq_inv), 
                                                        c: 1/Math.sqrt(c_sq_inv),
                                                        beta: beta
                                                    };
                                                    
                                                    const volume = rough_params.a * rough_params.b * rough_params.c * sinBeta;
                                                    if (volume > max_volume || volume < 1) continue;
                                                    if (rough_params.a < 2.7 || rough_params.b < 2.7 || rough_params.c < 2.7) continue;
                                                    
                                                    // Tentatively index with relaxed tolerance
                                                    const indexed_pairs = [];
                                                    const used_q_indices = new Set();
                                                    for (let peak_idx = 0; peak_idx < Math.min(15, q_obs.length); peak_idx++) {
                                                        if (used_q_indices.has(peak_idx)) continue;
                                                        const current_q_obs = q_obs[peak_idx];
                                                        const tolerance = get_q_tolerance(tth_obs[peak_idx]) * TOLERANCE_FACTOR_MONO;
                                                        let best_match = null; let min_diff = Infinity;
                                                        for (const hkl of hkl_quadruplets) {
                                                            const q_calc = (1/(sinBeta*sinBeta)) * 
                                                                          (hkl[0]**2/rough_params.a**2 + hkl[2]**2/rough_params.c**2 - 
                                                                           2*hkl[0]*hkl[2]*cosBeta/(rough_params.a*rough_params.c)) + 
                                                                          hkl[1]**2/rough_params.b**2;
                                                            const diff = Math.abs(q_calc - current_q_obs);
                                                            if (diff < tolerance && diff < min_diff) { 
                                                                min_diff = diff; 
                                                                best_match = hkl; 
                                                            }
                                                            if (q_calc > current_q_obs + tolerance) break;
                                                        }
                                                        if (best_match) { 
                                                            indexed_pairs.push({ q_obs: current_q_obs, hkl: best_match }); 
                                                            used_q_indices.add(peak_idx); 
                                                        }
                                                    }

                                                    if (indexed_pairs.length >= min_indexed_for_fit) {
                                                        // Try to refine beta angle by optimizing the fit
                                                        let best_beta = beta;
                                                        let best_m20 = 0;
                                                        let best_params = null;

                                                        for (let beta_refine = beta - 3; beta_refine <= beta + 3; beta_refine += 0.5) {
                                                            if (beta_refine < 85 || beta_refine > 135) continue;
                                                            
                                                            const sinBeta_ref = Math.sin(beta_refine * Math.PI / 180);
                                                            const cosBeta_ref = Math.cos(beta_refine * Math.PI / 180);
                                                            
                                                            const M_refine = indexed_pairs.map(p => [
                                                                p.hkl[0]**2,
                                                                p.hkl[1]**2,
                                                                p.hkl[2]**2,
                                                                -2 * p.hkl[0] * p.hkl[2] * cosBeta_ref
                                                            ]);
                                                            const q_refine = indexed_pairs.map(p => p.q_obs);
                                                            const refined_solution = solveLeastSquares(M_refine, q_refine);
                                                            
                                                            if (refined_solution && refined_solution.slice(0,3).every(s => s > 0)) {
                                                                const final_a_sq_inv = refined_solution[0] / (sinBeta_ref * sinBeta_ref);
                                                                const final_b_sq_inv = refined_solution[1];
                                                                const final_c_sq_inv = refined_solution[2] / (sinBeta_ref * sinBeta_ref);
                                                                
                                                                if (final_a_sq_inv > 0 && final_b_sq_inv > 0 && final_c_sq_inv > 0) {
                                                                    const test_params = {
                                                                        a: 1/Math.sqrt(final_a_sq_inv), 
                                                                        b: 1/Math.sqrt(final_b_sq_inv), 
                                                                        c: 1/Math.sqrt(final_c_sq_inv), 
                                                                        beta: beta_refine,
                                                                        system: 'monoclinic', 
                                                                        alpha: 90, 
                                                                        gamma: 90 
                                                                    };
                                                                    
                                                                    // Calculate M20 for this beta
                                                                    const q_calc_test = new Set();
                                                                    for (let h = 0; h <= 8; h++) {
                                                                        for (let k = 0; k <= 8; k++) {
                                                                            for (let l = 0; l <= 8; l++) {
                                                                                if (h === 0 && k === 0 && l === 0) continue;
                                                                                const q = (1/(sinBeta_ref*sinBeta_ref)) * 
                                                                                          (h*h/test_params.a**2 + l*l/test_params.c**2 - 
                                                                                           2*h*l*cosBeta_ref/(test_params.a*test_params.c)) + 
                                                                                          k*k/test_params.b**2;
                                                                                if (q > 0) q_calc_test.add(q);
                                                                            }
                                                                        }
                                                                    }
                                                                    const q_calc_test_sorted = Array.from(q_calc_test).sort((x, y) => x - y);
                                                                    const test_m20 = calculateM20(q_calc_test_sorted);
                                                                    
                                                                    if (test_m20 > best_m20) {
                                                                        best_m20 = test_m20;
                                                                        best_beta = beta_refine;
                                                                        best_params = test_params;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        
                                                        if (best_params && best_m20 > min_m20) {
                                                            testSolution(best_params);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };

            // Main worker execution flow
            if (systemToSearch === 'cubic') indexCubic();
            if (systemToSearch === 'tetragonal') indexTetragonal();
            if (systemToSearch === 'hexagonal') indexHexagonal();
            if (systemToSearch === 'orthorhombic') indexOrthorhombic();
            if (systemToSearch === 'monoclinic') indexMonoclinic();
            
            self.postMessage({ type: 'done' });
        };
    </script>
</body>
</html>