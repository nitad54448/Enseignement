<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Powder Indexing by Dichotomy Method</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        :root {
            --dark-bg: #111827;
            --medium-bg: #1f2937;
            --light-bg: #374151;
            --border-color: #4b5563;
            --primary-accent: #3b82f6;
            --primary-accent-hover: #2563eb;
            --text-light: #e5e7eb;
            --text-medium: #d1d5db;
            --text-dark: #9ca3af;
        }

        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f9fafb; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #app-container { display: flex; width: 100%; flex-grow: 1; min-height: 0; }
        #controls-panel { width: 450px; min-width: 350px; max-width: 600px; flex-shrink: 0; padding: 24px; background-color: var(--dark-bg); border-right: 1px solid var(--light-bg); overflow-y: auto; color: var(--text-medium); display: flex; flex-direction: column; }
        #drag-handle { width: 6px; cursor: col-resize; background-color: var(--light-bg); flex-shrink: 0; transition: background-color: 0.2s; }
        #drag-handle:hover, #drag-handle:active { background-color: var(--primary-accent); }
        #results-area { flex-grow: 1; position: relative; background-color: #ffffff; min-width: 0; display: flex; flex-direction: column; padding: 1.5rem; color: var(--medium-bg); }
        .control-group { margin-bottom: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--light-bg); }
        .control-group:first-child { border-top: none; padding-top: 0; }
        .control-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-dark); font-size: 0.875rem; }
        .control-input, .control-select { width: 100%; background-color: var(--light-bg); border: 1px solid var(--border-color); color: var(--text-light); border-radius: 0.375rem; padding: 0.5rem 0.75rem; transition: all 0.2s ease; box-sizing: border-box; }
        .control-input:focus, .control-select:focus { outline: none; border-color: var(--primary-accent); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); }
        .btn { padding: 0.6rem 1rem; border-radius: 0.375rem; font-weight: 600; transition: background-color: 0.2s; cursor: pointer; border: none; text-align: center;}
        .btn-primary { background-color: var(--primary-accent); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: var(--primary-accent-hover); }
        .btn-secondary { background-color: var(--border-color); color: white; }
        .btn-secondary:hover:not(:disabled) { background-color: #6b7280; }
        .btn:disabled { background-color: var(--border-color); cursor: not-allowed; opacity: 0.7; }
        .file-input-label { display: block; padding: 0.75rem 1rem; background-color: var(--border-color); color: var(--text-medium); border-radius: 0.375rem; text-align: center; cursor: pointer; transition: background-color: 0.2s; }
        .file-input-label:hover { background-color: #6b7280; }
        .parameter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
        .checkbox-label { display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; color: var(--text-medium); cursor: pointer;}
        #peak-table-container { max-height: 200px; overflow-y: auto; background-color: var(--medium-bg); border-radius: 0.375rem; border: 1px solid var(--border-color); margin-top: 1rem;}
        .peak-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        .peak-table th, .peak-table td { padding: 0.5rem; text-align: right; border-bottom: 1px solid var(--border-color); }
        .peak-table th { background-color: #2a3547; font-weight: 600; text-align: center; }
        .peak-table input { width: 100%; background: transparent; border: none; color: var(--text-light); text-align: right; padding: 2px; border-radius: 2px; }
        .peak-table input:focus { background-color: var(--light-bg); outline: 1px solid var(--primary-accent); }
        #solutions-table-container { flex-grow: 1; overflow-y: auto; background-color: var(--medium-bg); border-radius: 0.375rem; border: 1px solid var(--border-color); margin-top: 1rem;}
        .solutions-table { width: 100%; border-collapse: collapse; font-size: 0.75rem; }
        .solutions-table th, .solutions-table td { padding: 0.5rem; text-align: left; border-bottom: 1px solid var(--border-color); }
        .solutions-table th { background-color: #2a3547; font-weight: 600;}
        .solutions-table tbody tr { cursor: pointer; transition: background-color: 0.2s; }
        .solutions-table tbody tr:hover { background-color: var(--light-bg); }
        .solutions-table tbody tr.selected { background-color: var(--primary-accent); color: white;}
    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">
            <h1 style="font-size: 1.5rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">Powder XRD Indexing</h1>
            <p style="font-size: 0.875rem; color: var(--text-dark); margin-bottom: 1.5rem;">Determine unit cell parameters using the Dichotomy method. Based on the method of A. Boultif & D. Louer, J. Appl. Cryst. 37, 724-731 (2004)</p>
            
            <div class="control-group">
                <h2 style="font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem;">1. Load Data</h2>
                <label for="file-input" class="file-input-label">
                    <span id="file-name">Select .xy, .csv or .xrdml File</span>
                </label>
                <input type="file" id="file-input" class="hidden" accept=".xy,.csv,.txt,.xrdml">
            </div>

            <div class="control-group">
                <h2 style="font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem;">2. Find Peaks</h2>
                <div id="peak-controls" class="hidden">
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <button id="find-peaks-button" class="btn btn-secondary" style="flex-grow: 1;">Find Peaks</button>
                        <label for="peak-threshold-input" class="control-label" style="margin-bottom: 0; white-space: nowrap;">Min %:</label>
                        <input type="number" id="peak-threshold-input" class="control-input" value="2" min="0.1" max="50" step="0.1" style="width: 6rem;">
                    </div>
                    <div style="margin-top: 1rem;">
                        <label class="control-label">2θ Range for Peak Finding</label>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <input type="number" id="tth-min-input" class="control-input" style="width: 6rem; text-align: center;" disabled>
                            <div style="flex-grow: 1;">
                                <input type="range" id="tth-min-slider" disabled style="width: 100%;">
                                <input type="range" id="tth-max-slider" disabled style="width: 100%;">
                            </div>
                            <input type="number" id="tth-max-input" class="control-input" style="width: 6rem; text-align: center;" disabled>
                        </div>
                    </div>
                    <div id="peak-table-container" class="hidden">
                        <table class="peak-table">
                            <thead><tr><th>#</th><th>2θ Obs (°)</th><th>d (Å)</th><th>Del</th></tr></thead>
                            <tbody id="peak-list-body"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h2 style="font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem;">3. Indexing Parameters</h2>
                <div id="indexing-controls" class="hidden">
                     <div class="parameter-grid">
                        <div>
                            <label for="wavelength" class="control-label">Wavelength (Å)</label>
                            <input type="number" id="wavelength" value="1.54056" step="0.00001" min="0.1" class="control-input">
                        </div>
                        <div>
                            <label for="max-volume" class="control-label">Max Volume (Å³)</label>
                            <input type="number" id="max-volume" value="1000" step="100" min="100" class="control-input">
                        </div>
                    </div>
                    <div class="parameter-grid" style="margin-top: 1rem;">
                        <div>
                            <label for="tth-error" class="control-label">2θ Error (°)</label>
                            <input type="number" id="tth-error" value="0.02" step="0.005" min="0.001" class="control-input">
                        </div>
                        <div>
                            <label for="impurity-peaks" class="control-label">Impurity Peaks</label>
                            <input type="number" id="impurity-peaks" value="0" min="0" max="4" step="1" class="control-input">
                        </div>
                    </div>
                    <label class="control-label" style="margin-top: 1rem;">Crystal Systems to Search:</label>
                    <div class="parameter-grid">
                        <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="cubic" checked> Cubic</label>
                        <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="tetragonal" checked> Tetragonal</label>
                        <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="hexagonal" checked> Hexagonal</label>
                        <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="orthorhombic" checked> Orthorhombic</label>
                    </div>
                </div>
            </div>

            <div style="margin-top: auto; padding-top: 1rem;">
                <div id="progress-bar-container" class="w-full bg-gray-700 rounded-full h-2.5 my-2 hidden">
                    <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%; transition: width 0.2s;"></div>
                </div>
                <div style="display: flex; gap: 0.5rem;">
                    <button id="start-indexing-button" class="btn btn-primary" style="flex: 1; font-size: 1rem;" disabled>Find Peaks to Start</button>
                    <button id="report-button" class="btn btn-secondary" style="flex: 1; font-size: 1rem;" disabled>Generate PDF Report</button>
                </div>
            </div>
            
            <div class="control-group" style="display: flex; flex-direction: column; flex-grow: 1; min-height: 250px;">
                 <h2 style="font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem;">4. Solutions</h2>
                 <div id="solutions-table-container">
                    <table class="solutions-table">
                        <thead><tr><th>Sys.</th><th>a,b,c (Å)</th><th>α,β,γ (°)</th><th>Vol</th><th>M(20)</th></tr></thead>
                        <tbody id="solutions-table-body"></tbody>
                    </table>
                 </div>
            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="results-area">
             <div id="placeholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #6b7280;">
                <svg xmlns="http://www.w3.org/2000/svg" style="width: 4rem; height: 4rem; margin-bottom: 1rem;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                <h2 style="font-size: 1.5rem; font-weight: 600;">Awaiting Data</h2>
                <p>Load a data file to begin indexing.</p>
            </div>
            <div id="results-container" style="width: 100%; height: 100%; display: none; flex-direction: column; position: relative;">
                <canvas id="xrd-chart"></canvas>
            </div>
            <div style="position: absolute; bottom: 0.5rem; right: 1rem; font-size: 0.75rem; color: #9ca3af;">
                NitaD, Univ Paris-Saclay, 10 Sept 2025
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- UI Elements ---
            const ui = {
                fileInput: document.getElementById('file-input'),
                fileName: document.getElementById('file-name'),
                peakControls: document.getElementById('peak-controls'),
                peakThresholdInput: document.getElementById('peak-threshold-input'),
                findPeaksButton: document.getElementById('find-peaks-button'),
                peakTableContainer: document.getElementById('peak-table-container'),
                peakListBody: document.getElementById('peak-list-body'),
                indexingControls: document.getElementById('indexing-controls'),
                wavelength: document.getElementById('wavelength'),
                tthError: document.getElementById('tth-error'),
                maxVolume: document.getElementById('max-volume'),
                impurityPeaksInput: document.getElementById('impurity-peaks'),
                systemCheckboxes: document.querySelectorAll('.system-checkbox'),
                startIndexingButton: document.getElementById('start-indexing-button'),
                reportButton: document.getElementById('report-button'),
                progressBar: document.getElementById('progress-bar'),
                progressBarContainer: document.getElementById('progress-bar-container'),
                solutionsTableBody: document.getElementById('solutions-table-body'),
                chartCanvas: document.getElementById('xrd-chart'),
                placeholder: document.getElementById('placeholder'),
                resultsContainer: document.getElementById('results-container'),
                tthMinSlider: document.getElementById('tth-min-slider'),
                tthMaxSlider: document.getElementById('tth-max-slider'),
                tthMinInput: document.getElementById('tth-min-input'),
                tthMaxInput: document.getElementById('tth-max-input'),
            };

            // --- Global State ---
            let fullExperimentalData = { tth: [], intensity: [] };
            let pickedPeaks = []; // [{tth, d, q}]
            let solutions = [];
            let selectedSolution = null;
            let xrdChart;
            let isIndexing = false;
            let worker;

            // --- Input Validation ---
            const inputsToValidate = [
                { el: ui.wavelength, default: 1.54056 },
                { el: ui.maxVolume, default: 2000 },
                { el: ui.tthError, default: 0.05 },
                { el: ui.impurityPeaksInput, default: 0 },
                { el: ui.peakThresholdInput, default: 2 }
            ];

            inputsToValidate.forEach(({ el, default: defaultValue }) => {
                el.addEventListener('blur', () => {
                    const min = parseFloat(el.min);
                    const max = parseFloat(el.max);
                    let value = parseFloat(el.value);

                    if (isNaN(value)) {
                        el.value = defaultValue;
                        return;
                    }

                    if (!isNaN(min) && value < min) {
                        el.value = min;
                    }
                    if (!isNaN(max) && value > max) {
                        el.value = max;
                    }
                });
            });


            // --- Data Loading and Parsing ---
            const parseDataFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                const tth = [], intensity = [];
                lines.forEach(line => {
                    if (line.startsWith('#') || line.startsWith('//')) return;
                    const parts = line.trim().split(/[\s,;]+/);
                    if (parts.length >= 2) {
                        const x = parseFloat(parts[0]);
                        const y = parseFloat(parts[1]);
                        if (!isNaN(x) && !isNaN(y)) {
                            tth.push(x);
                            intensity.push(y);
                        }
                    }
                });
                return { tth, intensity };
            };
            
            const parseXrdmlFile = (xmlString) => {
                 const parser = new DOMParser();
                 const xmlDoc = parser.parseFromString(xmlString, "application/xml");
                 if (xmlDoc.querySelector("parsererror")) { console.error("Error parsing XRDML"); return null; }
                 
                 let wavelength = 1.5406;
                 const kAlpha1Node = xmlDoc.querySelector("kAlpha1");
                 if (kAlpha1Node?.textContent) wavelength = parseFloat(kAlpha1Node.textContent);

                 const intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts");
                 const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number);

                 const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]');
                 const startPos = parseFloat(positionsNode.querySelector("startPosition").textContent);
                 const endPos = parseFloat(positionsNode.querySelector("endPosition").textContent);
                 const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * (endPos - startPos) / (intensity.length - 1));
                 
                 return { tth, intensity, wavelength };
            };
            
            ui.fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    let parsedData;
                    if (file.name.toLowerCase().endsWith('.xrdml')) {
                        parsedData = parseXrdmlFile(evt.target.result);
                    } else {
                        parsedData = parseDataFile(evt.target.result);
                    }

                    if (!parsedData || parsedData.tth.length === 0) {
                        alert('No valid data could be parsed.');
                        return;
                    }

                    fullExperimentalData = parsedData;
                    // Normalize intensity
                    const maxIntensity = Math.max(...fullExperimentalData.intensity);
                    if (maxIntensity > 0) {
                         fullExperimentalData.intensity = fullExperimentalData.intensity.map(y => y / maxIntensity * 1000);
                    }
                    
                    if (parsedData.wavelength) {
                        ui.wavelength.value = parsedData.wavelength.toFixed(5);
                    }

                    selectedSolution = null;
                    ui.fileName.textContent = file.name;
                    ui.placeholder.style.display = 'none';
                    ui.resultsContainer.style.display = 'flex';
                    ui.peakControls.classList.remove('hidden');
                    ui.indexingControls.classList.remove('hidden');
                    initializeChart();
                    setupTthSliders();
                };
                reader.readAsText(file);
            });

            // --- Peak Picking and Filtering ---
            const setupTthSliders = () => {
                if (fullExperimentalData.tth.length === 0) return;
                const min = fullExperimentalData.tth[0];
                const max = fullExperimentalData.tth[fullExperimentalData.tth.length - 1];
                const step = (max - min) / 2000;
                
                [ui.tthMinSlider, ui.tthMaxSlider, ui.tthMinInput, ui.tthMaxInput].forEach(el => {
                    el.disabled = false;
                });

                Object.assign(ui.tthMinSlider, { min, max, step, value: min });
                Object.assign(ui.tthMaxSlider, { min, max, step, value: max });
                
                ui.tthMinInput.value = Math.floor(min);
                ui.tthMaxInput.value = Math.ceil(max);

                updatePlotRange();
            };

            const updatePlotRange = () => {
                if(!xrdChart) return;
                const min = parseFloat(ui.tthMinInput.value);
                const max = parseFloat(ui.tthMaxInput.value);
                xrdChart.options.scales.x.min = min;
                xrdChart.options.scales.x.max = max;
                
                const visibleIntensities = fullExperimentalData.intensity.filter((intensity, index) => {
                    const tth = fullExperimentalData.tth[index];
                    return tth >= min && tth <= max;
                });

                if (visibleIntensities.length > 0) {
                    const yMaxInRange = Math.max(...visibleIntensities);
                    xrdChart.options.scales.y.min = -yMaxInRange * 0.25;
                    xrdChart.options.scales.y.max = yMaxInRange * 1.1;
                } else {
                    // Fallback if no data is in range (e.g., invalid input)
                    const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
                    xrdChart.options.scales.y.min = -yMax * 0.25;
                    xrdChart.options.scales.y.max = yMax * 1.1;
                }

                xrdChart.update('none');
            };

            ui.tthMinSlider.addEventListener('input', () => {
                let minVal = parseFloat(ui.tthMinSlider.value);
                let maxVal = parseFloat(ui.tthMaxSlider.value);
                if (minVal >= maxVal) {
                    minVal = maxVal - parseFloat(ui.tthMinSlider.step);
                    ui.tthMinSlider.value = minVal;
                }
                ui.tthMinInput.value = Math.round(minVal);
                updatePlotRange();
                findPeaks();
            });
             ui.tthMaxSlider.addEventListener('input', () => {
                let minVal = parseFloat(ui.tthMinSlider.value);
                let maxVal = parseFloat(ui.tthMaxSlider.value);
                if (maxVal <= minVal) {
                    maxVal = minVal + parseFloat(ui.tthMaxSlider.step);
                    ui.tthMaxSlider.value = maxVal;
                }
                ui.tthMaxInput.value = Math.round(maxVal);
                updatePlotRange();
                findPeaks();
            });
            ui.tthMinInput.addEventListener('change', () => { if(!ui.tthMinSlider.disabled) {ui.tthMinSlider.value = ui.tthMinInput.value; updatePlotRange(); findPeaks();} });
            ui.tthMaxInput.addEventListener('change', () => { if(!ui.tthMaxSlider.disabled) {ui.tthMaxSlider.value = ui.tthMaxInput.value; updatePlotRange(); findPeaks();} });

            const findPeaks = () => {
                const intensity = fullExperimentalData.intensity;
                if (intensity.length < 3) return;

                const minTth = parseFloat(ui.tthMinInput.value);
                const maxTth = parseFloat(ui.tthMaxInput.value);
                
                let thresholdPercent = parseFloat(ui.peakThresholdInput.value);
                if (isNaN(thresholdPercent) || thresholdPercent < 0.1 || thresholdPercent > 50) {
                    thresholdPercent = 2;
                    ui.peakThresholdInput.value = 2;
                }
                const threshold = (thresholdPercent / 100) * Math.max(...intensity);
                pickedPeaks = [];
                for (let i = 1; i < intensity.length - 1; i++) {
                    const tth = fullExperimentalData.tth[i];
                    if (tth < minTth || tth > maxTth) continue;

                    if (intensity[i] > intensity[i - 1] && intensity[i] > intensity[i + 1] && intensity[i] > threshold) {
                        const lambda = parseFloat(ui.wavelength.value);
                        const d = lambda / (2 * Math.sin(tth * Math.PI / 360));
                        const q = 1 / (d * d);
                        pickedPeaks.push({ tth, d, q });
                    }
                }
                updatePeakTable();
                if (pickedPeaks.length > 0) {
                    ui.startIndexingButton.disabled = false;
                    ui.startIndexingButton.textContent = 'Start Indexing';
                } else {
                    ui.startIndexingButton.disabled = true;
                    ui.startIndexingButton.textContent = 'No Peaks Found in Range';
                }
            };
            
            const updatePeakTable = () => {
                ui.peakListBody.innerHTML = '';
                pickedPeaks.forEach((peak, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td><input type="number" class="peak-tth-input" value="${peak.tth.toFixed(4)}" data-index="${index}"></td>
                        <td><input type="number" class="peak-d-input" value="${peak.d.toFixed(5)}" data-index="${index}" disabled></td>
                        <td><button class="delete-peak-btn" data-index="${index}">X</button></td>
                    `;
                    ui.peakListBody.appendChild(row);
                });
                ui.peakTableContainer.classList.remove('hidden');
                updateAllMarkers();
            };

            ui.findPeaksButton.addEventListener('click', findPeaks);
            ui.peakThresholdInput.addEventListener('change', findPeaks);

            ui.peakListBody.addEventListener('change', (e) => {
                if (e.target.classList.contains('peak-tth-input')) {
                    const index = parseInt(e.target.dataset.index);
                    const tth = parseFloat(e.target.value);
                    const lambda = parseFloat(ui.wavelength.value);
                    const d = lambda / (2 * Math.sin(tth * Math.PI / 360));
                    const q = 1 / (d*d);
                    pickedPeaks[index] = {tth, d, q};
                    e.target.closest('tr').querySelector('.peak-d-input').value = d.toFixed(5);
                }
            });
             ui.peakListBody.addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-peak-btn')) {
                    const index = parseInt(e.target.dataset.index);
                    pickedPeaks.splice(index, 1);
                    updatePeakTable();
                }
            });


            // --- Indexing Logic (in a Web Worker) ---
            const startIndexing = () => {
                if (isIndexing) {
                    worker.terminate();
                    setUIState(false);
                    return;
                }
                if (pickedPeaks.length < 4) {
                    alert("Please find at least 4 peaks before starting indexing.");
                    return;
                }
                
                setUIState(true);
                solutions = [];
                selectedSolution = null;
                updateSolutionsTable();

                const params = {
                    peaks: pickedPeaks,
                    wavelength: parseFloat(ui.wavelength.value),
                    tth_error: parseFloat(ui.tthError.value),
                    max_volume: parseFloat(ui.maxVolume.value),
                    impurity_peaks: parseInt(ui.impurityPeaksInput.value, 10),
                    systems: Array.from(ui.systemCheckboxes).filter(cb => cb.checked).map(cb => cb.value)
                };

                const workerScript = document.getElementById('indexing-worker').textContent;
                const blob = new Blob([workerScript], { type: 'application/javascript' });
                worker = new Worker(URL.createObjectURL(blob));

                worker.onmessage = (e) => {
                    const { type, payload } = e.data;
                    if (type === 'progress') {
                        ui.progressBar.style.width = `${payload * 100}%`;
                    } else if (type === 'solution') {
                        solutions.push(payload);
                        solutions.sort((a,b) => b.m20 - a.m20);
                        updateSolutionsTable();
                    } else if (type === 'done') {
                        setUIState(false);
                        worker.terminate();
                        if (solutions.length > 0) {
                            ui.reportButton.disabled = false;
                        }
                    }
                };
                
                worker.postMessage(params);
            };
            
            ui.startIndexingButton.addEventListener('click', startIndexing);
            
            // --- UI Updates ---
            const setUIState = (indexing) => {
                isIndexing = indexing;
                document.body.style.cursor = indexing ? 'wait' : 'default';
                ui.startIndexingButton.textContent = indexing ? 'Stop Indexing' : 'Start Indexing';
                ui.reportButton.disabled = true; // Always disable report button when starting/stopping

                const controlsToDisable = [
                    ui.fileInput,
                    ui.findPeaksButton,
                    ui.peakThresholdInput,
                    ui.tthMinSlider,
                    ui.tthMaxSlider,
                    ui.tthMinInput,
                    ui.tthMaxInput,
                    ui.wavelength,
                    ui.tthError,
                    ui.maxVolume,
                    ui.impurityPeaksInput,
                    ...ui.systemCheckboxes,
                ];

                controlsToDisable.forEach(el => {
                    if (el) el.disabled = indexing;
                });

                // Disable peak table inputs and buttons
                ui.peakListBody.querySelectorAll('input, button').forEach(el => {
                    el.disabled = indexing;
                });
                
                const fileLabel = document.querySelector('.file-input-label');
                if (fileLabel) {
                    fileLabel.style.pointerEvents = indexing ? 'none' : 'auto';
                    fileLabel.style.opacity = indexing ? '0.7' : '1';
                }

                if (indexing) {
                    ui.progressBarContainer.classList.remove('hidden');
                } else {
                    ui.progressBarContainer.classList.add('hidden');
                    ui.progressBar.style.width = '0%';
                    // Special handling to re-enable sliders only if data is loaded
                    if (fullExperimentalData.tth.length > 0) {
                        ui.tthMinSlider.disabled = false;
                        ui.tthMaxSlider.disabled = false;
                        ui.tthMinInput.disabled = false;
                        ui.tthMaxInput.disabled = false;
                    }
                }
            };

            const updateSolutionsTable = () => {
                ui.solutionsTableBody.innerHTML = '';
                solutions.slice(0, 20).forEach((sol) => {
                    const originalIndex = solutions.indexOf(sol);
                    const row = document.createElement('tr');
                    row.dataset.index = originalIndex;
                    
                    const params_a = sol.a.toFixed(4);
                    const params_b = sol.b ? sol.b.toFixed(4) : '';
                    const params_c = sol.c ? sol.c.toFixed(4) : '';
                    let cell_params1 = `${params_a}`;
                    if(params_b) cell_params1 += `, ${params_b}`;
                    if(params_c) cell_params1 += `, ${params_c}`;

                    const params_alpha = sol.alpha ? sol.alpha.toFixed(2) : '90';
                    const params_beta = sol.beta ? sol.beta.toFixed(2) : '90';
                    const params_gamma = sol.gamma ? sol.gamma.toFixed(2) : '90';
                    let cell_params2 = `${params_alpha}, ${params_beta}, ${params_gamma}`;
                    
                    row.innerHTML = `
                        <td>${sol.system.substring(0,4)}</td>
                        <td>${cell_params1}</td>
                        <td>${cell_params2}</td>
                        <td>${sol.volume.toFixed(2)}</td>
                        <td>${sol.m20.toFixed(2)}</td>
                    `;
                    ui.solutionsTableBody.appendChild(row);
                });
            };

            ui.solutionsTableBody.addEventListener('click', (e) => {
                const row = e.target.closest('tr');
                if (!row) return;

                document.querySelectorAll('#solutions-table-body tr').forEach(r => r.classList.remove('selected'));
                row.classList.add('selected');

                const index = parseInt(row.dataset.index);
                selectedSolution = solutions[index];
                updateAllMarkers();
            });

            // --- Charting ---
            const initializeChart = () => {
                if (xrdChart) xrdChart.destroy();
                const experimentalPoints = fullExperimentalData.tth.map((t, i) => ({ x: t, y: fullExperimentalData.intensity[i] }));
                const yMax = Math.max(...fullExperimentalData.intensity);

                xrdChart = new Chart(ui.chartCanvas, {
                    type: 'line',
                    data: {
                        datasets: [
                            { 
                                label: 'Experimental', 
                                data: experimentalPoints, 
                                borderColor: 'rgba(107, 114, 128, 0.7)', 
                                borderWidth: 1.5, 
                                pointRadius: 0 
                            },
                            { 
                                type: 'bar', 
                                label: 'Observed Peaks', 
                                data: [], 
                                backgroundColor: 'rgba(239, 68, 68, 0.7)', 
                                barThickness: 2 
                            },
                            { 
                                type: 'bar', 
                                label: 'Calculated Peaks', 
                                data: [], 
                                backgroundColor: 'rgba(59, 130, 246, 0.9)', 
                                barThickness: 1 
                            }
                        ]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false, animation: false,
                        interaction: {
                            intersect: false,
                            mode: 'index',
                        },
                        scales: {
                            x: { type: 'linear', title: { display: true, text: '2-theta (degrees)' } },
                            y: { title: { display: true, text: 'Intensity (a.u.)' }, min: -yMax * 0.15, max: yMax * 1.1 }
                        },
                        plugins: { 
                            legend: { position: 'top' },
                            tooltip: {
                                // Corrected tooltip behavior
                                filter: function (tooltipItem) {
                                    // Only show tooltips for the first dataset (experimental line)
                                    return tooltipItem.datasetIndex === 0;
                                }
                            }
                        }
                    }
                });
            };

            const updateAllMarkers = () => {
                if (!xrdChart) return;

                // Get visible range and calculate yMax for scaling
                const minX = xrdChart.options.scales.x.min;
                const maxX = xrdChart.options.scales.x.max;
                const visibleIntensities = fullExperimentalData.intensity.filter((_, index) => {
                    const tth = fullExperimentalData.tth[index];
                    return tth >= minX && tth <= maxX;
                });
                const yMax = visibleIntensities.length > 0 ? Math.max(...visibleIntensities) : (Math.max(...fullExperimentalData.intensity) || 1000);

                const markerHeight = yMax * 0.04;

                // Update Observed Peaks (red)
                const obsMarkers = pickedPeaks.map(p => ({ x: p.tth, y: [-markerHeight * 0.25, -markerHeight * 1.25] }));
                xrdChart.data.datasets[1].data = obsMarkers;

                // Update Calculated Peaks (blue)
                if (selectedSolution) {
                    const { a, b, c, alpha, beta, gamma, system } = selectedSolution;
                    const lambda = parseFloat(ui.wavelength.value);
                    const maxVisibleTth = xrdChart.options.scales.x.max || Math.max(...pickedPeaks.map(p => p.tth));
                    const hklList = generateHKL(maxVisibleTth, {a,b,c,alpha,beta,gamma,lambda}, system);
                    const hklMarkers = hklList.map(hkl => ({ x: hkl.tth, y: [-markerHeight * 1.5, -markerHeight * 2.5] }));
                    xrdChart.data.datasets[2].data = hklMarkers;
                } else {
                    // Clear blue markers if no solution is selected
                    xrdChart.data.datasets[2].data = [];
                }
                
                xrdChart.update('none');
            }
            
             const generateHKL = (maxTth, params, system) => {
                 const { a, b, c, alpha, beta, gamma, lambda } = params;
                 if (!a || !lambda) return [];
                 const reflections = [];
                 const maxIndex = 10;

                 for (let h = 0; h <= maxIndex; h++) {
                     for (let k = 0; k <= maxIndex; k++) {
                         for (let l = 0; l <= maxIndex; l++) {
                             if (system === 'cubic' && (k > h || l > k)) continue;
                             if ((system === 'tetragonal' || system === 'hexagonal') && k > h) continue;

                            if (h === 0 && k === 0 && l === 0) continue;
                             let inv_d_sq = 0;
                             switch (system) {
                                 case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                                 case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                                 case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                                 case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                             }
                             if (inv_d_sq <= 0) continue;
                             const sinThetaSq = (lambda*lambda / 4) * inv_d_sq;
                             if (sinThetaSq <= 1) {
                                 const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                                 if (tth > maxTth * 1.05) continue;
                                reflections.push({tth, h, k, l, d: 1/Math.sqrt(inv_d_sq)});
                             }
                         }
                     }
                 }
                 return reflections.sort((a, b) => a.tth - b.tth);
             };


            // --- Resizer ---
            const resizer = document.getElementById('drag-handle');
            const leftPanel = document.getElementById('controls-panel');
            resizer.addEventListener('mousedown', (e) => {
                e.preventDefault(); document.body.style.cursor = 'col-resize';
                const moveHandler = (moveEvent) => { if (moveEvent.clientX > 350 && moveEvent.clientX < window.innerWidth - 350) { leftPanel.style.width = `${moveEvent.clientX}px`; } };
                const upHandler = () => { document.body.style.cursor = 'default'; window.removeEventListener('mousemove', moveHandler); window.removeEventListener('mouseup', upHandler); };
                window.addEventListener('mousemove', moveHandler);
                window.addEventListener('mouseup', upHandler);
            });

            // --- PDF Report Generation ---

const generatePDFReport = async () => {
    if (solutions.length === 0) {
        alert("No solutions found to generate a report.");
        return;
    }

    ui.reportButton.textContent = 'Generating...';
    ui.reportButton.disabled = true;
    document.body.style.cursor = 'wait';

    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
        const margin = 15;
        let yPos = 20;

        // 1. Title and Info
        const now = new Date();
        const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
        doc.setFontSize(18);
        doc.text('Powder Indexing Report', 105, yPos, { align: 'center' });
        yPos += 10;
        doc.setFontSize(10);
        doc.text(`Generated: ${timestamp}`, margin, yPos);
        yPos += 5;
        doc.text(`Data File: ${ui.fileName.textContent}`, margin, yPos);
        yPos += 10;

        // 2. Graph Image
        const canvas = await html2canvas(ui.chartCanvas, { backgroundColor: '#ffffff' });
        const imgData = canvas.toDataURL('image/png');
        const imgProps = doc.getImageProperties(imgData);
        const pdfWidth = doc.internal.pageSize.getWidth();
        const imgWidth = pdfWidth - 2 * margin;
        const imgHeight = (imgProps.height * imgWidth) / imgProps.width;
        doc.addImage(imgData, 'PNG', margin, yPos, imgWidth, imgHeight);
        yPos += imgHeight + 10;

        // 3. Solutions Summary (unchanged)
        doc.addPage();
        yPos = 20;
        doc.setFontSize(14);
        doc.text('Indexing Solutions Summary', margin, yPos);
        yPos += 8;
        doc.setFont('courier', 'normal');
        doc.setFontSize(9);
        doc.text('Sys  M(20)   Volume(A^3)  a(A)      b(A)      c(A)      alpha  beta   gamma', margin, yPos);
        yPos += 5;
        solutions.slice(0, 20).forEach(sol => {
            if (yPos > 280) { doc.addPage(); yPos = 20; }
            const line = `${sol.system.substring(0,4).padEnd(5)}` +
                        `${sol.m20.toFixed(2).padStart(6)}  ` +
                        `${sol.volume.toFixed(2).padStart(10)}  ` +
                        `${sol.a.toFixed(4).padStart(8)}  ` +
                        `${(sol.b ? sol.b.toFixed(4) : '-').padStart(8)}  ` +
                        `${(sol.c ? sol.c.toFixed(4) : '-').padStart(8)}  ` +
                        `${(sol.alpha ? sol.alpha.toFixed(2) : '90.00').padStart(6)} ` +
                        `${(sol.beta ? sol.beta.toFixed(2) : '90.00').padStart(6)} ` +
                        `${(sol.gamma ? sol.gamma.toFixed(2) : '90.00').padStart(6)}`;
            doc.text(line, margin, yPos);
            yPos += 5;
        });

        // 4. Pdetail (now with both 2theta obs and calc)
        const lambda = parseFloat(ui.wavelength.value);
        solutions.slice(0, 20).forEach(sol => {
            doc.addPage();
            yPos = 20;
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(12);
            doc.text(`Details for Solution: ${sol.system}, M(20) = ${sol.m20.toFixed(2)}`, margin, yPos);
            yPos += 7;

            doc.setFont('courier', 'normal');
            doc.setFontSize(9);
            let paramsLine = `a=${sol.a.toFixed(4)}`;
            if(sol.b) paramsLine += `, b=${sol.b.toFixed(4)}`;
            if(sol.c) paramsLine += `, c=${sol.c.toFixed(4)}`;
            paramsLine += ` (A)`;
            if(sol.alpha) paramsLine += `, a=${sol.alpha.toFixed(2)}`;
            if(sol.beta) paramsLine += `, b=${sol.beta.toFixed(2)}`;
            if(sol.gamma) paramsLine += `, g=${sol.gamma.toFixed(2)}`;
            doc.text(paramsLine, margin, yPos);
            yPos += 7;

            // Centering and space group (unchanged)
            doc.setFont('helvetica', 'bold');
            doc.text(`Suggested Centering:`, margin, yPos);
            doc.setFont('courier', 'normal');
            doc.text(sol.analysis.centering, margin + 45, yPos);
            yPos += 5;

            if (sol.analysis.conditions && sol.analysis.conditions.length > 0) {
                doc.setFont('helvetica', 'bold');
                doc.text(`Reflection Conditions:`, margin, yPos);
                doc.setFont('courier', 'normal');
                doc.text(sol.analysis.conditions.join(', '), margin + 45, yPos);
                yPos += 5;
            }

            if (sol.analysis.possibleSpaceGroups && sol.analysis.possibleSpaceGroups.length > 0) {
                doc.setFont('helvetica', 'bold');
                doc.text(`Space Groups:`, margin, yPos);
                let currentX = margin + 45;
                const probableSet = new Set(sol.analysis.probableSpaceGroups);
                const allGroups = sol.analysis.possibleSpaceGroups;
                const pageRightMargin = doc.internal.pageSize.getWidth() - margin;

                allGroups.forEach((sg, index) => {
                    const isProbable = probableSet.has(sg);
                    doc.setFont('courier', isProbable ? 'bold' : 'normal');
                    const text = sg + (index < allGroups.length - 1 ? ', ' : '');
                    if (currentX + doc.getTextWidth(text) > pageRightMargin && currentX > margin + 45) {
                        yPos += 4;
                        currentX = margin + 45;
                    }
                    doc.text(text, currentX, yPos);
                    currentX += doc.getTextWidth(text);
                });
                yPos += 4;
            }
            yPos += 3;

            // Modified table header with d_calc, 2θ_calc, d_obs, 2θ_obs
            doc.setFont('courier', 'normal');
            doc.text(' h  k  l |   d_cal(A) 2t_calc   d_obs(A)  2t_obs', margin, yPos);
            yPos += 5;

            const hklList = generateHKL(90, {...sol, lambda}, sol.system);
            const usedObsPeaks = new Set();
            const tth_err = parseFloat(ui.tthError.value);

            hklList.slice(0, 30).forEach(hkl => {
                if (yPos > 280) { doc.addPage(); yPos = 20; }

                // Find best matching observed peak
                let bestMatch = null;
                let minDiff = Infinity;
                pickedPeaks.forEach((peak, index) => {
                    if (usedObsPeaks.has(index)) return;
                    const diff = Math.abs(hkl.d - peak.d);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestMatch = { peak, index };
                    }
                });

                let d_obs_str = '-';
                let tth_obs_str = '-';
                if (bestMatch) {
                    // d matching logic same as before
                    const d_err_plus = lambda / (2 * Math.sin((bestMatch.peak.tth - tth_err) * Math.PI / 360));
                    const d_err_minus = lambda / (2 * Math.sin((bestMatch.peak.tth + tth_err) * Math.PI / 360));
                    const d_tolerance = Math.abs(d_err_plus - d_err_minus) / 2;
                    if (minDiff < d_tolerance * 2) {
                        d_obs_str = bestMatch.peak.d.toFixed(5);
                        tth_obs_str = bestMatch.peak.tth.toFixed(3);
                        usedObsPeaks.add(bestMatch.index);
                    }
                }

                // Compute 2theta_calc
                let tth_calc = '-';
                if (hkl.d > 0 && lambda/(2*hkl.d) < 1) {
                    tth_calc = (2 * Math.asin(lambda / (2 * hkl.d)) * 180 / Math.PI).toFixed(3);
                }

                const line = `${String(hkl.h).padStart(2)} ${String(hkl.k).padStart(2)} ${String(hkl.l).padStart(2)} | ` +
                             `${hkl.d.toFixed(5).padStart(9)} ` +
                             `${String(tth_calc).padStart(7)}  ` +
                             `${d_obs_str.padStart(9)}  ` +
                             `${tth_obs_str.padStart(7)}`;
                doc.text(line, margin, yPos);
                yPos += 5;
            });
        });

        // Save the PDF
        const filename = `Indexing-Report-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}.pdf`;
        doc.save(filename);

    } catch (error) {
        console.error("Failed to generate PDF:", error);
        alert("An error occurred while generating the PDF report.");
    } finally {
        ui.reportButton.textContent = 'Generate PDF Report';
        ui.reportButton.disabled = false;
        document.body.style.cursor = 'default';
    }
};


            ui.reportButton.addEventListener('click', generatePDFReport);
        });
    </script>
    
    <script id="indexing-worker" type="text/javascript">
        // This script block will not be executed directly. Its content is read and used to create the Web Worker.
        self.onmessage = function(e) {
            const { peaks, wavelength, tth_error, max_volume, systems, impurity_peaks } = e.data;
            
            const max_hkl_indexing = 5;
            const max_hkl_analysis = 7;
            const min_m20 = 5.0;
            const N_FOR_M20 = Math.min(20, peaks.length);
            const q_obs = peaks.map(p => p.q);
            const tth_obs = peaks.map(p => p.tth);

            const spaceGroupData = {
                cubic: {
                    'P': { 'Pm-3m':{c:[]}, 'P432':{c:[]}, 'P-43m':{c:[]}, 'Pn-3n':{c:['0kl:k+l=2n','hhl:l=2n']}, 'Pm-3n':{c:['hk0:h+k=2n']}, 'Pn-3m':{c:['hhl:l=2n']} },
                    'I': { 'Im-3m':{c:[]}, 'I432':{c:[]}, 'I-43m':{c:[]}, 'Ia-3d':{c:['0kl:k=2n,l=2n','hhl:2h+l=4n']} },
                    'F': { 'Fm-3m':{c:[]}, 'F432':{c:[]}, 'F-43m':{c:[]}, 'Fd-3m':{c:['0kl:k+l=4n']} }
                },
                tetragonal: {
                    'P': {
                        'P4/mmm': {c:[]}, 'P4/mcc': {c:['hhl:l=2n', '0kl:l=2n']}, 'P4/nbm': {c:['hk0:h+k=2n']}, 'P4/ncs': {c:['hk0:h+k=2n']}, 'P42/mnm':{c:['0kl:k+l=2n','h0l:h+l=2n']},
                        'P4_2/mnm': {c:['0kl:k+l=2n', 'h00:h=2n']}, 'P4_2/mcm': {c:['0kl:l=2n', 'hhl:l=2n']}, 'P4_2/nbc':{c:['hk0:h+k=2n','0kl:k=2n','hhl:l=2n']}, 'P-42m':{c:[]}, 'P-42c':{c:['hhl:l=2n']}, 'P-4b2':{c:['hk0:h=2n,k=2n']}
                    },
                    'I': {
                        'I4/mmm': {c:[]}, 'I4/mcm': {c:['0kl:l=2n', 'hhl:l=2n']}, 'I4_1/amd': {c:['hkl:2h+l=4n', 'hk0:h=2n,k=2n']}, 'I4_1/acd': {c:['hkl:2h+l=4n', 'hk0:h=2n,k=2n','0kl:k=2n,l=2n','hhl:l=2n']}
                    }
                },
                hexagonal: {
                    'P': { 'P6/mmm': {c:[]}, 'P6_3/mcm': {c:['h-hl:l=2n', '00l:l=2n']}, 'P6_3/mmc': {c:['00l:l=2n']} },
                    'R': { 'R-3m': {c:[]}, 'R-3c': {c:['h-hl:l=2n']} }
                },
                orthorhombic: {
                    'P': {'Pmmm': {c:[]}, 'Pnnn': {c:['0kl:k+l=2n','h0l:h+l=2n','hk0:h+k=2n']}, 'Pbca':{c:['0kl:k=2n','h0l:l=2n','hk0:h=2n']}, 'Pnma':{c:['0kl:k+l=2n','hk0:h=2n']}},
                    'I': {'Immm': {c:[]}, 'Ibca':{c:['0kl:k=2n','h0l:l=2n']}},
                    'F': {'Fmmm': {c:[]}, 'Fddd':{c:['0kl:k+l=4n','h0l:h+l=4n','hk0:h+k=4n']}},
                    'C': {'Cmmm': {c:[]}, 'Cmce':{c:['0kl:l=2n','h0l:h+l=2n']}}
                }
            };
            
            // --- CORE FUNCTIONS (M(20) and Error calculation corrected) ---
            const q_from_tth = (tth) => {
                const d = wavelength / (2 * Math.sin(tth * Math.PI / 360));
                return 1 / (d * d);
            };

            const get_q_tolerance = (tth) => {
                const q_plus = q_from_tth(tth + tth_error);
                const q_minus = q_from_tth(tth - tth_error);
                return Math.abs(q_plus - q_minus) / 2;
            };

            const calculateM20 = (q_calc_sorted) => {
                let N_indexed = 0; 
                let sum_delta_q = 0;
                for(let i=0; i < N_FOR_M20; i++){
                    const q_o = q_obs[i];
                    const tolerance = get_q_tolerance(tth_obs[i]);
                    let min_diff = Infinity;
                    let found = false;
                    for(const q_c of q_calc_sorted){
                        const diff = Math.abs(q_o - q_c);
                        if(diff < tolerance){
                           min_diff = Math.min(min_diff, diff);
                           found = true;
                        }
                    }
                    if(found) {
                        N_indexed++;
                        sum_delta_q += min_diff;
                    }
                }
                
                const unindexed_peaks = N_FOR_M20 - N_indexed;
                if (unindexed_peaks > impurity_peaks) return 0;
                
                const q_n = q_obs[N_FOR_M20 - 1];
                const N_calc = q_calc_sorted.filter(q => q <= q_n * 1.05).length;
                const avg_delta_q = N_indexed > 0 ? sum_delta_q / N_indexed : 0;
                 if (avg_delta_q === 0) return 0;
                
                return q_n / (2 * avg_delta_q * N_calc);
            };

            const testSolution = (params) => {
                const {a, b, c, system} = params;
                let volume = 0;
                switch(system){
                    case 'cubic': volume = a*a*a; break;
                    case 'tetragonal': volume = a*a*c; break;
                    case 'hexagonal': volume = a*a*c * Math.sqrt(3)/2; break;
                    case 'orthorhombic': volume = a*b*c; break;
                }
                if (volume > max_volume || volume < 1) return;
                const q_calc = new Set();
                 for (let h = 0; h <= max_hkl_indexing; h++) {
                    for (let k = 0; k <= max_hkl_indexing; k++) {
                        for (let l = 0; l <= max_hkl_indexing; l++) {
                            if (system === 'cubic' && (k > h || l > k)) continue;
                            if ((system === 'tetragonal' || system === 'hexagonal') && k > h) continue;
                            if (h === 0 && k === 0 && l === 0) continue;
                            let q = 0;
                             switch (system) {
                                 case 'cubic': q = (h*h + k*k + l*l) / (a*a); break;
                                 case 'tetragonal': q = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                                 case 'hexagonal': q = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                                 case 'orthorhombic': q = h*h/(a*a) + k*k/(b*b) + l*l/(c*c); break;
                             }
                            if(q > 0) q_calc.add(q);
                        }
                    }
                }
                const q_calc_sorted = Array.from(q_calc).sort((x, y) => x - y);
                const m20 = calculateM20(q_calc_sorted);
                if (m20 > min_m20) {
                     const analysis = analyzeSystematicAbsences(params, peaks);
                     self.postMessage({ type: 'solution', payload: {...params, volume, m20, analysis} });
                }
            };
            
            // --- SYMMETRY ANALYSIS ---
            const analyzeSystematicAbsences = (solution, obs_peaks) => {
                const { system } = solution;
                const all_hkls = generateHKL_for_analysis(solution, wavelength, Math.max(...obs_peaks.map(p=>p.tth)));
                const obs_hkl_list = [];
                const used_peaks = new Set();
                all_hkls.forEach(hkl => {
                    let bestMatch = null; let minDiff = Infinity;
                    obs_peaks.forEach((peak, index) => {
                        if (used_peaks.has(index)) return;
                        const diff = Math.abs(hkl.d - peak.d);
                        if (diff < minDiff) { minDiff = diff; bestMatch = { peak, index }; }
                    });
                    if (bestMatch) {
                        const tolerance = get_q_tolerance(bestMatch.peak.tth);
                        const d_tolerance = Math.abs(1/Math.sqrt(bestMatch.peak.q + tolerance) - 1/Math.sqrt(bestMatch.peak.q - tolerance)) / 2;
                        if (minDiff < d_tolerance) {
                           obs_hkl_list.push(hkl); used_peaks.add(bestMatch.index);
                        }
                    }
                });

                let centering = 'Primitive (P)';
                if (obs_hkl_list.length >= 3) {
                    const violates_I = obs_hkl_list.some(({h,k,l}) => (h+k+l) % 2 !== 0);
                    const violates_F = obs_hkl_list.some(({h,k,l}) => !((h%2===k%2)&&(k%2===l%2)));
                    if (system === 'cubic' || system === 'tetragonal' || system === 'orthorhombic') {
                        if (!violates_F) centering = 'Face (F)';
                        else if (!violates_I) centering = 'Body (I)';
                    }
                    if (system === 'orthorhombic' && centering === 'Primitive (P)' && !obs_hkl_list.some(({h,k,l}) => (h+k) % 2 !== 0)) centering = 'C-Face (C)';
                    if (system === 'hexagonal' && (!obs_hkl_list.some(({h,k,l}) => (-h+k+l)%3!==0) || !obs_hkl_list.some(({h,k,l}) => (h-k+l)%3!==0))) centering = 'Rhombohedral (R)';
                }
                const centerChar = centering.charAt(centering.indexOf('(')+1);
                
                const foundConditions = new Set();
                const check = (filter, rule) => {
                    const subset = obs_hkl_list.filter(filter);
                    return subset.length === 0 || !subset.some(rule);
                };
                if (check(p => p.h !== 0 && p.k===0 && p.l===0, p => p.h%2 !== 0)) foundConditions.add('h00:h=2n');
                if (check(p => p.k !== 0 && p.h===0 && p.l===0, p => p.k%2 !== 0)) foundConditions.add('0k0:k=2n');
                if (check(p => p.l !== 0 && p.h===0 && p.k===0, p => p.l%2 !== 0)) foundConditions.add('00l:l=2n');
                if (check(p => p.h!==0 && p.k!==0 && p.l===0, p => (p.h+p.k)%2 !== 0)) foundConditions.add('hk0:h+k=2n');
                if (check(p => p.k!==0 && p.l!==0 && p.h===0, p => (p.k+p.l)%2 !== 0)) foundConditions.add('0kl:k+l=2n');
                if (check(p => p.h!==0 && p.l!==0 && p.k===0, p => (p.h+p.l)%2 !== 0)) foundConditions.add('h0l:h+l=2n');
                if (check(p => p.h===p.k && p.l!==0, p => p.l%2 !== 0)) foundConditions.add('hhl:l=2n');
                if (check(p => p.h===-p.k && p.l!==0, p => p.l%2 !== 0)) foundConditions.add('h-hl:l=2n');

                const sg_block = spaceGroupData[system]?.[centerChar] || {};
                const possibleSpaceGroups = Object.keys(sg_block);
                const probableSpaceGroups = possibleSpaceGroups.filter(sg => 
                    (sg_block[sg].c || []).every(cond => foundConditions.has(cond))
                );
                
                return { centering, conditions: Array.from(foundConditions), possibleSpaceGroups, probableSpaceGroups };
            };

            const generateHKL_for_analysis = (params, lambda, maxTth) => {
                 const { a, b, c, system } = params;
                 const reflections = [];
                 for (let h = -max_hkl_analysis; h <= max_hkl_analysis; h++) {
                     for (let k = -max_hkl_analysis; k <= max_hkl_analysis; k++) {
                         for (let l = -max_hkl_analysis; l <= max_hkl_analysis; l++) {
                             if (h === 0 && k === 0 && l === 0) continue;
                             let inv_d_sq = 0;
                             switch (system) {
                                 case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                                 case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                                 case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                                 case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                             }
                             if (inv_d_sq > 0) {
                                  const d = 1 / Math.sqrt(inv_d_sq);
                                  const sinThetaSq = (lambda * lambda / 4) * inv_d_sq;
                                  if (sinThetaSq <= 1) {
                                     const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                                     if(tth <= maxTth*1.05) reflections.push({ tth, h, k, l, d });
                                  }
                             }
                         }
                     }
                 }
                 return reflections.sort((a, b) => a.tth - b.tth);
            };

            // --- INDEXING ALGORITHMS ---
            const indexCubic = () => {
                for (let i = 0; i < Math.min(4, q_obs.length); i++) {
                    for (let h = 1; h <= max_hkl_indexing; h++) {
                        for (let k = 0; k <= h; k++) {
                            for (let l = 0; l <= k; l++) {
                                const S = h * h + k * k + l * l;
                                if (S === 0) continue;
                                testSolution({a: Math.sqrt(S / q_obs[i]), system: 'cubic'});
                            }
                        }
                    }
                }
            };
            const indexTetragonal = () => {
                for (let i = 0; i < Math.min(6, q_obs.length); i++) {
                    for (let j = i + 1; j < Math.min(7, q_obs.length); j++) {
                        for (let h1 = 0; h1 <= max_hkl_indexing; h1++) {
                            for (let k1 = 0; k1 <= h1; k1++) {
                                for (let l1 = 0; l1 <= max_hkl_indexing; l1++) {
                                    if (h1 === 0 && k1 === 0 && l1 === 0) continue;
                                    const S1 = h1*h1 + k1*k1;
                                    for (let h2 = 0; h2 <= max_hkl_indexing; h2++) {
                                        for (let k2 = 0; k2 <= h2; k2++) {
                                            for (let l2 = 0; l2 <= max_hkl_indexing; l2++) {
                                                if (h2 === 0 && k2 === 0 && l2 === 0) continue;
                                                const S2 = h2*h2 + k2*k2;
                                                const det = S1 * l2*l2 - S2 * l1*l1;
                                                if (Math.abs(det) < 1e-6) continue;
                                                const a_sq_inv = (q_obs[i] * l2*l2 - q_obs[j] * l1*l1) / det;
                                                const c_sq_inv = (q_obs[j] * S1 - q_obs[i] * S2) / det;
                                                if (a_sq_inv > 0 && c_sq_inv > 0) {
                                                    testSolution({a: 1/Math.sqrt(a_sq_inv), c: 1/Math.sqrt(c_sq_inv), system: 'tetragonal'});
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
            const indexHexagonal = () => {
                for (let i = 0; i < Math.min(6, q_obs.length); i++) {
                    for (let j = i + 1; j < Math.min(7, q_obs.length); j++) {
                        for (let h1 = 0; h1 <= max_hkl_indexing; h1++) {
                            for (let k1 = 0; k1 <= h1; k1++) {
                                for (let l1 = 0; l1 <= max_hkl_indexing; l1++) {
                                    if(h1 === 0 && k1 === 0 && l1 === 0) continue;
                                    const S1 = h1*h1 + h1*k1 + k1*k1;
                                    for(let h2 = 0; h2 <= max_hkl_indexing; h2++) {
                                        for(let k2 = 0; k2 <= h2; k2++) {
                                            for(let l2 = 0; l2 <= max_hkl_indexing; l2++) {
                                                if(h2 === 0 && k2 === 0 && l2 === 0) continue;
                                                const S2 = h2*h2 + h2*k2 + k2*k2;
                                                const det = S1*l2*l2 - S2*l1*l1;
                                                if(Math.abs(det) < 1e-6) continue;
                                                const a_term = (q_obs[i]*l2*l2 - q_obs[j]*l1*l1) / det;
                                                const c_inv = (q_obs[j]*S1 - q_obs[i]*S2) / det;
                                                if(a_term > 0 && c_inv > 0) {
                                                    testSolution({a: Math.sqrt(4/(3*a_term)), c: Math.sqrt(1/c_inv), system: 'hexagonal'});
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
            const indexOrthorhombic = () => {
                for(let i=0; i < Math.min(4, q_obs.length); i++) {
                    for(let j=i+1; j < Math.min(5, q_obs.length); j++) {
                        for(let k=j+1; k < Math.min(6, q_obs.length); k++) {
                            const perms = [[i,j,k],[i,k,j],[j,i,k],[j,k,i],[k,i,j],[k,j,i]];
                            perms.forEach(p => {
                                const [a_inv, b_inv, c_inv] = [q_obs[p[0]], q_obs[p[1]], q_obs[p[2]]];
                                if(a_inv > 0 && b_inv > 0 && c_inv > 0) {
                                    testSolution({a:1/Math.sqrt(a_inv), b:1/Math.sqrt(b_inv), c:1/Math.sqrt(c_inv), system:'orthorhombic'});
                                }
                            });
                        }
                    }
                }
            };

            // --- Main execution ---
            systems.forEach((system, i) => {
                if (system === 'cubic') indexCubic();
                if (system === 'tetragonal') indexTetragonal();
                if (system === 'hexagonal') indexHexagonal();
                if (system === 'orthorhombic') indexOrthorhombic();
                self.postMessage({ type: 'progress', payload: (i + 1) / systems.length });
            });
            self.postMessage({ type: 'done' });
        };
    </script>
</body>
</html>


