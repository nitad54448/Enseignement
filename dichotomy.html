<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dichotomy</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        :root {
            --dark-bg: #111827;
            --medium-bg: #1f2937;
            --light-bg: #374151;
            --border-color: #4b5563;
            --primary-accent: #1a73e8;
            --primary-accent-hover: #1765cc;
            --text-light: #e5e7eb;
            --text-medium: #d1d5db;
            --text-dark: #9ca3af;
            --success-green: #16a34a;
            --error-red: #dc2626;
            --led-gray: #6b7280;
        }

        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f9fafb; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #app-container { display: flex; width: 100%; flex-grow: 1; min-height: 0; }
        
        #controls-panel { 
            width: 400px; min-width: 300px; max-width: 700px; flex-shrink: 0; 
            padding: 24px; background-color: var(--dark-bg); border-right: 1px solid var(--light-bg); 
            overflow-y: visible; color: var(--text-medium); display: flex; flex-direction: column;
            position: relative;
            z-index: 20;
        }
        
        #drag-handle { width: 6px; cursor: col-resize; background-color: var(--light-bg); flex-shrink: 0; transition: background-color: 0.2s; }
        #drag-handle:hover, #drag-handle:active { background-color: var(--primary-accent); }
        
        #results-area { 
            flex-grow: 1; position: relative; background-color: #ffffff; 
            min-width: 0; display: flex; flex-direction: column; 
            padding: 1.5rem; color: var(--medium-bg);
            z-index: 10;
        }

        .control-group { margin-bottom: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--light-bg); }
        .control-group:first-child { border-top: none; padding-top: 0; }
        .control-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-dark); font-size: 0.875rem; }
        .control-input, .control-select { width: 100%; background-color: var(--light-bg); border: 1px solid var(--border-color); color: var(--text-light); border-radius: 0.375rem; padding: 0.5rem 0.75rem; transition: all 0.2s ease; box-sizing: border-box; }
        .control-input:focus, .control-select:focus { outline: none; border-color: var(--primary-accent); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); }
        .btn { padding: 0.6rem 1rem; border-radius: 0.375rem; font-weight: 600; transition: background-color: 0.2s, color 0.2s, border-color 0.2s; cursor: pointer; border: none; text-align: center;}
        .btn-primary { background-color: var(--primary-accent); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: var(--primary-accent-hover); }
        .btn-secondary { background-color: var(--light-bg); color: var(--text-light); border-color: var(--border-color); }
        .btn-secondary:hover:not(:disabled) { background-color: #4a5568; }
        .btn:disabled { background-color: var(--border-color); cursor: not-allowed; opacity: 0.7; }
        .file-input-label { display: block; padding: 0.75rem 1rem; background-color: var(--border-color); color: var(--text-medium); border-radius: 0.375rem; text-align: center; cursor: pointer; transition: background-color: 0.2s; }
        .file-input-label:hover { background-color: #6b7280; }
        .parameter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
        .checkbox-label { display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; color: var(--text-medium); cursor: pointer;}
        .hidden { display: none !important; }

        /* Tab Styles */
        .tab-buttons { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 1rem; }
        .tab-btn { flex: 1; padding: 0.75rem 0.5rem; background: none; border: none; color: var(--text-dark); font-weight: 600; cursor: pointer; border-bottom: 2px solid transparent; transition: all 0.2s; font-size: 0.9rem; display: flex; align-items: center; justify-content: center; gap: 8px;}
        .tab-btn:hover { color: var(--text-light); }
        .tab-btn.active { color: var(--primary-accent); border-bottom-color: var(--primary-accent); }
        .tab-content-panels { flex-grow: 1; min-height: 0; position: relative; }
        .tab-content-panel { display: none; flex-direction: column; height: 100%; overflow-y: auto; padding-right: 8px; margin-right: -8px;}
        .tab-content-panel.active { display: flex; }
        .tab-content-panel::-webkit-scrollbar { width: 6px; }
        .tab-content-panel::-webkit-scrollbar-track { background: var(--dark-bg); }
        .tab-content-panel::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
        .tab-content-panel::-webkit-scrollbar-thumb:hover { background: var(--light-bg); }
        #solutions-tab-content .control-group { flex-grow: 1; display: flex; flex-direction: column; margin-bottom: 0;}
        #solutions-table-container { flex-grow: 1; overflow-y: auto; background-color: var(--medium-bg); border-radius: 0.375rem; border: 1px solid var(--border-color); }

        /* --- LED Indicator Styles --- */
        .led-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transition: background-color 0.3s ease;
        }
        .led-indicator.gray { background-color: var(--led-gray); }
        .led-indicator.green { background-color: var(--success-green); box-shadow: 0 0 5px var(--success-green);}
        .led-indicator.red { background-color: var(--error-red); box-shadow: 0 0 5px var(--error-red); }

        #peak-table-container {
            overflow-y: auto;
            background-color: var(--medium-bg);
            border-radius: 0.375rem;
            border: 1px solid var(--border-color);
            margin-top: 1rem;
        }
        .peak-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        .peak-table th, .peak-table td { padding: 0.5rem; text-align: right; border-bottom: 1px solid var(--border-color); }
        .peak-table th { background-color: #2a3547; font-weight: 600; text-align: center; position: sticky; top: 0; }
        .peak-table input { width: 100%; background: transparent; border: none; color: var(--text-light); text-align: right; padding: 2px; border-radius: 2px; }
        .peak-table input:focus { background-color: var(--light-bg); outline: 1px solid var(--primary-accent); }
        .peak-table th, .peak-table td, .peak-table input { text-align: center; }
        .delete-peak-btn { background: none; border: none; color: var(--text-dark); cursor: pointer; font-weight: bold; }
        .delete-peak-btn:hover { color: var(--error-red); }

        .solutions-table { width: 100%; border-collapse: collapse; font-size: 0.75rem; }
        .solutions-table th, .solutions-table td { padding: 0.5rem; text-align: left; border-bottom: 1px solid var(--border-color); }
        .solutions-table th { background-color: #2a3547; font-weight: 600; position: sticky; top: 0;}
        .solutions-table th[data-sort] { cursor: pointer; } 
        .solutions-table th[data-sort]:hover { background-color: var(--light-bg); }
        .solutions-table th.sort-asc::after,
        .solutions-table th.sort-desc::after {
            content: ''; display: inline-block; margin-left: 5px; width: 0; height: 0;
            border-left: 4px solid transparent; border-right: 4px solid transparent;
        }
        .solutions-table th.sort-asc::after { border-bottom: 4px solid var(--text-light); }
        .solutions-table th.sort-desc::after { border-top: 4px solid var(--text-light); }

        .solutions-table tbody tr { cursor: pointer; transition: background-color: 0.2s; }
        .solutions-table tbody tr:hover { background-color: var(--light-bg); }
        .solutions-table tbody tr.selected { background-color: var(--primary-accent); color: white;}

        .bottom-actions { margin-top: auto; padding-top: 1rem; border-top: 1px solid var(--light-bg); }

        #status-box {
            position: fixed; bottom: 20px; right: 20px; padding: 12px 20px; border-radius: 6px;
            color: white; font-size: 0.8rem; font-weight: 500; z-index: 1000;
            opacity: 0; visibility: hidden; transform: translateY(20px);
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        #status-box.show { opacity: 1; visibility: visible; transform: translateY(0); }
        #status-box.success { background-color: var(--success-green); }
        #status-box.error { background-color: var(--error-red); }
        #status-box.info { background-color: var(--border-color); }

        /* --- Help Tooltip Styles --- */
        .help-tooltip-container { position: relative; display: inline-block; }
        .help-icon {
            display: flex; align-items: center; justify-content: center; width: 28px; height: 28px;
            background-color: var(--border-color); color: var(--text-light); border-radius: 50%;
            font-weight: bold; font-size: 1rem; cursor: help; transition: background-color: 0.2s;
        }
        .help-icon:hover { background-color: #6b7280; }
        .tooltip-content {
            visibility: hidden; opacity: 0; width: 320px; background-color: var(--light-bg);
            color: var(--text-medium); text-align: left; border-radius: 0.375rem; padding: 1rem;
            position: absolute; z-index: 1001;
            top: -15px; 
            left: 115%; 
            margin-left: 10px; 
            transition: opacity 0.3s; font-size: 0.8rem; border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }
        .tooltip-content::after {
            content: ""; position: absolute;
            top: 20px; 
            right: 100%;
            margin-top: -5px; 
            border-width: 5px; border-style: solid;
            border-color: transparent var(--light-bg) transparent transparent;
        }
        .help-tooltip-container:hover .tooltip-content { visibility: visible; opacity: 1; }
        .tooltip-content h4 { color: var(--text-light); font-size: 0.9rem; margin-top: 0; margin-bottom: 0.5rem; font-weight: 600; }
        .tooltip-content p { margin-top: 0; margin-bottom: 0.75rem; line-height: 1.4; }
        .tooltip-content p:last-child { margin-bottom: 0; }
        .tooltip-content hr { border: none; border-top: 1px solid var(--border-color); margin: 0.75rem 0; }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">

            <div class="control-group">
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                     <label for="file-input" class="file-input-label" style="flex-grow: 1;">
                        <span id="file-name">Select Data File</span>
                    </label>
                     <div class="help-tooltip-container">
                        <span class="help-icon">?</span>
                        <div class="tooltip-content">
                            <h4>Powder XRD Indexing</h4>
                            <p>Determine unit cell parameters using the Dichotomy method. Based on the method of A. Boultif & D. Louer, J. Appl. Cryst. 37, 724-731 (2004).</p>
                            <p>This is a simplified version for educational purposes. For real stuff use the original code or other indexing programs.</p>
                            <hr>
                            <h4>Supported File Formats:</h4>
                            <p>Generic 2-column (2&theta; intensity), .xrdml, .brml, .ras, .uxd, .udf, GSAS .esd</p>
                        </div>
                    </div>
                </div>
                <input type="file" id="file-input" class="hidden">
            </div>

            <div class="tab-buttons">
                <button class="tab-btn active" data-tab="peaks">Peaks</button>
                <button class="tab-btn" data-tab="parameters">Parameters</button>
                <button class="tab-btn" data-tab="solutions">
                    Solutions
                    <span id="solutions-led" class="led-indicator gray"></span>
                </button>
            </div>

            <div class="tab-content-panels">
                <div id="peaks-tab-content" class="tab-content-panel active">
                     <div class="control-group" style="width: 100%; flex-grow: 1; display: flex; flex-direction: column;">
                        <div id="peak-controls" class="hidden" style="display: flex; flex-direction: column; flex-grow: 1;">
                            <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                <button id="find-peaks-button" class="btn btn-secondary" style="flex-grow: 1;">Find Peaks</button>
                                <label for="peak-threshold-input" class="control-label" style="margin-bottom: 0; white-space: nowrap;">Min %:</label>
                                <input type="number" id="peak-threshold-input" class="control-input" value="2" min="0.1" max="50" step="0.1" style="width: 6rem;">
                            </div>
                            <div style="margin-top: 1rem;">
                                <label class="control-label">2θ Range for Peak Finding</label>
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <input type="number" id="tth-min-input" class="control-input" style="width: 6rem; text-align: center;" disabled>
                                    <div style="flex-grow: 1;">
                                        <input type="range" id="tth-min-slider" disabled style="width: 100%;">
                                        <input type="range" id="tth-max-slider" disabled style="width: 100%;">
                                    </div>
                                    <input type="number" id="tth-max-input" class="control-input" style="width: 6rem; text-align: center;" disabled>
                                </div>
                            </div>
                            <div id="peak-table-container" class="hidden" style="flex-grow: 1; min-height: 0;">
                                <table class="peak-table">
                                    <thead><tr><th>#</th><th>2θ Obs (°)</th><th>d (Å)</th><th>Del</th></tr></thead>
                                    <tbody id="peak-list-body"></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="parameters-tab-content" class="tab-content-panel">
                    <div class="control-group" style="width: 100%;">
                        <div id="indexing-controls" class="hidden">
                            <div class="parameter-grid">
                                <div>
                                    <label for="wavelength" class="control-label">Wavelength (Å)</label>
                                    <input type="number" id="wavelength" value="1.54178" step="0.00001" min="0.1" class="control-input">
                                </div>
                                <div>
                                    <label for="max-volume" class="control-label">Max Volume (Å³)</label>
                                    <input type="number" id="max-volume" value="1000" step="100" min="60" max="12000" class="control-input">
                                </div>
                            </div>
                            <div class="parameter-grid" style="margin-top: 1rem;">
                                <div>
                                    <label for="tth-error" class="control-label">2θ Error (°)</label>
                                    <input type="number" id="tth-error" value="0.05" step="0.005" min="0.001" class="control-input">
                                </div>
                                <div>
                                    <label for="impurity-peaks" class="control-label">Impurity Peaks</label>
                                    <input type="number" id="impurity-peaks" value="0" min="0" max="5" step="1" class="control-input">
                                </div>
                            </div>
                            <label class="control-label" style="margin-top: 1.5rem; margin-bottom: 1rem;">Crystal Systems to Search:</label>
                            <div class="parameter-grid">
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="cubic" checked> Cubic</label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="tetragonal" checked> Tetragonal</label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="hexagonal" checked> Hexagonal</label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="orthorhombic" > Orthorhombic</label>
                                <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="monoclinic" > Monoclinic</label>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="solutions-tab-content" class="tab-content-panel">
                    <div class="control-group" style="width: 100%;">
                         <div id="solutions-table-container">
                            <table class="solutions-table">
                                <thead><tr>
                                    <th data-sort="system">Sys.</th>
                                    <th>a,b,c (Å)</th>
                                    <th>α,β,γ (°)</th>
                                    <th data-sort="volume">Vol</th>
                                    <th data-sort="m20">M(20)</th>
                                </tr></thead>
                                <tbody id="solutions-table-body"></tbody>
                            </table>
                         </div>
                    </div>
                </div>
            </div>

            <div class="bottom-actions">
                <div id="progress-bar-container" class="hidden" style="width: 100%; background-color: var(--light-bg); border-radius: 9999px; height: 0.625rem; margin-bottom: 0.5rem;">
                    <div id="progress-bar" style="background-color: var(--primary-accent); height: 0.625rem; border-radius: 9999px; width: 0%; transition: width 0.2s;"></div>
                </div>
                <div style="display: flex; gap: 0.5rem;">
                    <button id="start-indexing-button" class="btn btn-primary" style="flex: 1; font-size: 1rem;" disabled>Find Peaks to Start</button>
                    <button id="report-button" class="btn btn-secondary" style="flex: 1; font-size: 1rem;" disabled>Generate PDF Report</button>
                </div>
            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="results-area">
             <div id="placeholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #6b7280;">
                <svg xmlns="http://www.w3.org/2000/svg" style="width: 4rem; height: 4rem; margin-bottom: 1rem;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                <h2 style="font-size: 1.5rem; font-weight: 600;">Awaiting Data</h2>
                <p>Load a data file to begin indexing.</p>
            </div>
            <div id="results-container" style="width: 100%; height: 100%; display: none; flex-direction: column; position: relative;">
                <canvas id="xrd-chart"></canvas>
            </div>
            <div style="position: absolute; bottom: 0.5rem; right: 1rem; font-size: 0.75rem; color: #9ca3af;">
                NitaD, Univ Paris-Saclay, 18 Sept 2025
            </div>
        </div>
    </div>

    <div id="status-box"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const ui = {
                fileInput: document.getElementById('file-input'),
                fileName: document.getElementById('file-name'),
                peakControls: document.getElementById('peak-controls'),
                peakThresholdInput: document.getElementById('peak-threshold-input'),
                findPeaksButton: document.getElementById('find-peaks-button'),
                peakTableContainer: document.getElementById('peak-table-container'),
                peakListBody: document.getElementById('peak-list-body'),
                indexingControls: document.getElementById('indexing-controls'),
                wavelength: document.getElementById('wavelength'),
                tthError: document.getElementById('tth-error'),
                maxVolume: document.getElementById('max-volume'),
                impurityPeaksInput: document.getElementById('impurity-peaks'),
                systemCheckboxes: document.querySelectorAll('.system-checkbox'),
                startIndexingButton: document.getElementById('start-indexing-button'),
                reportButton: document.getElementById('report-button'),
                progressBar: document.getElementById('progress-bar'),
                progressBarContainer: document.getElementById('progress-bar-container'),
                solutionsTableBody: document.getElementById('solutions-table-body'),
                solutionsTableHeaders: document.querySelectorAll('#solutions-table-container th'),
                solutionsLed: document.getElementById('solutions-led'),
                chartCanvas: document.getElementById('xrd-chart'),
                placeholder: document.getElementById('placeholder'),
                resultsContainer: document.getElementById('results-container'),
                tthMinSlider: document.getElementById('tth-min-slider'),
                tthMaxSlider: document.getElementById('tth-max-slider'),
                tthMinInput: document.getElementById('tth-min-input'),
                tthMaxInput: document.getElementById('tth-max-input'),
                statusBar: document.getElementById('status-box'),
                tabButtonsContainer: document.querySelector('.tab-buttons'),
                tabButtons: document.querySelectorAll('.tab-btn'),
                tabPanels: document.querySelectorAll('.tab-content-panel')
            };

            // --- TAB SWITCHING .. it does not work during calculation, eo as to make it faster--
            ui.tabButtonsContainer.addEventListener('click', (e) => {
                const clickedTab = e.target.closest('.tab-btn');
                if (!clickedTab) return;

                const tabTarget = clickedTab.dataset.tab;

                ui.tabButtons.forEach(btn => btn.classList.remove('active'));
                ui.tabPanels.forEach(panel => panel.classList.remove('active'));

                clickedTab.classList.add('active');
                document.getElementById(`${tabTarget}-tab-content`).classList.add('active');
            });


            let statusTimeout;
            const showStatus = (message, type = 'info', duration = 4000) => {
                if (!ui.statusBar) {
                    console.warn(`Status bar element (#status-box) not found. Message: "${message}"`);
                    return;
                }
                if (statusTimeout) clearTimeout(statusTimeout);
                ui.statusBar.textContent = message;
                ui.statusBar.className = `show ${type}`;
                statusTimeout = setTimeout(() => {
                    if (ui.statusBar) {
                        ui.statusBar.classList.remove('show');
                    }
                }, duration);
            };

            let fullExperimentalData = { tth: [], intensity: [] };
            let pickedPeaks = [];
            let solutions = [];
            let selectedSolution = null;
            let currentHklList = [];
            let xrdChart;
            let isIndexing = false;
            let activeWorkers = [];
            let sortState = { column: 'm20', direction: 'desc' };


            const inputsToValidate = [
                { id: 'wavelength', el: ui.wavelength, default: 1.541780 },
                { id: 'max-volume', el: ui.maxVolume, default: 1000 },
                { id: 'tth-error', el: ui.tthError, default: 0.05 },
                { id: 'impurity-peaks', el: ui.impurityPeaksInput, default: 0 },
                { id: 'peak-threshold-input', el: ui.peakThresholdInput, default: 2 },
            ];

            // Setup input validation
            inputsToValidate.forEach(({ id, el, default: defaultValue }) => {
                if (el) {
                    el.addEventListener('blur', () => {
                        const min = parseFloat(el.min);
                        const max = parseFloat(el.max);
                        let value = parseFloat(el.value);

                        if (isNaN(value)) {
                            el.value = defaultValue;
                            return;
                        }
                        if (el.step == 2 && value % 2 === 0) { // Ensure window is odd
                            value += 1;
                            el.value = value;
                        }

                        if (!isNaN(min) && value < min) el.value = min;
                        if (!isNaN(max) && value > max) el.value = max;
                    });
                } else {
                    console.error(`Initialization Error: The element with id="${id}" was not found. Input validation will not be applied to it.`);
                }
            });

            if (ui.wavelength) {
                ui.wavelength.addEventListener('change', () => {
                    if (pickedPeaks.length > 0) {
                        recalculatePeakValues();
                        updatePeakTable();
                    }
                });
            }


            const parseDataFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                const tth = [], intensity = [];
                lines.forEach(line => {
                    if (line.startsWith('#') || line.startsWith('//') || line.trim() === '') return;
                    const parts = line.trim().split(/[\s,;]+/);
                    if (parts.length >= 2) {
                        const x = parseFloat(parts[0]);
                        const y = parseFloat(parts[1]);
                        if (!isNaN(x) && !isNaN(y)) {
                            tth.push(x);
                            intensity.push(y);
                        }
                    }
                });
                return { tth, intensity };
            };

            const parseXrdmlFile = (xmlString) => {
                 const parser = new DOMParser();
                 const xmlDoc = parser.parseFromString(xmlString, "application/xml");
                 if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing XRDML file."); }

                 let wavelength = null;
                 const kAlpha1Node = xmlDoc.querySelector("kAlpha1");
                 if (kAlpha1Node?.textContent) wavelength = parseFloat(kAlpha1Node.textContent);

                 const intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts");
                 if (!intensityNode) throw new Error("Could not find <intensities> or <counts> in XRDML file.");
                 const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number);

                 const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]');
                 if (!positionsNode) throw new Error("Could not find <positions> in XRDML file.");
                 const startPos = parseFloat(positionsNode.querySelector("startPosition").textContent);
                 const endPos = parseFloat(positionsNode.querySelector("endPosition").textContent);
                 const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * (endPos - startPos) / (intensity.length - 1));

                 return { tth, intensity, wavelength };
            };
            
            const parseBrukerBrmlFile = (xmlString) => {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, "application/xml");
                if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing BRML file."); }

                let wavelength = null;
                const wlNode = xmlDoc.querySelector('usedWavelength');
                if (wlNode) {
                    const kAlpha1 = wlNode.getAttribute('kAlpha1');
                    if (kAlpha1) wavelength = parseFloat(kAlpha1);
                }
                
                const intensityNode = xmlDoc.querySelector("dataPoints > counts");
                if (!intensityNode) throw new Error("No <counts> data found in BRML file.");
                const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number);

                const startPosNode = xmlDoc.querySelector('startPosition[axis="TwoTheta"]');
                const stepSizeNode = xmlDoc.querySelector('increment[axis="TwoTheta"]');
                if (!startPosNode || !stepSizeNode) throw new Error("Could not find scan parameters in BRML file.");

                const startPos = parseFloat(startPosNode.textContent);
                const stepSize = parseFloat(stepSizeNode.textContent);
                
                const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * stepSize);

                return { tth, intensity, wavelength };
            };

            const parseRigakuRasFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                const tth = [], intensity = [];
                let inDataSection = false;
                let wavelength = null;

                for (const line of lines) {
                    const upperLine = line.toUpperCase();
                    if (upperLine.startsWith('*WAVE_LENGTH') || upperLine.startsWith('*MEAS_COND_XG_WAVE_LENGTH')) {
                        const parts = line.trim().split(/\s+/);
                        if (parts.length > 1) {
                            const wl = parseFloat(parts[1]);
                            if (!isNaN(wl)) wavelength = wl;
                        }
                    }
                    if (upperLine.startsWith('*RAS_INT_START')) {
                        inDataSection = true;
                        continue;
                    }
                    if (upperLine.startsWith('*RAS_INT_END')) {
                        break;
                    }
                    if (inDataSection) {
                        const parts = line.trim().split(/[\s,]+/);
                        if (parts.length >= 2) {
                            const x = parseFloat(parts[0]);
                            const y = parseFloat(parts[1]);
                            if (!isNaN(x) && !isNaN(y)) {
                                tth.push(x);
                                intensity.push(y);
                            }
                        }
                    }
                }
                if (tth.length === 0) throw new Error("No data found in RAS file data section.");
                return { tth, intensity, wavelength };
            };

            const parseGsasEsdFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                if (lines.length < 2) throw new Error("GSAS-style file is too short or invalid.");

                // Parse the first line for scan parameters: start, step, [end]
                const paramsLine = lines[0].trim().split(/\s+/);
                const startTth = parseFloat(paramsLine[0]);
                const stepSize = parseFloat(paramsLine[1]);

                if (isNaN(startTth) || isNaN(stepSize) || stepSize === 0) {
                    throw new Error("Could not parse start angle and step size from the file header.");
                }

                const intensity = [];
                // Start reading intensities from the 2nd or 3rd line, skipping any 'BANK' line
                let startLine = 1;
                if (lines.length > 1 && lines[1].toUpperCase().includes('BANK')) {
                    startLine = 2;
                }
                
                for (let i = startLine; i < lines.length; i++) {
                    const parts = lines[i].trim().split(/\s+/);
                    parts.forEach(part => {
                        const val = parseFloat(part);
                        if (!isNaN(val)) {
                            intensity.push(val);
                        }
                    });
                }

                if (intensity.length === 0) throw new Error("No intensity data found in GSAS-style file.");

                const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize);
                
                return { tth, intensity };
            };

            const parseUxdFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                const intensity = [];
                let startTth, stepSize, wavelength;
                let inDataSection = false;

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (inDataSection) {
                        const parts = trimmedLine.split(/\s+/);
                        parts.forEach(part => {
                            const val = parseFloat(part);
                            if (!isNaN(val)) {
                                intensity.push(val);
                            }
                        });
                    } else {
                        if (trimmedLine.toUpperCase().startsWith('_START=')) {
                            startTth = parseFloat(trimmedLine.substring(7));
                        } else if (trimmedLine.toUpperCase().startsWith('_STEPSIZE=')) {
                            stepSize = parseFloat(trimmedLine.substring(10));
                        } else if (trimmedLine.toUpperCase().startsWith('_WL1=')) {
                            wavelength = parseFloat(trimmedLine.substring(5));
                        } else if (trimmedLine.toUpperCase() === '_COUNTS') {
                            inDataSection = true;
                        }
                    }
                }

                if (startTth === undefined || stepSize === undefined) {
                    throw new Error("Could not find _START and _STEPSIZE parameters in UXD file.");
                }
                if (intensity.length === 0) {
                    throw new Error("No intensity data found after _COUNTS in UXD file.");
                }

                const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize);
                
                return { tth, intensity, wavelength };
            };

            const parsePhilipsUdfFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                const tth = [], intensity = [];
                let inDataSection = false;
                let wavelength = null;

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (trimmedLine.toUpperCase().startsWith('LAMBDA')) {
                        const parts = trimmedLine.split('=');
                        if (parts.length > 1) wavelength = parseFloat(parts[1]);
                    }
                    if (trimmedLine.toUpperCase() === '[DATA]') {
                        inDataSection = true;
                        continue;
                    }
                    if (trimmedLine.startsWith('[') && trimmedLine.toUpperCase() !== '[DATA]') {
                        inDataSection = false;
                    }
                    if (inDataSection) {
                        const parts = trimmedLine.split(/,/).map(p => p.trim());
                        if(parts.length >= 2) {
                            const x = parseFloat(parts[0]);
                            const y = parseFloat(parts[1]);
                            if (!isNaN(x) && !isNaN(y)) {
                                tth.push(x);
                                intensity.push(y);
                            }
                        }
                    }
                }
                if (tth.length === 0) throw new Error("No [Data] section found in UDF file.");
                return { tth, intensity, wavelength };
            };


            ui.fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    try {
                        let parsedData;
                        const fileContent = evt.target.result;
                        const fileName = file.name.toLowerCase();
                        
                        const lines = fileContent.trim().split(/\r?\n/);
                        const firstLine = lines.length > 0 ? lines[0].trim() : '';

                        if (fileName.endsWith('.uxd') || firstLine.startsWith('_FILEVERSION')) {
                            parsedData = parseUxdFile(fileContent);
                        } else if (fileName.endsWith('.xrdml') || (fileContent.includes('<?xml') && fileContent.includes('<xrdMeasurement'))) {
                            parsedData = parseXrdmlFile(fileContent);
                        } else if (fileName.endsWith('.brml') || (fileContent.includes('<?xml') && fileContent.includes('<RawDataFile'))) {
                            parsedData = parseBrukerBrmlFile(fileContent);
                        } else if (fileName.endsWith('.ras') || fileContent.toUpperCase().includes('*RAS_HEADER_START')) {
                            parsedData = parseRigakuRasFile(fileContent);
                        } else if (fileName.endsWith('.udf')) {
                            parsedData = parsePhilipsUdfFile(fileContent);
                        } else if (lines.length > 2 && lines[1].toUpperCase().includes('BANK')) {
                             parsedData = parseGsasEsdFile(fileContent);
                        } else {
                            parsedData = parseDataFile(fileContent);
                        }
                        
                        if (!parsedData || parsedData.tth.length === 0) {
                            throw new Error("No valid data points could be parsed from the file.");
                        }

                        // --- Successful Parse: Update UI ---
                        fullExperimentalData = parsedData;
                        const maxIntensity = Math.max(...fullExperimentalData.intensity);
                        if (maxIntensity > 0) {
                             fullExperimentalData.intensity = fullExperimentalData.intensity.map(y => y / maxIntensity * 1000);
                        }

                        solutions = [];
                        updateSolutionsTable();
                        ui.solutionsLed.className = 'led-indicator gray'; // Reset LED

                        if (parsedData.wavelength) {
                            ui.wavelength.value = parsedData.wavelength.toFixed(5);
                        }

                        selectedSolution = null;
                        currentHklList = [];
                        ui.fileName.textContent = file.name;
                        ui.placeholder.style.display = 'none';
                        ui.resultsContainer.style.display = 'flex';
                        ui.peakControls.classList.remove('hidden');
                        ui.indexingControls.classList.remove('hidden');
                        initializeChart();
                        setupTthSliders();
                        showStatus(`File "${file.name}" loaded successfully.`, 'success');

                    } catch (error) {
                        showStatus(`Error reading file: ${error.message}`, 'error');
                        console.error(error);
                    }
                };
                reader.onerror = () => {
                     showStatus('Error: Could not read the selected file.', 'error');
                };
                reader.readAsText(file);
            });

            const setupTthSliders = () => {
                if (fullExperimentalData.tth.length === 0) return;
                const min = fullExperimentalData.tth[0];
                const max = fullExperimentalData.tth[fullExperimentalData.tth.length - 1];
                const step = (max - min) / 2000;

                [ui.tthMinSlider, ui.tthMaxSlider, ui.tthMinInput, ui.tthMaxInput].forEach(el => {
                    el.disabled = false;
                });

                Object.assign(ui.tthMinSlider, { min, max, step, value: min });
                Object.assign(ui.tthMaxSlider, { min, max, step, value: max });

                ui.tthMinInput.value = Math.floor(min);
                ui.tthMaxInput.value = Math.ceil(max);

                updatePlotRange();
            };

            const updatePlotRange = () => {
                if(!xrdChart) return;
                const min = parseFloat(ui.tthMinInput.value);
                const max = parseFloat(ui.tthMaxInput.value);
                xrdChart.options.scales.x.min = min;
                xrdChart.options.scales.x.max = max;

                const visibleIntensities = fullExperimentalData.intensity.filter((intensity, index) => {
                    const tth = fullExperimentalData.tth[index];
                    return tth >= min && tth <= max;
                });

                if (visibleIntensities.length > 0) {
                    const yMaxInRange = Math.max(...visibleIntensities);
                    xrdChart.options.scales.y.min = -yMaxInRange * 0.25;
                    xrdChart.options.scales.y.max = yMaxInRange * 1.1;
                } else {
                    const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
                    xrdChart.options.scales.y.min = -yMax * 0.25;
                    xrdChart.options.scales.y.max = yMax * 1.1;
                }

                xrdChart.update('none');
            };

            ui.tthMinSlider.addEventListener('input', () => {
                let minVal = parseFloat(ui.tthMinSlider.value);
                let maxVal = parseFloat(ui.tthMaxSlider.value);
                if (minVal >= maxVal) {
                    minVal = maxVal - parseFloat(ui.tthMinSlider.step);
                    ui.tthMinSlider.value = minVal;
                }
                ui.tthMinInput.value = Math.round(minVal);
                updatePlotRange();
                findPeaks();
            });
             ui.tthMaxSlider.addEventListener('input', () => {
                let minVal = parseFloat(ui.tthMinSlider.value);
                let maxVal = parseFloat(ui.tthMaxSlider.value);
                if (maxVal <= minVal) {
                    maxVal = minVal + parseFloat(ui.tthMaxSlider.step);
                    ui.tthMaxSlider.value = maxVal;
                }
                ui.tthMaxInput.value = Math.round(maxVal);
                updatePlotRange();
                findPeaks();
            });
            ui.tthMinInput.addEventListener('change', () => { if(!ui.tthMinSlider.disabled) {ui.tthMinSlider.value = ui.tthMinInput.value; updatePlotRange(); findPeaks();} });
            ui.tthMaxInput.addEventListener('change', () => { if(!ui.tthMaxSlider.disabled) {ui.tthMaxSlider.value = ui.tthMaxInput.value; updatePlotRange(); findPeaks();} });

            // =======  trouver un background un peu approx

            const estimateBackgroundRollingBall = (data, ballRadius) => {
                const n = data.length;
                const background = new Array(n);
                
                const windowSize = Math.max(5, Math.min(Math.floor(ballRadius), Math.floor(n / 10)));
                const halfWindow = Math.floor(windowSize / 2);
                
                for (let i = 0; i < n; i++) {
                    let minVal = data[i];
                    for (let j = Math.max(0, i - halfWindow); j <= Math.min(n - 1, i + halfWindow); j++) {
                        minVal = Math.min(minVal, data[j]);
                    }
                    background[i] = minVal;
                }
                
                return smoothBackground(background, Math.max(3, Math.floor(windowSize / 3)));
            };

            const estimateBackgroundMovingMinimum = (data, windowSize) => {
                const n = data.length;
                const background = new Array(n);
                const halfWindow = Math.floor(windowSize / 2);
                
                for (let i = 0; i < n; i++) {
                    const start = Math.max(0, i - halfWindow);
                    const end = Math.min(n - 1, i + halfWindow);
                    let minVal = Infinity;
                    for (let j = start; j <= end; j++) {
                        minVal = Math.min(minVal, data[j]);
                    }
                    background[i] = minVal;
                }
                
                return smoothBackground(background, Math.max(5, Math.floor(windowSize / 5)));
            };

            const estimateBackgroundPercentile = (data, windowSize, percentile = 10) => {
                const n = data.length;
                const background = new Array(n);
                const halfWindow = Math.floor(windowSize / 2);
                
                for (let i = 0; i < n; i++) {
                    const start = Math.max(0, i - halfWindow);
                    const end = Math.min(n - 1, i + halfWindow);
                    const windowData = [];
                    for (let j = start; j <= end; j++) {
                        windowData.push(data[j]);
                    }
                    windowData.sort((a, b) => a - b);
                    const index = Math.floor((percentile / 100) * windowData.length);
                    background[i] = windowData[Math.max(0, Math.min(index, windowData.length - 1))];
                }
                
                return smoothBackground(background, Math.max(5, Math.floor(windowSize / 4)));
            };

            const smoothBackground = (background, smoothWindow) => {
                const n = background.length;
                if (smoothWindow <= 1) return background;
                
                const smoothed = new Array(n);
                const halfWindow = Math.floor(smoothWindow / 2);
                
                for (let i = 0; i < n; i++) {
                    let sum = 0;
                    let count = 0;
                    for (let j = Math.max(0, i - halfWindow); j <= Math.min(n - 1, i + halfWindow); j++) {
                        sum += background[j];
                        count++;
                    }
                    smoothed[i] = sum / count;
                }
                
                return smoothed;
            };

            const subtractBackground = (data, method = 'percentile') => {
                const n = data.length;
                if (n < 10) return { corrected: data, background: new Array(n).fill(0) };
                
                const windowSize = Math.max(20, Math.min(100, Math.floor(n / 15)));
                let background;
                
                switch (method) {
                    case 'rolling_ball':
                        background = estimateBackgroundRollingBall(data, windowSize);
                        break;
                    case 'moving_minimum':
                        background = estimateBackgroundMovingMinimum(data, windowSize);
                        break;
                    case 'percentile':
                    default:
                        background = estimateBackgroundPercentile(data, windowSize, 5);
                        break;
                }
                
                const corrected = new Array(n);
                let minCorrected = Infinity;
                
                for (let i = 0; i < n; i++) {
                    corrected[i] = data[i] - background[i];
                    minCorrected = Math.min(minCorrected, corrected[i]);
                }
                
                if (minCorrected < 0) {
                    for (let i = 0; i < n; i++) {
                        corrected[i] -= minCorrected;
                    }
                }
                
                return { corrected, background };
            };

            // ======= 
            const savitzkyGolay = (data, windowSize = 9, polyOrder = 2) => {
                const n = data.length;
                if (n === 0) return [];
                
                windowSize = Math.max(3, windowSize);
                if (windowSize % 2 === 0) windowSize += 1;
                windowSize = Math.min(windowSize, n);
                
                const halfWindow = Math.floor(windowSize / 2);
                const result = new Array(n);
                
                const coefficients = calculateSavitzkyGolayCoefficients(windowSize, polyOrder);
                
                for (let i = 0; i < n; i++) {
                    let smoothedValue = 0;
                    for (let j = -halfWindow; j <= halfWindow; j++) {
                        let idx = i + j;
                        if (idx < 0) idx = Math.abs(idx);
                        else if (idx >= n) idx = n - 1 - (idx - (n - 1));
                        smoothedValue += data[idx] * coefficients[j + halfWindow];
                    }
                    result[i] = smoothedValue;
                }
                
                return result;
            };

            const calculateSavitzkyGolayCoefficients = (windowSize, polyOrder) => {
                if (windowSize === 9 && polyOrder === 2) {
                    return [-0.0909, 0.0606, 0.1687, 0.2333, 0.2545, 0.2333, 0.1687, 0.0606, -0.0909];
                }
                
                const halfWindow = Math.floor(windowSize / 2);
                const weights = [];
                for (let i = -halfWindow; i <= halfWindow; i++) {
                    weights.push(1 - Math.abs(i) / (halfWindow + 1));
                }
                
                const sum = weights.reduce((a, b) => a + b, 0);
                return weights.map(w => w / sum);
            };

            // ======enleve un backhround...
            const findPeaks = () => {
                if (!fullExperimentalData || !fullExperimentalData.intensity || fullExperimentalData.intensity.length < 5) {
                    showStatus("Not enough data points for peak finding.", "error");
                    return;
                }

                const { intensity, tth } = fullExperimentalData;
                const n = tth.length;

                const minTth = parseFloat(ui.tthMinInput.value) || tth[0];
                const maxTth = parseFloat(ui.tthMaxInput.value) || tth[n - 1];
                const minHeightPercent = parseFloat(ui.peakThresholdInput.value) || 2;

                const backgroundResult = subtractBackground(intensity, 'percentile');
                const backgroundCorrected = backgroundResult.corrected;

                const windowSize = Math.max(5, Math.min(11, Math.floor(n / 100)));
                const smoothed = savitzkyGolay(backgroundCorrected, windowSize, 2);

                const maxCorrectedIntensity = Math.max(...backgroundCorrected);
                const minAbsoluteHeight = (minHeightPercent / 100) * maxCorrectedIntensity;
                
                const noiseLevel = calculateNoiseLevel(backgroundCorrected);
                const adaptiveThreshold = Math.max(minAbsoluteHeight, noiseLevel * 3);

                const localMaxIndices = [];
                for (let i = 1; i < n - 1; i++) {
                    const current = smoothed[i];
                    if (current < adaptiveThreshold) continue;
                    
                    if (current > smoothed[i - 1] && current > smoothed[i + 1]) {
                        localMaxIndices.push(i);
                    } else if (current === smoothed[i + 1] && current > smoothed[i - 1]) {
                        let plateauEnd = i + 1;
                        while (plateauEnd < n - 1 && Math.abs(smoothed[plateauEnd] - current) < maxCorrectedIntensity * 0.001) {
                            plateauEnd++;
                        }
                        if (plateauEnd < n && smoothed[plateauEnd] < current) {
                            localMaxIndices.push(Math.round((i + plateauEnd - 1) / 2));
                        }
                        i = plateauEnd - 1;
                    }
                }

                const candidates = [];
                for (const idx of localMaxIndices) {
                    if (tth[idx] < minTth || tth[idx] > maxTth) continue;
                    if (backgroundCorrected[idx] < adaptiveThreshold) continue;
                    
                    const prominence = calculatePeakProminence(smoothed, idx);
                    if (prominence < adaptiveThreshold * 0.3) continue;
                    
                    const peakWidth = calculatePeakWidth(smoothed, idx, smoothed[idx] * 0.5);
                    if (peakWidth < 2) continue;
                    
                    candidates.push({ 
                        idx, tth: tth[idx], height: smoothed[idx], 
                        backgroundCorrectedHeight: backgroundCorrected[idx],
                        prominence, width: peakWidth
                    });
                }

                const refinedPeaks = [];
                for (const peak of candidates) {
                    const { idx } = peak;
                    let refinedTth = peak.tth;
                    
                    if (idx > 0 && idx < n - 1) {
                        const y1 = smoothed[idx - 1], y2 = smoothed[idx], y3 = smoothed[idx + 1];
                        const denominator = 2 * (y1 - 2 * y2 + y3);
                        if (Math.abs(denominator) > 1e-10) {
                            const delta = (y1 - y3) / denominator;
                            if (Math.abs(delta) < 1.0) {
                                const stepSize = idx < n - 1 ? tth[idx + 1] - tth[idx] : tth[idx] - tth[idx - 1];
                                refinedTth = tth[idx] + delta * stepSize;
                            }
                        }
                    }
                    refinedPeaks.push({ ...peak, tth: refinedTth });
                }

                refinedPeaks.sort((a, b) => a.tth - b.tth);

                const finalPeaks = [];
                const mergeThreshold = 0.02;
                for (const peak of refinedPeaks) {
                    if (finalPeaks.length === 0 || Math.abs(peak.tth - finalPeaks[finalPeaks.length - 1].tth) >= mergeThreshold) {
                        finalPeaks.push(peak);
                    } else if (peak.prominence > finalPeaks[finalPeaks.length - 1].prominence) {
                        finalPeaks[finalPeaks.length - 1] = peak;
                    }
                }

                const lambda = parseFloat(ui.wavelength.value) || 1.54178;
                pickedPeaks = finalPeaks.map(p => {
                    const d = lambda / (2 * Math.sin(p.tth * Math.PI / 360));
                    return { tth: p.tth, d: d, q: 1 / (d * d) };
                });

                updatePeakTable();

                ui.startIndexingButton.disabled = (pickedPeaks.length < 4);
                ui.startIndexingButton.textContent = pickedPeaks.length < 4 ? 
                    `Need ${4 - pickedPeaks.length} more peaks` : 'Start Indexing';

                showStatus(`Found ${pickedPeaks.length} peaks after background subtraction.`, 'info');
            };

            // ====  meilleure détection de pics

            const calculateNoiseLevel = (data) => {
                const n = data.length;
                if (n < 10) return 0;
                
                const sample = [];
                for (let i = 0; i < n; i += Math.max(1, Math.floor(n / 100))) {
                    sample.push(data[i]);
                }
                sample.sort((a, b) => a - b);
                const median = sample[Math.floor(sample.length / 2)];
                
                const deviations = sample.map(x => Math.abs(x - median));
                deviations.sort((a, b) => a - b);
                
                return deviations[Math.floor(deviations.length / 2)] * 1.4826;
            };

            const calculatePeakProminence = (data, peakIndex) => {
                const n = data.length;
                const peakHeight = data[peakIndex];
                
                const windowSize = Math.min(20, Math.floor(n / 20));
                const start = Math.max(0, peakIndex - windowSize);
                const end = Math.min(n - 1, peakIndex + windowSize);
                
                let minLeft = peakHeight, minRight = peakHeight;
                for (let i = peakIndex - 1; i >= start; i--) minLeft = Math.min(minLeft, data[i]);
                for (let i = peakIndex + 1; i <= end; i++) minRight = Math.min(minRight, data[i]);
                
                return peakHeight - Math.max(minLeft, minRight);
            };

            const calculatePeakWidth = (data, peakIndex, halfMaxHeight) => {
                const n = data.length;
                let leftIndex = peakIndex, rightIndex = peakIndex;

                for (let i = peakIndex - 1; i >= 0; i--) {
                    if (data[i] <= halfMaxHeight) { leftIndex = i; break; }
                }
                for (let i = peakIndex + 1; i < n; i++) {
                    if (data[i] <= halfMaxHeight) { rightIndex = i; break; }
                }
                return rightIndex - leftIndex + 1;
            };

            const recalculatePeakValues = () => {
                const lambda = parseFloat(ui.wavelength.value);
                pickedPeaks.forEach(peak => {
                    peak.d = lambda / (2 * Math.sin(peak.tth * Math.PI / 360));
                    peak.q = 1 / (peak.d * peak.d);
                });
            };

            const updatePeakTable = () => {
                ui.peakListBody.innerHTML = '';
                pickedPeaks.forEach((peak, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td><input type="number" class="peak-tth-input" value="${peak.tth.toFixed(4)}" data-index="${index}" step="0.0001"></td>
                        <td><input type="number" class="peak-d-input" value="${peak.d.toFixed(5)}" data-index="${index}" disabled></td>
                        <td><button class="delete-peak-btn" data-index="${index}">X</button></td>
                    `;
                    ui.peakListBody.appendChild(row);
                });
                ui.peakTableContainer.classList.toggle('hidden', pickedPeaks.length === 0);
                updateAllMarkers();
            };

            ui.findPeaksButton.addEventListener('click', () => {
                findPeaks();
                showStatus(`${pickedPeaks.length} peaks found in the specified range.`, 'info');
            });
            ui.peakThresholdInput.addEventListener('change', findPeaks);

            ui.peakListBody.addEventListener('change', (e) => {
                if (e.target.classList.contains('peak-tth-input')) {
                    const index = parseInt(e.target.dataset.index);
                    const tth = parseFloat(e.target.value);
                    const lambda = parseFloat(ui.wavelength.value);
                    const d = lambda / (2 * Math.sin(tth * Math.PI / 360));
                    const q = 1 / (d*d);
                    pickedPeaks[index] = {tth, d, q};
                    e.target.closest('tr').querySelector('.peak-d-input').value = d.toFixed(5);
                    updateAllMarkers();
                }
            });
             ui.peakListBody.addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-peak-btn')) {
                    const index = parseInt(e.target.dataset.index);
                    pickedPeaks.splice(index, 1);
                    updatePeakTable();
                }
            });

            const startIndexing = () => {
                if (pickedPeaks.length < 4) {
                    showStatus("Please find at least 4 peaks before starting indexing.", 'error');
                    return;
                }

                const systemsToSearch = Array.from(ui.systemCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
                if (systemsToSearch.length === 0) {
                    showStatus("Please select at least one crystal system to search.", 'error');
                    return;
                }

                setUIState(true);
                solutions = [];
                selectedSolution = null;
                currentHklList = [];
                activeWorkers = [];
                updateSolutionsTable();
                showStatus(`Indexing started for ${systemsToSearch.length} system(s)...`, 'info');

                const baseParams = {
                    peaks: pickedPeaks,
                    wavelength: parseFloat(ui.wavelength.value),
                    tth_error: parseFloat(ui.tthError.value),
                    max_volume: parseFloat(ui.maxVolume.value),
                    impurity_peaks: parseInt(ui.impurityPeaksInput.value, 10),
                };

                const workerScript = document.getElementById('indexing-worker').textContent;
                const blob = new Blob([workerScript], { type: 'application/javascript' });
                const workerURL = URL.createObjectURL(blob);

                let completedWorkers = 0;
                const totalWorkers = systemsToSearch.length;

                systemsToSearch.forEach(system => {
                    const worker = new Worker(workerURL);
                    activeWorkers.push(worker);

                    worker.onmessage = (e) => {
                        const { type, payload } = e.data;
                        if (type === 'solution') {
                            solutions.push(payload);
                        } else if (type === 'done') {
                            completedWorkers++;
                            ui.progressBar.style.width = `${(completedWorkers / totalWorkers) * 100}%`;
                            worker.terminate();
                            activeWorkers = activeWorkers.filter(w => w !== worker);

                            if (completedWorkers === totalWorkers) {
                                URL.revokeObjectURL(workerURL);
                                setUIState(false);
                                sortSolutions(); // Initial sort by M20
                                updateSolutionsTable(); // Render sorted results
                                if (solutions.length > 0) {
                                    showStatus(`Indexing complete. Found ${solutions.length} potential solution(s).`, 'success');
                                    ui.solutionsLed.className = 'led-indicator green';
                                } else {
                                    showStatus('Indexing finished, but no valid solutions were found.', 'info');
                                    ui.solutionsLed.className = 'led-indicator red';
                                }
                            }
                        }
                    };
                    worker.postMessage({ ...baseParams, systemToSearch: system });
                });
            };

            ui.startIndexingButton.addEventListener('click', startIndexing);

            ui.reportButton.addEventListener('click', () => {
                if (isIndexing) {
                    activeWorkers.forEach(w => w.terminate());
                    activeWorkers = [];
                    setUIState(false);
                    showStatus('Indexing stopped by user.', 'info');
                } else {
                    generatePDFReport();
                }
            });

            const setUIState = (indexing) => {
                isIndexing = indexing;
                document.body.style.cursor = indexing ? 'wait' : 'default';

                const controlsToDisable = [
                    ui.fileInput, ui.findPeaksButton, ui.peakThresholdInput,
                    ui.tthMinSlider, ui.tthMaxSlider, ui.tthMinInput, ui.tthMaxInput,
                    ui.wavelength, ui.tthError, ui.maxVolume,
                    ui.impurityPeaksInput, ...ui.systemCheckboxes, ...ui.tabButtons
                ];

                controlsToDisable.forEach(el => {
                    if (el) el.disabled = indexing;
                });

                ui.peakListBody.querySelectorAll('input, button').forEach(el => {
                    el.disabled = indexing;
                });

                const fileLabel = document.querySelector('.file-input-label');
                if (fileLabel) {
                    fileLabel.style.pointerEvents = indexing ? 'none' : 'auto';
                    fileLabel.style.opacity = indexing ? '0.7' : '1';
                }

                if (indexing) {
                    ui.startIndexingButton.disabled = true;
                    ui.startIndexingButton.textContent = 'Indexing...';
                    ui.reportButton.textContent = 'Stop';
                    ui.reportButton.disabled = false;
                    ui.progressBarContainer.classList.remove('hidden');
                    ui.progressBar.style.width = '0%';
                } else {
                    ui.startIndexingButton.disabled = (pickedPeaks.length === 0);
                    ui.startIndexingButton.textContent = 'Start Indexing';
                    ui.reportButton.textContent = 'Generate PDF Report';
                    ui.reportButton.disabled = (solutions.length === 0);
                    ui.progressBarContainer.classList.add('hidden');
                    ui.progressBar.style.width = '0%';
                    if (fullExperimentalData.tth.length > 0) {
                        ui.tthMinSlider.disabled = false;
                        ui.tthMaxSlider.disabled = false;
                        ui.tthMinInput.disabled = false;
                        ui.tthMaxInput.disabled = false;
                    }
                }
            };
            
            const sortSolutions = () => {
                const { column, direction } = sortState;
                const dir = direction === 'asc' ? 1 : -1;
                solutions.sort((a, b) => {
                    if (column === 'system') {
                        return a.system.localeCompare(b.system) * dir;
                    } else {
                        return (a[column] - b[column]) * dir;
                    }
                });
            };

            const updateSortIndicators = () => {
                 ui.solutionsTableHeaders.forEach(h => {
                     h.classList.remove('sort-asc', 'sort-desc');
                     if (h.dataset.sort === sortState.column) {
                         h.classList.add(sortState.direction === 'asc' ? 'sort-asc' : 'sort-desc');
                     }
                 });
            };

            ui.solutionsTableHeaders.forEach(header => {
                header.addEventListener('click', () => {
                    const column = header.dataset.sort;
                    if (!column) return;
                    if (sortState.column === column) {
                        sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortState.column = column;
                        sortState.direction = (column === 'm20' || column === 'volume') ? 'desc' : 'asc';
                    }
                    sortSolutions();
                    updateSolutionsTable();
                });
            });

            const updateSolutionsTable = () => {
                ui.solutionsTableBody.innerHTML = '';
                solutions.slice(0, 50).forEach((sol) => {
                    const row = document.createElement('tr');
                    row.dataset.originalIndex = solutions.indexOf(sol);

                    let cell_params1 = `${sol.a.toFixed(4)}`;
                    if(sol.b) cell_params1 += `, ${sol.b.toFixed(4)}`;
                    if(sol.c) cell_params1 += `, ${sol.c.toFixed(4)}`;

                    const cell_params2 = `${sol.alpha ? sol.alpha.toFixed(2) : '90'}, ${sol.beta ? sol.beta.toFixed(2) : '90'}, ${sol.gamma ? sol.gamma.toFixed(2) : '90'}`;

                    row.innerHTML = `
                        <td>${sol.system.substring(0,4)}</td>
                        <td>${cell_params1}</td>
                        <td>${cell_params2}</td>
                        <td>${sol.volume.toFixed(2)}</td>
                        <td>${sol.m20.toFixed(2)}</td>
                    `;
                    ui.solutionsTableBody.appendChild(row);
                });
                updateSortIndicators();
            };

            ui.solutionsTableBody.addEventListener('click', (e) => {
                const row = e.target.closest('tr');
                if (!row) return;

                document.querySelectorAll('#solutions-table-body tr').forEach(r => r.classList.remove('selected'));
                row.classList.add('selected');

                const index = parseInt(row.dataset.originalIndex);
                selectedSolution = solutions[index];

                const lambda = parseFloat(ui.wavelength.value);
                const maxTth = xrdChart.options.scales.x.max || Math.max(...pickedPeaks.map(p => p.tth));
                currentHklList = generateHKL(maxTth, {...selectedSolution, lambda}, selectedSolution.system);

                updateAllMarkers();
            });

            const verticalCursorLine = {
                id: 'verticalCursorLine',
                afterDraw: chart => {
                    if (chart.tooltip?._active?.length) {
                        let x = chart.tooltip._active[0].element.x;
                        let yAxis = chart.scales.y;
                        let ctx = chart.ctx;
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(x, yAxis.top);
                        ctx.lineTo(x, yAxis.bottom);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)';
                        ctx.setLineDash([4, 4]);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            };
            Chart.register(verticalCursorLine);

            const initializeChart = () => {
                if (xrdChart) xrdChart.destroy();
                const experimentalPoints = fullExperimentalData.tth.map((t, i) => ({ x: t, y: fullExperimentalData.intensity[i] }));
                const yMax = Math.max(...fullExperimentalData.intensity);

                xrdChart = new Chart(ui.chartCanvas, {
                    type: 'line',
                    data: {
                        datasets: [
                            {
                                label: 'Intensity',
                                data: experimentalPoints,
                                borderColor: 'rgba(107, 114, 128, 0.7)',
                                borderWidth: 1.5,
                                pointRadius: 0
                            },
                            {
                                type: 'bar',
                                label: 'Observed Peaks',
                                data: [],
                                backgroundColor: 'rgba(239, 68, 68, 0.7)',
                                barThickness: 1
                            },
                            {
                                type: 'bar',
                                label: 'Calculated Peaks',
                                data: [],
                                backgroundColor: 'rgba(59, 130, 246, 0.9)',
                                barThickness: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false, animation: false,
                        interaction: {
                            intersect: false,
                            mode: 'index',
                        },
                        scales: {
                            x: { type: 'linear', title: { display: true, text: '2-theta (degrees)' } },
                            y: { title: { display: true, text: 'Intensity (a.u.)' }, min: -yMax * 0.15, max: yMax * 1.1 }
                        },
                        plugins: {
                            zoom: {
                                pan: { enabled: true, mode: 'xy', threshold: 5, },
                                zoom: { wheel: { enabled: false, }, pinch: { enabled: true, }, drag: { enabled: false, } }
                            },
                            legend: { position: 'top' },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        if (!tooltipItems.length) return '';
                                        const tth = tooltipItems[0].parsed.x;
                                        let title = `2θ: ${tth.toFixed(3)}°`;

                                        if (currentHklList && currentHklList.length > 0) {
                                            let closestPeak = null;
                                            let minDiff = Infinity;
                                            for (const hkl of currentHklList) {
                                                const diff = Math.abs(tth - hkl.tth);
                                                if (diff < minDiff) { minDiff = diff; closestPeak = hkl; }
                                            }
                                            
                                            const tolerance = parseFloat(ui.tthError.value) || 0.05;
                                            if (closestPeak && minDiff < tolerance) {
                                                title += `, HKL: (${closestPeak.h},${closestPeak.k},${closestPeak.l})`;
                                            }
                                        }
                                        return title;
                                    },
                                    label: function(context) {
                                        const datasetLabel = context.dataset.label || '';
                                        if (datasetLabel === 'Observed Peaks' || datasetLabel === 'Calculated Peaks') {
                                            return null;
                                        }
                                        let label = datasetLabel ? `${datasetLabel}: ` : '';
                                        if (context.parsed.y !== null) { label += Math.round(context.parsed.y); }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
            };

            const updateAllMarkers = () => {
                if (!xrdChart) return;

                const minX = xrdChart.options.scales.x.min;
                const maxX = xrdChart.options.scales.x.max;
                const visibleIntensities = fullExperimentalData.intensity.filter((_, index) => {
                    const tth = fullExperimentalData.tth[index];
                    return tth >= minX && tth <= maxX;
                });
                const yMax = visibleIntensities.length > 0 ? Math.max(...visibleIntensities) : (Math.max(...fullExperimentalData.intensity) || 1000);
                const markerHeight = yMax * 0.04;

                xrdChart.data.datasets[1].data = pickedPeaks.map(p => ({ x: p.tth, y: [-markerHeight * 0.25, -markerHeight * 1.25] }));

                if (selectedSolution) {
                    xrdChart.data.datasets[2].data = currentHklList.map(hkl => ({ x: hkl.tth, y: [-markerHeight * 1.5, -markerHeight * 2.5] }));
                } else {
                    xrdChart.data.datasets[2].data = [];
                }

                xrdChart.update('none');
            }

             const generateHKL = (maxTth, params, system) => {
                 const { a, b, c, alpha, beta, gamma, lambda } = params;
                 if (!a || !lambda) return [];
                 const reflections = [];
                 
                 const d_min = lambda / (2 * Math.sin(maxTth * Math.PI / 360));
                 const q_max_limit = (1 / (d_min * d_min)) * 1.05;

                 const h_max = Math.ceil(a / d_min);
                 const k_max = b ? Math.ceil(b / d_min) : h_max;
                 const l_max = c ? Math.ceil(c / d_min) : h_max;

                 for (let h = 0; h <= h_max; h++) {
                     for (let k = 0; k <= k_max; k++) {
                         if ((system === 'cubic' || system === 'tetragonal' || system === 'hexagonal') && k > h) continue;
                         for (let l = 0; l <= l_max; l++) {
                             if (system === 'cubic' && l > k) continue;
                             if (h === 0 && k === 0 && l === 0) continue;
                             let inv_d_sq = 0;
                             switch (system) {
                                 case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                                 case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                                 case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                                 case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                                 case 'monoclinic': 
                                     const sinBeta = Math.sin(beta * Math.PI / 180);
                                     const cosBeta = Math.cos(beta * Math.PI / 180);
                                     inv_d_sq = (1 / (sinBeta * sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + k*k/(b*b);
                                     break;
                             }
                             if (inv_d_sq <= 0 || inv_d_sq > q_max_limit) continue;

                             const sinThetaSq = (lambda*lambda / 4) * inv_d_sq;
                             if (sinThetaSq <= 1) {
                                 const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                                 reflections.push({tth, h, k, l, d: 1/Math.sqrt(inv_d_sq)});
                             }
                         }
                     }
                 }
                 return reflections.sort((a, b) => a.tth - b.tth);
             };


            const resizer = document.getElementById('drag-handle');
            const leftPanel = document.getElementById('controls-panel');
            resizer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                document.body.style.cursor = 'col-resize';
                const moveHandler = (moveEvent) => {
                    if (moveEvent.clientX > 350 && moveEvent.clientX < window.innerWidth - 350) {
                        leftPanel.style.width = `${moveEvent.clientX}px`;
                    }
                };
                const upHandler = () => {
                    document.body.style.cursor = 'default';
                    window.removeEventListener('mousemove', moveHandler);
                    window.removeEventListener('mouseup', upHandler);
                };
                window.addEventListener('mousemove', moveHandler);
                window.addEventListener('mouseup', upHandler);
            });
            
            ui.chartCanvas.addEventListener('wheel', e => {
                e.preventDefault();

                const chart = xrdChart;
                if (!chart || !chart.chartArea) return;

                const { left, right, top, bottom } = chart.chartArea;
                const x = e.offsetX;
                const y = e.offsetY;

                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;

                if (y > bottom) {
                    chart.zoom({ x: zoomFactor }, { x, y });
                } else if (x < left) {
                    chart.zoom({ y: zoomFactor }, { x, y });
                } else if (x >= left && x <= right && y >= top && y <= bottom) {
                    chart.zoom({ x: zoomFactor, y: zoomFactor }, { x, y });
                }
            });

            ui.chartCanvas.addEventListener('contextmenu', e => {
                e.preventDefault();
                if (xrdChart) {
                    xrdChart.resetZoom();
                }
            });


        const generatePDFReport = async () => {
                if (solutions.length === 0) {
                    showStatus("No solutions found to generate a report.", 'info');
                    return;
                }

                ui.reportButton.textContent = 'Generating...';
                ui.reportButton.disabled = true;
                document.body.style.cursor = 'wait';

                try {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                    const margin = 15;
                    let yPos = 20;

                    const now = new Date();
                    const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                    doc.setFontSize(18);
                    doc.text('Powder Indexing Report', 105, yPos, { align: 'center' });
                    yPos += 10;
                    doc.setFontSize(10);
                    doc.text(`Generated: ${timestamp}`, margin, yPos);
                    yPos += 5;
                    doc.text(`Data File: ${ui.fileName.textContent}`, margin, yPos);
                    yPos += 10;

                    const canvas = await html2canvas(ui.chartCanvas, { backgroundColor: '#ffffff' });
                    const imgData = canvas.toDataURL('image/png');
                    const imgProps = doc.getImageProperties(imgData);
                    const pdfWidth = doc.internal.pageSize.getWidth();
                    const imgWidth = pdfWidth - 2 * margin;
                    const imgHeight = (imgProps.height * imgWidth) / imgProps.width;
                    doc.addImage(imgData, 'PNG', margin, yPos, imgWidth, imgHeight);
                    yPos += imgHeight + 10;

                    doc.addPage();
                    yPos = 20;
                    doc.setFontSize(14);
                    doc.text('Indexing Solutions Summary', margin, yPos);
                    yPos += 8;
                    doc.setFont('courier', 'normal');
                    doc.setFontSize(9);
                    doc.text('Sys  M(20)   Volume(A^3)  a(A)      b(A)      c(A)      alpha  beta   gamma', margin, yPos);
                    yPos += 5;
                    solutions.slice(0, 20).forEach(sol => {
                        if (yPos > 280) { doc.addPage(); yPos = 20; }
                        const line = `${sol.system.substring(0,4).padEnd(5)}` +
                                    `${sol.m20.toFixed(2).padStart(6)}  ` +
                                    `${sol.volume.toFixed(2).padStart(10)}  ` +
                                    `${sol.a.toFixed(4).padStart(8)}  ` +
                                    `${(sol.b ? sol.b.toFixed(4) : '-').padStart(8)}  ` +
                                    `${(sol.c ? sol.c.toFixed(4) : '-').padStart(8)}  ` +
                                    `${(sol.alpha ? sol.alpha.toFixed(2) : '90.00').padStart(6)} ` +
                                    `${(sol.beta ? sol.beta.toFixed(2) : '90.00').padStart(6)} ` +
                                    `${(sol.gamma ? sol.gamma.toFixed(2) : '90.00').padStart(6)}`;
                        doc.text(line, margin, yPos);
                        yPos += 5;
                    });

                    const lambda = parseFloat(ui.wavelength.value);
                    solutions.forEach((sol, solIndex) => {
                        doc.addPage();
                        yPos = 20;
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(12);
                        doc.text(`Details for Solution #${solIndex+1}: ${sol.system}, M(20) = ${sol.m20.toFixed(2)}`, margin, yPos);
                        yPos += 7;

                        doc.setFont('courier', 'normal');
                        doc.setFontSize(9);
                        let paramsLine = `a=${sol.a.toFixed(4)}`;
                        if(sol.b) paramsLine += `, b=${sol.b.toFixed(4)}`;
                        if(sol.c) paramsLine += `, c=${sol.c.toFixed(4)}`;
                        paramsLine += ` (A)`;
                        if(sol.alpha && sol.system !== 'cubic') paramsLine += `, alpha=${sol.alpha.toFixed(2)}`;
                        if(sol.beta && sol.system !== 'cubic') paramsLine += `, beta=${sol.beta.toFixed(2)}`;
                        if(sol.gamma && sol.system !== 'cubic') paramsLine += `, gamma=${sol.gamma.toFixed(2)}`;
                        doc.text(paramsLine, margin, yPos);
                        yPos += 7;

                        doc.setFont('helvetica', 'bold');
                        doc.text(`Suggested Centering:`, margin, yPos);
                        doc.setFont('courier', 'normal');
                        doc.text(sol.analysis.centering, margin + 45, yPos);
                        yPos += 5;

                        if (sol.analysis.conditions.length > 0) {
                            doc.setFont('helvetica', 'bold');
                            doc.text(`Reflection Conditions:`, margin, yPos);
                            doc.setFont('courier', 'normal');
                            doc.text(sol.analysis.conditions.join(', '), margin + 45, yPos);
                            yPos += 5;
                        }

                        if (sol.analysis.possibleSpaceGroups.length > 0) {
                            doc.setFont('helvetica', 'bold');
                            doc.text(`Space Groups:`, margin, yPos);
                            let currentX = margin + 45;
                            const probableSet = new Set(sol.analysis.probableSpaceGroups);
                            const allGroups = sol.analysis.possibleSpaceGroups;
                            const pageRightMargin = doc.internal.pageSize.getWidth() - margin;

                            allGroups.forEach((sg, index) => {
                                doc.setFont('courier', probableSet.has(sg) ? 'bold' : 'normal');
                                const text = sg + (index < allGroups.length - 1 ? ', ' : '');
                                if (currentX + doc.getTextWidth(text) > pageRightMargin && currentX > margin + 45) {
                                    yPos += 4;
                                    currentX = margin + 45;
                                }
                                doc.text(text, currentX, yPos);
                                currentX += doc.getTextWidth(text);
                            });
                            yPos += 4;
                        }
                        yPos += 3;

                        doc.setFont('courier', 'normal');
                        doc.text(' h  k  l |   d_cal(A) 2t_calc   d_obs(A)  2t_obs    d(2t)', margin, yPos);
                        yPos += 5;

                        const hklList = generateHKL(Math.max(...pickedPeaks.map(p=>p.tth)), {...sol, lambda}, sol.system);
                        const usedObsPeaks = new Set();
                        const tth_err = parseFloat(ui.tthError.value);

                        hklList.slice(0, 30).forEach(hkl => {
                            if (yPos > 280) { doc.addPage(); yPos = 20; }

                            let bestMatch = null;
                            let minDiff = Infinity;
                            pickedPeaks.forEach((peak, index) => {
                                if (usedObsPeaks.has(index)) return;
                                const diff = Math.abs(hkl.d - peak.d);
                                if (diff < minDiff) {
                                    minDiff = diff;
                                    bestMatch = { peak, index };
                                }
                            });

                            let d_obs_str = '-';
                            let tth_obs_str = '-';
                            let tth_diff_str = '-';

                            let tth_calc = '-';
                            if (hkl.d > 0 && lambda/(2*hkl.d) < 1) {
                                tth_calc = (2 * Math.asin(lambda / (2 * hkl.d)) * 180 / Math.PI).toFixed(3);
                            }
                            
                            if (bestMatch) {
                                const d_err_plus = lambda / (2 * Math.sin((bestMatch.peak.tth - tth_err) * Math.PI / 360));
                                const d_err_minus = lambda / (2 * Math.sin((bestMatch.peak.tth + tth_err) * Math.PI / 360));
                                if (minDiff < Math.abs(d_err_plus - d_err_minus)) {
                                    d_obs_str = bestMatch.peak.d.toFixed(5);
                                    tth_obs_str = bestMatch.peak.tth.toFixed(3);
                                    
                                    if (tth_calc !== '-') {
                                        const tth_diff = parseFloat(tth_calc) - bestMatch.peak.tth;
                                        tth_diff_str = tth_diff.toFixed(3);
                                    }
                                    
                                    usedObsPeaks.add(bestMatch.index);
                                }
                            }
                            
                            const line = `${String(hkl.h).padStart(2)} ${String(hkl.k).padStart(2)} ${String(hkl.l).padStart(2)} | ` +
                                         `${hkl.d.toFixed(5).padStart(9)} ` +
                                         `${String(tth_calc).padStart(7)}  ` +
                                         `${d_obs_str.padStart(9)}  ` +
                                         `${tth_obs_str.padStart(7)} ` +
                                         `${tth_diff_str.padStart(7)}`;
                            doc.text(line, margin, yPos);
                            yPos += 5;
                        });
                    });


                    const filename = `Indexing-Report-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}.pdf`;
                    doc.save(filename);
                    showStatus('PDF report generated and saved.', 'success');

                } catch (error) {
                    console.error("Failed to generate PDF:", error);
                    showStatus("An error occurred during PDF generation.", 'error');
                } finally {
                    ui.reportButton.textContent = 'Generate PDF Report';
                    ui.reportButton.disabled = (solutions.length === 0);
                    document.body.style.cursor = 'default';
                }
            };

        });
    </script>
    
<script id="indexing-worker" type="text/javascript">
    self.onmessage = function(e) {
        const { peaks, wavelength, tth_error, max_volume, systemToSearch, impurity_peaks } = e.data;
        const foundSolutions = [];
        const foundSolutionKeys = new Set(); // For O(1) duplicate checking

        const q_from_tth_local = (tth) => {
            const sin_theta = Math.sin(tth * Math.PI / 360);
            return (4 * sin_theta * sin_theta) / (wavelength * wavelength);
        };
        
        // Use sorted Float64Array for q_obs
        const tth_obs_deg = new Float64Array(peaks.map(p => p.tth));
        const peaks_sorted_by_q = peaks.map((p, i) => ({...p, original_index: i}))
                                     .sort((a,b) => a.q - b.q);
        const q_obs = new Float64Array(peaks_sorted_by_q.map(p => p.q));
        const original_indices = peaks_sorted_by_q.map(p => p.original_index);

        // Pre-calculate theta in radians for tolerance calculations
        const tth_obs_rad = new Float64Array(peaks.map(p => p.tth * Math.PI / 360));
        const N_FOR_M20 = Math.min(20, peaks.length);

        // Calculate d_min and q_max for dynamic HKL bounds
        const d_min = wavelength / (2 * Math.sin(peaks.map(p => p.tth).sort((a,b)=>b-a)[0] * Math.PI / 360));
        const q_max = 1 / (d_min * d_min);

        const min_lattice_param = 3.0;
        const max_lattice_param = 42.0;
        const min_m20 = 2.0;
        
        // Search depth parameters
        const max_hkl_low_angle_search = 5; //  reduced from 15+
        const tetra_hexa_i_depth = Math.min(10, peaks.length); // Use fewer peaks for basis, bon, je vais perdre certains ?
        const tetra_hexa_j_depth = Math.min(10, peaks.length);

        const max_hkl_analysis = 10;
        const spaceGroupData = { /* space group data */ 
            cubic: { 'P': { 'Pm-3m': { c: [] }, 'Pn-3n': { c: ['0kl:k+l=2n', 'hhl:l=2n'] }, 'Pm-3n': { c: ['hk0:h+k=2n'] }, 'Pa-3': { c: ['hk0:h=2n'] }, 'Pn-3m': { c: ['hhl:l=2n'] } }, 'I': { 'Im-3m': { c: [] }, 'Ia-3': { c: ['0kl:k=2n'] }, 'Ia-3d': { c: ['0kl:k=2n,l=2n', 'hhl:2h+l=4n'] } }, 'F': { 'Fm-3m': { c: [] }, 'Fd-3m': { c: ['0kl:k+l=4n'] }, 'Fm-3c': { c: ['hhl:l=2n'] } } },
            tetragonal: { 'P': { 'P4/mmm': { c: [] }, 'P4/mcc': { c: ['hhl:l=2n', '0kl:l=2n'] }, 'P4/nmm': { c: ['hk0:h+k=2n'] }, 'P4/ncc': { c: ['hk0:h+k=2n', '0kl:l=2n'] }, 'P4_2/mcm': { c: ['0kl:l=2n', 'hhl:l=2n'] }, 'P4_2/mnm': { c: ['0kl:k+l=2n', 'h00:h=2n'] }, 'P4_2/nmc': { c: ['hk0:h+k=2n', 'h0l:l=2n'] }, 'P4_2/nbc': { c: ['hk0:h+k=2n', '0kl:k=2n'] } }, 'I': { 'I4/mmm': { c: [] }, 'I4/mcm': { c: ['0kl:l=2n', 'hhl:l=2n'] }, 'I4_1/a': { c: ['hkl:2h+l=4n'] }, 'I4_1/amd': { c: ['hkl:2h+l=4n', 'hk0:h=2n,k=2n'] }, 'I4_1/acd': { c: ['hkl:2h+l=4n', 'hk0:h=2n,k=2n', '0kl:k=2n,l=2n'] } } },
            hexagonal: { 'P': { 'P6/mmm': { c: [] }, 'P6/mcc': { c: ['h-hl:l=2n', '00l:l=2n'] }, 'P6_3/mmc': { c: ['00l:l=2n'] }, 'P6_3/mcm': { c: ['h-hl:l=2n', '00l:l=2n'] }, 'P-3': { c: [] }, 'P-3m1': { c: [] }, 'P-31m': { c: [] }, }, 'R': { 'R-3': { c: [] }, 'R-3m': { c: [] }, 'R-3c': { c: ['h-hl:l=2n'] } } },
            orthorhombic: { 'P': { 'Pmmm': { c: [] }, 'Pnnn': { c: ['0kl:k+l=2n', 'h0l:h+l=2n', 'hk0:h+k=2n'] }, 'Pccm': { c: ['h0l:l=2n', '0kl:l=2n'] }, 'Pban': { c: ['0kl:k=2n', 'h0l:h=2n'] }, 'Pccn': { c: ['h0l:l=2n', '0kl:k=2n'] }, 'Pbcm': { c: ['0kl:k=2n', 'h0l:l=2n'] }, 'Pnnm': { c: ['hk0:h+k=2n'] }, 'Pnma': { c: ['0kl:k+l=2n', 'hk0:h=2n'] }, 'Pbca': { c: ['0kl:k=2n', 'h0l:l=2n', 'hk0:h=2n'] }, 'P2_12_12_1': { c: ['h00:h=2n', '0k0:k=2n', '00l:l=2n'] } }, 'C': { 'Cmmm': { c: [] }, 'Cmcm': { c: ['h0l:l=2n'] }, 'Cmce': { c: ['0kl:l=2n', 'h0l:h+l=2n'] }, 'Cccm': { c: ['h0l:l=2n'] }, 'Ccce': { c: ['h0l:l=2n', 'hhl:l=2n'] }, }, 'I': { 'Immm': { c: [] }, 'Ibam': { c: ['0kl:k=2n'] }, 'Ibca': { c: ['0kl:k=2n', 'h0l:l=2n'] }, 'Imma': { c: ['0kl:k+l=2n'] } }, 'F': { 'Fmmm': { c: [] }, 'Fddd': { c: ['0kl:k+l=4n', 'h0l:h+l=4n', 'hk0:h+k=4n'] } } },
            monoclinic: { 'P': { 'P2/m': { c: [] }, 'P2_1/m': { c: ['0k0:k=2n'] }, 'P2/c': { c: ['h0l:l=2n'] }, 'P2_1/c': { c: ['h0l:l=2n', '0k0:k=2n'] } }, 'C': { 'C2/m': { c: [] }, 'C2/c': { c: ['h0l:l=2n'] } } }
        };


        const get_q_tolerance = (original_peak_index) => {
            const theta = tth_obs_rad[original_peak_index];
            const d_theta = tth_error * Math.PI / 360;
            return ((8 * Math.sin(theta) * Math.cos(theta)) / (wavelength * wavelength)) * d_theta;
        };

        const binarySearchClosest = (arr, target) => {
            let low = 0, high = arr.length - 1;
            if (target <= arr[low]) return low;
            if (target >= arr[high]) return high;
            while (low <= high) {
                let mid = Math.floor((low + high) / 2);
                if (arr[mid] === target) return mid;
                if (arr[mid] < target) low = mid + 1;
                else high = mid - 1;
            }
            return (arr[low] - target) < (target - arr[high]) ? low : high;
        };
        
        const calculateM20 = (q_calc_sorted) => {
            if (q_calc_sorted.length === 0) return 0;
            let N_indexed = 0;
            let sum_delta_q = 0;
            for (let i = 0; i < N_FOR_M20; i++) {
                const q_o = q_obs[i];
                const tolerance = get_q_tolerance(original_indices[i]);
                const closest_idx = binarySearchClosest(q_calc_sorted, q_o);
                const diff = Math.abs(q_o - q_calc_sorted[closest_idx]);
                if (diff < tolerance) {
                    N_indexed++;
                    sum_delta_q += diff;
                }
            }

            const unindexed_peaks = N_FOR_M20 - N_indexed;
            if (unindexed_peaks > impurity_peaks) return 0;
            if (N_indexed === 0) return 0;

            const q_n = q_obs[N_FOR_M20 - 1];
            let N_calc = 0;
            for (let i = 0; i < q_calc_sorted.length; i++) {
                if (q_calc_sorted[i] > q_n * 1.05) break;
                N_calc++;
            }

            if (N_calc === 0) return 0;
            const avg_delta_q = sum_delta_q / N_indexed;
            if (avg_delta_q === 0) return 0;
            return q_n / (2 * avg_delta_q * N_calc);
        };

        const testSolution = (params) => {
            let {a, b, c, alpha, beta, gamma, system} = params;
            
            if (a < min_lattice_param || a > max_lattice_param ||
                (b && (b < min_lattice_param || b > max_lattice_param)) ||
                (c && (c < min_lattice_param || c > max_lattice_param))) {
                return;
            }

            if (system === 'monoclinic' && beta < 90.0) {
                beta = 180.0 - beta;
            }

            let volume = 0;
            switch(system){
                case 'cubic': volume = a*a*a; break;
                case 'tetragonal': volume = a*a*c; break;
                case 'hexagonal': volume = a*a*c * Math.sqrt(3)/2; break;
                case 'orthorhombic': volume = a*b*c; break;
                case 'monoclinic': volume = a*b*c*Math.sin(beta * Math.PI / 180); break;
            }
            if (volume > max_volume || volume < 20) return;

            const q_calc = new Set();
            const h_max = Math.ceil(a / d_min);
            const k_max = b ? Math.ceil(b / d_min) : h_max;
            const l_max = c ? Math.ceil(c / d_min) : h_max;
            const q_limit = q_max * 1.05;
            
            for (let h = 0; h <= h_max; h++) {
                for (let k = 0; k <= k_max; k++) {
                    if ((system === 'cubic' || system === 'tetragonal' || system === 'hexagonal') && k > h) continue;
                    for (let l = 0; l <= l_max; l++) {
                        if (system === 'cubic' && l > k) continue;
                        if (h === 0 && k === 0 && l === 0) continue;
                        
                        let q = 0;
                        switch (system) {
                            case 'cubic': {
                                const q_h = h*h; if(q_h/a/a > q_limit) { l=l_max+1; k=k_max+1; continue; }
                                const q_hk = q_h + k*k; if(q_hk/a/a > q_limit) { l=l_max+1; continue; }
                                q = (q_hk + l*l) / (a*a);
                                break;
                            }
                            case 'tetragonal': {
                                const q_hk = (h*h + k*k)/(a*a); if (q_hk > q_limit) { l=l_max+1; k=k_max+1; continue; }
                                q = q_hk + (l*l) / (c*c);
                                break;
                            }
                            case 'hexagonal': {
                                const q_hk = (4/3) * (h*h + h*k + k*k) / (a*a); if (q_hk > q_limit) { l=l_max+1; k=k_max+1; continue; }
                                q = q_hk + (l*l) / (c*c);
                                break;
                            }
                            case 'orthorhombic': {
                                const q_h = h*h/(a*a); if (q_h > q_limit) { l=l_max+1; k=k_max+1; continue; }
                                const q_hk = q_h + k*k/(b*b); if (q_hk > q_limit) { l=l_max+1; continue; }
                                q = q_hk + l*l/(c*c);
                                break;
                            }
                            case 'monoclinic': {
                                const sinBeta = Math.sin(beta * Math.PI / 180);
                                const cosBeta = Math.cos(beta * Math.PI / 180);
                                const q_k = k*k/(b*b); if (q_k > q_limit) {l=l_max+1; k=k_max+1; continue; }
                                q = (1/(sinBeta*sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + q_k;
                                break;
                            }
                        }
                        if (q > q_limit) {
                            if (l>0) break;
                            if (k>0) {l=l_max+1; continue;}
                            if (h>0) {k=k_max+1;l=l_max+1; continue;}
                        }
                        if (q > 0) q_calc.add(q);
                    }
                }
            }

            const q_calc_sorted = new Float64Array(Array.from(q_calc)).sort((x, y) => x - y);
            const m20 = calculateM20(q_calc_sorted);

            if (m20 > min_m20) {
                const analysis = analyzeSystematicAbsences({a, b, c, alpha, beta, gamma, system}, peaks);
                const newSolution = {a, b, c, alpha, beta, gamma, system, volume, m20, analysis};
                
                let key;
                const P = 3;
                switch(system) {
                    case 'cubic':
                        key = `${system}_${a.toFixed(P)}`;
                        break;
                    case 'tetragonal':
                    case 'hexagonal':
                        key = `${system}_${a.toFixed(P)}_${c.toFixed(P)}`;
                        break;
                    case 'orthorhombic':
                        key = `${system}_${[a,b,c].sort().map(p => p.toFixed(P)).join('_')}`;
                        break;
                    case 'monoclinic':
                        key = `${system}_${volume.toFixed(2)}_${beta.toFixed(2)}`;
                        break;
                }

                if (!foundSolutionKeys.has(key)) {
                    foundSolutionKeys.add(key);
                    foundSolutions.push(newSolution);
                    self.postMessage({ type: 'solution', payload: newSolution });
                }
            }
        };
        const analyzeSystematicAbsences = (solution, obs_peaks) => { 
            const { system } = solution;
            const all_hkls = generateHKL_for_analysis(solution, wavelength, Math.max(...obs_peaks.map(p=>p.tth)));
            const obs_hkl_list = [];
            const used_peaks = new Set();
            all_hkls.forEach(hkl => {
                let bestMatch = null; let minDiff = Infinity;
                obs_peaks.forEach((peak, index) => {
                    if (used_peaks.has(index)) return;
                    const diff = Math.abs(hkl.d - peak.d);
                    if (diff < minDiff) { minDiff = diff; bestMatch = { peak, index }; }
                });
                if (bestMatch) {
                    const tolerance = get_q_tolerance(bestMatch.index);
                    const d_tolerance = Math.abs(1/Math.sqrt(bestMatch.peak.q + tolerance) - 1/Math.sqrt(bestMatch.peak.q - tolerance)) / 2;
                    if (minDiff < d_tolerance) {
                       obs_hkl_list.push(hkl); used_peaks.add(bestMatch.index);
                    }
                }
            });
            let centering = 'Primitive (P)';
            if (obs_hkl_list.length >= 3) {
                 if (system === 'cubic' || system === 'tetragonal' || system === 'orthorhombic') {
                    const violates_I = obs_hkl_list.some(({h,k,l}) => (h+k+l) % 2 !== 0);
                    const violates_F = obs_hkl_list.some(({h,k,l}) => !((h%2===k%2)&&(k%2===l%2)));
                    if (!violates_F) centering = 'Face (F)';
                    else if (!violates_I) centering = 'Body (I)';
                 }
                if ((system === 'orthorhombic' || system === 'monoclinic') && centering === 'Primitive (P)' && !obs_hkl_list.some(({h,k,l}) => (h+k) % 2 !== 0)) centering = 'C-Face (C)';
                if (system === 'hexagonal' && (!obs_hkl_list.some(({h,k,l}) => (-h+k+l)%3!==0) || !obs_hkl_list.some(({h,k,l}) => (h-k+l)%3!==0))) centering = 'Rhombohedral (R)';
            }
            const centerChar = centering.charAt(centering.indexOf('(')+1);
            const foundConditions = new Set();
            const check = (filter, rule) => { const subset = obs_hkl_list.filter(filter); return subset.length === 0 || !subset.some(rule); };
            if (check(p => p.h !== 0 && p.k===0 && p.l===0, p => p.h%2 !== 0)) foundConditions.add('h00:h=2n');
            if (check(p => p.k !== 0 && p.h===0 && p.l===0, p => p.k%2 !== 0)) foundConditions.add('0k0:k=2n');
            if (check(p => p.l !== 0 && p.h===0 && p.k===0, p => p.l%2 !== 0)) foundConditions.add('00l:l=2n');
            if (check(p => p.h!==0 && p.k!==0 && p.l===0, p => (p.h+p.k)%2 !== 0)) foundConditions.add('hk0:h+k=2n');
            if (check(p => p.k!==0 && p.l!==0 && p.h===0, p => (p.k+p.l)%2 !== 0)) foundConditions.add('0kl:k+l=2n');
            if (check(p => p.h!==0 && p.l!==0 && p.k===0, p => (p.h+p.l)%2 !== 0)) foundConditions.add('h0l:h+l=2n');
            if (system === 'monoclinic' && check(p => p.h!==0 && p.l!==0 && p.k===0, p => p.l%2 !== 0)) foundConditions.add('h0l:l=2n');
            if (check(p => p.h===p.k && p.l!==0, p => p.l%2 !== 0)) foundConditions.add('hhl:l=2n');
            if (check(p => p.h===-p.k && p.l!==0, p => p.l%2 !== 0)) foundConditions.add('h-hl:l=2n');
            const sg_block = spaceGroupData[system]?.[centerChar] || {};
            const possibleSpaceGroups = Object.keys(sg_block);
            const probableSpaceGroups = possibleSpaceGroups.filter(sg => (sg_block[sg].c || []).every(cond => foundConditions.has(cond)));
            return { centering, conditions: Array.from(foundConditions), possibleSpaceGroups, probableSpaceGroups };
         };
        const generateHKL_for_analysis = (params, lambda, maxTth) => { 
             const { a, b, c, beta, system } = params;
             const reflections = [];
             for (let h = -max_hkl_analysis; h <= max_hkl_analysis; h++) {
                 for (let k = -max_hkl_analysis; k <= max_hkl_analysis; k++) {
                     for (let l = -max_hkl_analysis; l <= max_hkl_analysis; l++) {
                         if (h === 0 && k === 0 && l === 0) continue;
                         let inv_d_sq = 0;
                         switch (system) {
                             case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                             case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                             case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                             case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                             case 'monoclinic':
                                 const sinBeta = Math.sin(beta * Math.PI / 180);
                                 const cosBeta = Math.cos(beta * Math.PI / 180);
                                 inv_d_sq = (1/(sinBeta*sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + k*k/(b*b);
                                 break;
                         }
                         if (inv_d_sq > 0) {
                              const d = 1 / Math.sqrt(inv_d_sq);
                              const sinThetaSq = (lambda * lambda / 4) * inv_d_sq;
                              if (sinThetaSq <= 1) {
                                 const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                                 if(tth <= maxTth*1.05) reflections.push({ tth, h, k, l, d });
                              }
                         }
                     }
                 }
             }
             return reflections.sort((a, b) => a.tth - b.tth);
        };
        const indexCubic = () => {
            const h_max = 8;
            for (let i = 0; i < Math.min(peaks.length, 10); i++) {
                for (let h = 1; h <= h_max; h++) {
                    for (let k = 0; k <= h; k++) {
                        for (let l = 0; l <= k; l++) {
                            const S = h * h + k * k + l * l;
                            if (S === 0) continue;
                            testSolution({a: Math.sqrt(S / q_obs[i]), system: 'cubic', alpha: 90, beta: 90, gamma: 90});
                        }
                    }
                }
            }
        };
        const indexTetragonal = () => {
            for (let i = 0; i < tetra_hexa_i_depth; i++) {
                for (let j = i + 1; j < tetra_hexa_j_depth; j++) {
                    for (let h1 = 0; h1 <= max_hkl_low_angle_search; h1++) {
                        for (let k1 = 0; k1 <= h1; k1++) {
                            for (let l1 = 0; l1 <= max_hkl_low_angle_search; l1++) {
                                if (h1 === 0 && k1 === 0 && l1 === 0) continue;
                                const S1 = h1*h1 + k1*k1;
                                for (let h2 = 0; h2 <= max_hkl_low_angle_search; h2++) {
                                    for (let k2 = 0; k2 <= h2; k2++) {
                                        for (let l2 = 0; l2 <= max_hkl_low_angle_search; l2++) {
                                            if (h2 === 0 && k2 === 0 && l2 === 0) continue;
                                            const S2 = h2*h2 + k2*k2;
                                            const det = S1 * l2*l2 - S2 * l1*l1;
                                            if (Math.abs(det) < 1e-6) continue;
                                            const a_sq_inv = (q_obs[i] * l2*l2 - q_obs[j] * l1*l1) / det;
                                            const c_sq_inv = (q_obs[j] * S1 - q_obs[i] * S2) / det;
                                            if (a_sq_inv > 0 && c_sq_inv > 0) {
                                                testSolution({a: 1/Math.sqrt(a_sq_inv), c: 1/Math.sqrt(c_sq_inv), system: 'tetragonal', alpha: 90, beta: 90, gamma: 90});
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        const indexHexagonal = () => {
            for (let i = 0; i < tetra_hexa_i_depth; i++) {
                for (let j = i + 1; j < tetra_hexa_j_depth; j++) {
                    for (let h1 = 0; h1 <= max_hkl_low_angle_search; h1++) {
                        for (let k1 = 0; k1 <= h1; k1++) {
                            for (let l1 = 0; l1 <= max_hkl_low_angle_search; l1++) {
                                if(h1 === 0 && k1 === 0 && l1 === 0) continue;
                                const S1 = h1*h1 + h1*k1 + k1*k1;
                                for(let h2 = 0; h2 <= max_hkl_low_angle_search; h2++) {
                                    for(let k2 = 0; k2 <= h2; k2++) {
                                        for(let l2 = 0; l2 <= max_hkl_low_angle_search; l2++) {
                                            if(h2 === 0 && k2 === 0 && l2 === 0) continue;
                                            const S2 = h2*h2 + h2*k2 + k2*k2;
                                            const det = S1*l2*l2 - S2*l1*l1;
                                            if(Math.abs(det) < 1e-6) continue;
                                            const a_term = (q_obs[i]*l2*l2 - q_obs[j]*l1*l1) / det;
                                            const c_inv = (q_obs[j]*S1 - q_obs[i]*S2) / det;
                                            if(a_term > 0 && c_inv > 0) {
                                                testSolution({a: Math.sqrt(4/(3*a_term)), c: Math.sqrt(1/c_inv), system: 'hexagonal', alpha: 90, beta: 90, gamma: 120});
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        
        const solveLeastSquares = (M, q_vec) => { 
            const num_eq = M.length; if (num_eq === 0) return null;
            const num_params = M[0].length; if (num_eq < num_params) return null;
            const MT = Array(num_params).fill(0).map(() => Array(num_eq).fill(0));
            for (let i = 0; i < num_params; i++) for (let j = 0; j < num_eq; j++) MT[i][j] = M[j][i];
            const MTM = Array(num_params).fill(0).map(() => Array(num_params).fill(0));
            for (let i = 0; i < num_params; i++) for (let j = 0; j < num_params; j++) { let sum = 0; for (let k = 0; k < num_eq; k++) sum += MT[i][k] * M[k][j]; MTM[i][j] = sum; }
            let det;
            if (num_params === 3) { det = MTM[0][0]*(MTM[1][1]*MTM[2][2] - MTM[2][1]*MTM[1][2]) - MTM[0][1]*(MTM[1][0]*MTM[2][2] - MTM[1][2]*MTM[2][0]) + MTM[0][2]*(MTM[1][0]*MTM[2][1] - MTM[1][1]*MTM[2][0]); } 
            else if (num_params === 4) { const m = MTM; det = m[0][0]*(m[1][1]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])+m[1][3]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])) - m[0][1]*(m[1][0]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])) + m[0][2]*(m[1][0]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])-m[1][1]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][1]-m[2][1]*m[3][0])) - m[0][3]*(m[1][0]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])-m[1][1]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])+m[1][2]*(m[2][0]*m[3][1]-m[2][1]*m[3][0])); } 
            else { return null; }
            if (Math.abs(det) < 1e-9) return null;
            const invDet = 1.0 / det;
            const MTM_inv = Array(num_params).fill(0).map(() => Array(num_params).fill(0));
            if (num_params === 3) { MTM_inv[0][0] = (MTM[1][1]*MTM[2][2] - MTM[2][1]*MTM[1][2])*invDet; MTM_inv[0][1] = (MTM[0][2]*MTM[2][1] - MTM[0][1]*MTM[2][2])*invDet; MTM_inv[0][2] = (MTM[0][1]*MTM[1][2] - MTM[0][2]*MTM[1][1])*invDet; MTM_inv[1][0] = (MTM[1][2]*MTM[2][0] - MTM[1][0]*MTM[2][2])*invDet; MTM_inv[1][1] = (MTM[0][0]*MTM[2][2] - MTM[0][2]*MTM[2][0])*invDet; MTM_inv[1][2] = (MTM[0][2]*MTM[1][0] - MTM[0][0]*MTM[1][2])*invDet; MTM_inv[2][0] = (MTM[1][0]*MTM[2][1] - MTM[2][0]*MTM[1][1])*invDet; MTM_inv[2][1] = (MTM[0][1]*MTM[2][0] - MTM[0][0]*MTM[2][1])*invDet; MTM_inv[2][2] = (MTM[0][0]*MTM[1][1] - MTM[0][1]*MTM[1][0])*invDet; } 
            else { const m = MTM; MTM_inv[0][0] = (m[1][1]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])+m[1][3]*(m[2][1]*m[3][2]-m[2][2]*m[3][1]))*invDet; MTM_inv[0][1] = -(m[0][1]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[0][2]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])+m[0][3]*(m[2][1]*m[3][2]-m[2][2]*m[3][1]))*invDet; MTM_inv[0][2] = (m[0][1]*(m[1][2]*m[3][3]-m[1][3]*m[3][2])-m[0][2]*(m[1][1]*m[3][3]-m[1][3]*m[3][1])+m[0][3]*(m[1][1]*m[3][2]-m[1][2]*m[3][1]))*invDet; MTM_inv[0][3] = -(m[0][1]*(m[1][2]*m[2][3]-m[1][3]*m[2][2])-m[0][2]*(m[1][1]*m[2][3]-m[1][3]*m[2][1])+m[0][3]*(m[1][1]*m[2][2]-m[1][2]*m[2][1]))*invDet; MTM_inv[1][0] = -(m[1][0]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][2]-m[2][2]*m[3][0]))*invDet; MTM_inv[1][1] = (m[0][0]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[0][2]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[0][3]*(m[2][0]*m[3][2]-m[2][2]*m[3][0]))*invDet; MTM_inv[1][2] = -(m[0][0]*(m[1][2]*m[3][3]-m[1][3]*m[3][2])-m[0][2]*(m[1][0]*m[3][3]-m[1][3]*m[3][0])+m[0][3]*(m[1][0]*m[3][2]-m[1][2]*m[3][0]))*invDet; MTM_inv[1][3] = (m[0][0]*(m[1][2]*m[2][3]-m[1][3]*m[2][2])-m[0][2]*(m[1][0]*m[2][3]-m[1][3]*m[2][0])+m[0][3]*(m[1][0]*m[2][2]-m[1][2]*m[2][0]))*invDet; MTM_inv[2][0] = (m[1][0]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])-m[1][1]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet; MTM_inv[2][1] = -(m[0][0]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])-m[0][1]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[0][3]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet; MTM_inv[2][2] = (m[0][0]*(m[1][1]*m[3][3]-m[1][3]*m[3][1])-m[0][1]*(m[1][0]*m[3][3]-m[1][3]*m[3][0])+m[0][3]*(m[1][0]*m[3][1]-m[1][1]*m[3][0]))*invDet; MTM_inv[2][3] = -(m[0][0]*(m[1][1]*m[2][3]-m[1][3]*m[2][1])-m[0][1]*(m[1][0]*m[2][3]-m[1][3]*m[2][0])+m[0][3]*(m[1][0]*m[2][1]-m[1][1]*m[2][0]))*invDet; MTM_inv[3][0] = -(m[1][0]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])-m[1][1]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])+m[1][2]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet; MTM_inv[3][1] = (m[0][0]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])-m[0][1]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])+m[0][2]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet; MTM_inv[3][2] = -(m[0][0]*(m[1][1]*m[3][2]-m[1][2]*m[3][1])-m[0][1]*(m[1][0]*m[3][2]-m[1][2]*m[3][0])+m[0][2]*(m[1][0]*m[3][1]-m[1][1]*m[3][0]))*invDet; MTM_inv[3][3] = (m[0][0]*(m[1][1]*m[2][2]-m[1][2]*m[2][1])-m[0][1]*(m[1][0]*m[2][2]-m[1][2]*m[2][0])+m[0][2]*(m[1][0]*m[2][1]-m[1][1]*m[2][0]))*invDet; }
            const MTq = Array(num_params).fill(0);
            for (let i = 0; i < num_params; i++) { let sum = 0; for (let j = 0; j < num_eq; j++) sum += MT[i][j] * q_vec[j]; MTq[i] = sum; }
            const x = Array(num_params).fill(0);
            for (let i = 0; i < num_params; i++) { let sum = 0; for (let j = 0; j < num_params; j++) sum += MTM_inv[i][j] * MTq[j]; x[i] = sum; }
            return x;
        };
        const indexOrthorhombic = () => {
            const max_peaks_basis = Math.min(15, q_obs.length);
            const min_indexed_for_fit = 6;
            const min_indexed_pre_filter = 5;
            const max_hkl_main = 6;
            const hkl_triplets = [];
            for (let h = 0; h <= max_hkl_main; h++) for (let k = 0; k <= max_hkl_main; k++) for (let l = 0; l <= max_hkl_main; l++) {
                if (h === 0 && k === 0 && l === 0) continue;
                hkl_triplets.push([h, k, l]);
            }
            hkl_triplets.sort((a, b) => (a[0]**2 + a[1]**2 + a[2]**2) - (b[0]**2 + b[1]**2 + b[2]**2));
            const basis_hkls = hkl_triplets.slice(0, 30);
            for (let i = 0; i < max_peaks_basis - 2; i++) {
                for (let j = i + 1; j < max_peaks_basis - 1; j++) {
                    for (let k = j + 1; k < max_peaks_basis; k++) {
                        for (let n1 = 0; n1 < basis_hkls.length - 2; n1++) {
                            for (let n2 = n1 + 1; n2 < basis_hkls.length - 1; n2++) {
                                for (let n3 = n2 + 1; n3 < basis_hkls.length; n3++) {
                                    const hkl_basis = [basis_hkls[n1], basis_hkls[n2], basis_hkls[n3]];
                                    const M = hkl_basis.map(hkl => [hkl[0]**2, hkl[1]**2, hkl[2]**2]);
                                    const q_vec = [q_obs[i], q_obs[j], q_obs[k]];
                                    const solution = solveLeastSquares(M, q_vec);
                                    if (!solution || solution.some(s => s <=0)) continue;
                                    const [a_sq_inv, b_sq_inv, c_sq_inv] = solution;
                                    if (1/Math.sqrt(a_sq_inv) < min_lattice_param || 1/Math.sqrt(b_sq_inv) < min_lattice_param || 1/Math.sqrt(c_sq_inv) < min_lattice_param) continue;
                                    if (1/(Math.sqrt(a_sq_inv)*Math.sqrt(b_sq_inv)*Math.sqrt(c_sq_inv)) > max_volume) continue;
                                    let rough_indexed_count = 0;
                                    for (let peak_idx = 0; peak_idx < Math.min(10, q_obs.length); peak_idx++) {
                                        const current_q_obs = q_obs[peak_idx];
                                        const tolerance = get_q_tolerance(original_indices[peak_idx]) * 5; // Wider tolerance
                                        for (const hkl of hkl_triplets) {
                                            const q_calc = hkl[0]**2 * a_sq_inv + hkl[1]**2 * b_sq_inv + hkl[2]**2 * c_sq_inv;
                                            if (Math.abs(q_calc - current_q_obs) < tolerance) { rough_indexed_count++; break; }
                                            if (q_calc > current_q_obs + tolerance) break;
                                        }
                                    }
                                    if (rough_indexed_count < min_indexed_pre_filter - impurity_peaks) continue;
                                    const indexed_pairs = [];
                                    for (let peak_idx = 0; peak_idx < N_FOR_M20; peak_idx++) {
                                        const current_q_obs = q_obs[peak_idx];
                                        const tolerance = get_q_tolerance(original_indices[peak_idx]);
                                        let best_match = null; let min_diff = Infinity;
                                        for (const hkl of hkl_triplets) {
                                            const q_calc = hkl[0]**2 * a_sq_inv + hkl[1]**2 * b_sq_inv + hkl[2]**2 * c_sq_inv;
                                            const diff = Math.abs(q_calc - current_q_obs);
                                            if (diff < tolerance && diff < min_diff) { min_diff = diff; best_match = hkl; }
                                            if (q_calc > current_q_obs + tolerance) break;
                                        }
                                        if (best_match) indexed_pairs.push({ q_obs: current_q_obs, hkl: best_match });
                                    }
                                    if (indexed_pairs.length >= min_indexed_for_fit) {
                                        const M_refine = indexed_pairs.map(p => [p.hkl[0]**2, p.hkl[1]**2, p.hkl[2]**2]);
                                        const q_refine = indexed_pairs.map(p => p.q_obs);
                                        const refined_solution = solveLeastSquares(M_refine, q_refine);
                                        if (refined_solution && refined_solution.every(s => s > 0)) {
                                            testSolution({ a: 1/Math.sqrt(refined_solution[0]), b: 1/Math.sqrt(refined_solution[1]), c: 1/Math.sqrt(refined_solution[2]), system: 'orthorhombic', alpha: 90, beta: 90, gamma: 90 });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        const indexMonoclinic = () => {
            const max_peaks_basis = Math.min(15, q_obs.length);
            const min_indexed_for_fit = 7;
            const min_indexed_pre_filter = 6;
            const max_hkl_main = 5;
            const hkl_triplets = [];
            for (let h = 0; h <= max_hkl_main; h++) for (let k = 0; k <= max_hkl_main; k++) for (let l = 0; l <= max_hkl_main; l++) {
                if (h === 0 && k === 0 && l === 0) continue;
                hkl_triplets.push([h, k, l]);
            }
            hkl_triplets.sort((a, b) => (a[0]**2 + a[1]**2 + a[2]**2) - (b[0]**2 + b[1]**2 + b[2]**2));
            const basis_hkls = hkl_triplets.slice(0, 35);
            for (let i = 0; i < max_peaks_basis - 3; i++) {
                for (let j = i + 1; j < max_peaks_basis - 2; j++) {
                    for (let k = j + 1; k < max_peaks_basis - 1; k++) {
                        for (let l = k + 1; l < max_peaks_basis; l++) {
                            for (let n1 = 0; n1 < basis_hkls.length - 3; n1++) {
                                for (let n2 = n1 + 1; n2 < basis_hkls.length - 2; n2++) {
                                    for (let n3 = n2 + 1; n3 < basis_hkls.length - 1; n3++) {
                                        for (let n4 = n3 + 1; n4 < basis_hkls.length; n4++) {
                                            const hkl_basis = [basis_hkls[n1], basis_hkls[n2], basis_hkls[n3], basis_hkls[n4]];
                                            const M = hkl_basis.map(hkl => [hkl[0]**2, hkl[1]**2, hkl[2]**2, hkl[0]*hkl[2]]);
                                            const q_vec = [q_obs[i], q_obs[j], q_obs[k], q_obs[l]];
                                            const solution = solveLeastSquares(M, q_vec);
                                            if (!solution) continue;
                                            const [A, B, C, D] = solution;
                                            if (A <= 0 || B <= 0 || C <= 0 || D**2 >= 4 * A * C) continue;
                                            const cosBeta = -D / (2 * Math.sqrt(A * C));
                                            let beta = Math.acos(cosBeta) * 180 / Math.PI;
                                            if (beta < 80 || beta > 140) continue;
                                            const sinBetaSq = 1 - cosBeta**2;
                                            const a = 1 / Math.sqrt(A * sinBetaSq); const b = 1 / Math.sqrt(B); const c = 1 / Math.sqrt(C * sinBetaSq);
                                            if (a*b*c*Math.sqrt(sinBetaSq) > max_volume) continue;
                                            let rough_indexed_count = 0;
                                            for (let peak_idx = 0; peak_idx < Math.min(12, q_obs.length); peak_idx++) {
                                                const current_q_obs = q_obs[peak_idx];
                                                const tolerance = get_q_tolerance(original_indices[peak_idx]) * 5;
                                                for (const hkl of hkl_triplets) {
                                                    const q_calc = (1/sinBetaSq) * (hkl[0]**2/a**2 + hkl[2]**2/c**2 - 2*hkl[0]*hkl[2]*cosBeta/(a*c)) + hkl[1]**2/b**2;
                                                    if (Math.abs(q_calc - current_q_obs) < tolerance) { rough_indexed_count++; break; }
                                                    if (q_calc > current_q_obs + tolerance) break;
                                                }
                                            }
                                            if (rough_indexed_count < min_indexed_pre_filter - impurity_peaks) continue;
                                            const indexed_pairs = [];
                                            for (let peak_idx = 0; peak_idx < N_FOR_M20; peak_idx++) {
                                                const current_q_obs = q_obs[peak_idx]; const tolerance = get_q_tolerance(original_indices[peak_idx]);
                                                let best_match = null; let min_diff = Infinity;
                                                for (const hkl of hkl_triplets) {
                                                    const q_calc = (1/sinBetaSq) * (hkl[0]**2/a**2 + hkl[2]**2/c**2 - 2*hkl[0]*hkl[2]*cosBeta/(a*c)) + hkl[1]**2/b**2;
                                                    const diff = Math.abs(q_calc - current_q_obs);
                                                    if (diff < tolerance && diff < min_diff) { min_diff = diff; best_match = hkl; }
                                                    if (q_calc > current_q_obs + tolerance) break;
                                                }
                                                if (best_match) indexed_pairs.push({ q_obs: current_q_obs, hkl: best_match });
                                            }
                                            if (indexed_pairs.length >= min_indexed_for_fit) {
                                                const M_refine = indexed_pairs.map(p => [p.hkl[0]**2, p.hkl[1]**2, p.hkl[2]**2, p.hkl[0]*p.hkl[2]]);
                                                const q_refine = indexed_pairs.map(p => p.q_obs);
                                                const refined_solution = solveLeastSquares(M_refine, q_refine);
                                                if (refined_solution) {
                                                    const [rA, rB, rC, rD] = refined_solution;
                                                    if (rA > 0 && rB > 0 && rC > 0 && rD**2 < 4 * rA * rC) {
                                                        const rCosBeta = -rD / (2 * Math.sqrt(rA * rC));
                                                        const rBeta = Math.acos(rCosBeta) * 180 / Math.PI;
                                                        const rSinBetaSq = 1 - rCosBeta**2;
                                                        testSolution({ a: 1/Math.sqrt(rA*rSinBetaSq), b: 1/Math.sqrt(rB), c: 1/Math.sqrt(rC*rSinBetaSq), beta: rBeta, system: 'monoclinic', alpha: 90, gamma: 90 });
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };

        if (systemToSearch === 'cubic') indexCubic();
        if (systemToSearch === 'tetragonal') indexTetragonal();
        if (systemToSearch === 'hexagonal') indexHexagonal();
        if (systemToSearch === 'orthorhombic') indexOrthorhombic();
        if (systemToSearch === 'monoclinic') indexMonoclinic();
        
        self.postMessage({ type: 'done' });
    };
</script>
</body>
</html>