<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Powder Indexing by Dichotomy Method (Optimized)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        :root {
            --dark-bg: #111827;
            --medium-bg: #1f2937;
            --light-bg: #374151;
            --border-color: #4b5563;
            --primary-accent: #3b82f6;
            --primary-accent-hover: #2563eb;
            --text-light: #e5e7eb;
            --text-medium: #d1d5db;
            --text-dark: #9ca3af;
            --success-green: #16a34a;
            --error-red: #dc2626;
        }

        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f9fafb; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #app-container { display: flex; width: 100%; flex-grow: 1; min-height: 0; }
        #controls-panel { width: 350px; min-width: 250px; max-width: 600px; flex-shrink: 0; padding: 24px; background-color: var(--dark-bg); border-right: 1px solid var(--light-bg); overflow-y: auto; color: var(--text-medium); display: flex; flex-direction: column; }
        #drag-handle { width: 6px; cursor: col-resize; background-color: var(--light-bg); flex-shrink: 0; transition: background-color: 0.2s; }
        #drag-handle:hover, #drag-handle:active { background-color: var(--primary-accent); }
        #results-area { flex-grow: 1; position: relative; background-color: #ffffff; min-width: 0; display: flex; flex-direction: column; padding: 1.5rem; color: var(--medium-bg); }
        .control-group { margin-bottom: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--light-bg); }
        .control-group:first-child { border-top: none; padding-top: 0; }
        .control-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-dark); font-size: 0.875rem; }
        .control-input, .control-select { width: 100%; background-color: var(--light-bg); border: 1px solid var(--border-color); color: var(--text-light); border-radius: 0.375rem; padding: 0.5rem 0.75rem; transition: all 0.2s ease; box-sizing: border-box; }
        .control-input:focus, .control-select:focus { outline: none; border-color: var(--primary-accent); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); }
        .btn { padding: 0.6rem 1rem; border-radius: 0.375rem; font-weight: 600; transition: background-color: 0.2s; cursor: pointer; border: none; text-align: center;}
        .btn-primary { background-color: var(--primary-accent); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: var(--primary-accent-hover); }
        .btn-secondary { background-color: var(--border-color); color: white; }
        .btn-secondary:hover:not(:disabled) { background-color: #6b7280; }
        .btn:disabled { background-color: var(--border-color); cursor: not-allowed; opacity: 0.7; }
        .file-input-label { display: block; padding: 0.75rem 1rem; background-color: var(--border-color); color: var(--text-medium); border-radius: 0.375rem; text-align: center; cursor: pointer; transition: background-color: 0.2s; }
        .file-input-label:hover { background-color: #6b7280; }
        .parameter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
        .checkbox-label { display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; color: var(--text-medium); cursor: pointer;}
        .hidden { display: none !important; }
        #peak-table-container { max-height: 200px; overflow-y: auto; background-color: var(--medium-bg); border-radius: 0.375rem; border: 1px solid var(--border-color); margin-top: 1rem;}
        .peak-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        .peak-table th, .peak-table td { padding: 0.5rem; text-align: right; border-bottom: 1px solid var(--border-color); }
        .peak-table th { background-color: #2a3547; font-weight: 600; text-align: center; }
        .peak-table input { width: 100%; background: transparent; border: none; color: var(--text-light); text-align: right; padding: 2px; border-radius: 2px; }
        .peak-table input:focus { background-color: var(--light-bg); outline: 1px solid var(--primary-accent); }
        .delete-peak-btn { background: none; border: none; color: var(--text-dark); cursor: pointer; font-weight: bold; }
        .delete-peak-btn:hover { color: var(--error-red); }
        #solutions-table-container { flex-grow: 1; overflow-y: auto; background-color: var(--medium-bg); border-radius: 0.375rem; border: 1px solid var(--border-color); margin-top: 1rem;}
        .solutions-table { width: 100%; border-collapse: collapse; font-size: 0.75rem; }
        .solutions-table th, .solutions-table td { padding: 0.5rem; text-align: left; border-bottom: 1px solid var(--border-color); }
        .solutions-table th { background-color: #2a3547; font-weight: 600;}
        .solutions-table tbody tr { cursor: pointer; transition: background-color: 0.2s; }
        .solutions-table tbody tr:hover { background-color: var(--light-bg); }
        .solutions-table tbody tr.selected { background-color: var(--primary-accent); color: white;}

        #status-box {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            color: white;
            font-size: 0.8rem; 
            font-weight: 500;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transform: translateY(20px);
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        #status-box.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        #status-box.success { background-color: var(--success-green); }
        #status-box.error { background-color: var(--error-red); }
        #status-box.info { background-color: var(--border-color); }

    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">
            <h1 style="font-size: 1.5rem; font-weight: 700; color: white; margin-bottom: 0.5rem;">Powder XRD Indexing</h1>
            <p style="font-size: 0.875rem; color: var(--text-dark); margin-bottom: 1.5rem;">Determine unit cell parameters using the Dichotomy method. Based on the method of A. Boultif & D. Louer, J. Appl. Cryst. 37, 724-731 (2004). This is a simplified version to be used for educational purposes or simple systems. For real stuff use the original code or other indexing programs.</p>

            <div class="control-group">
                <h2 style="font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem;">1. Load Data</h2>
                <label for="file-input" class="file-input-label">
                    <span id="file-name">Select Data File</span>
                </label>
                <input type="file" id="file-input" class="hidden">
            </div>

            <div class="control-group">
                <h2 style="font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem;">2. Find Peaks</h2>
                <div id="peak-controls" class="hidden">
                    <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                        <button id="find-peaks-button" class="btn btn-secondary" style="flex-grow: 1;">Find Peaks</button>
                        <label for="peak-threshold-input" class="control-label" style="margin-bottom: 0; white-space: nowrap;">Min %:</label>
                        <input type="number" id="peak-threshold-input" class="control-input" value="2" min="0.1" max="50" step="0.1" style="width: 6rem;">
                    </div>
                    <div style="margin-top: 1rem;">
                        <label class="control-label">2θ Range for Peak Finding</label>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <input type="number" id="tth-min-input" class="control-input" style="width: 6rem; text-align: center;" disabled>
                            <div style="flex-grow: 1;">
                                <input type="range" id="tth-min-slider" disabled style="width: 100%;">
                                <input type="range" id="tth-max-slider" disabled style="width: 100%;">
                            </div>
                            <input type="number" id="tth-max-input" class="control-input" style="width: 6rem; text-align: center;" disabled>
                        </div>
                    </div>
                    <div id="peak-table-container" class="hidden">
                        <table class="peak-table">
                            <thead><tr><th>#</th><th>2θ Obs (°)</th><th>d (Å)</th><th>Del</th></tr></thead>
                            <tbody id="peak-list-body"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h2 style="font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem;">3. Indexing Parameters</h2>
                <div id="indexing-controls" class="hidden">
                     <div class="parameter-grid">
                        <div>
                            <label for="wavelength" class="control-label">Wavelength (Å)</label>
                            <input type="number" id="wavelength" value="1.54056" step="0.00001" min="0.1" class="control-input">
                        </div>
                        <div>
                            <label for="max-volume" class="control-label">Max Volume (Å³)</label>
                            <input type="number" id="max-volume" value="1000" step="100" min="60" max="12000" class="control-input">
                        </div>
                    </div>
                    <div class="parameter-grid" style="margin-top: 1rem;">
                        <div>
                            <label for="tth-error" class="control-label">2θ Error (°)</label>
                            <input type="number" id="tth-error" value="0.05" step="0.005" min="0.001" class="control-input">
                        </div>
                        <div>
                            <label for="impurity-peaks" class="control-label">Impurity Peaks</label>
                            <input type="number" id="impurity-peaks" value="1" min="0" max="4" step="1" class="control-input">
                        </div>
                    </div>
                    <label class="control-label" style="margin-top: 1rem;">Crystal Systems to Search:</label>
                    <div class="parameter-grid">
                        <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="cubic" checked> Cubic</label>
                        <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="tetragonal" checked> Tetragonal</label>
                        <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="hexagonal" checked> Hexagonal</label>
                        <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="orthorhombic" > Orthorhombic</label>
                        <label class="checkbox-label"><input type="checkbox" class="system-checkbox" value="monoclinic" > Monoclinic</label>
                    </div>
                </div>
            </div>

            <div style="margin-top: auto; padding-top: 1rem;">
                <div id="progress-bar-container" class="hidden" style="width: 100%; background-color: var(--light-bg); border-radius: 9999px; height: 0.625rem; margin-bottom: 0.5rem;">
                    <div id="progress-bar" style="background-color: var(--primary-accent); height: 0.625rem; border-radius: 9999px; width: 0%; transition: width 0.2s;"></div>
                </div>
                <div style="display: flex; gap: 0.5rem;">
                    <button id="start-indexing-button" class="btn btn-primary" style="flex: 1; font-size: 1rem;" disabled>Find Peaks to Start</button>
                    <button id="report-button" class="btn btn-secondary" style="flex: 1; font-size: 1rem;" disabled>Generate PDF Report</button>
                </div>
            </div>

            <div class="control-group" style="display: flex; flex-direction: column; flex-grow: 1; min-height: 250px;">
                 <h2 style="font-size: 1.125rem; font-weight: 600; color: white; margin-bottom: 0.75rem;">4. Solutions</h2>
                 <div id="solutions-table-container">
                    <table class="solutions-table">
                        <thead><tr><th>Sys.</th><th>a,b,c (Å)</th><th>α,β,γ (°)</th><th>Vol</th><th>M(20)</th></tr></thead>
                        <tbody id="solutions-table-body"></tbody>
                    </table>
                 </div>
            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="results-area">
             <div id="placeholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #6b7280;">
                <svg xmlns="http://www.w3.org/2000/svg" style="width: 4rem; height: 4rem; margin-bottom: 1rem;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                <h2 style="font-size: 1.5rem; font-weight: 600;">Awaiting Data</h2>
                <p>Load a data file to begin indexing.</p>
            </div>
            <div id="results-container" style="width: 100%; height: 100%; display: none; flex-direction: column; position: relative;">
                <canvas id="xrd-chart"></canvas>
            </div>
            <div style="position: absolute; bottom: 0.5rem; right: 1rem; font-size: 0.75rem; color: #9ca3af;">
                NitaD, Univ Paris-Saclay, 14 Sept 2025
            </div>
        </div>
    </div>

    <div id="status-box"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const ui = {
                fileInput: document.getElementById('file-input'),
                fileName: document.getElementById('file-name'),
                peakControls: document.getElementById('peak-controls'),
                peakThresholdInput: document.getElementById('peak-threshold-input'),
                findPeaksButton: document.getElementById('find-peaks-button'),
                peakTableContainer: document.getElementById('peak-table-container'),
                peakListBody: document.getElementById('peak-list-body'),
                indexingControls: document.getElementById('indexing-controls'),
                wavelength: document.getElementById('wavelength'),
                tthError: document.getElementById('tth-error'),
                maxVolume: document.getElementById('max-volume'),
                impurityPeaksInput: document.getElementById('impurity-peaks'),
                systemCheckboxes: document.querySelectorAll('.system-checkbox'),
                startIndexingButton: document.getElementById('start-indexing-button'),
                reportButton: document.getElementById('report-button'),
                progressBar: document.getElementById('progress-bar'),
                progressBarContainer: document.getElementById('progress-bar-container'),
                solutionsTableBody: document.getElementById('solutions-table-body'),
                chartCanvas: document.getElementById('xrd-chart'),
                placeholder: document.getElementById('placeholder'),
                resultsContainer: document.getElementById('results-container'),
                tthMinSlider: document.getElementById('tth-min-slider'),
                tthMaxSlider: document.getElementById('tth-max-slider'),
                tthMinInput: document.getElementById('tth-min-input'),
                tthMaxInput: document.getElementById('tth-max-input'),
                statusBar: document.getElementById('status-box'),
            };

            let statusTimeout;
            const showStatus = (message, type = 'info', duration = 4000) => {
                if (!ui.statusBar) {
                    console.warn(`Status bar element (#status-box) not found. Message: "${message}"`);
                    return;
                }
                if (statusTimeout) clearTimeout(statusTimeout);
                ui.statusBar.textContent = message;
                ui.statusBar.className = `show ${type}`;
                statusTimeout = setTimeout(() => {
                    if (ui.statusBar) {
                        ui.statusBar.classList.remove('show');
                    }
                }, duration);
            };

            let fullExperimentalData = { tth: [], intensity: [] };
            let pickedPeaks = [];
            let solutions = [];
            let selectedSolution = null;
            let currentHklList = [];
            let xrdChart;
            let isIndexing = false;
            let activeWorkers = [];

            const inputsToValidate = [
                { id: 'wavelength', el: ui.wavelength, default: 1.54056 },
                { id: 'max-volume', el: ui.maxVolume, default: 1000 },
                { id: 'tth-error', el: ui.tthError, default: 0.05 },
                { id: 'impurity-peaks', el: ui.impurityPeaksInput, default: 1 },
                { id: 'peak-threshold-input', el: ui.peakThresholdInput, default: 2 },
            ];

            // Setup input validation
            inputsToValidate.forEach(({ id, el, default: defaultValue }) => {
                if (el) {
                    el.addEventListener('blur', () => {
                        const min = parseFloat(el.min);
                        const max = parseFloat(el.max);
                        let value = parseFloat(el.value);

                        if (isNaN(value)) {
                            el.value = defaultValue;
                            return;
                        }
                        if (el.step == 2 && value % 2 === 0) { // Ensure window is odd
                            value += 1;
                            el.value = value;
                        }

                        if (!isNaN(min) && value < min) el.value = min;
                        if (!isNaN(max) && value > max) el.value = max;
                    });
                } else {
                    console.error(`Initialization Error: The element with id="${id}" was not found. Input validation will not be applied to it.`);
                }
            });

            if (ui.wavelength) {
                ui.wavelength.addEventListener('change', () => {
                    if (pickedPeaks.length > 0) {
                        recalculatePeakValues();
                        updatePeakTable();
                    }
                });
            }


            const parseDataFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                const tth = [], intensity = [];
                lines.forEach(line => {
                    if (line.startsWith('#') || line.startsWith('//') || line.trim() === '') return;
                    const parts = line.trim().split(/[\s,;]+/);
                    if (parts.length >= 2) {
                        const x = parseFloat(parts[0]);
                        const y = parseFloat(parts[1]);
                        if (!isNaN(x) && !isNaN(y)) {
                            tth.push(x);
                            intensity.push(y);
                        }
                    }
                });
                return { tth, intensity };
            };

            const parseXrdmlFile = (xmlString) => {
                 const parser = new DOMParser();
                 const xmlDoc = parser.parseFromString(xmlString, "application/xml");
                 if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing XRDML file."); }

                 let wavelength = null;
                 const kAlpha1Node = xmlDoc.querySelector("kAlpha1");
                 if (kAlpha1Node?.textContent) wavelength = parseFloat(kAlpha1Node.textContent);

                 const intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts");
                 if (!intensityNode) throw new Error("Could not find <intensities> or <counts> in XRDML file.");
                 const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number);

                 const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]');
                 if (!positionsNode) throw new Error("Could not find <positions> in XRDML file.");
                 const startPos = parseFloat(positionsNode.querySelector("startPosition").textContent);
                 const endPos = parseFloat(positionsNode.querySelector("endPosition").textContent);
                 const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * (endPos - startPos) / (intensity.length - 1));

                 return { tth, intensity, wavelength };
            };
            
            const parseBrukerBrmlFile = (xmlString) => {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, "application/xml");
                if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing BRML file."); }

                let wavelength = null;
                const wlNode = xmlDoc.querySelector('usedWavelength');
                if (wlNode) {
                    const kAlpha1 = wlNode.getAttribute('kAlpha1');
                    if (kAlpha1) wavelength = parseFloat(kAlpha1);
                }
                
                const intensityNode = xmlDoc.querySelector("dataPoints > counts");
                if (!intensityNode) throw new Error("No <counts> data found in BRML file.");
                const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number);

                const startPosNode = xmlDoc.querySelector('startPosition[axis="TwoTheta"]');
                const stepSizeNode = xmlDoc.querySelector('increment[axis="TwoTheta"]');
                if (!startPosNode || !stepSizeNode) throw new Error("Could not find scan parameters in BRML file.");

                const startPos = parseFloat(startPosNode.textContent);
                const stepSize = parseFloat(stepSizeNode.textContent);
                
                const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * stepSize);

                return { tth, intensity, wavelength };
            };

            const parseRigakuRasFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                const tth = [], intensity = [];
                let inDataSection = false;
                let wavelength = null;

                for (const line of lines) {
                    const upperLine = line.toUpperCase();
                    if (upperLine.startsWith('*WAVE_LENGTH') || upperLine.startsWith('*MEAS_COND_XG_WAVE_LENGTH')) {
                        const parts = line.trim().split(/\s+/);
                        if (parts.length > 1) {
                            const wl = parseFloat(parts[1]);
                            if (!isNaN(wl)) wavelength = wl;
                        }
                    }
                    if (upperLine.startsWith('*RAS_INT_START')) {
                        inDataSection = true;
                        continue;
                    }
                    if (upperLine.startsWith('*RAS_INT_END')) {
                        break;
                    }
                    if (inDataSection) {
                        const parts = line.trim().split(/[\s,]+/);
                        if (parts.length >= 2) {
                            const x = parseFloat(parts[0]);
                            const y = parseFloat(parts[1]);
                            if (!isNaN(x) && !isNaN(y)) {
                                tth.push(x);
                                intensity.push(y);
                            }
                        }
                    }
                }
                if (tth.length === 0) throw new Error("No data found in RAS file data section.");
                return { tth, intensity, wavelength };
            };

            const parseGsasEsdFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                const tth = [], intensity = [];
                let inDataSection = false;
                
                for (const line of lines) {
                    // Data lines in GSAS are strange.... 
                    if (!inDataSection && /^\s*\d/.test(line)) {
                        inDataSection = true;
                    }

                    if (inDataSection) {
                         if (line.trim().length < 30) continue;
                        try {
                            const tth_val = parseFloat(line.substring(0, 10)) / 100;
                            const int_val = parseFloat(line.substring(20, 30)); // raw intensity
                            if (!isNaN(tth_val) && !isNaN(int_val)) {
                                tth.push(tth_val);
                                intensity.push(int_val);
                            }
                        } catch (e) { 
                            console.warn("Skipping malformed data line in GSAS file:", line);
                        }
                    }
                }
                if (tth.length === 0) throw new Error("Could not parse data from GSAS ESD file.");
                return { tth, intensity };
            };

            const parsePhilipsUdfFile = (text) => {
                const lines = text.trim().split(/\r?\n/);
                const tth = [], intensity = [];
                let inDataSection = false;
                let wavelength = null;

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (trimmedLine.toUpperCase().startsWith('LAMBDA')) {
                        const parts = trimmedLine.split('=');
                        if (parts.length > 1) wavelength = parseFloat(parts[1]);
                    }
                    if (trimmedLine.toUpperCase() === '[DATA]') {
                        inDataSection = true;
                        continue;
                    }
                    if (trimmedLine.startsWith('[') && trimmedLine.toUpperCase() !== '[DATA]') {
                        inDataSection = false;
                    }
                    if (inDataSection) {
                        const parts = trimmedLine.split(/,/).map(p => p.trim());
                        if(parts.length >= 2) {
                            const x = parseFloat(parts[0]);
                            const y = parseFloat(parts[1]);
                            if (!isNaN(x) && !isNaN(y)) {
                                tth.push(x);
                                intensity.push(y);
                            }
                        }
                    }
                }
                if (tth.length === 0) throw new Error("No [Data] section found in UDF file.");
                return { tth, intensity, wavelength };
            };

            ui.fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    try {
                        let parsedData;
                        const fileContent = evt.target.result;
                        const fileName = file.name.toLowerCase();
                        const fileStart = fileContent.substring(0, 200).toUpperCase();
                        
                        // --- Smart Dispatcher Logic ---
                        if (fileName.endsWith('.xrdml')) {
                            parsedData = parseXrdmlFile(fileContent);
                        } else if (fileName.endsWith('.brml')) {
                            parsedData = parseBrukerBrmlFile(fileContent);
                        } else if (fileName.endsWith('.ras')) {
                            parsedData = parseRigakuRasFile(fileContent);
                        } else if (fileName.endsWith('.esd') || fileName.endsWith('.std')) {
                             parsedData = parseGsasEsdFile(fileContent);
                        } else if (fileName.endsWith('.udf')) {
                             parsedData = parsePhilipsUdfFile(fileContent);
                        } else if (fileStart.includes('<?XML')) { // Content-based check for XML
                            if (fileStart.includes('<XRDMEASUREMENT')) parsedData = parseXrdmlFile(fileContent);
                            else if (fileStart.includes('<RAWDATAFILE')) parsedData = parseBrukerBrmlFile(fileContent);
                            else throw new Error("Unsupported XML file format.");
                        } else if (fileStart.includes('*RAS_HEADER_START')) { // Content-based for RAS
                            parsedData = parseRigakuRasFile(fileContent);
                        } else {
                            // Fallback for generic .xy, .csv, .txt files
                            parsedData = parseDataFile(fileContent);
                        }
                        
                        if (!parsedData || parsedData.tth.length === 0) {
                            throw new Error("No valid data points could be parsed from the file.");
                        }

                        // --- Successful Parse: Update UI ---
                        fullExperimentalData = parsedData;
                        const maxIntensity = Math.max(...fullExperimentalData.intensity);
                        if (maxIntensity > 0) {
                             fullExperimentalData.intensity = fullExperimentalData.intensity.map(y => y / maxIntensity * 1000);
                        }

                        solutions = [];
                        updateSolutionsTable();

                        if (parsedData.wavelength) {
                            ui.wavelength.value = parsedData.wavelength.toFixed(5);
                        }

                        selectedSolution = null;
                        currentHklList = [];
                        ui.fileName.textContent = file.name;
                        ui.placeholder.style.display = 'none';
                        ui.resultsContainer.style.display = 'flex';
                        ui.peakControls.classList.remove('hidden');
                        ui.indexingControls.classList.remove('hidden');
                        initializeChart();
                        setupTthSliders();
                        showStatus(`File "${file.name}" loaded successfully.`, 'success');

                    } catch (error) {
                        showStatus(`Error reading file: ${error.message}`, 'error');
                        console.error(error);
                    }
                };
                reader.onerror = () => {
                     showStatus('Error: Could not read the selected file.', 'error');
                };
                reader.readAsText(file);
            });

            const setupTthSliders = () => {
                if (fullExperimentalData.tth.length === 0) return;
                const min = fullExperimentalData.tth[0];
                const max = fullExperimentalData.tth[fullExperimentalData.tth.length - 1];
                const step = (max - min) / 2000;

                [ui.tthMinSlider, ui.tthMaxSlider, ui.tthMinInput, ui.tthMaxInput].forEach(el => {
                    el.disabled = false;
                });

                Object.assign(ui.tthMinSlider, { min, max, step, value: min });
                Object.assign(ui.tthMaxSlider, { min, max, step, value: max });

                ui.tthMinInput.value = Math.floor(min);
                ui.tthMaxInput.value = Math.ceil(max);

                updatePlotRange();
            };

            const updatePlotRange = () => {
                if(!xrdChart) return;
                const min = parseFloat(ui.tthMinInput.value);
                const max = parseFloat(ui.tthMaxInput.value);
                xrdChart.options.scales.x.min = min;
                xrdChart.options.scales.x.max = max;

                const visibleIntensities = fullExperimentalData.intensity.filter((intensity, index) => {
                    const tth = fullExperimentalData.tth[index];
                    return tth >= min && tth <= max;
                });

                if (visibleIntensities.length > 0) {
                    const yMaxInRange = Math.max(...visibleIntensities);
                    xrdChart.options.scales.y.min = -yMaxInRange * 0.25;
                    xrdChart.options.scales.y.max = yMaxInRange * 1.1;
                } else {
                    const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
                    xrdChart.options.scales.y.min = -yMax * 0.25;
                    xrdChart.options.scales.y.max = yMax * 1.1;
                }

                xrdChart.update('none');
            };

            ui.tthMinSlider.addEventListener('input', () => {
                let minVal = parseFloat(ui.tthMinSlider.value);
                let maxVal = parseFloat(ui.tthMaxSlider.value);
                if (minVal >= maxVal) {
                    minVal = maxVal - parseFloat(ui.tthMinSlider.step);
                    ui.tthMinSlider.value = minVal;
                }
                ui.tthMinInput.value = Math.round(minVal);
                updatePlotRange();
                findPeaks();
            });
             ui.tthMaxSlider.addEventListener('input', () => {
                let minVal = parseFloat(ui.tthMinSlider.value);
                let maxVal = parseFloat(ui.tthMaxSlider.value);
                if (maxVal <= minVal) {
                    maxVal = minVal + parseFloat(ui.tthMaxSlider.step);
                    ui.tthMaxSlider.value = maxVal;
                }
                ui.tthMaxInput.value = Math.round(maxVal);
                updatePlotRange();
                findPeaks();
            });
            ui.tthMinInput.addEventListener('change', () => { if(!ui.tthMinSlider.disabled) {ui.tthMinSlider.value = ui.tthMinInput.value; updatePlotRange(); findPeaks();} });
            ui.tthMaxInput.addEventListener('change', () => { if(!ui.tthMaxSlider.disabled) {ui.tthMaxSlider.value = ui.tthMaxInput.value; updatePlotRange(); findPeaks();} });

            const savitzkyGolay = (data, windowSize, polyOrder) => {
                const halfWindow = Math.floor(windowSize / 2);
                const numPoints = data.length;
                const result = new Array(numPoints).fill(0);

                const coeffs = getSGCoefficients(windowSize, polyOrder);
                if (!coeffs) {
                    showStatus('Invalid Savitzky-Golay parameters.', 'error');
                    return data;
                }

                for (let i = 0; i < numPoints; i++) {
                    let sum = 0;
                    for (let j = -halfWindow; j <= halfWindow; j++) {
                        const dataIndex = i + j;
                        // Use reflection for boundary conditions
                        let reflectedIndex = dataIndex;
                        if (dataIndex < 0) reflectedIndex = -dataIndex;
                        if (dataIndex >= numPoints) reflectedIndex = numPoints - 1 - (dataIndex - (numPoints - 1));

                        sum += data[reflectedIndex] * coeffs[j + halfWindow];
                    }
                    result[i] = sum;
                }
                return result;
            };

            const getSGCoefficients = (windowSize, polyOrder) => {
                 // Pre-computed coefficients for the 2nd derivative, which is used for peak finding.
                if (windowSize === 5 && polyOrder === 2) return [0.142857, -0.0714286, -0.142857, -0.0714286, 0.142857];
                if (windowSize === 7 && polyOrder === 2) return [0.0714286, 0, -0.047619, -0.0714286, -0.047619, 0, 0.0714286];
                if (windowSize === 9 && (polyOrder === 2 || polyOrder === 3)) return [0.0384615, 0.0128205, -0.00769231, -0.0230769, -0.0333333, -0.0230769, -0.00769231, 0.0128205, 0.0384615];
                if (windowSize === 11 && (polyOrder === 2 || polyOrder === 3)) return [ 0.025175, 0.006993, -0.00559, -0.01399, -0.01958, -0.02308, -0.01958, -0.01399, -0.00559, 0.006993, 0.025175];

                console.warn(`No precomputed SG coefficients for window=${windowSize}, order=${polyOrder}.`);
                return null;
            };


            const findPeaks = () => {
                const intensity = fullExperimentalData.intensity;
                if (intensity.length < 5) return;

                const sgWindow = 9; // Fixed value
                const sgOrder = 2;  // Fixed value

                const minTth = parseFloat(ui.tthMinInput.value);
                const maxTth = parseFloat(ui.tthMaxInput.value);

                let thresholdPercent = parseFloat(ui.peakThresholdInput.value);
                if (isNaN(thresholdPercent) || thresholdPercent < 0.1 || thresholdPercent > 50) {
                    thresholdPercent = 2; ui.peakThresholdInput.value = 2;
                }
                const threshold = (thresholdPercent / 100) * Math.max(...intensity);

                const secondDerivative = savitzkyGolay(intensity, sgWindow, sgOrder);

                pickedPeaks = [];
                for (let i = 1; i < secondDerivative.length - 1; i++) {
                    const tth = fullExperimentalData.tth[i];
                    if (tth < minTth || tth > maxTth) continue;

                    // A peak in the data corresponds to a local minimum in the 2nd derivative that is also negative.
                    if (secondDerivative[i] < secondDerivative[i-1] &&
                        secondDerivative[i] < secondDerivative[i+1] &&
                        secondDerivative[i] < 0) {

                        if(intensity[i] > threshold) {
                            const lambda = parseFloat(ui.wavelength.value);
                            const d = lambda / (2 * Math.sin(tth * Math.PI / 360));
                            const q = 1 / (d * d);
                            pickedPeaks.push({ tth, d, q });
                        }
                    }
                }

                updatePeakTable();
                if (pickedPeaks.length > 0) {
                    ui.startIndexingButton.disabled = false;
                    ui.startIndexingButton.textContent = 'Start Indexing';
                } else {
                    ui.startIndexingButton.disabled = true;
                    ui.startIndexingButton.textContent = 'No Peaks Found in Range';
                }
            };

            const recalculatePeakValues = () => {
                const lambda = parseFloat(ui.wavelength.value);
                pickedPeaks.forEach(peak => {
                    peak.d = lambda / (2 * Math.sin(peak.tth * Math.PI / 360));
                    peak.q = 1 / (peak.d * peak.d);
                });
            };

            const updatePeakTable = () => {
                ui.peakListBody.innerHTML = '';
                pickedPeaks.forEach((peak, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td><input type="number" class="peak-tth-input" value="${peak.tth.toFixed(4)}" data-index="${index}" step="0.0001"></td>
                        <td><input type="number" class="peak-d-input" value="${peak.d.toFixed(5)}" data-index="${index}" disabled></td>
                        <td><button class="delete-peak-btn" data-index="${index}">X</button></td>
                    `;
                    ui.peakListBody.appendChild(row);
                });
                ui.peakTableContainer.classList.toggle('hidden', pickedPeaks.length === 0);
                updateAllMarkers();
            };

            ui.findPeaksButton.addEventListener('click', () => {
                findPeaks();
                showStatus(`${pickedPeaks.length} peaks found in the specified range.`, 'info');
            });
            ui.peakThresholdInput.addEventListener('change', findPeaks);

            ui.peakListBody.addEventListener('change', (e) => {
                if (e.target.classList.contains('peak-tth-input')) {
                    const index = parseInt(e.target.dataset.index);
                    const tth = parseFloat(e.target.value);
                    const lambda = parseFloat(ui.wavelength.value);
                    const d = lambda / (2 * Math.sin(tth * Math.PI / 360));
                    const q = 1 / (d*d);
                    pickedPeaks[index] = {tth, d, q};
                    e.target.closest('tr').querySelector('.peak-d-input').value = d.toFixed(5);
                    updateAllMarkers();
                }
            });
             ui.peakListBody.addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-peak-btn')) {
                    const index = parseInt(e.target.dataset.index);
                    pickedPeaks.splice(index, 1);
                    updatePeakTable();
                }
            });

            const startIndexing = () => {
                if (pickedPeaks.length < 4) {
                    showStatus("Please find at least 4 peaks before starting indexing.", 'error');
                    return;
                }

                const systemsToSearch = Array.from(ui.systemCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
                if (systemsToSearch.length === 0) {
                    showStatus("Please select at least one crystal system to search.", 'error');
                    return;
                }

                setUIState(true);
                solutions = [];
                selectedSolution = null;
                currentHklList = [];
                activeWorkers = [];
                updateSolutionsTable();
                showStatus(`Indexing started for ${systemsToSearch.length} system(s)...`, 'info');

                const baseParams = {
                    peaks: pickedPeaks,
                    wavelength: parseFloat(ui.wavelength.value),
                    tth_error: parseFloat(ui.tthError.value),
                    max_volume: parseFloat(ui.maxVolume.value),
                    impurity_peaks: parseInt(ui.impurityPeaksInput.value, 10),
                };

                const workerScript = document.getElementById('indexing-worker').textContent;
                const blob = new Blob([workerScript], { type: 'application/javascript' });
                const workerURL = URL.createObjectURL(blob);

                let completedWorkers = 0;
                const totalWorkers = systemsToSearch.length;

                systemsToSearch.forEach(system => {
                    const worker = new Worker(workerURL);
                    activeWorkers.push(worker);

                    worker.onmessage = (e) => {
                        const { type, payload } = e.data;
                        if (type === 'solution') {
                             const newSolution = payload;
                             const DUPLICATE_TOLERANCE = 0.001;
                             let isDuplicate = solutions.some(existing => {
                                 if (existing.system !== newSolution.system) return false;
                                 switch(existing.system) {
                                     case 'cubic': return Math.abs(existing.a - newSolution.a) / existing.a < DUPLICATE_TOLERANCE;
                                     case 'tetragonal': case 'hexagonal':
                                         return Math.abs(existing.a - newSolution.a) / existing.a < DUPLICATE_TOLERANCE &&
                                                Math.abs(existing.c - newSolution.c) / existing.c < DUPLICATE_TOLERANCE;
                                     case 'orthorhombic':
                                         const exParams = [existing.a, existing.b, existing.c].sort((x,y)=>x-y);
                                         const newParams = [newSolution.a, newSolution.b, newSolution.c].sort((x,y)=>x-y);
                                         return exParams.every((p, idx) => Math.abs(p - newParams[idx]) / p < DUPLICATE_TOLERANCE);
                                     case 'monoclinic':
                                          return Math.abs(existing.volume - newSolution.volume) / existing.volume < DUPLICATE_TOLERANCE &&
                                                 Math.abs(existing.beta - newSolution.beta) / existing.beta < DUPLICATE_TOLERANCE;
                                     default: return false;
                                 }
                             });
                             if (!isDuplicate) {
                                 solutions.push(newSolution);
                                 solutions.sort((a, b) => b.m20 - a.m20);
                                 updateSolutionsTable();
                             }
                        } else if (type === 'done') {
                            completedWorkers++;
                            ui.progressBar.style.width = `${(completedWorkers / totalWorkers) * 100}%`;
                            worker.terminate();
                            activeWorkers = activeWorkers.filter(w => w !== worker);

                            if (completedWorkers === totalWorkers) {
                                URL.revokeObjectURL(workerURL);
                                setUIState(false);
                                if (solutions.length > 0) {
                                    showStatus(`Indexing complete. Found ${solutions.length} potential solution(s).`, 'success');
                                } else {
                                    showStatus('Indexing finished, but no valid solutions were found.', 'info');
                                }
                            }
                        }
                    };
                    worker.postMessage({ ...baseParams, systemToSearch: system });
                });
            };

            ui.startIndexingButton.addEventListener('click', startIndexing);

            ui.reportButton.addEventListener('click', () => {
                if (isIndexing) {
                    activeWorkers.forEach(w => w.terminate());
                    activeWorkers = [];
                    setUIState(false);
                    showStatus('Indexing stopped by user.', 'info');
                } else {
                    generatePDFReport();
                }
            });

            const setUIState = (indexing) => {
                isIndexing = indexing;
                document.body.style.cursor = indexing ? 'wait' : 'default';

                const controlsToDisable = [
                    ui.fileInput, ui.findPeaksButton, ui.peakThresholdInput,
                    ui.tthMinSlider, ui.tthMaxSlider, ui.tthMinInput, ui.tthMaxInput,
                    ui.wavelength, ui.tthError, ui.maxVolume,
                    ui.impurityPeaksInput, ...ui.systemCheckboxes,
                ];

                controlsToDisable.forEach(el => {
                    if (el) el.disabled = indexing;
                });

                ui.peakListBody.querySelectorAll('input, button').forEach(el => {
                    el.disabled = indexing;
                });

                const fileLabel = document.querySelector('.file-input-label');
                if (fileLabel) {
                    fileLabel.style.pointerEvents = indexing ? 'none' : 'auto';
                    fileLabel.style.opacity = indexing ? '0.7' : '1';
                }

                if (indexing) {
                    ui.startIndexingButton.disabled = true;
                    ui.startIndexingButton.textContent = 'Indexing...';
                    ui.reportButton.textContent = 'Stop';
                    ui.reportButton.disabled = false;
                    ui.progressBarContainer.classList.remove('hidden');
                    ui.progressBar.style.width = '0%';
                } else {
                    ui.startIndexingButton.disabled = (pickedPeaks.length === 0);
                    ui.startIndexingButton.textContent = 'Start Indexing';
                    ui.reportButton.textContent = 'Generate PDF Report';
                    ui.reportButton.disabled = (solutions.length === 0);
                    ui.progressBarContainer.classList.add('hidden');
                    ui.progressBar.style.width = '0%';
                    if (fullExperimentalData.tth.length > 0) {
                        ui.tthMinSlider.disabled = false;
                        ui.tthMaxSlider.disabled = false;
                        ui.tthMinInput.disabled = false;
                        ui.tthMaxInput.disabled = false;
                    }
                }
            };

            const updateSolutionsTable = () => {
                ui.solutionsTableBody.innerHTML = '';
                solutions.slice(0, 20).forEach((sol, index) => {
                    const row = document.createElement('tr');
                    row.dataset.index = index;

                    let cell_params1 = `${sol.a.toFixed(4)}`;
                    if(sol.b) cell_params1 += `, ${sol.b.toFixed(4)}`;
                    if(sol.c) cell_params1 += `, ${sol.c.toFixed(4)}`;

                    const cell_params2 = `${sol.alpha ? sol.alpha.toFixed(2) : '90'}, ${sol.beta ? sol.beta.toFixed(2) : '90'}, ${sol.gamma ? sol.gamma.toFixed(2) : '90'}`;

                    row.innerHTML = `
                        <td>${sol.system.substring(0,4)}</td>
                        <td>${cell_params1}</td>
                        <td>${cell_params2}</td>
                        <td>${sol.volume.toFixed(2)}</td>
                        <td>${sol.m20.toFixed(2)}</td>
                    `;
                    ui.solutionsTableBody.appendChild(row);
                });
            };

            ui.solutionsTableBody.addEventListener('click', (e) => {
                const row = e.target.closest('tr');
                if (!row) return;

                document.querySelectorAll('#solutions-table-body tr').forEach(r => r.classList.remove('selected'));
                row.classList.add('selected');

                const index = parseInt(row.dataset.index);
                selectedSolution = solutions[index];

                const lambda = parseFloat(ui.wavelength.value);
                const maxTth = xrdChart.options.scales.x.max || Math.max(...pickedPeaks.map(p => p.tth));
                currentHklList = generateHKL(maxTth, {...selectedSolution, lambda}, selectedSolution.system);

                updateAllMarkers();
            });

            // --- Chart.js Vertical Line Plugin ---
            const verticalCursorLine = {
                id: 'verticalCursorLine',
                afterDraw: chart => {
                    if (chart.tooltip?._active?.length) {
                        let x = chart.tooltip._active[0].element.x;
                        let yAxis = chart.scales.y;
                        let ctx = chart.ctx;
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(x, yAxis.top);
                        ctx.lineTo(x, yAxis.bottom);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)';
                        ctx.setLineDash([4, 4]);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            };
            Chart.register(verticalCursorLine);
            // --- End Plugin ---

            const initializeChart = () => {
                if (xrdChart) xrdChart.destroy();
                const experimentalPoints = fullExperimentalData.tth.map((t, i) => ({ x: t, y: fullExperimentalData.intensity[i] }));
                const yMax = Math.max(...fullExperimentalData.intensity);

                xrdChart = new Chart(ui.chartCanvas, {
                    type: 'line',
                    data: {
                        datasets: [
                            {
                                label: 'Experimental',
                                data: experimentalPoints,
                                borderColor: 'rgba(107, 114, 128, 0.7)',
                                borderWidth: 1.5,
                                pointRadius: 0
                            },
                            {
                                type: 'bar',
                                label: 'Observed Peaks',
                                data: [],
                                backgroundColor: 'rgba(239, 68, 68, 0.7)',
                                barThickness: 1
                            },
                            {
                                type: 'bar',
                                label: 'Calculated Peaks',
                                data: [],
                                backgroundColor: 'rgba(59, 130, 246, 0.9)',
                                barThickness: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false, animation: false,
                        interaction: {
                            intersect: false,
                            mode: 'index',
                        },
                        scales: {
                            x: { type: 'linear', title: { display: true, text: '2-theta (degrees)' } },
                            y: { title: { display: true, text: 'Intensity (a.u.)' }, min: -yMax * 0.15, max: yMax * 1.1 }
                        },
                        plugins: {
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'xy',
                                    threshold: 5,
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false, // Custom wheel handler is used instead
                                    },
                                    pinch: {
                                        enabled: true,
                                    },
                                    drag: {
                                        enabled: false,
                                    }
                                }
                            },
                            legend: { position: 'top' },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        if (!tooltipItems.length) return '';
                                        const tth = tooltipItems[0].parsed.x;
                                        let title = `2θ: ${tth.toFixed(3)}°`;

                                        if (currentHklList && currentHklList.length > 0) {
                                            let closestPeak = null;
                                            let minDiff = Infinity;

                                            for (const hkl of currentHklList) {
                                                const diff = Math.abs(tth - hkl.tth);
                                                if (diff < minDiff) {
                                                    minDiff = diff;
                                                    closestPeak = hkl;
                                                }
                                            }
                                            
                                            const tolerance = parseFloat(ui.tthError.value) || 0.05;
                                            if (closestPeak && minDiff < tolerance) {
                                                title += `, HKL: (${closestPeak.h},${closestPeak.k},${closestPeak.l})`;
                                            }
                                        }
                                        return title;
                                    },
                                    label: function(context) {
                                        const datasetLabel = context.dataset.label || '';
                                        if (datasetLabel === 'Observed Peaks' || datasetLabel === 'Calculated Peaks') {
                                            return null;
                                        }
                                        let label = datasetLabel ? `${datasetLabel}: ` : '';
                                        if (context.parsed.y !== null) {
                                            label += Math.round(context.parsed.y);
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
            };

            const updateAllMarkers = () => {
                if (!xrdChart) return;

                const minX = xrdChart.options.scales.x.min;
                const maxX = xrdChart.options.scales.x.max;
                const visibleIntensities = fullExperimentalData.intensity.filter((_, index) => {
                    const tth = fullExperimentalData.tth[index];
                    return tth >= minX && tth <= maxX;
                });
                const yMax = visibleIntensities.length > 0 ? Math.max(...visibleIntensities) : (Math.max(...fullExperimentalData.intensity) || 1000);
                const markerHeight = yMax * 0.04;

                xrdChart.data.datasets[1].data = pickedPeaks.map(p => ({ x: p.tth, y: [-markerHeight * 0.25, -markerHeight * 1.25] }));

                if (selectedSolution) {
                    xrdChart.data.datasets[2].data = currentHklList.map(hkl => ({ x: hkl.tth, y: [-markerHeight * 1.5, -markerHeight * 2.5] }));
                } else {
                    xrdChart.data.datasets[2].data = [];
                }

                xrdChart.update('none');
            }

             const generateHKL = (maxTth, params, system) => {
                 const { a, b, c, alpha, beta, gamma, lambda } = params;
                 if (!a || !lambda) return [];
                 const reflections = [];
                 const maxIndex = 10;

                 for (let h = 0; h <= maxIndex; h++) {
                     for (let k = 0; k <= maxIndex; k++) {
                         for (let l = 0; l <= maxIndex; l++) {
                             if (system === 'cubic' && (k > h || l > k)) continue;
                             if ((system === 'tetragonal' || system === 'hexagonal') && k > h) continue;
                            if (h === 0 && k === 0 && l === 0) continue;
                             let inv_d_sq = 0;
                             switch (system) {
                                 case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                                 case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                                 case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                                 case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                                 case 'monoclinic': 
                                     const sinBeta = Math.sin(beta * Math.PI / 180);
                                     const cosBeta = Math.cos(beta * Math.PI / 180);
                                     inv_d_sq = (1 / (sinBeta * sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + k*k/(b*b);
                                     break;
                             }
                             if (inv_d_sq <= 0) continue;
                             const sinThetaSq = (lambda*lambda / 4) * inv_d_sq;
                             if (sinThetaSq <= 1) {
                                 const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                                 if (tth <= maxTth * 1.05) {
                                     reflections.push({tth, h, k, l, d: 1/Math.sqrt(inv_d_sq)});
                                 }
                             }
                         }
                     }
                 }
                 return reflections.sort((a, b) => a.tth - b.tth);
             };


            const resizer = document.getElementById('drag-handle');
            const leftPanel = document.getElementById('controls-panel');
            resizer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                document.body.style.cursor = 'col-resize';
                const moveHandler = (moveEvent) => {
                    if (moveEvent.clientX > 350 && moveEvent.clientX < window.innerWidth - 350) {
                        leftPanel.style.width = `${moveEvent.clientX}px`;
                    }
                };
                const upHandler = () => {
                    document.body.style.cursor = 'default';
                    window.removeEventListener('mousemove', moveHandler);
                    window.removeEventListener('mouseup', upHandler);
                };
                window.addEventListener('mousemove', moveHandler);
                window.addEventListener('mouseup', upHandler);
            });
            
            ui.chartCanvas.addEventListener('wheel', e => {
                e.preventDefault();

                const chart = xrdChart;
                if (!chart || !chart.chartArea) return;

                const { left, right, top, bottom } = chart.chartArea;
                const x = e.offsetX;
                const y = e.offsetY;

                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;

                if (y > bottom) {
                    chart.zoom({ x: zoomFactor }, { x, y });
                } else if (x < left) {
                    chart.zoom({ y: zoomFactor }, { x, y });
                } else if (x >= left && x <= right && y >= top && y <= bottom) {
                    chart.zoom({ x: zoomFactor, y: zoomFactor }, { x, y });
                }
            });

            ui.chartCanvas.addEventListener('contextmenu', e => {
                e.preventDefault();
                if (xrdChart) {
                    xrdChart.resetZoom();
                }
            });


        const generatePDFReport = async () => {
                if (solutions.length === 0) {
                    showStatus("No solutions found to generate a report.", 'info');
                    return;
                }

                ui.reportButton.textContent = 'Generating...';
                ui.reportButton.disabled = true;
                document.body.style.cursor = 'wait';

                try {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                    const margin = 15;
                    let yPos = 20;

                    const now = new Date();
                    const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                    doc.setFontSize(18);
                    doc.text('Powder Indexing Report', 105, yPos, { align: 'center' });
                    yPos += 10;
                    doc.setFontSize(10);
                    doc.text(`Generated: ${timestamp}`, margin, yPos);
                    yPos += 5;
                    doc.text(`Data File: ${ui.fileName.textContent}`, margin, yPos);
                    yPos += 10;

                    const canvas = await html2canvas(ui.chartCanvas, { backgroundColor: '#ffffff' });
                    const imgData = canvas.toDataURL('image/png');
                    const imgProps = doc.getImageProperties(imgData);
                    const pdfWidth = doc.internal.pageSize.getWidth();
                    const imgWidth = pdfWidth - 2 * margin;
                    const imgHeight = (imgProps.height * imgWidth) / imgProps.width;
                    doc.addImage(imgData, 'PNG', margin, yPos, imgWidth, imgHeight);
                    yPos += imgHeight + 10;

                    doc.addPage();
                    yPos = 20;
                    doc.setFontSize(14);
                    doc.text('Indexing Solutions Summary', margin, yPos);
                    yPos += 8;
                    doc.setFont('courier', 'normal');
                    doc.setFontSize(9);
                    doc.text('Sys  M(20)   Volume(A^3)  a(A)      b(A)      c(A)      alpha  beta   gamma', margin, yPos);
                    yPos += 5;
                    solutions.slice(0, 20).forEach(sol => {
                        if (yPos > 280) { doc.addPage(); yPos = 20; }
                        const line = `${sol.system.substring(0,4).padEnd(5)}` +
                                    `${sol.m20.toFixed(2).padStart(6)}  ` +
                                    `${sol.volume.toFixed(2).padStart(10)}  ` +
                                    `${sol.a.toFixed(4).padStart(8)}  ` +
                                    `${(sol.b ? sol.b.toFixed(4) : '-').padStart(8)}  ` +
                                    `${(sol.c ? sol.c.toFixed(4) : '-').padStart(8)}  ` +
                                    `${(sol.alpha ? sol.alpha.toFixed(2) : '90.00').padStart(6)} ` +
                                    `${(sol.beta ? sol.beta.toFixed(2) : '90.00').padStart(6)} ` +
                                    `${(sol.gamma ? sol.gamma.toFixed(2) : '90.00').padStart(6)}`;
                        doc.text(line, margin, yPos);
                        yPos += 5;
                    });

                    const lambda = parseFloat(ui.wavelength.value);
                    solutions.forEach((sol, solIndex) => {
                        doc.addPage();
                        yPos = 20;
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(12);
                        doc.text(`Details for Solution #${solIndex+1}: ${sol.system}, M(20) = ${sol.m20.toFixed(2)}`, margin, yPos);
                        yPos += 7;

                        doc.setFont('courier', 'normal');
                        doc.setFontSize(9);
                        let paramsLine = `a=${sol.a.toFixed(4)}`;
                        if(sol.b) paramsLine += `, b=${sol.b.toFixed(4)}`;
                        if(sol.c) paramsLine += `, c=${sol.c.toFixed(4)}`;
                        paramsLine += ` (A)`;
                        if(sol.alpha && sol.system !== 'cubic') paramsLine += `, alpha=${sol.alpha.toFixed(2)}`;
                        if(sol.beta && sol.system !== 'cubic') paramsLine += `, beta=${sol.beta.toFixed(2)}`;
                        if(sol.gamma && sol.system !== 'cubic') paramsLine += `, gamma=${sol.gamma.toFixed(2)}`;
                        doc.text(paramsLine, margin, yPos);
                        yPos += 7;

                        doc.setFont('helvetica', 'bold');
                        doc.text(`Suggested Centering:`, margin, yPos);
                        doc.setFont('courier', 'normal');
                        doc.text(sol.analysis.centering, margin + 45, yPos);
                        yPos += 5;

                        if (sol.analysis.conditions.length > 0) {
                            doc.setFont('helvetica', 'bold');
                            doc.text(`Reflection Conditions:`, margin, yPos);
                            doc.setFont('courier', 'normal');
                            doc.text(sol.analysis.conditions.join(', '), margin + 45, yPos);
                            yPos += 5;
                        }

                        if (sol.analysis.possibleSpaceGroups.length > 0) {
                            doc.setFont('helvetica', 'bold');
                            doc.text(`Space Groups:`, margin, yPos);
                            let currentX = margin + 45;
                            const probableSet = new Set(sol.analysis.probableSpaceGroups);
                            const allGroups = sol.analysis.possibleSpaceGroups;
                            const pageRightMargin = doc.internal.pageSize.getWidth() - margin;

                            allGroups.forEach((sg, index) => {
                                doc.setFont('courier', probableSet.has(sg) ? 'bold' : 'normal');
                                const text = sg + (index < allGroups.length - 1 ? ', ' : '');
                                if (currentX + doc.getTextWidth(text) > pageRightMargin && currentX > margin + 45) {
                                    yPos += 4;
                                    currentX = margin + 45;
                                }
                                doc.text(text, currentX, yPos);
                                currentX += doc.getTextWidth(text);
                            });
                            yPos += 4;
                        }
                        yPos += 3;

                        doc.setFont('courier', 'normal');
                        doc.text(' h  k  l |   d_cal(A) 2t_calc   d_obs(A)  2t_obs    d(2t)', margin, yPos);
                        yPos += 5;

                        const hklList = generateHKL(Math.max(...pickedPeaks.map(p=>p.tth)), {...sol, lambda}, sol.system);
                        const usedObsPeaks = new Set();
                        const tth_err = parseFloat(ui.tthError.value);

                        hklList.slice(0, 30).forEach(hkl => {
                            if (yPos > 280) { doc.addPage(); yPos = 20; }

                            let bestMatch = null;
                            let minDiff = Infinity;
                            pickedPeaks.forEach((peak, index) => {
                                if (usedObsPeaks.has(index)) return;
                                const diff = Math.abs(hkl.d - peak.d);
                                if (diff < minDiff) {
                                    minDiff = diff;
                                    bestMatch = { peak, index };
                                }
                            });

                            let d_obs_str = '-';
                            let tth_obs_str = '-';
                            let tth_diff_str = '-';

                            let tth_calc = '-';
                            if (hkl.d > 0 && lambda/(2*hkl.d) < 1) {
                                tth_calc = (2 * Math.asin(lambda / (2 * hkl.d)) * 180 / Math.PI).toFixed(3);
                            }
                            
                            if (bestMatch) {
                                const d_err_plus = lambda / (2 * Math.sin((bestMatch.peak.tth - tth_err) * Math.PI / 360));
                                const d_err_minus = lambda / (2 * Math.sin((bestMatch.peak.tth + tth_err) * Math.PI / 360));
                                if (minDiff < Math.abs(d_err_plus - d_err_minus)) {
                                    d_obs_str = bestMatch.peak.d.toFixed(5);
                                    tth_obs_str = bestMatch.peak.tth.toFixed(3);
                                    
                                    if (tth_calc !== '-') {
                                        const tth_diff = parseFloat(tth_calc) - bestMatch.peak.tth;
                                        tth_diff_str = tth_diff.toFixed(3);
                                    }
                                    
                                    usedObsPeaks.add(bestMatch.index);
                                }
                            }
                            
                            const line = `${String(hkl.h).padStart(2)} ${String(hkl.k).padStart(2)} ${String(hkl.l).padStart(2)} | ` +
                                         `${hkl.d.toFixed(5).padStart(9)} ` +
                                         `${String(tth_calc).padStart(7)}  ` +
                                         `${d_obs_str.padStart(9)}  ` +
                                         `${tth_obs_str.padStart(7)} ` +
                                         `${tth_diff_str.padStart(7)}`;
                            doc.text(line, margin, yPos);
                            yPos += 5;
                        });
                    });


                    const filename = `Indexing-Report-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}.pdf`;
                    doc.save(filename);
                    showStatus('PDF report generated and saved.', 'success');

                } catch (error) {
                    console.error("Failed to generate PDF:", error);
                    showStatus("An error occurred during PDF generation.", 'error');
                } finally {
                    ui.reportButton.textContent = 'Generate PDF Report';
                    ui.reportButton.disabled = (solutions.length === 0);
                    document.body.style.cursor = 'default';
                }
            };

        });
    </script>
    
<script id="indexing-worker" type="text/javascript">
    self.onmessage = function(e) {
        const { peaks, wavelength, tth_error, max_volume, systemToSearch, impurity_peaks } = e.data;
        const DUPLICATE_TOLERANCE = 0.002;
        const foundSolutions = [];

        const q_from_tth_local = (tth) => {
            const sin_theta = Math.sin(tth * Math.PI / 360);
            return (4 * sin_theta * sin_theta) / (wavelength * wavelength);
        };
        
        // Use sorted Float64Array for q_obs
        const tth_obs_deg = new Float64Array(peaks.map(p => p.tth));
        const peaks_sorted_by_q = peaks.map((p, i) => ({...p, original_index: i}))
                                     .sort((a,b) => a.q - b.q);
        const q_obs = new Float64Array(peaks_sorted_by_q.map(p => p.q));
        const original_indices = peaks_sorted_by_q.map(p => p.original_index);

        // Pre-calculate theta in radians for tolerance calculations
        const tth_obs_rad = new Float64Array(peaks.map(p => p.tth * Math.PI / 360));
        const N_FOR_M20 = Math.min(20, peaks.length);

        // Calculate d_min and q_max for dynamic HKL bounds
        const d_min = wavelength / (2 * Math.sin(peaks.map(p => p.tth).sort((a,b)=>b-a)[0] * Math.PI / 360));
        const q_max = 1 / (d_min * d_min);

        const min_lattice_param = 3.0;
        const max_lattice_param = 42.0;
        const min_m20 = 2.0;
        
        // Search depth parameters
        const max_hkl_low_angle_search = 5; //  reduced from 15+
        const tetra_hexa_i_depth = Math.min(10, peaks.length); // Use fewer peaks for basis, bon, je vais perdre certains ?
        const tetra_hexa_j_depth = Math.min(10, peaks.length);

        const max_hkl_analysis = 10;
        const spaceGroupData = { /* space group data */ 
            cubic: { 'P': { 'Pm-3m': { c: [] }, 'Pn-3n': { c: ['0kl:k+l=2n', 'hhl:l=2n'] }, 'Pm-3n': { c: ['hk0:h+k=2n'] }, 'Pa-3': { c: ['hk0:h=2n'] }, 'Pn-3m': { c: ['hhl:l=2n'] } }, 'I': { 'Im-3m': { c: [] }, 'Ia-3': { c: ['0kl:k=2n'] }, 'Ia-3d': { c: ['0kl:k=2n,l=2n', 'hhl:2h+l=4n'] } }, 'F': { 'Fm-3m': { c: [] }, 'Fd-3m': { c: ['0kl:k+l=4n'] }, 'Fm-3c': { c: ['hhl:l=2n'] } } },
            tetragonal: { 'P': { 'P4/mmm': { c: [] }, 'P4/mcc': { c: ['hhl:l=2n', '0kl:l=2n'] }, 'P4/nmm': { c: ['hk0:h+k=2n'] }, 'P4/ncc': { c: ['hk0:h+k=2n', '0kl:l=2n'] }, 'P4_2/mcm': { c: ['0kl:l=2n', 'hhl:l=2n'] }, 'P4_2/mnm': { c: ['0kl:k+l=2n', 'h00:h=2n'] }, 'P4_2/nmc': { c: ['hk0:h+k=2n', 'h0l:l=2n'] }, 'P4_2/nbc': { c: ['hk0:h+k=2n', '0kl:k=2n'] } }, 'I': { 'I4/mmm': { c: [] }, 'I4/mcm': { c: ['0kl:l=2n', 'hhl:l=2n'] }, 'I4_1/a': { c: ['hkl:2h+l=4n'] }, 'I4_1/amd': { c: ['hkl:2h+l=4n', 'hk0:h=2n,k=2n'] }, 'I4_1/acd': { c: ['hkl:2h+l=4n', 'hk0:h=2n,k=2n', '0kl:k=2n,l=2n'] } } },
            hexagonal: { 'P': { 'P6/mmm': { c: [] }, 'P6/mcc': { c: ['h-hl:l=2n', '00l:l=2n'] }, 'P6_3/mmc': { c: ['00l:l=2n'] }, 'P6_3/mcm': { c: ['h-hl:l=2n', '00l:l=2n'] }, 'P-3': { c: [] }, 'P-3m1': { c: [] }, 'P-31m': { c: [] }, }, 'R': { 'R-3': { c: [] }, 'R-3m': { c: [] }, 'R-3c': { c: ['h-hl:l=2n'] } } },
            orthorhombic: { 'P': { 'Pmmm': { c: [] }, 'Pnnn': { c: ['0kl:k+l=2n', 'h0l:h+l=2n', 'hk0:h+k=2n'] }, 'Pccm': { c: ['h0l:l=2n', '0kl:l=2n'] }, 'Pban': { c: ['0kl:k=2n', 'h0l:h=2n'] }, 'Pccn': { c: ['h0l:l=2n', '0kl:k=2n'] }, 'Pbcm': { c: ['0kl:k=2n', 'h0l:l=2n'] }, 'Pnnm': { c: ['hk0:h+k=2n'] }, 'Pnma': { c: ['0kl:k+l=2n', 'hk0:h=2n'] }, 'Pbca': { c: ['0kl:k=2n', 'h0l:l=2n', 'hk0:h=2n'] }, 'P2_12_12_1': { c: ['h00:h=2n', '0k0:k=2n', '00l:l=2n'] } }, 'C': { 'Cmmm': { c: [] }, 'Cmcm': { c: ['h0l:l=2n'] }, 'Cmce': { c: ['0kl:l=2n', 'h0l:h+l=2n'] }, 'Cccm': { c: ['h0l:l=2n'] }, 'Ccce': { c: ['h0l:l=2n', 'hhl:l=2n'] }, }, 'I': { 'Immm': { c: [] }, 'Ibam': { c: ['0kl:k=2n'] }, 'Ibca': { c: ['0kl:k=2n', 'h0l:l=2n'] }, 'Imma': { c: ['0kl:k+l=2n'] } }, 'F': { 'Fmmm': { c: [] }, 'Fddd': { c: ['0kl:k+l=4n', 'h0l:h+l=4n', 'hk0:h+k=4n'] } } },
            monoclinic: { 'P': { 'P2/m': { c: [] }, 'P2_1/m': { c: ['0k0:k=2n'] }, 'P2/c': { c: ['h0l:l=2n'] }, 'P2_1/c': { c: ['h0l:l=2n', '0k0:k=2n'] } }, 'C': { 'C2/m': { c: [] }, 'C2/c': { c: ['h0l:l=2n'] } } }
        };


        const get_q_tolerance = (original_peak_index) => {
            const theta = tth_obs_rad[original_peak_index];
            const d_theta = tth_error * Math.PI / 360;
            // dq/d(theta) = (8*sin(theta)*cos(theta))/lambda^2
            return ((8 * Math.sin(theta) * Math.cos(theta)) / (wavelength * wavelength)) * d_theta;
        };

        const binarySearchClosest = (arr, target) => {
            let low = 0, high = arr.length - 1;
            if (target <= arr[low]) return low;
            if (target >= arr[high]) return high;
            while (low <= high) {
                let mid = Math.floor((low + high) / 2);
                if (arr[mid] === target) return mid;
                if (arr[mid] < target) low = mid + 1;
                else high = mid - 1;
            }
            return (arr[low] - target) < (target - arr[high]) ? low : high;
        };
        
        // Suggestion 6: Rewritten M20 calculation with O(N log N) matching
        const calculateM20 = (q_calc_sorted) => {
            if (q_calc_sorted.length === 0) return 0;
            let N_indexed = 0;
            let sum_delta_q = 0;
            for (let i = 0; i < N_FOR_M20; i++) {
                const q_o = q_obs[i];
                const tolerance = get_q_tolerance(original_indices[i]);
                const closest_idx = binarySearchClosest(q_calc_sorted, q_o);
                const diff = Math.abs(q_o - q_calc_sorted[closest_idx]);
                if (diff < tolerance) {
                    N_indexed++;
                    sum_delta_q += diff;
                }
            }

            const unindexed_peaks = N_FOR_M20 - N_indexed;
            if (unindexed_peaks > impurity_peaks) return 0;
            if (N_indexed === 0) return 0;

            const q_n = q_obs[N_FOR_M20 - 1];
            let N_calc = 0;
            for (let i = 0; i < q_calc_sorted.length; i++) {
                if (q_calc_sorted[i] > q_n * 1.05) break;
                N_calc++;
            }

            if (N_calc === 0) return 0;
            const avg_delta_q = sum_delta_q / N_indexed;
            if (avg_delta_q === 0) return 0;
            return q_n / (2 * avg_delta_q * N_calc);
        };

        const testSolution = (params) => {
            let {a, b, c, alpha, beta, gamma, system} = params;
            // Suggestion 1: Apply parameter limits early
            if (a < min_lattice_param || a > max_lattice_param ||
                (b && (b < min_lattice_param || b > max_lattice_param)) ||
                (c && (c < min_lattice_param || c > max_lattice_param))) {
                return;
            }

            if (system === 'monoclinic' && beta < 90.0) {
                beta = 180.0 - beta;
            }

            let volume = 0;
            switch(system){
                case 'cubic': volume = a*a*a; break;
                case 'tetragonal': volume = a*a*c; break;
                case 'hexagonal': volume = a*a*c * Math.sqrt(3)/2; break;
                case 'orthorhombic': volume = a*b*c; break;
                case 'monoclinic': volume = a*b*c*Math.sin(beta * Math.PI / 180); break;
            }
            if (volume > max_volume || volume < 20) return;

            //  Dynamic HKL bounds and early loop exit
            const q_calc = new Set();
            const h_max = Math.ceil(a / d_min);
            const k_max = b ? Math.ceil(b / d_min) : h_max;
            const l_max = c ? Math.ceil(c / d_min) : h_max;
            
            for (let h = 0; h <= h_max; h++) {
                for (let k = 0; k <= k_max; k++) {
                    if ((system === 'cubic' || system === 'tetragonal' || system === 'hexagonal') && k > h) continue;
                    for (let l = 0; l <= l_max; l++) {
                        if (system === 'cubic' && l > k) continue;
                        if (h === 0 && k === 0 && l === 0) continue;
                        let q = 0;
                        switch (system) {
                            case 'cubic': q = (h*h + k*k + l*l) / (a*a); break;
                            case 'tetragonal': q = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                            case 'hexagonal': q = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                            case 'orthorhombic': 
                                 const q_h = h*h/(a*a); if(q_h > q_max*1.05) continue;
                                 const q_hk = q_h + k*k/(b*b); if(q_hk > q_max*1.05) continue;
                                 q = q_hk + l*l/(c*c);
                                 break;
                            case 'monoclinic':
                                 const sinBeta = Math.sin(beta * Math.PI / 180);
                                 const cosBeta = Math.cos(beta * Math.PI / 180);
                                 q = (1/(sinBeta*sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + k*k/(b*b);
                                 break;
                        }
                        if (q > q_max * 1.05) continue;
                        if (q > 0) q_calc.add(q);
                    }
                }
            }

            const q_calc_sorted = new Float64Array(Array.from(q_calc)).sort((x, y) => x - y);
            const m20 = calculateM20(q_calc_sorted);

            if (m20 > min_m20) {
                const analysis = analyzeSystematicAbsences({a, b, c, alpha, beta, gamma, system}, peaks);
                const newSolution = {a, b, c, alpha, beta, gamma, system, volume, m20, analysis};
                let isDuplicate = foundSolutions.some(existing => {
                    if (existing.system !== system) return false;
                    if (system === 'monoclinic') return Math.abs(volume - existing.volume) / volume < DUPLICATE_TOLERANCE && Math.abs(beta - existing.beta) / beta < DUPLICATE_TOLERANCE;
                    const newParams = [a, b, c].filter(Boolean).sort((x,y)=>x-y);
                    const exParams = [existing.a, existing.b, existing.c].filter(Boolean).sort((x,y)=>x-y);
                    if (newParams.length !== exParams.length) return false;
                    return newParams.every((p, idx) => Math.abs(p - exParams[idx]) / p < DUPLICATE_TOLERANCE);
                });
                if (!isDuplicate) {
                    foundSolutions.push(newSolution);
                    self.postMessage({ type: 'solution', payload: newSolution });
                }
            }
        };
        const analyzeSystematicAbsences = (solution, obs_peaks) => { /* unchanged */ 
            const { system } = solution;
            const all_hkls = generateHKL_for_analysis(solution, wavelength, Math.max(...obs_peaks.map(p=>p.tth)));
            const obs_hkl_list = [];
            const used_peaks = new Set();
            all_hkls.forEach(hkl => {
                let bestMatch = null; let minDiff = Infinity;
                obs_peaks.forEach((peak, index) => {
                    if (used_peaks.has(index)) return;
                    const diff = Math.abs(hkl.d - peak.d);
                    if (diff < minDiff) { minDiff = diff; bestMatch = { peak, index }; }
                });
                if (bestMatch) {
                    const tolerance = get_q_tolerance(bestMatch.index);
                    const d_tolerance = Math.abs(1/Math.sqrt(bestMatch.peak.q + tolerance) - 1/Math.sqrt(bestMatch.peak.q - tolerance)) / 2;
                    if (minDiff < d_tolerance) {
                       obs_hkl_list.push(hkl); used_peaks.add(bestMatch.index);
                    }
                }
            });
            let centering = 'Primitive (P)';
            if (obs_hkl_list.length >= 3) {
                 if (system === 'cubic' || system === 'tetragonal' || system === 'orthorhombic') {
                    const violates_I = obs_hkl_list.some(({h,k,l}) => (h+k+l) % 2 !== 0);
                    const violates_F = obs_hkl_list.some(({h,k,l}) => !((h%2===k%2)&&(k%2===l%2)));
                    if (!violates_F) centering = 'Face (F)';
                    else if (!violates_I) centering = 'Body (I)';
                 }
                if ((system === 'orthorhombic' || system === 'monoclinic') && centering === 'Primitive (P)' && !obs_hkl_list.some(({h,k,l}) => (h+k) % 2 !== 0)) centering = 'C-Face (C)';
                if (system === 'hexagonal' && (!obs_hkl_list.some(({h,k,l}) => (-h+k+l)%3!==0) || !obs_hkl_list.some(({h,k,l}) => (h-k+l)%3!==0))) centering = 'Rhombohedral (R)';
            }
            const centerChar = centering.charAt(centering.indexOf('(')+1);
            const foundConditions = new Set();
            const check = (filter, rule) => { const subset = obs_hkl_list.filter(filter); return subset.length === 0 || !subset.some(rule); };
            if (check(p => p.h !== 0 && p.k===0 && p.l===0, p => p.h%2 !== 0)) foundConditions.add('h00:h=2n');
            if (check(p => p.k !== 0 && p.h===0 && p.l===0, p => p.k%2 !== 0)) foundConditions.add('0k0:k=2n');
            if (check(p => p.l !== 0 && p.h===0 && p.k===0, p => p.l%2 !== 0)) foundConditions.add('00l:l=2n');
            if (check(p => p.h!==0 && p.k!==0 && p.l===0, p => (p.h+p.k)%2 !== 0)) foundConditions.add('hk0:h+k=2n');
            if (check(p => p.k!==0 && p.l!==0 && p.h===0, p => (p.k+p.l)%2 !== 0)) foundConditions.add('0kl:k+l=2n');
            if (check(p => p.h!==0 && p.l!==0 && p.k===0, p => (p.h+p.l)%2 !== 0)) foundConditions.add('h0l:h+l=2n');
            if (system === 'monoclinic' && check(p => p.h!==0 && p.l!==0 && p.k===0, p => p.l%2 !== 0)) foundConditions.add('h0l:l=2n');
            if (check(p => p.h===p.k && p.l!==0, p => p.l%2 !== 0)) foundConditions.add('hhl:l=2n');
            if (check(p => p.h===-p.k && p.l!==0, p => p.l%2 !== 0)) foundConditions.add('h-hl:l=2n');
            const sg_block = spaceGroupData[system]?.[centerChar] || {};
            const possibleSpaceGroups = Object.keys(sg_block);
            const probableSpaceGroups = possibleSpaceGroups.filter(sg => (sg_block[sg].c || []).every(cond => foundConditions.has(cond)));
            return { centering, conditions: Array.from(foundConditions), possibleSpaceGroups, probableSpaceGroups };
         };
        const generateHKL_for_analysis = (params, lambda, maxTth) => { /* unchanged */
             const { a, b, c, beta, system } = params;
             const reflections = [];
             for (let h = -max_hkl_analysis; h <= max_hkl_analysis; h++) {
                 for (let k = -max_hkl_analysis; k <= max_hkl_analysis; k++) {
                     for (let l = -max_hkl_analysis; l <= max_hkl_analysis; l++) {
                         if (h === 0 && k === 0 && l === 0) continue;
                         let inv_d_sq = 0;
                         switch (system) {
                             case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break;
                             case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break;
                             case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break;
                             case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break;
                             case 'monoclinic':
                                 const sinBeta = Math.sin(beta * Math.PI / 180);
                                 const cosBeta = Math.cos(beta * Math.PI / 180);
                                 inv_d_sq = (1/(sinBeta*sinBeta)) * (h*h/(a*a) + l*l/(c*c) - 2*h*l*cosBeta/(a*c)) + k*k/(b*b);
                                 break;
                         }
                         if (inv_d_sq > 0) {
                              const d = 1 / Math.sqrt(inv_d_sq);
                              const sinThetaSq = (lambda * lambda / 4) * inv_d_sq;
                              if (sinThetaSq <= 1) {
                                 const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                                 if(tth <= maxTth*1.05) reflections.push({ tth, h, k, l, d });
                              }
                         }
                     }
                 }
             }
             return reflections.sort((a, b) => a.tth - b.tth);
        };
        const indexCubic = () => {
            const h_max = 8;
            for (let i = 0; i < Math.min(peaks.length, 10); i++) {
                for (let h = 1; h <= h_max; h++) {
                    for (let k = 0; k <= h; k++) {
                        for (let l = 0; l <= k; l++) {
                            const S = h * h + k * k + l * l;
                            if (S === 0) continue;
                            testSolution({a: Math.sqrt(S / q_obs[i]), system: 'cubic', alpha: 90, beta: 90, gamma: 90});
                        }
                    }
                }
            }
        };
        const indexTetragonal = () => {
            for (let i = 0; i < tetra_hexa_i_depth; i++) {
                for (let j = i + 1; j < tetra_hexa_j_depth; j++) {
                    for (let h1 = 0; h1 <= max_hkl_low_angle_search; h1++) {
                        for (let k1 = 0; k1 <= h1; k1++) {
                            for (let l1 = 0; l1 <= max_hkl_low_angle_search; l1++) {
                                if (h1 === 0 && k1 === 0 && l1 === 0) continue;
                                const S1 = h1*h1 + k1*k1;
                                for (let h2 = 0; h2 <= max_hkl_low_angle_search; h2++) {
                                    for (let k2 = 0; k2 <= h2; k2++) {
                                        for (let l2 = 0; l2 <= max_hkl_low_angle_search; l2++) {
                                            if (h2 === 0 && k2 === 0 && l2 === 0) continue;
                                            const S2 = h2*h2 + k2*k2;
                                            const det = S1 * l2*l2 - S2 * l1*l1;
                                            if (Math.abs(det) < 1e-6) continue;
                                            const a_sq_inv = (q_obs[i] * l2*l2 - q_obs[j] * l1*l1) / det;
                                            const c_sq_inv = (q_obs[j] * S1 - q_obs[i] * S2) / det;
                                            if (a_sq_inv > 0 && c_sq_inv > 0) {
                                                testSolution({a: 1/Math.sqrt(a_sq_inv), c: 1/Math.sqrt(c_sq_inv), system: 'tetragonal', alpha: 90, beta: 90, gamma: 90});
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        const indexHexagonal = () => {
            for (let i = 0; i < tetra_hexa_i_depth; i++) {
                for (let j = i + 1; j < tetra_hexa_j_depth; j++) {
                    for (let h1 = 0; h1 <= max_hkl_low_angle_search; h1++) {
                        for (let k1 = 0; k1 <= h1; k1++) {
                            for (let l1 = 0; l1 <= max_hkl_low_angle_search; l1++) {
                                if(h1 === 0 && k1 === 0 && l1 === 0) continue;
                                const S1 = h1*h1 + h1*k1 + k1*k1;
                                for(let h2 = 0; h2 <= max_hkl_low_angle_search; h2++) {
                                    for(let k2 = 0; k2 <= h2; k2++) {
                                        for(let l2 = 0; l2 <= max_hkl_low_angle_search; l2++) {
                                            if(h2 === 0 && k2 === 0 && l2 === 0) continue;
                                            const S2 = h2*h2 + h2*k2 + k2*k2;
                                            const det = S1*l2*l2 - S2*l1*l1;
                                            if(Math.abs(det) < 1e-6) continue;
                                            const a_term = (q_obs[i]*l2*l2 - q_obs[j]*l1*l1) / det;
                                            const c_inv = (q_obs[j]*S1 - q_obs[i]*S2) / det;
                                            if(a_term > 0 && c_inv > 0) {
                                                testSolution({a: Math.sqrt(4/(3*a_term)), c: Math.sqrt(1/c_inv), system: 'hexagonal', alpha: 90, beta: 90, gamma: 120});
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        
        const solveLeastSquares = (M, q_vec) => { /* unchanged */ 
            const num_eq = M.length; if (num_eq === 0) return null;
            const num_params = M[0].length; if (num_eq < num_params) return null;
            const MT = Array(num_params).fill(0).map(() => Array(num_eq).fill(0));
            for (let i = 0; i < num_params; i++) for (let j = 0; j < num_eq; j++) MT[i][j] = M[j][i];
            const MTM = Array(num_params).fill(0).map(() => Array(num_params).fill(0));
            for (let i = 0; i < num_params; i++) for (let j = 0; j < num_params; j++) { let sum = 0; for (let k = 0; k < num_eq; k++) sum += MT[i][k] * M[k][j]; MTM[i][j] = sum; }
            let det;
            if (num_params === 3) { det = MTM[0][0]*(MTM[1][1]*MTM[2][2] - MTM[2][1]*MTM[1][2]) - MTM[0][1]*(MTM[1][0]*MTM[2][2] - MTM[1][2]*MTM[2][0]) + MTM[0][2]*(MTM[1][0]*MTM[2][1] - MTM[1][1]*MTM[2][0]); } 
            else if (num_params === 4) { const m = MTM; det = m[0][0]*(m[1][1]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])+m[1][3]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])) - m[0][1]*(m[1][0]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])) + m[0][2]*(m[1][0]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])-m[1][1]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][1]-m[2][1]*m[3][0])) - m[0][3]*(m[1][0]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])-m[1][1]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])+m[1][2]*(m[2][0]*m[3][1]-m[2][1]*m[3][0])); } 
            else { return null; }
            if (Math.abs(det) < 1e-9) return null;
            const invDet = 1.0 / det;
            const MTM_inv = Array(num_params).fill(0).map(() => Array(num_params).fill(0));
            if (num_params === 3) { MTM_inv[0][0] = (MTM[1][1]*MTM[2][2] - MTM[2][1]*MTM[1][2])*invDet; MTM_inv[0][1] = (MTM[0][2]*MTM[2][1] - MTM[0][1]*MTM[2][2])*invDet; MTM_inv[0][2] = (MTM[0][1]*MTM[1][2] - MTM[0][2]*MTM[1][1])*invDet; MTM_inv[1][0] = (MTM[1][2]*MTM[2][0] - MTM[1][0]*MTM[2][2])*invDet; MTM_inv[1][1] = (MTM[0][0]*MTM[2][2] - MTM[0][2]*MTM[2][0])*invDet; MTM_inv[1][2] = (MTM[0][2]*MTM[1][0] - MTM[0][0]*MTM[1][2])*invDet; MTM_inv[2][0] = (MTM[1][0]*MTM[2][1] - MTM[2][0]*MTM[1][1])*invDet; MTM_inv[2][1] = (MTM[0][1]*MTM[2][0] - MTM[0][0]*MTM[2][1])*invDet; MTM_inv[2][2] = (MTM[0][0]*MTM[1][1] - MTM[0][1]*MTM[1][0])*invDet; } 
            else { const m = MTM; MTM_inv[0][0] = (m[1][1]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])+m[1][3]*(m[2][1]*m[3][2]-m[2][2]*m[3][1]))*invDet; MTM_inv[0][1] = -(m[0][1]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[0][2]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])+m[0][3]*(m[2][1]*m[3][2]-m[2][2]*m[3][1]))*invDet; MTM_inv[0][2] = (m[0][1]*(m[1][2]*m[3][3]-m[1][3]*m[3][2])-m[0][2]*(m[1][1]*m[3][3]-m[1][3]*m[3][1])+m[0][3]*(m[1][1]*m[3][2]-m[1][2]*m[3][1]))*invDet; MTM_inv[0][3] = -(m[0][1]*(m[1][2]*m[2][3]-m[1][3]*m[2][2])-m[0][2]*(m[1][1]*m[2][3]-m[1][3]*m[2][1])+m[0][3]*(m[1][1]*m[2][2]-m[1][2]*m[2][1]))*invDet; MTM_inv[1][0] = -(m[1][0]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[1][2]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][2]-m[2][2]*m[3][0]))*invDet; MTM_inv[1][1] = (m[0][0]*(m[2][2]*m[3][3]-m[2][3]*m[3][2])-m[0][2]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[0][3]*(m[2][0]*m[3][2]-m[2][2]*m[3][0]))*invDet; MTM_inv[1][2] = -(m[0][0]*(m[1][2]*m[3][3]-m[1][3]*m[3][2])-m[0][2]*(m[1][0]*m[3][3]-m[1][3]*m[3][0])+m[0][3]*(m[1][0]*m[3][2]-m[1][2]*m[3][0]))*invDet; MTM_inv[1][3] = (m[0][0]*(m[1][2]*m[2][3]-m[1][3]*m[2][2])-m[0][2]*(m[1][0]*m[2][3]-m[1][3]*m[2][0])+m[0][3]*(m[1][0]*m[2][2]-m[1][2]*m[2][0]))*invDet; MTM_inv[2][0] = (m[1][0]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])-m[1][1]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[1][3]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet; MTM_inv[2][1] = -(m[0][0]*(m[2][1]*m[3][3]-m[2][3]*m[3][1])-m[0][1]*(m[2][0]*m[3][3]-m[2][3]*m[3][0])+m[0][3]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet; MTM_inv[2][2] = (m[0][0]*(m[1][1]*m[3][3]-m[1][3]*m[3][1])-m[0][1]*(m[1][0]*m[3][3]-m[1][3]*m[3][0])+m[0][3]*(m[1][0]*m[3][1]-m[1][1]*m[3][0]))*invDet; MTM_inv[2][3] = -(m[0][0]*(m[1][1]*m[2][3]-m[1][3]*m[2][1])-m[0][1]*(m[1][0]*m[2][3]-m[1][3]*m[2][0])+m[0][3]*(m[1][0]*m[2][1]-m[1][1]*m[2][0]))*invDet; MTM_inv[3][0] = -(m[1][0]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])-m[1][1]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])+m[1][2]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet; MTM_inv[3][1] = (m[0][0]*(m[2][1]*m[3][2]-m[2][2]*m[3][1])-m[0][1]*(m[2][0]*m[3][2]-m[2][2]*m[3][0])+m[0][2]*(m[2][0]*m[3][1]-m[2][1]*m[3][0]))*invDet; MTM_inv[3][2] = -(m[0][0]*(m[1][1]*m[3][2]-m[1][2]*m[3][1])-m[0][1]*(m[1][0]*m[3][2]-m[1][2]*m[3][0])+m[0][2]*(m[1][0]*m[3][1]-m[1][1]*m[3][0]))*invDet; MTM_inv[3][3] = (m[0][0]*(m[1][1]*m[2][2]-m[1][2]*m[2][1])-m[0][1]*(m[1][0]*m[2][2]-m[1][2]*m[2][0])+m[0][2]*(m[1][0]*m[2][1]-m[1][1]*m[2][0]))*invDet; }
            const MTq = Array(num_params).fill(0);
            for (let i = 0; i < num_params; i++) { let sum = 0; for (let j = 0; j < num_eq; j++) sum += MT[i][j] * q_vec[j]; MTq[i] = sum; }
            const x = Array(num_params).fill(0);
            for (let i = 0; i < num_params; i++) { let sum = 0; for (let j = 0; j < num_params; j++) sum += MTM_inv[i][j] * MTq[j]; x[i] = sum; }
            return x;
        };
        const indexOrthorhombic = () => {
            const max_peaks_basis = Math.min(15, q_obs.length);
            const min_indexed_for_fit = 6;
            const min_indexed_pre_filter = 5; // Parameter for early rejection
            const max_hkl_main = 6;
            const hkl_triplets = [];
            for (let h = 0; h <= max_hkl_main; h++) for (let k = 0; k <= max_hkl_main; k++) for (let l = 0; l <= max_hkl_main; l++) {
                if (h === 0 && k === 0 && l === 0) continue;
                hkl_triplets.push([h, k, l]);
            }
            hkl_triplets.sort((a, b) => (a[0]**2 + a[1]**2 + a[2]**2) - (b[0]**2 + b[1]**2 + b[2]**2));
            const basis_hkls = hkl_triplets.slice(0, 30);
            for (let i = 0; i < max_peaks_basis - 2; i++) {
                for (let j = i + 1; j < max_peaks_basis - 1; j++) {
                    for (let k = j + 1; k < max_peaks_basis; k++) {
                        for (let n1 = 0; n1 < basis_hkls.length - 2; n1++) {
                            for (let n2 = n1 + 1; n2 < basis_hkls.length - 1; n2++) {
                                for (let n3 = n2 + 1; n3 < basis_hkls.length; n3++) {
                                    const hkl_basis = [basis_hkls[n1], basis_hkls[n2], basis_hkls[n3]];
                                    const M = hkl_basis.map(hkl => [hkl[0]**2, hkl[1]**2, hkl[2]**2]);
                                    const q_vec = [q_obs[i], q_obs[j], q_obs[k]];
                                    const solution = solveLeastSquares(M, q_vec);
                                    if (!solution || solution.some(s => s <=0)) continue;
                                    const [a_sq_inv, b_sq_inv, c_sq_inv] = solution;
                                    if (1/Math.sqrt(a_sq_inv) < min_lattice_param || 1/Math.sqrt(b_sq_inv) < min_lattice_param || 1/Math.sqrt(c_sq_inv) < min_lattice_param) continue;
                                    if (1/(Math.sqrt(a_sq_inv)*Math.sqrt(b_sq_inv)*Math.sqrt(c_sq_inv)) > max_volume) continue;
                                    let rough_indexed_count = 0;
                                    for (let peak_idx = 0; peak_idx < Math.min(10, q_obs.length); peak_idx++) {
                                        const current_q_obs = q_obs[peak_idx];
                                        const tolerance = get_q_tolerance(original_indices[peak_idx]) * 5; // Wider tolerance
                                        for (const hkl of hkl_triplets) {
                                            const q_calc = hkl[0]**2 * a_sq_inv + hkl[1]**2 * b_sq_inv + hkl[2]**2 * c_sq_inv;
                                            if (Math.abs(q_calc - current_q_obs) < tolerance) { rough_indexed_count++; break; }
                                            if (q_calc > current_q_obs + tolerance) break;
                                        }
                                    }
                                    if (rough_indexed_count < min_indexed_pre_filter - impurity_peaks) continue;
                                    const indexed_pairs = [];
                                    for (let peak_idx = 0; peak_idx < N_FOR_M20; peak_idx++) {
                                        const current_q_obs = q_obs[peak_idx];
                                        const tolerance = get_q_tolerance(original_indices[peak_idx]);
                                        let best_match = null; let min_diff = Infinity;
                                        for (const hkl of hkl_triplets) {
                                            const q_calc = hkl[0]**2 * a_sq_inv + hkl[1]**2 * b_sq_inv + hkl[2]**2 * c_sq_inv;
                                            const diff = Math.abs(q_calc - current_q_obs);
                                            if (diff < tolerance && diff < min_diff) { min_diff = diff; best_match = hkl; }
                                            if (q_calc > current_q_obs + tolerance) break;
                                        }
                                        if (best_match) indexed_pairs.push({ q_obs: current_q_obs, hkl: best_match });
                                    }
                                    if (indexed_pairs.length >= min_indexed_for_fit) {
                                        const M_refine = indexed_pairs.map(p => [p.hkl[0]**2, p.hkl[1]**2, p.hkl[2]**2]);
                                        const q_refine = indexed_pairs.map(p => p.q_obs);
                                        const refined_solution = solveLeastSquares(M_refine, q_refine);
                                        if (refined_solution && refined_solution.every(s => s > 0)) {
                                            testSolution({ a: 1/Math.sqrt(refined_solution[0]), b: 1/Math.sqrt(refined_solution[1]), c: 1/Math.sqrt(refined_solution[2]), system: 'orthorhombic', alpha: 90, beta: 90, gamma: 90 });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        const indexMonoclinic = () => {
            const max_peaks_basis = Math.min(15, q_obs.length);
            const min_indexed_for_fit = 7;
            const min_indexed_pre_filter = 6;
            const max_hkl_main = 5;
            const hkl_triplets = [];
            for (let h = 0; h <= max_hkl_main; h++) for (let k = 0; k <= max_hkl_main; k++) for (let l = 0; l <= max_hkl_main; l++) {
                if (h === 0 && k === 0 && l === 0) continue;
                hkl_triplets.push([h, k, l]);
            }
            hkl_triplets.sort((a, b) => (a[0]**2 + a[1]**2 + a[2]**2) - (b[0]**2 + b[1]**2 + b[2]**2));
            const basis_hkls = hkl_triplets.slice(0, 35);
            for (let i = 0; i < max_peaks_basis - 3; i++) {
                for (let j = i + 1; j < max_peaks_basis - 2; j++) {
                    for (let k = j + 1; k < max_peaks_basis - 1; k++) {
                        for (let l = k + 1; l < max_peaks_basis; l++) {
                            for (let n1 = 0; n1 < basis_hkls.length - 3; n1++) {
                                for (let n2 = n1 + 1; n2 < basis_hkls.length - 2; n2++) {
                                    for (let n3 = n2 + 1; n3 < basis_hkls.length - 1; n3++) {
                                        for (let n4 = n3 + 1; n4 < basis_hkls.length; n4++) {
                                            const hkl_basis = [basis_hkls[n1], basis_hkls[n2], basis_hkls[n3], basis_hkls[n4]];
                                            const M = hkl_basis.map(hkl => [hkl[0]**2, hkl[1]**2, hkl[2]**2, hkl[0]*hkl[2]]);
                                            const q_vec = [q_obs[i], q_obs[j], q_obs[k], q_obs[l]];
                                            const solution = solveLeastSquares(M, q_vec);
                                            if (!solution) continue;
                                            const [A, B, C, D] = solution;
                                            if (A <= 0 || B <= 0 || C <= 0 || D**2 >= 4 * A * C) continue;
                                            const cosBeta = -D / (2 * Math.sqrt(A * C));
                                            let beta = Math.acos(cosBeta) * 180 / Math.PI;
                                            if (beta < 80 || beta > 140) continue;
                                            const sinBetaSq = 1 - cosBeta**2;
                                            const a = 1 / Math.sqrt(A * sinBetaSq); const b = 1 / Math.sqrt(B); const c = 1 / Math.sqrt(C * sinBetaSq);
                                            if (a*b*c*Math.sqrt(sinBetaSq) > max_volume) continue;
                                            let rough_indexed_count = 0;
                                            for (let peak_idx = 0; peak_idx < Math.min(12, q_obs.length); peak_idx++) {
                                                const current_q_obs = q_obs[peak_idx];
                                                const tolerance = get_q_tolerance(original_indices[peak_idx]) * 5;
                                                for (const hkl of hkl_triplets) {
                                                    const q_calc = (1/sinBetaSq) * (hkl[0]**2/a**2 + hkl[2]**2/c**2 - 2*hkl[0]*hkl[2]*cosBeta/(a*c)) + hkl[1]**2/b**2;
                                                    if (Math.abs(q_calc - current_q_obs) < tolerance) { rough_indexed_count++; break; }
                                                    if (q_calc > current_q_obs + tolerance) break;
                                                }
                                            }
                                            if (rough_indexed_count < min_indexed_pre_filter - impurity_peaks) continue;
                                            const indexed_pairs = [];
                                            for (let peak_idx = 0; peak_idx < N_FOR_M20; peak_idx++) {
                                                const current_q_obs = q_obs[peak_idx]; const tolerance = get_q_tolerance(original_indices[peak_idx]);
                                                let best_match = null; let min_diff = Infinity;
                                                for (const hkl of hkl_triplets) {
                                                    const q_calc = (1/sinBetaSq) * (hkl[0]**2/a**2 + hkl[2]**2/c**2 - 2*hkl[0]*hkl[2]*cosBeta/(a*c)) + hkl[1]**2/b**2;
                                                    const diff = Math.abs(q_calc - current_q_obs);
                                                    if (diff < tolerance && diff < min_diff) { min_diff = diff; best_match = hkl; }
                                                    if (q_calc > current_q_obs + tolerance) break;
                                                }
                                                if (best_match) indexed_pairs.push({ q_obs: current_q_obs, hkl: best_match });
                                            }
                                            if (indexed_pairs.length >= min_indexed_for_fit) {
                                                const M_refine = indexed_pairs.map(p => [p.hkl[0]**2, p.hkl[1]**2, p.hkl[2]**2, p.hkl[0]*p.hkl[2]]);
                                                const q_refine = indexed_pairs.map(p => p.q_obs);
                                                const refined_solution = solveLeastSquares(M_refine, q_refine);
                                                if (refined_solution) {
                                                    const [rA, rB, rC, rD] = refined_solution;
                                                    if (rA > 0 && rB > 0 && rC > 0 && rD**2 < 4 * rA * rC) {
                                                        const rCosBeta = -rD / (2 * Math.sqrt(rA * rC));
                                                        const rBeta = Math.acos(rCosBeta) * 180 / Math.PI;
                                                        const rSinBetaSq = 1 - rCosBeta**2;
                                                        testSolution({ a: 1/Math.sqrt(rA*rSinBetaSq), b: 1/Math.sqrt(rB), c: 1/Math.sqrt(rC*rSinBetaSq), beta: rBeta, system: 'monoclinic', alpha: 90, gamma: 90 });
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };

        if (systemToSearch === 'cubic') indexCubic();
        if (systemToSearch === 'tetragonal') indexTetragonal();
        if (systemToSearch === 'hexagonal') indexHexagonal();
        if (systemToSearch === 'orthorhombic') indexOrthorhombic();
        if (systemToSearch === 'monoclinic') indexMonoclinic();
        
        self.postMessage({ type: 'done' });
    };
</script>
</body>
</html>