<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystal Symmetry Explorer v2.7</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: #1f2937;
            color: #e5e7eb;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        #app-container {
            display: flex;
            width: 100%;
            height: calc(100vh - 32px);
        }
        #controls-panel {
            width: 380px;
            min-width: 320px;
            max-width: 700px;
            flex-shrink: 0;
            padding: 24px;
            background-color: #111827;
            border-right: 1px solid #374151;
            overflow-y: auto;
            color: #d1d5db;
        }
        #drag-handle {
            width: 6px;
            cursor: col-resize;
            background-color: #374151;
            flex-shrink: 0;
            transition: background-color: 0.2s;
        }
        #drag-handle:hover {
            background-color: #3b82f6;
        }
        #visualization-area {
            flex-grow: 1;
            position: relative;
            background-color: #f0f0f0;
            min-width: 0;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #controls-panel h1 { font-size: 1.8em; margin-bottom: 8px; font-weight: 700; color: #ffffff; }
        #controls-panel > p { font-size: 0.9em; margin-bottom: 24px; color: #9ca3af; }
        #controls-panel h2 { font-size: 1.25em; font-weight: 600; margin-bottom: 16px; border-bottom: 1px solid #374151; padding-bottom: 8px; color: #ffffff;}
        #controls-panel h4 { margin-top: 0.5rem; margin-bottom: 0.5rem; font-weight: 500; color: #9ca3af; }
        .control-group, .sym-element {
            margin-bottom: 1.5rem;
            padding: 1rem;
            border: 1px solid #374151;
            border-radius: 0.5rem;
            background-color: rgba(255, 255, 255, 0.05);
        }
        .sym-element {
             background-color: #1f2937;
             margin-top: 1rem;
        }
        .control-group label, .sym-element label {
            display: inline-block;
            font-weight: 500;
            color: #9ca3af;
            width: auto;
        }
        .input-row {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .input-row label {
             width: 20px;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            flex-grow: 1;
            margin: 0 1rem;
            background: transparent;
            cursor: pointer;
            accent-color: #4b5563; 
        }
        input[type="range"]::-webkit-slider-runnable-track { height: 6px; background: #4b5563; border-radius: 3px; }
        input[type="range"]::-moz-range-track { height: 6px; background: #4b5563; border-radius: 3px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; margin-top: -6px; width: 18px; height: 18px; background: #3b82f6; border-radius: 50%; }
        input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; background: #3b82f6; border-radius: 50%; border: none; }

        input[type="number"], select {
            background-color: #374151; border: 1px solid #4b5563;
            color: #e5e7eb; border-radius: 0.375rem; padding: 0.5rem;
        }
        input[type="number"] { width: 70px; }
        select { width: 100%; }
        input[type="checkbox"] {
            width: 1.15rem; height: 1.15rem;
            accent-color: #3b82f6;
        }
        
        #add-sym-btn {
            background-color: #3b82f6; color: white; border: none; padding: 10px 15px;
            border-radius: 0.375rem; cursor: pointer; width: 100%; font-size: 1em; margin-top: 10px;
        }
        #add-sym-btn:hover { background-color: #2563eb; }
        
        .sym-element h3 {
            margin: 0 0 10px 0; font-size: 1em; font-weight: 600;
            display: flex; justify-content: space-between; align-items: center;
        }
        .remove-btn {
            background: #ef4444; color: white; border: none; border-radius: 50%;
            width: 24px; height: 24px; cursor: pointer; font-weight: bold;
            line-height: 24px; text-align: center;
        }
        #generated-coordinates-list {
            font-family: monospace; font-size: 0.9em; background-color: #1f2937;
            border: 1px solid #4b5563; border-radius: 0.5rem; padding: 0.75rem;
            max-height: 200px; overflow-y: auto;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">
            <div style="font-size: 0.9em; color: #9ca3af; padding: 0 0 16px 0; margin-bottom: 24px; border-bottom: 1px solid #374151;">
                <p style="margin: 0 0 4px 0;"><strong>Orbit:</strong> Left-click + Drag</p>
                <p style="margin: 0 0 4px 0;"><strong>Pan:</strong> Right-click + Drag</p>
                <p style="margin: 0;"><strong>Zoom:</strong> Mouse Wheel</p>
            </div>

            <div class="control-group">
                <h2>Crystal System</h2>
                <select id="crystal-system-select">
                    <option value="orthorhombic">Orthorhombic (a≠b≠c, 90,90,90)</option>
                    <option value="tetragonal">Tetragonal (a=b≠c, 90,90,90)</option>
                    <option value="cubic">Cubic (a=b=c, 90,90,90)</option>
                    <option value="hexagonal">Hexagonal (a=b≠c, 90,90,120)</option>
                </select>
                <div id="cell-display-controls" style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #374151;">
                    <h4 style="margin-top: 0; margin-bottom: 0.5rem;">Cell Display Range</h4>
                    <div class="input-row"><label for="cell-range-x-num">X</label><input type="range" id="cell-range-x-range" min="1" max="4" value="1" step="1"><input type="number" id="cell-range-x-num" min="1" max="4" value="1" step="1"></div>
                    <div class="input-row"><label for="cell-range-y-num">Y</label><input type="range" id="cell-range-y-range" min="1" max="4" value="1" step="1"><input type="number" id="cell-range-y-num" min="1" max="4" value="1" step="1"></div>
                    <div class="input-row"><label for="cell-range-z-num">Z</label><input type="range" id="cell-range-z-range" min="1" max="4" value="1" step="1"><input type="number" id="cell-range-z-num" min="1" max="4" value="1" step="1"></div>
                </div>
            </div>

            <div id="parent-motif-controls" class="control-group">
                <h2>Parent Motif</h2>
                <div class="input-row"><label for="parent-x-num">X</label><input type="range" id="parent-x-range" min="0" max="1" value="0.12" step="0.01"><input type="number" id="parent-x-num" min="0" max="1" value="0.12" step="0.01"></div>
                <div class="input-row"><label for="parent-y-num">Y</label><input type="range" id="parent-y-range" min="0" max="1" value="0.29" step="0.01"><input type="number" id="parent-y-num" min="0" max="1" value="0.29" step="0.01"></div>
                <div class="input-row"><label for="parent-z-num">Z</label><input type="range" id="parent-z-range" min="0" max="1" value="0.45" step="0.01"><input type="number" id="parent-z-num" min="0" max="1" value="0.45" step="0.01"></div>
            </div>

            <div class="control-group">
                <h2>Add Symmetry Element</h2>
                <select id="sym-type-select">
                    <optgroup label="Mirrors"><option value="m_x">Mirror m_x</option><option value="m_y">Mirror m_y</option><option value="m_z">Mirror m_z</option></optgroup>
                    <optgroup label="Glides"><option value="g_x">Glide g_x</option><option value="g_y">Glide g_y</option><option value="g_z">Glide g_z</option></optgroup>
                    <optgroup label="Diagonal Glides"><option value="gn_x">Diagonal Glide gn_x</option><option value="gn_y">Diagonal Glide gn_y</option><option value="gn_z">Diagonal Glide gn_z</option></optgroup>
                    <optgroup label="Rotations">
                        <option value="2_x">2-Fold Axis (|| x)</option><option value="2_y">2-Fold Axis (|| y)</option><option value="2_z">2-Fold Axis (|| z)</option>
                        <option value="3_111">3-Fold Axis (&lt;111&gt;)</option>
                        <option value="3_z">3-Fold Axis (|| z)</option>
                        <option value="4_x">4-Fold Axis (|| x)</option><option value="4_y">4-Fold Axis (|| y)</option><option value="4_z">4-Fold Axis (|| z)</option>
                        <option value="6_z">6-Fold Axis (|| z)</option>
                    </optgroup>
                    <optgroup label="Screw Axes">
                        <option value="s2_1_x">Screw 2₁ (|| x)</option><option value="s2_1_y">Screw 2₁ (|| y)</option><option value="s2_1_z">Screw 2₁ (|| z)</option>
                        <option value="s3_1_z">Screw 3₁ (|| z)</option><option value="s3_2_z">Screw 3₂ (|| z)</option>
                        <option value="s4_1_z">Screw 4₁ (|| z)</option><option value="s4_2_z">Screw 4₂ (|| z)</option><option value="s4_3_z">Screw 4₃ (|| z)</option>
                        <option value="s6_1_z">Screw 6₁ (|| z)</option><option value="s6_2_z">Screw 6₂ (|| z)</option><option value="s6_3_z">Screw 6₃ (|| z)</option><option value="s6_4_z">Screw 6₄ (|| z)</option><option value="s6_5_z">Screw 6₅ (|| z)</option>
                    </optgroup>
                    <optgroup label="Inversion"><option value="inversion">Inversion Center</option></optgroup>
                </select>
                <button id="add-sym-btn">Add Element</button>
            </div>

            <div id="symmetry-list"></div>
            <div id="generated-coords-container" class="mt-6"><h2>Coordinates</h2><div id="generated-coordinates-list"></div></div>
        </div>

        <div id="drag-handle"></div>
        <div id="visualization-area"></div>
    </div>

    <footer style="position: fixed; bottom: 0; left: 0; width: 100%; background-color: #111827; padding: 4px 8px; display: flex; justify-content: space-between; align-items: center; font-size: 0.75rem; color: #9ca3af; border-top: 1px solid #374151; z-index: 10;">
        <div style="padding: 0 1rem;">Crystal Symmetry v2.7</div>
        <div style="padding: 0 1rem;">NitaD, Univ Paris-Saclay, August 27, 2025</div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const identityMatrix = new THREE.Matrix4().identity();
        const hexagonalMatrix = new THREE.Matrix4().set(
            1, -0.5, 0, 0,
            0, Math.sqrt(3)/2, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        );

        const crystalSystems = {
            "orthorhombic": {
                validElements: ['m_x', 'm_y', 'm_z', 'g_x', 'g_y', 'g_z', 'gn_x', 'gn_y', 'gn_z', '2_x', '2_y', '2_z', 's2_1_x', 's2_1_y', 's2_1_z', 'inversion'],
                cellGenerator: generateOrthorhombicCell,
                transformationMatrix: identityMatrix
            },
            "tetragonal": {
                validElements: ['m_x', 'm_y', 'm_z', 'g_x', 'g_y', 'g_z', 'gn_z', '2_x', '2_y', '2_z', '4_z', 's2_1_x', 's2_1_y', 's2_1_z', 's4_1_z', 's4_2_z', 's4_3_z', 'inversion'],
                cellGenerator: generateOrthorhombicCell,
                transformationMatrix: identityMatrix
            },
            "cubic": {
                validElements: ['m_x', 'm_y', 'm_z', 'g_x', 'g_y', 'g_z', 'gn_x', 'gn_y', 'gn_z', '2_x', '2_y', '2_z', '3_111', '4_x', '4_y', '4_z', 's2_1_x', 's2_1_y', 's2_1_z', 'inversion'],
                cellGenerator: generateOrthorhombicCell,
                transformationMatrix: identityMatrix
            },
            "hexagonal": {
                validElements: ['m_z', 'g_z', '2_z', '3_z', '6_z', 's2_1_z', 's3_1_z', 's3_2_z', 's6_1_z', 's6_2_z', 's6_3_z', 's6_4_z', 's6_5_z', 'inversion'],
                cellGenerator: generateHexagonalCell,
                transformationMatrix: hexagonalMatrix
            }
        };

        let scene, camera, renderer, controls;
        let parentMotif, unitCellVisuals;
        const symmetryElements = [];
        const generatedMotifs = new THREE.Group();
        const symmetryElementVisuals = new THREE.Group();
        let currentSystem = "orthorhombic";

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            scene.add(generatedMotifs);
            scene.add(symmetryElementVisuals);

            const viewport = document.getElementById('visualization-area');
            const aspect = viewport.clientWidth / viewport.clientHeight;
            
            const frustumSize = 2.0;
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
            camera.up.set(0, 0, 1);
            
            camera.position.set(2, -2, 2);
            camera.lookAt(0.5, 0.5, 0.5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
            viewport.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, -7, 10);
            scene.add(directionalLight);
            
            const OrbitControls = function(camera, domElement) {
                this.object = camera;
                this.domElement = domElement;
                this.target = new THREE.Vector3(0.5, 0.5, 0.5);
                const frustumSize = 2.0;

                let isMouseDown = false, lastMouseX = 0, lastMouseY = 0, mouseButton = -1;

                const onMouseDown = e => {
                    isMouseDown = true;
                    mouseButton = e.button;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                };

                const onMouseUp = () => {
                    isMouseDown = false;
                    mouseButton = -1;
                };

                const onMouseMove = e => {
                    if (!isMouseDown) return;
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;

                    if (mouseButton === 0) { // Left-click: Orbit
                        const azimuth = -deltaX * 0.005;
                        const elevation = -deltaY * 0.005;
                        this.object.position.sub(this.target);
                        const R_azimuth = new THREE.Matrix4().makeRotationZ(azimuth);
                        const axis_elevation = new THREE.Vector3().crossVectors(this.object.position, this.object.up).normalize();
                        const R_elevation = new THREE.Matrix4().makeRotationAxis(axis_elevation, elevation);
                        this.object.position.applyMatrix4(R_elevation).applyMatrix4(R_azimuth);
                        this.object.position.add(this.target);
                        this.object.lookAt(this.target);
                    } else if (mouseButton === 2) { // Right-click: Pan
                        const panSpeed = frustumSize / (this.domElement.clientHeight * this.object.zoom);
                        const panVector = new THREE.Vector3();
                        const right = new THREE.Vector3().setFromMatrixColumn(this.object.matrix, 0);
                        const up = new THREE.Vector3().setFromMatrixColumn(this.object.matrix, 1);
                        
                        panVector.add(right.multiplyScalar(-deltaX * panSpeed));
                        panVector.add(up.multiplyScalar(deltaY * panSpeed));
                        
                        this.object.position.add(panVector);
                        this.target.add(panVector);
                    }
                };
                
                const onWheel = e => {
                    this.object.zoom *= (e.deltaY > 0 ? 0.9 : 1.1);
                    this.object.updateProjectionMatrix();
                };

                const onContextMenu = e => e.preventDefault();

                domElement.addEventListener('mousedown', onMouseDown);
                domElement.addEventListener('mouseup', onMouseUp);
                domElement.addEventListener('mousemove', onMouseMove);
                domElement.addEventListener('wheel', onWheel, { passive: true });
                domElement.addEventListener('contextmenu', onContextMenu);

                this.update = () => {};
            };
            controls = new OrbitControls(camera, renderer.domElement);
            
            unitCellVisuals = new THREE.Group();
            scene.add(unitCellVisuals);
            
            parentMotif = createAsymmetricObject();
            setupEventListeners();
            handleSystemChange();
            animate();
        }
        
        function drawAxes(system) {
            const group = new THREE.Group();
            const length = 1.1; 
            const origin = new THREE.Vector3(0, 0, 0);

            const xAxisMat = new THREE.LineBasicMaterial({ color: 0xff0000 });
            const xPoints = [origin, new THREE.Vector3(length, 0, 0)];
            const xGeom = new THREE.BufferGeometry().setFromPoints(xPoints);
            group.add(new THREE.Line(xGeom, xAxisMat));

            const yAxisMat = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            let yEndPoint;
            if (system === 'hexagonal') {
                yEndPoint = new THREE.Vector3(length * Math.cos(2 * Math.PI / 3), length * Math.sin(2 * Math.PI / 3), 0); // 120 degrees
            } else {
                yEndPoint = new THREE.Vector3(0, length, 0); // 90 degrees
            }
            const yPoints = [origin, yEndPoint];
            const yGeom = new THREE.BufferGeometry().setFromPoints(yPoints);
            group.add(new THREE.Line(yGeom, yAxisMat));

            const zAxisMat = new THREE.LineBasicMaterial({ color: 0x0000ff });
            const zPoints = [origin, new THREE.Vector3(0, 0, length)];
            const zGeom = new THREE.BufferGeometry().setFromPoints(zPoints);
            group.add(new THREE.Line(zGeom, zAxisMat));
            
            group.position.set(-0.05, -0.05, -0.05);
            return group;
        }
        
        function handleSystemChange() {
            currentSystem = document.getElementById('crystal-system-select').value;
            updateSymmetryOptions(currentSystem);
            
            if(currentSystem === 'hexagonal'){
                const n = parseInt(document.getElementById('cell-range-x-num').value) || 1;
                controls.target.set(0.25 * n, Math.sqrt(3)/4 * n, 0.5);
            } else {
                controls.target.set(0.5, 0.5, 0.5);
            }
            camera.lookAt(controls.target);

            resetSymmetry();
        }

        function updateSymmetryOptions(system) {
            const validElements = crystalSystems[system].validElements;
            const select = document.getElementById('sym-type-select');
            select.querySelectorAll('option').forEach(option => {
                option.style.display = validElements.includes(option.value) ? '' : 'none';
            });
            select.querySelectorAll('optgroup').forEach(group => {
                const hasVisibleOptions = Array.from(group.querySelectorAll('option')).some(o => o.style.display !== 'none');
                group.style.display = hasVisibleOptions ? '' : 'none';
            });
            if(select.options[select.selectedIndex].style.display === 'none') {
                for(let i=0; i < select.options.length; i++) {
                    if(select.options[i].style.display !== 'none') {
                        select.selectedIndex = i;
                        break;
                    }
                }
            }
        }
        
        function resetSymmetry() {
            symmetryElements.length = 0;
            document.getElementById('symmetry-list').innerHTML = '';
            updateScene();
        }

        function generateOrthorhombicCell() {
            const points = [
                new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0), new THREE.Vector3(1, 1, 0), new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, 0, 1), new THREE.Vector3(1, 0, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 1, 1)
            ];
            const lineIndices = [0,1, 1,2, 2,3, 3,0, 4,5, 5,6, 6,7, 7,4, 0,4, 1,5, 2,6, 3,7];
            const positions = points.flatMap(p => p.toArray());
            const lineGeometry = new THREE.BufferGeometry();
            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            lineGeometry.setIndex(lineIndices);
            const material = new THREE.LineBasicMaterial({ color: 0x9ca3af });
            return new THREE.LineSegments(lineGeometry, material);
        }
        
        function generateHexagonalCell() {
            const a = 1.0, c = 1.0;
            const s60 = Math.sqrt(3)/2;
            const c60 = 0.5;
            
            const points = [
                new THREE.Vector3(0, 0, 0), new THREE.Vector3(a, 0, 0),
                new THREE.Vector3(-a * c60, a * s60, 0), new THREE.Vector3(a - a * c60, a * s60, 0),
                new THREE.Vector3(0, 0, c), new THREE.Vector3(a, 0, c),
                new THREE.Vector3(-a * c60, a * s60, c), new THREE.Vector3(a - a * c60, a * s60, c)
            ];
            const lineIndices = [0, 1, 0, 2, 1, 3, 2, 3, 4, 5, 4, 6, 5, 7, 6, 7, 0, 4, 1, 5, 2, 6, 3, 7];
            const positions = points.flatMap(p => p.toArray());
            const lineGeometry = new THREE.BufferGeometry();
            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            lineGeometry.setIndex(lineIndices);
            const material = new THREE.LineBasicMaterial({ color: 0x9ca3af });
            return new THREE.LineSegments(lineGeometry, material);
        }
        
		function createAsymmetricObject() {
			const group = new THREE.Group();
			const material = new THREE.MeshLambertMaterial({ side: THREE.DoubleSide });
			
            const radius = 0.02, height = 0.1;

			const cylinder1Geom = new THREE.CylinderGeometry(radius, radius, height, 16);
			const cylinder1 = new THREE.Mesh(cylinder1Geom, material);
            cylinder1.rotation.x = Math.PI / 2;
			cylinder1.position.z = height / 2; 

			const cylinder2Geom = new THREE.CylinderGeometry(radius, radius, height * 0.75, 16);
			const cylinder2 = new THREE.Mesh(cylinder2Geom, material);
			cylinder2.rotation.z = Math.PI / 2; 
			cylinder2.position.x = height / 2;
			cylinder2.position.z = radius;

            const sphereGeom = new THREE.SphereGeometry(radius * 1.2, 16, 16);
            const sphere = new THREE.Mesh(sphereGeom, material);
            sphere.position.set(height * 0.1, height * 0.3, height * 0.8);

			group.add(cylinder1);
			group.add(cylinder2);
            group.add(sphere);
			return group;
		}

        function expandSpecialPosition(motif) {
            const expandedList = [];
            const p = motif.position;
            const isXint = (Math.abs(p.x % 1) < 1e-4 || Math.abs(p.x % 1 - 1) < 1e-4);
            const isYint = (Math.abs(p.y % 1) < 1e-4 || Math.abs(p.y % 1 - 1) < 1e-4);
            const isZint = (Math.abs(p.z % 1) < 1e-4 || Math.abs(p.z % 1 - 1) < 1e-4);
            const numInts = Number(isXint) + Number(isYint) + Number(isZint);

            if (numInts > 0) {
                const xCoords = isXint ? [0, 1] : [p.x];
                const yCoords = isYint ? [0, 1] : [p.y];
                const zCoords = isZint ? [0, 1] : [p.z];

                for (const x of xCoords) {
                    for (const y of yCoords) {
                        for (const z of zCoords) {
                            const newMotif = motif.clone();
                            newMotif.position.set(x, y, z);
                            expandedList.push(newMotif);
                        }
                    }
                }
            } else {
                expandedList.push(motif.clone());
            }
            return expandedList;
        }
		
		function updateScene() {
            if (!parentMotif) return;

            generatedMotifs.clear();
            unitCellVisuals.clear();
            symmetryElementVisuals.clear();
            
            const rangeX = parseInt(document.getElementById('cell-range-x-num').value);
            const rangeY = parseInt(document.getElementById('cell-range-y-num').value);
            const rangeZ = parseInt(document.getElementById('cell-range-z-num').value);
            const transformation = crystalSystems[currentSystem].transformationMatrix;

            const cellGenerator = crystalSystems[currentSystem].cellGenerator;
            const singleCellLines = cellGenerator();
            for (let dx = 0; dx < rangeX; dx++) {
                for (let dy = 0; dy < rangeY; dy++) {
                    for (let dz = 0; dz < rangeZ; dz++) {
                        const cellCopy = singleCellLines.clone();
                        const translationVector = new THREE.Vector3(dx, dy, dz).applyMatrix4(transformation);
                        cellCopy.position.add(translationVector);
                        unitCellVisuals.add(cellCopy);
                    }
                }
            }
            const axes = drawAxes(currentSystem);
            unitCellVisuals.add(axes);
            
            symmetryElements.forEach(element => {
                updateElementVisual(element);
                const visualTemplate = element.visual;
                const templatePosition = visualTemplate.position;

                for (let dx = 0; dx < rangeX; dx++) {
                    for (let dy = 0; dy < rangeY; dy++) {
                        for (let dz = 0; dz < rangeZ; dz++) {
                            const visualCopy = visualTemplate.clone();
                            const translationVector = new THREE.Vector3(dx, dy, dz).applyMatrix4(transformation);
                            
                            visualCopy.position.copy(templatePosition).add(translationVector);
                            
                            symmetryElementVisuals.add(visualCopy);
                        }
                    }
                }
            });

            parentMotif.position.set(parseFloat(document.getElementById('parent-x-num').value), parseFloat(document.getElementById('parent-y-num').value), parseFloat(document.getElementById('parent-z-num').value));
            parentMotif.traverse(child => { if (child.isMesh) { child.material.color.set(0x3b82f6); }});
            parentMotif.userData.chirality = 'right';

            const canonicalParent = parentMotif.clone();
            canonicalParent.position.x -= Math.floor(canonicalParent.position.x);
            canonicalParent.position.y -= Math.floor(canonicalParent.position.y);
            canonicalParent.position.z -= Math.floor(canonicalParent.position.z);
            const canonicalMotifList = [canonicalParent];

            let added = true;
            while (added) {
                added = false;
                const currentCount = canonicalMotifList.length;
                for (let i = 0; i < currentCount; i++) {
                    const source = canonicalMotifList[i];
                    symmetryElements.forEach(element => {
                        const copy = source.clone();
                        copy.userData.chirality = source.userData.chirality;
                        const opType = getOpType(element.type);
                        switch (opType) {
                            case 'mirror': applyMirror(copy, element.position, element.normal); copy.userData.chirality = (source.userData.chirality === 'right') ? 'left' : 'right'; break;
                            case 'glide': applyGlide(copy, element.position, element.normal, element.glideVector); copy.userData.chirality = (source.userData.chirality === 'right') ? 'left' : 'right'; break;
                            case 'rotation': applyRotation(copy, element.position, element.axis, element.angle); break;
                            case 'screw': applyScrew(copy, element.position, element.axis, element.angle, element.translationFactor); break;
                            case 'inversion': applyInversion(copy, element.position); copy.userData.chirality = (source.userData.chirality === 'right') ? 'left' : 'right'; break;
                        }

                        copy.position.x -= Math.floor(copy.position.x);
                        copy.position.y -= Math.floor(copy.position.y);
                        copy.position.z -= Math.floor(copy.position.z);
                        
                        const newColor = (copy.userData.chirality === 'right') ? 0x3b82f6 : 0xef4444;
                        copy.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = child.material.clone();
                                child.material.color.set(newColor);
                            }
                        });

                        const isDuplicate = canonicalMotifList.some(m => m.position.distanceTo(copy.position) < 1e-4 && m.quaternion.angleTo(copy.quaternion) < 1e-3 && m.userData.chirality === copy.userData.chirality);
                        
                        if (!isDuplicate) { canonicalMotifList.push(copy); added = true; }
                    });
                }
            }
            
            const coordsContainer = document.getElementById('generated-coords-container');
            const coordsList = document.getElementById('generated-coordinates-list');
            let html = '';
            canonicalMotifList.forEach(m => {
                const pos = m.position.clone();
                const color = m.userData.chirality === 'right' ? '#3b82f6' : '#ef4444';
                html += `<div style="color:${color};">(${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})</div>`;
            });
            coordsList.innerHTML = html;
            coordsContainer.style.display = 'block';

            let visualMotifList = [];
            canonicalMotifList.forEach(motif => {
                const cartesianMotif = motif.clone();
                cartesianMotif.position.applyMatrix4(transformation);
                visualMotifList.push(...expandSpecialPosition(cartesianMotif));
            });
            
            const occupiedPositions = new Set();
            visualMotifList.forEach(originalMotif => {
                for (let dx = 0; dx < rangeX; dx++) {
                    for (let dy = 0; dy < rangeY; dy++) {
                        for (let dz = 0; dz < rangeZ; dz++) {
                            const periodicCopy = originalMotif.clone();
                            const translationVector = new THREE.Vector3(dx, dy, dz).applyMatrix4(transformation);
                            periodicCopy.position.add(translationVector);
                            const posKey = periodicCopy.position.toArray().map(p => p.toFixed(4)).join(',');
                            if (!occupiedPositions.has(posKey)) {
                                generatedMotifs.add(periodicCopy);
                                occupiedPositions.add(posKey);
                            }
                        }
                    }
                }
            });
        }
        function getOpType(type) {
            if (type.startsWith('m_')) return 'mirror';
            if (type.startsWith('g_') || type.startsWith('gn_')) return 'glide';
            if (/^[2346]_/.test(type)) return 'rotation';
            if (type.startsWith('s')) return 'screw';
            return type;
        }
        function applyMirror(object, planePosition, planeNormal) {
            const n = planeNormal.clone().normalize();
            const d = -n.dot(planePosition);
            const M = new THREE.Matrix4().set(1 - 2 * n.x * n.x, -2 * n.x * n.y, -2 * n.x * n.z, -2 * d * n.x, -2 * n.y * n.x, 1 - 2 * n.y * n.y, -2 * n.y * n.z, -2 * d * n.y, -2 * n.z * n.x, -2 * n.z * n.y, 1 - 2 * n.z * n.z, -2 * d * n.z, 0, 0, 0, 1);
            object.applyMatrix4(M);
        }
        function applyGlide(object, planePosition, planeNormal, glideVector) {
            applyMirror(object, planePosition, planeNormal);
            const glideTranslation = new THREE.Vector3(glideVector.x * 0.5, glideVector.y * 0.5, glideVector.z * 0.5);
            object.position.add(glideTranslation);
        }
        function applyRotation(object, axisPosition, axisDirection, angle) {
            const axis = axisDirection.clone().normalize();
            const quaternion = new THREE.Quaternion().setFromAxisAngle(axis, angle);
            object.position.sub(axisPosition).applyQuaternion(quaternion).add(axisPosition);
            object.quaternion.premultiply(quaternion);
        }
        function applyScrew(object, axisPosition, axisDirection, angle, translationFactor) {
            applyRotation(object, axisPosition, axisDirection, angle);
            const translation = axisDirection.clone().multiplyScalar(translationFactor);
            object.position.add(translation);
        }
        function applyInversion(object, center) {
            const T_to_origin = new THREE.Matrix4().makeTranslation(-center.x, -center.y, -center.z);
            const S_invert = new THREE.Matrix4().makeScale(-1, -1, -1);
            const T_back = new THREE.Matrix4().makeTranslation(center.x, center.y, center.z);
            const M_inversion = new THREE.Matrix4().multiplyMatrices(T_back, new THREE.Matrix4().multiplyMatrices(S_invert, T_to_origin));
            object.applyMatrix4(M_inversion);
        }
        function setupEventListeners() {
            document.getElementById('crystal-system-select').addEventListener('change', handleSystemChange);
            document.getElementById('add-sym-btn').addEventListener('click', addSymmetryElement);
            window.addEventListener('resize', onWindowResize);
            
            const syncInputs = (event) => {
                if (event.target.type === 'range' || event.target.type === 'number') {
                    const newValue = event.target.value;
                    const parentRow = event.target.closest('.input-row');
                    if (parentRow) {
                        const rangeInput = parentRow.querySelector('input[type="range"]');
                        const numberInput = parentRow.querySelector('input[type="number"]');
                        if (rangeInput) rangeInput.value = newValue;
                        if (numberInput) numberInput.value = newValue;
                        updateScene();
                    }
                }
            };
            const parentControls = document.getElementById('parent-motif-controls');
            parentControls.addEventListener('input', syncInputs);
            const cellControls = document.getElementById('cell-display-controls');
            cellControls.addEventListener('input', syncInputs);
            document.getElementById('symmetry-list').addEventListener('input', handleSymElementChange);
        }
        function addSymmetryElement() {
            const type = document.getElementById('sym-type-select').value;
            const id = Date.now();
            const elementData = { id, type, position: new THREE.Vector3(0, 0, 0), visual: null };
            const opType = getOpType(type);
            const axis = type.split('_').pop();
            if (opType === 'mirror' || opType === 'glide') {
                const color = opType === 'mirror' ? 0xff0000 : 0x6ee7b7;
                elementData.visual = new THREE.Mesh(new THREE.PlaneGeometry(1.0, 1.0), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.4, side: THREE.DoubleSide }));
                elementData.normal = new THREE.Vector3(Number(axis === 'x'), Number(axis === 'y'), Number(axis === 'z'));
                if (type.startsWith('g_')) {
                    elementData.glideDirection = { g_x: 'y', g_y: 'x', g_z: 'x' }[type];
                    elementData.glideVector = new THREE.Vector3(Number(elementData.glideDirection === 'x'), Number(elementData.glideDirection === 'y'), Number(elementData.glideDirection === 'z'));
                } else if(type.startsWith('gn_')) {
                    const vectors = { gn_x: [0, 1, 1], gn_y: [1, 0, 1], gn_z: [1, 1, 0] };
                    elementData.glideVector = new THREE.Vector3(...vectors[type]);
                }
            } else if (opType === 'rotation' || opType === 'screw') {
                elementData.axis = type === '3_111' ? new THREE.Vector3(1,1,1).normalize() : new THREE.Vector3(Number(axis === 'x'), Number(axis === 'y'), Number(axis === 'z'));
                const lineColor = opType === 'rotation' ? 0xff00ff : 0x22c55e;
                const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, -0.5), new THREE.Vector3(0, 0, 1.5)]), new THREE.LineBasicMaterial({ color: lineColor }));
                elementData.visual = line;
                if (opType === 'rotation') {
                    const fold = parseInt(type.split('_')[0]);
                    elementData.angle = 2 * Math.PI / fold;
                } else {
                    const parts = type.match(/^s(\d+)_(\d+)/);
                    const fold = parseInt(parts[1]), m = parseInt(parts[2]);
                    elementData.angle = 2 * Math.PI / fold;
                    elementData.translationFactor = m / fold;
                }
            } else if (opType === 'inversion') {
                elementData.visual = new THREE.Mesh(new THREE.SphereGeometry(0.05, 16, 8), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
            }
            
            symmetryElements.push(elementData);
            createSymmetryElementUI(elementData);
            updateElementVisual(elementData);
            updateScene();
        }
        function createSymmetryElementUI(elementData) {
            const div = document.createElement('div');
            div.className = 'sym-element';
            div.id = `sym-element-${elementData.id}`;
            div.dataset.id = elementData.id;
            let contentHtml = '<h4>Position</h4>', title = '';
            const type = elementData.type;
            const opType = getOpType(type);
            const createRow = (axis, disabled=false) => `<div class="input-row"><label for="sym-${elementData.id}-${axis}-num">${axis.toUpperCase()}</label><input type="range" id="sym-${elementData.id}-${axis}-range" class="pos" data-axis="${axis}" min="0" max="1" step="0.01" value="0" ${disabled?'disabled':''}><input type="number" id="sym-${elementData.id}-${axis}-num" class="pos" data-axis="${axis}" min="0" max="1" step="0.01" value="0" ${disabled?'disabled':''}></div>`;
            if (type === '3_111') {
                title = '3-Fold Axis &lt;111&gt;';
                contentHtml = `<h4>Position (fixed at origin)</h4>`;
            } else if (opType === 'mirror' || opType === 'glide') {
                const axis = type.split('_')[1];
                contentHtml += createRow(axis);
                title = `${opType.charAt(0).toUpperCase() + opType.slice(1)} ${type.substring(1)}`;
                if (type.startsWith('g_')) {
                    const options = { g_x: ['y', 'z'], g_y: ['x', 'z'], g_z: ['x', 'y'] }[type];
                    contentHtml += `<h4>Glide Direction</h4><select class="glide-dir" data-id="${elementData.id}"><option value="${options[0]}" selected>${options[0].toUpperCase()}</option><option value="${options[1]}">${options[1].toUpperCase()}</option></select>`;
                }
            } else if (opType === 'rotation' || opType === 'screw') {
                const mainAxis = type.split('_').pop();
                const axes = { x: ['y', 'z'], y: ['x', 'z'], z: ['x', 'y'] }[mainAxis];
                axes.forEach(axis => { contentHtml += createRow(axis); });
                if (opType === 'rotation') {
                    title = `${type.split('_')[0]}-Fold Axis || ${mainAxis}`;
                } else {
                    const parts = type.match(/^s(\d+)_(\d+)/);
                    title = `Screw ${parts[1]}<sub style="font-size:0.8em">${parts[2]}</sub> || ${mainAxis}`;
                }
            } else if (opType === 'inversion') {
                ['x', 'y', 'z'].forEach(axis => { contentHtml += createRow(axis); });
                title = 'Inversion Center';
            }
            div.innerHTML = `<h3>${title} <button class="remove-btn" data-id="${elementData.id}">X</button></h3>${contentHtml}`;
            document.getElementById('symmetry-list').appendChild(div);
            div.querySelector('.remove-btn').addEventListener('click', removeSymmetryElement);
        }
        function handleSymElementChange(event) {
            const symElementDiv = event.target.closest('.sym-element');
            if (!symElementDiv) return;
            const id = parseInt(symElementDiv.dataset.id);
            const element = symmetryElements.find(e => e.id === id);
            if (!element) return;
            if (event.target.classList.contains('glide-dir')) {
                element.glideDirection = event.target.value;
                element.glideVector.set(Number(element.glideDirection === 'x'), Number(element.glideDirection === 'y'), Number(element.glideDirection === 'z'));
            } else if (event.target.type === 'range' || event.target.type === 'number') {
                const axis = event.target.dataset.axis;
                if(!axis) return;
                const value = parseFloat(event.target.value);
                const row = event.target.closest('.input-row');
                if (row) {
                    const rangeInput = row.querySelector('input[type="range"]');
                    const numberInput = row.querySelector('input[type="number"]');
                    if (rangeInput) rangeInput.value = value;
                    if (numberInput) numberInput.value = value;
                }
                const type = element.type;
                if (getOpType(type) === 'mirror' || getOpType(type) === 'glide') {
                    const mainAxis = type.split('_')[1];
                    element.position.set(0, 0, 0);
                    element.position[mainAxis] = value;
                } else {
                    element.position[axis] = value;
                }
            }
            updateElementVisual(element);
            updateScene();
        }
        function updateElementVisual(element) {
            const opType = getOpType(element.type);
            const pos = element.position.clone();
            const vis = element.visual;
            const transformation = crystalSystems[currentSystem].transformationMatrix;
            pos.applyMatrix4(transformation);

            if (opType === 'mirror' || opType === 'glide') {
                const center = new THREE.Vector3(0.5, 0.5, 0.5).applyMatrix4(transformation);
                vis.position.copy(center);
                vis.position[element.normal.x ? 'x' : element.normal.y ? 'y' : 'z'] = pos[element.normal.x ? 'x' : element.normal.y ? 'y' : 'z'];
                
                let normal = element.normal.clone();
                if(currentSystem === 'hexagonal') {
                   const invTrans = new THREE.Matrix4().copy(transformation).invert();
                   normal.transformDirection(invTrans);
                }
                vis.lookAt(vis.position.clone().add(normal));

            } else if (opType === 'rotation' || opType === 'screw') {
                vis.position.copy(pos);
                vis.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), element.axis);
            } else { 
                 vis.position.copy(pos);
            }
        }
        function removeSymmetryElement(event) {
            const id = parseInt(event.target.dataset.id);
            const index = symmetryElements.findIndex(e => e.id === id);
            if (index > -1) {
                symmetryElements.splice(index, 1);
                document.getElementById(`sym-element-${id}`).remove();
                updateScene();
            }
        }
        function onWindowResize() {
            const viewport = document.getElementById('visualization-area');
            const aspect = viewport.clientWidth / viewport.clientHeight;
            const frustumSize = 2.0;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
        }
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        const resizer = document.getElementById('drag-handle');
        const leftPanel = document.getElementById('controls-panel');
        let isResizing = false;
        resizer.addEventListener('mousedown', e => {
            e.preventDefault(); isResizing = true; document.body.style.cursor = 'col-resize'; document.body.style.userSelect = 'none';
            window.addEventListener('mousemove', handleMouseMove); window.addEventListener('mouseup', stopResize);
        });
        function handleMouseMove(e) {
            if (!isResizing) return;
            const newLeftWidth = e.clientX - leftPanel.parentElement.getBoundingClientRect().left;
            if (newLeftWidth > 320 && newLeftWidth < document.body.clientWidth - 300) {
                leftPanel.style.width = `${newLeftWidth}px`;
                onWindowResize();
            }
        }
        function stopResize() {
            isResizing = false; document.body.style.cursor = 'default'; document.body.style.userSelect = 'auto';
            window.removeEventListener('mousemove', handleMouseMove); window.removeEventListener('mouseup', stopResize);
        }

        init();
    </script>
</body>
</html>