<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patterson Function Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f1f5f9; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #app-container { display: flex; width: 100%; flex-grow: 1; min-height: 0; }
        #controls-panel { width: 400px; min-width: 350px; max-width: 550px; flex-shrink: 0; padding: 24px; background-color: #111827; border-right: 1px solid #374151; overflow-y: auto; color: #d1d5db; }
        #drag-handle { width: 6px; cursor: col-resize; background-color: #374151; flex-shrink: 0; transition: background-color 0.2s; }
        #drag-handle:hover { background-color: #3b82f6; }
        #results-area { flex-grow: 1; background-color: #f1f5f9; min-width: 0; display: flex; flex-direction: column; padding: 1.5rem; color: #1f2937; overflow-y: auto; }
        
        .control-group { margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid #374151;}
        .control-group:last-child { border-bottom: none; padding-bottom: 0; }
        .control-label { display: block; margin-bottom: 8px; font-weight: 500; color: #9ca3af; }
        
        input[type="radio"]:checked + label { background-color: #3b82f6; color: white; border-color: #2563eb; }
        .atom-type-label { text-align: center; padding: 0.5rem; border: 1px solid #4b5563; background-color: #374151; color: #e5e7eb; border-radius: 0.375rem; cursor: pointer; transition: all 0.2s ease; }
        .atom-type-label:hover { background-color: #4b5563; }
        
        .btn-danger { display: block; padding: 0.5rem 1rem; border-radius: 0.375rem; font-weight: 600; transition: background-color 0.2s; cursor: pointer; text-align: center; background-color: #dc2626; color: white; width: 100%;}
        .btn-danger:hover { background-color: #b91c1c; }

        footer { width: 100%; background-color: #ffffff; padding: 8px 24px; font-size: 0.8em; color: #4b5563; border-top: 1px solid #e5e7eb; flex-shrink: 0; }
        
        .canvas-wrapper { background-color: #e5e7eb; box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.05); width: 100%; overflow: hidden; aspect-ratio: 1 / 1; }
        .canvas-wrapper.rounded { border-radius: 0.75rem; }
        canvas { cursor: crosshair; display: block; width: 100%; height: 100%; }
        
        .coord-input { width: 60px; text-align: center; background-color: #374151; border: 1px solid #4b5563; color: #e5e7eb; border-radius: 0.375rem; padding: 2px 4px; }
        .coord-input:focus { outline: none; border-color: #3b82f6; }
        
        .plot-grid { display: grid; grid-template-areas: 'y-axis plot' '. x-axis'; grid-template-rows: 1fr auto; grid-template-columns: auto 1fr; gap: 0.25rem; }
        .y-axis-labels { grid-area: y-axis; }
        .x-axis-labels { grid-area: x-axis; }
        .plot-area { grid-area: plot; }

        .toggle-checkbox:checked { right: 0; border-color: #3b82f6; }
        .toggle-checkbox:checked + .toggle-label { background-color: #3b82f6; }
        body.resizing { cursor: col-resize !important; user-select: none; }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="controls-panel">
            <h1 class="text-2xl font-bold text-white mb-4">Patterson Function Simulator</h1>
            
            <div class="control-group">
                <label class="control-label">Instructions</label>
                <p class="text-sm text-gray-400">
                    1. Select atom type & click on the crystal canvas to add.<br>
                    2. Edit atom coordinates directly in the list below.<br>
                    3. Hover over Patterson peaks to see the vectors.
                </p>
            </div>
            
            <div class="control-group">
                <label class="control-label">Select Atom Type to Add</label>
                <div id="atom-type-selector" class="grid grid-cols-2 gap-2">
                    <input type="radio" id="atom-type-a" name="atom-type" value="A" class="sr-only" checked>
                    <label for="atom-type-a" class="atom-type-label">Type A</label>
                    <input type="radio" id="atom-type-b" name="atom-type" value="B" class="sr-only">
                    <label for="atom-type-b" class="atom-type-label">Type B</label>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Diffraction Controls</label>
                 <div class="space-y-4">
                     <div>
                        <label for="hk-range-slider" class="block mb-2 text-sm font-medium">Range (h,k): <span id="hk-range-value" class="font-bold">5</span></label>
                        <input type="range" id="hk-range-slider" min="3" max="20" value="5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div>
                        <label for="spot-size-slider" class="block mb-2 text-sm font-medium">Spot Size Multiplier: <span id="spot-size-value" class="font-bold">5</span></label>
                        <input type="range" id="spot-size-slider" min="1" max="15" value="5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-hk-labels" class="text-sm font-medium">Show h,k Labels</label>
                        <div class="relative inline-block w-10 mr-2 align-middle select-none">
                            <input type="checkbox" name="toggle" id="toggle-hk-labels" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" checked/>
                            <label for="toggle-hk-labels" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-600 cursor-pointer"></label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Vector Details</label>
                <div id="vector-info-box" class="bg-gray-900/50 p-3 rounded-lg border border-gray-700 min-h-[100px] text-sm font-mono">
                    Hover over a Patterson peak...
                </div>
            </div>

            <div class="control-group">
                 <label class="control-label">Atom List</label>
                <div id="atom-list-container" class="max-h-72 overflow-y-auto bg-gray-900/50 p-2 rounded-lg border border-gray-700">
                    <ul id="atom-list" class="space-y-2">
                        <li id="no-atoms-msg" class="text-gray-500 text-sm text-center p-2">No atoms added yet.</li>
                    </ul>
                </div>
                <button id="clear-btn" class="btn-danger mt-4">Clear All Atoms</button>
            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="results-area">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="bg-white p-4 shadow-md rounded-lg">
                    <h2 class="text-lg font-semibold text-center mb-3">Crystal Structure (Real Space)</h2>
                    <div class="plot-grid">
                        <div id="real-y-axis" class="y-axis-labels"></div>
                        <div id="real-x-axis" class="x-axis-labels"></div>
                        <div class="plot-area canvas-wrapper rounded-lg"><canvas id="real-space-canvas"></canvas></div>
                    </div>
                </div>

                <div class="bg-white p-4 shadow-md rounded-lg">
                    <h2 class="text-lg font-semibold text-center mb-3">Patterson Map (Vector Space)</h2>
                    <div class="plot-grid">
                        <div id="patterson-y-axis" class="y-axis-labels"></div>
                        <div id="patterson-x-axis" class="x-axis-labels"></div>
                        <div class="plot-area canvas-wrapper rounded-lg"><canvas id="patterson-canvas"></canvas></div>
                    </div>
                </div>
                
                <div class="bg-white p-4 shadow-md rounded-lg">
                    <h2 class="text-lg font-semibold text-center mb-3">Diffraction Pattern (|F<sub>hkl</sub>|Â²)</h2>
                    <div class="plot-grid">
                        <div id="diffraction-y-axis" class="y-axis-labels"></div>
                        <div id="diffraction-x-axis" class="x-axis-labels"></div>
                        <div class="plot-area canvas-wrapper rounded-lg"><canvas id="diffraction-canvas"></canvas></div>
                    </div>
                </div>

                <div class="bg-white p-4 shadow-md rounded-lg">
                    <h2 class="text-lg font-semibold text-center mb-3">FT of Intensities (Patterson)</h2>
                    <div class="plot-grid">
                        <div id="ft-y-axis" class="y-axis-labels"></div>
                        <div id="ft-x-axis" class="x-axis-labels"></div>
                        <div class="plot-area canvas-wrapper rounded-lg"><canvas id="ft-canvas"></canvas></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        This tool demonstrates the relationship between a crystal structure, its diffraction pattern, and the Patterson function. (NitaD, Univ. Paris-Saclay, 2025)
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM ELEMENT SELECTION ---
            const realCanvas = document.getElementById('real-space-canvas');
            const pattersonCanvas = document.getElementById('patterson-canvas');
            const diffractionCanvas = document.getElementById('diffraction-canvas');
            const ftCanvas = document.getElementById('ft-canvas');
            const clearBtn = document.getElementById('clear-btn');
            const atomList = document.getElementById('atom-list');
            const noAtomsMsg = document.getElementById('no-atoms-msg');
            const atomTypeSelector = document.getElementById('atom-type-selector');
            const vectorInfoBox = document.getElementById('vector-info-box');
            const hkRangeSlider = document.getElementById('hk-range-slider');
            const hkRangeValue = document.getElementById('hk-range-value');
            const toggleHkLabels = document.getElementById('toggle-hk-labels');
            const spotSizeSlider = document.getElementById('spot-size-slider');
            const spotSizeValue = document.getElementById('spot-size-value');

            const realCtx = realCanvas.getContext('2d');
            const pattersonCtx = pattersonCanvas.getContext('2d');
            const diffractionCtx = diffractionCanvas.getContext('2d');
            const ftCtx = ftCanvas.getContext('2d');

            // --- STATE MANAGEMENT ---
            let atoms = [];
            let pattersonPeaks = [];
            let diffractionIntensities = [];
            let ftOfIntensities = null;
            let highlightedVector = null;
            let currentAtomType = 'A';
            let diffractionGridSize = 5;
            let showHkLabels = true;
            let diffractionSpotSizeFactor = 5;

            // --- CONSTANTS ---
            const ATOM_COLOR_A = '#3b82f6';
            const ATOM_COLOR_B = '#ef4444';
            const ATOMIC_WEIGHTS = { 'A': 1, 'B': 2 };
            const HIGHLIGHT_COLOR_1 = '#db2777';
            const HIGHLIGHT_COLOR_2 = '#c026d3';
            const VECTOR_COLOR = '#7e22ce';
            const PEAK_COLOR = '#16a34a';
            const ORIGIN_PEAK_COLOR = '#f59e0b';
            const ATOM_RADIUS_A = 7; 
            const ATOM_RADIUS_B = 11;
            const MIN_PEAK_RADIUS = 4;
            const MAX_PEAK_RADIUS = 9;
            
            // --- CALCULATION FUNCTIONS ---
            function calculatePattersonMap() {
                pattersonPeaks = [];
                if (atoms.length === 0) return;
                let maxWeight = 0;
                for (let i = 0; i < atoms.length; i++) {
                    for (let j = 0; j < atoms.length; j++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                const u = (atoms[j].x + dx) - atoms[i].x;
                                const v = (atoms[j].y + dy) - atoms[i].y;
                                if (Math.abs(u) > 1.01 || Math.abs(v) > 1.01) continue;
                                const weight = ATOMIC_WEIGHTS[atoms[i].type] * ATOMIC_WEIGHTS[atoms[j].type];
                                if (weight > maxWeight) maxWeight = weight;
                                pattersonPeaks.push({ u, v, from: i, to: j, weight });
                            }
                        }
                    }
                }
                pattersonPeaks.forEach(peak => {
                    const weightRatio = maxWeight > 1 ? (peak.weight - 1) / (maxWeight - 1) : 0;
                    peak.radius = MIN_PEAK_RADIUS + weightRatio * (MAX_PEAK_RADIUS - MIN_PEAK_RADIUS);
                });
            }

            function calculateDiffractionPattern() {
                diffractionIntensities = [];
                if (atoms.length === 0) return;
                for (let h = -diffractionGridSize; h <= diffractionGridSize; h++) {
                    for (let k = -diffractionGridSize; k <= diffractionGridSize; k++) {
                        let F_real = 0, F_imag = 0;
                        atoms.forEach(atom => {
                            const phase = 2 * Math.PI * (h * atom.x + k * atom.y);
                            const f = ATOMIC_WEIGHTS[atom.type];
                            F_real += f * Math.cos(phase);
                            F_imag += f * Math.sin(phase);
                        });
                        const intensity = F_real * F_real + F_imag * F_imag;
                        diffractionIntensities.push({ h, k, intensity });
                    }
                }
            }

            function calculateFTofIntensities() {
                if (diffractionIntensities.length === 0 || ftCanvas.width === 0) {
                    ftOfIntensities = null; return;
                }
                const size = ftCanvas.width;
                ftOfIntensities = ftCtx.createImageData(size, size);
                let maxPattersonVal = 0;
                const pattersonGrid = [];
                for (let v_px = 0; v_px < size; v_px++) {
                    for (let u_px = 0; u_px < size; u_px++) {
                        const u = (u_px / size) * 2 - 1;
                        const v = (v_px / size) * 2 - 1;
                        let pattersonVal = 0;
                        diffractionIntensities.forEach(spot => {
                            const phase = 2 * Math.PI * (spot.h * (u / 2) + spot.k * (v / 2));
                            pattersonVal += spot.intensity * Math.cos(phase);
                        });
                        pattersonGrid.push(pattersonVal);
                        if (pattersonVal > maxPattersonVal) maxPattersonVal = pattersonVal;
                    }
                }
                for (let i = 0; i < pattersonGrid.length; i++) {
                    const normalizedVal = pattersonGrid[i] > 0 && maxPattersonVal > 0 ? Math.floor(255 * (pattersonGrid[i] / maxPattersonVal)) : 0;
                    const pixelIndex = i * 4;
                    ftOfIntensities.data[pixelIndex] = normalizedVal;
                    ftOfIntensities.data[pixelIndex+1] = normalizedVal;
                    ftOfIntensities.data[pixelIndex+2] = normalizedVal;
                    ftOfIntensities.data[pixelIndex+3] = 255;
                }
            }

            // --- DRAWING FUNCTIONS ---
            function resizeCanvases() {
                [realCanvas, pattersonCanvas, diffractionCanvas, ftCanvas].forEach(canvas => {
                    const wrapper = canvas.parentElement;
                    if (wrapper && wrapper.clientWidth > 0) {
                        const size = wrapper.clientWidth;
                        canvas.width = size; canvas.height = size;
                    }
                });
                redrawAll();
            }

            function drawAxisLabels(yId, xId, centered, isDiffraction, theme) {
                const yEl = document.getElementById(yId), xEl = document.getElementById(xId);
                yEl.innerHTML = ''; xEl.innerHTML = '';
                const textColor = theme === 'dark' ? 'text-gray-400' : 'text-gray-500';
                yEl.className = `w-8 flex-shrink-0 y-axis-labels flex flex-col justify-between text-right text-xs pr-1 ${textColor}`;
                xEl.className = `x-axis-labels flex justify-between text-center text-xs pt-1 ${textColor}`;
                for (let i = 0; i <= 5; i++) {
                    const ySpan = document.createElement('span'), xSpan = document.createElement('span');
                    let yVal = centered ? 1 - (i / 5) * 2 : 1.0 - (i / 5);
                    ySpan.textContent = isDiffraction ? Math.round(yVal * diffractionGridSize) : yVal.toFixed(1);
                    yEl.appendChild(ySpan);
                    let xVal = centered ? -1 + (i / 5) * 2 : i / 5;
                    xSpan.textContent = isDiffraction ? Math.round(xVal * diffractionGridSize) : xVal.toFixed(1);
                    xEl.appendChild(xSpan);
                }
            }
            
            function drawGridOnCanvas(ctx, theme = 'light') {
                const size = ctx.canvas.width;
                const bgColor = theme === 'dark' ? 'black' : '#f8fafc';
                const gridColor = theme === 'dark' ? '#4a4a4a' : '#e2e8f0';
                
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, size, size);
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const pos = i * size / 10;
                    ctx.beginPath(); ctx.moveTo(pos, 0); ctx.lineTo(pos, size); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, pos); ctx.lineTo(size, pos); ctx.stroke();
                }
            }

            function drawDiffractionGrid(ctx, theme = 'dark') {
                const size = ctx.canvas.width;
                const bgColor = theme === 'dark' ? 'black' : '#f8fafc';
                const gridColor = theme === 'dark' ? '#374151' : '#e5e7eb';
                const axisColor = theme === 'dark' ? '#6b7280' : '#d1d5db';
                const center = size / 2;

                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, size, size);
                
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 0.5;

                for (let i = 1; i <= diffractionGridSize; i++) {
                    let pos = center + (i / diffractionGridSize) * center;
                    ctx.beginPath(); ctx.moveTo(pos, 0); ctx.lineTo(pos, size); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, pos); ctx.lineTo(size, pos); ctx.stroke();
                    pos = center - (i / diffractionGridSize) * center;
                    ctx.beginPath(); ctx.moveTo(pos, 0); ctx.lineTo(pos, size); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, pos); ctx.lineTo(size, pos); ctx.stroke();
                }
                
                ctx.strokeStyle = axisColor;
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(center, 0); ctx.lineTo(center, size); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, center); ctx.lineTo(size, center); ctx.stroke();
            }

            function drawAtoms() {
                drawGridOnCanvas(realCtx);
                const size = realCanvas.width;
                
                atoms.forEach((atom, index) => {
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            const x_abs = (atom.x + i) * size;
                            const y_abs = (1-(atom.y + j)) * size;

                            if (x_abs > -ATOM_RADIUS_B && x_abs < size + ATOM_RADIUS_B && y_abs > -ATOM_RADIUS_B && y_abs < size + ATOM_RADIUS_B) {
                                realCtx.fillStyle = atom.type === 'A' ? ATOM_COLOR_A : ATOM_COLOR_B;
                                realCtx.strokeStyle = 'white';
                                realCtx.lineWidth = 2;
                                if (highlightedVector) {
                                    if (index === highlightedVector.from || index === highlightedVector.to) {
                                        realCtx.fillStyle = index === highlightedVector.from ? HIGHLIGHT_COLOR_1 : HIGHLIGHT_COLOR_2;
                                    }
                                }
                                const radius = atom.type === 'A' ? ATOM_RADIUS_A : ATOM_RADIUS_B;
                                realCtx.beginPath();
                                realCtx.arc(atom.x * size, (1-atom.y) * size, radius, 0, 2 * Math.PI);
                                realCtx.fill();
                                realCtx.stroke();
                            }
                        }
                    }
                });

                if (highlightedVector) {
                    const fromAtom = atoms[highlightedVector.from];
                    const toAtom = atoms[highlightedVector.to];
                    if (fromAtom && toAtom) {
                        realCtx.strokeStyle = VECTOR_COLOR;
                        realCtx.lineWidth = 2.5;
                        realCtx.lineCap = 'round';
                        realCtx.beginPath();
                        realCtx.moveTo(fromAtom.x * size, (1-fromAtom.y) * size);
                        realCtx.lineTo(toAtom.x * size, (1-toAtom.y) * size);
                        realCtx.stroke();
                        const angle = Math.atan2((1-toAtom.y) - (1-fromAtom.y), toAtom.x - fromAtom.x);
                        realCtx.fillStyle = VECTOR_COLOR;
                        realCtx.save();
                        realCtx.translate(toAtom.x * size, (1-toAtom.y) * size);
                        realCtx.rotate(angle);
                        realCtx.beginPath();
                        realCtx.moveTo(0, 0); realCtx.lineTo(-10, -5); realCtx.lineTo(-10, 5);
                        realCtx.closePath(); realCtx.fill();
                        realCtx.restore();
                    }
                }
            }

            function drawPattersonMap() {
                drawGridOnCanvas(pattersonCtx);
                const size = pattersonCanvas.width;
                const center = size / 2;
                pattersonPeaks.forEach(peak => {
                    const isOriginPeak = Math.abs(peak.u) < 1e-9 && Math.abs(peak.v) < 1e-9;
                    const isHighlighted = highlightedVector && peak.from === highlightedVector.from && peak.to === highlightedVector.to && Math.abs(peak.u - highlightedVector.u) < 1e-9 && Math.abs(peak.v - highlightedVector.v) < 1e-9;
                    pattersonCtx.fillStyle = isOriginPeak ? ORIGIN_PEAK_COLOR : PEAK_COLOR;
                    pattersonCtx.strokeStyle = 'white';
                    pattersonCtx.lineWidth = 2;
                    if (isHighlighted) {
                        pattersonCtx.fillStyle = VECTOR_COLOR;
                    }
                    pattersonCtx.beginPath();
                    pattersonCtx.arc(peak.u * center + center, peak.v * center + center, peak.radius, 0, 2 * Math.PI);
                    pattersonCtx.fill();
                    pattersonCtx.stroke();
                });
                if (highlightedVector) {
                    pattersonCtx.fillStyle = '#1e293b';
                    pattersonCtx.font = 'bold 12px Inter';
                    const text = `(${highlightedVector.u.toFixed(2)}, ${highlightedVector.v.toFixed(2)})`;
                    const xPos = highlightedVector.u * center + center + 10;
                    const yPos = highlightedVector.v * center + center;
                    pattersonCtx.textAlign = 'left';
                    pattersonCtx.textBaseline = 'middle';
                    pattersonCtx.fillText(text, xPos, yPos);
                }
            }

            function drawDiffractionPattern() {
                drawDiffractionGrid(diffractionCtx, 'dark');
                const size = diffractionCanvas.width;
                const center = size / 2;
                
                let maxIntensity = 0;
                diffractionIntensities.forEach(spot => {
                    if (spot.h === 0 && spot.k === 0) return;
                    if (spot.intensity > maxIntensity) maxIntensity = spot.intensity;
                });

                if (maxIntensity < 1e-9) return;

                const maxLogIntensity = Math.log(1 + maxIntensity);

                diffractionIntensities.forEach(spot => {
                    if (spot.h === 0 && spot.k === 0) return;

                    const logIntensity = Math.log(1 + spot.intensity);
                    const normalizedIntensity = maxLogIntensity > 0 ? logIntensity / maxLogIntensity : 0;

                    if (normalizedIntensity < 0.01) return;

                    const radius = 1 + diffractionSpotSizeFactor * normalizedIntensity;
                    const x = center + (spot.h / diffractionGridSize) * center;
                    const y = center - (spot.k / diffractionGridSize) * center;
                    
                    const colorValue = Math.floor(200 * normalizedIntensity) + 55;
                    diffractionCtx.fillStyle = `rgb(${colorValue}, ${colorValue}, ${colorValue})`;
                    diffractionCtx.beginPath();
                    diffractionCtx.arc(x, y, radius, 0, 2 * Math.PI);
                    diffractionCtx.fill();
                });

                if (showHkLabels) {
                    diffractionCtx.fillStyle = '#fbbf24';
                    diffractionCtx.font = '10px Inter';
                    diffractionCtx.textAlign = 'center';
                    diffractionCtx.textBaseline = 'middle';
                    
                    diffractionIntensities.forEach(spot => {
                        if (spot.h === 0 && spot.k === 0) return;
                        const logIntensity = Math.log(1 + spot.intensity);
                        const normalizedIntensity = maxLogIntensity > 0 ? logIntensity / maxLogIntensity : 0;
                        if (normalizedIntensity < 0.15) return;
                        const x = center + (spot.h / diffractionGridSize) * center;
                        const y = center - (spot.k / diffractionGridSize) * center;
                        diffractionCtx.fillText(`${spot.h},${spot.k}`, x, y - 12);
                    });
                }
                diffractionCtx.fillStyle = '#ef4444';
                diffractionCtx.fillText('0,0', center, center - 10);
            }

            function drawFTofIntensities() {
                drawGridOnCanvas(ftCtx, 'dark');
                if (ftOfIntensities) {
                    ftCtx.putImageData(ftOfIntensities, 0, 0);
                }
            }
            
            function updateAtomList() {
                const activeId = document.activeElement ? document.activeElement.id : null;
                atomList.innerHTML = '';
                noAtomsMsg.style.display = atoms.length === 0 ? 'block' : 'none';
                atoms.forEach((atom, index) => {
                    const li = document.createElement('li');
                    li.className = 'flex justify-between items-center bg-gray-700 p-2 rounded-md border border-gray-600';
                    const isHighlighted = highlightedVector && (index === highlightedVector.from || index === highlightedVector.to);
                    if(isHighlighted) {
                        li.style.backgroundColor = index === highlightedVector.from ? '#581c87' : '#5b21b6';
                    }
                    li.innerHTML = `
                        <div class="flex items-center gap-2 font-mono text-sm text-gray-300">
                            <span>${index + 1}(${atom.type}): (</span>
                            <input type="number" step="0.01" min="0" max="1" value="${atom.x.toFixed(2)}" id="atom-${index}-x" data-index="${index}" data-coord="x" class="coord-input">,
                            <input type="number" step="0.01" min="0" max="1" value="${atom.y.toFixed(2)}" id="atom-${index}-y" data-index="${index}" data-coord="y" class="coord-input">
                            <span>)</span>
                        </div>
                        <button data-index="${index}" class="remove-atom-btn text-red-500 hover:text-red-400 text-xs font-semibold">REMOVE</button>
                    `;
                    atomList.appendChild(li);
                });
                if (activeId) document.getElementById(activeId)?.focus();
            }

            function updateVectorInfo() {
                if (!highlightedVector) {
                    vectorInfoBox.innerHTML = 'Hover over a Patterson peak...'; return;
                }
                const fromAtom = atoms[highlightedVector.from];
                const toAtom = atoms[highlightedVector.to];
                if (!fromAtom || !toAtom) return;
                vectorInfoBox.innerHTML = `
                    <div class="space-y-1">
                        <div><span class="text-pink-400">Atom 1 (xâ,yâ):</span> (${fromAtom.x.toFixed(2)}, ${fromAtom.y.toFixed(2)})</div>
                        <div><span class="text-purple-400">Atom 2 (xâ,yâ):</span> (${toAtom.x.toFixed(2)}, ${toAtom.y.toFixed(2)})</div>
                        <div class="pt-2">
                           <div>u = xâ-xâ = ${highlightedVector.u.toFixed(2)}</div>
                           <div>v = yâ-yâ = ${highlightedVector.v.toFixed(2)}</div>
                        </div>
                        <div class="font-bold pt-2"><span class="text-indigo-400">Vector (u,v):</span> (${highlightedVector.u.toFixed(2)}, ${highlightedVector.v.toFixed(2)})</div>
                    </div>
                `;
            }

            function redrawAll() {
                calculatePattersonMap();
                calculateDiffractionPattern();
                calculateFTofIntensities();
                updateAtomList();
                updateVectorInfo();
                drawAxisLabels('real-y-axis', 'real-x-axis', false, false, 'light');
                drawAtoms();
                drawAxisLabels('patterson-y-axis', 'patterson-x-axis', true, false, 'light');
                drawPattersonMap();
                drawAxisLabels('diffraction-y-axis', 'diffraction-x-axis', true, true, 'dark');
                drawDiffractionPattern();
                drawAxisLabels('ft-y-axis', 'ft-x-axis', true, false, 'dark');
                drawFTofIntensities();
            }

            // --- EVENT HANDLERS ---
            function handleAtomTypeChange(event) {
                if (event.target.name === 'atom-type') currentAtomType = event.target.value;
            }
            function handleAddAtom(event) {
                const rect = realCanvas.getBoundingClientRect();
                const x = (event.clientX - rect.left) / rect.width;
                const y = 1 - ((event.clientY - rect.top) / rect.height);
                if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {
                    atoms.push({ x, y, type: currentAtomType });
                    redrawAll();
                }
            }
            function handleAtomListInteraction(event) {
                if (event.target.classList.contains('remove-atom-btn')) {
                    const indexToRemove = parseInt(event.target.dataset.index, 10);
                    atoms.splice(indexToRemove, 1);
                    highlightedVector = null; 
                    redrawAll();
                }
            }
            function handleCoordinateChange(event) {
                if (event.target.classList.contains('coord-input')) {
                    const index = parseInt(event.target.dataset.index, 10);
                    const coord = event.target.dataset.coord;
                    let value = Math.max(0, Math.min(1, parseFloat(event.target.value) || 0));
                    if (atoms[index]) {
                        atoms[index][coord] = value;
                        redrawAll();
                    }
                }
            }
            function handlePattersonHover(event) {
                const rect = pattersonCanvas.getBoundingClientRect();
                const center = rect.width / 2;
                const mouseU = ((event.clientX - rect.left) - center) / center;
                const mouseV = ((event.clientY - rect.top) - center) / center;
                let foundPeak = null;
                let minDistance = Infinity;
                const hoverThreshold = (MAX_PEAK_RADIUS * 2) / rect.width;
                for (const peak of pattersonPeaks) {
                    const dist = Math.sqrt(Math.pow(peak.u - mouseU, 2) + Math.pow(peak.v - mouseV, 2));
                    if (dist < hoverThreshold && dist < minDistance) {
                        minDistance = dist;
                        foundPeak = peak;
                    }
                }
                if (JSON.stringify(foundPeak) !== JSON.stringify(highlightedVector)) {
                    highlightedVector = foundPeak;
                    redrawAll();
                }
            }
            function clearAll() {
                atoms = [];
                highlightedVector = null;
                redrawAll();
            }
            function handleHkRangeChange(event) {
                diffractionGridSize = parseInt(event.target.value, 10);
                hkRangeValue.textContent = diffractionGridSize;
                redrawAll();
            }
            function handleToggleHkLabels(event) {
                showHkLabels = event.target.checked;
                redrawAll();
            }
            function handleSpotSizeChange(event) {
                diffractionSpotSizeFactor = parseInt(event.target.value, 10);
                spotSizeValue.textContent = diffractionSpotSizeFactor;
                redrawAll();
            }

            // --- Resizer Logic ---
            const leftPanel = document.getElementById('controls-panel'), resizer = document.getElementById('drag-handle');
            resizer.addEventListener('mousedown', (e) => {
                e.preventDefault(); document.body.classList.add('resizing');
                const moveHandler = (e) => { if (e.clientX > 350 && e.clientX < 550) leftPanel.style.width = `${e.clientX}px`; };
                const upHandler = () => {
                    document.body.classList.remove('resizing');
                    window.removeEventListener('mousemove', moveHandler); window.removeEventListener('mouseup', upHandler);
                    setTimeout(resizeCanvases, 50);
                };
                window.addEventListener('mousemove', moveHandler); window.addEventListener('mouseup', upHandler);
            });
            
            // --- INITIALIZATION AND EVENT LISTENERS ---
            atomTypeSelector.addEventListener('change', handleAtomTypeChange);
            realCanvas.addEventListener('click', handleAddAtom);
            clearBtn.addEventListener('click', clearAll);
            atomList.addEventListener('click', handleAtomListInteraction);
            atomList.addEventListener('change', handleCoordinateChange);
            pattersonCanvas.addEventListener('mousemove', handlePattersonHover);
            pattersonCanvas.addEventListener('mouseleave', () => {
                if (highlightedVector) {
                    highlightedVector = null;
                    redrawAll();
                }
            });
            hkRangeSlider.addEventListener('input', handleHkRangeChange);
            toggleHkLabels.addEventListener('change', handleToggleHkLabels);
            spotSizeSlider.addEventListener('input', handleSpotSizeChange);

            window.addEventListener('resize', () => setTimeout(resizeCanvases, 50));
            setTimeout(resizeCanvases, 100);
        });
    </script>
</body>
</html>