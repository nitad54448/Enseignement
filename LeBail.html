<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Le Bail Fit</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        :root {
            --system-blue: #007AFF;
            --system-gray-1: #8E8E93;
            --system-gray-2: #AEAEB2;
            --system-gray-3: #C7C7CC;
            --system-gray-4: #D1D1D6;
            --system-gray-5: #E5E5EA;
            --system-gray-6: #F2F2F7;
            --system-background: #FFFFFF;
            --system-grouped-background: #F2F2F7;
            --system-material-thin: rgba(255, 255, 255, 0.7);
            --system-material-regular: rgba(255, 255, 255, 0.8);
            --system-label: #000000;
            --system-secondary-label: rgba(60, 60, 67, 0.6);
            --system-tertiary-label: rgba(60, 60, 67, 0.3);
            --system-separator: rgba(60, 60, 67, 0.29);
            --system-fill: rgba(120, 120, 128, 0.2);
            --system-secondary-fill: rgba(120, 120, 128, 0.16);
            --system-shadow: rgba(0, 0, 0, 0.1);
        }

        #fit-button { width: 100%; }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif; 
            margin: 0; 
            background-color: var(--system-grouped-background); 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            overflow: hidden; 
            color: var(--system-label);
        }
        #app-container { 
            display: flex; 
            width: 100%; 
            flex-grow: 1; 
            min-height: 0; 
            background-color: var(--system-grouped-background);
        }
        
        #controls-panel { 
            width: 380px; 
            min-width: 320px; 
            max-width: 500px; 
            flex-shrink: 0; 
            padding: 16px; 
            background-color: var(--system-background); 
            border-right: 1px solid var(--system-separator); 
            display: flex; 
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            z-index: 20;
            box-shadow: 0 0 20px rgba(0,0,0,0.05);
            border-radius: 0 12px 12px 0;
        }
        
        #drag-handle { 
            width: 6px; 
            cursor: col-resize; 
            background-color: var(--system-gray-5); 
            flex-shrink: 0; 
            transition: background-color 0.2s; 
        }
        #drag-handle:hover, #drag-handle:active { 
            background-color: var(--system-blue); 
        }
        
        #results-area { 
            flex-grow: 1; 
            position: relative; 
            background-color: var(--system-background); 
            min-width: 0; 
            display: flex; 
            flex-direction: column; 
            padding: 20px; 
            z-index: 10;
            border-radius: 12px 0 0 12px;
            margin: 8px 8px 8px 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
        }
        
        .control-group { 
            padding: 16px; 
            margin-bottom: 16px;
            background-color: var(--system-background);
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .control-group:first-child { 
            padding-top: 0; 
            margin-top: 0;
        }
        .control-label { 
            display: block; 
            font-weight: 500; 
            color: var(--system-secondary-label); 
            font-size: 13px; 
            margin-bottom: 6px;
        }
        
        .control-input, .control-select { 
            width: 100%; 
            background-color: var(--system-gray-6); 
            border: 1px solid var(--system-gray-4); 
            color: var(--system-label); 
            border-radius: 8px; 
            padding: 10px 14px; 
            transition: all 0.2s ease; 
            box-sizing: border-box;
            font-size: 15px;
            height: 40px;
        }
        .control-input:focus, .control-select:focus { 
            outline: none; 
            border-color: var(--system-blue); 
            box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2); 
        }
        .control-input:disabled { 
            background-color: var(--system-gray-6);
            color: var(--system-tertiary-label);
            cursor: not-allowed; 
        }
        
        .btn { 
            padding: 12px 20px; 
            border-radius: 10px; 
            font-weight: 600; 
            transition: all 0.2s; 
            cursor: pointer; 
            border: none; 
            text-align: center; 
            font-size: 15px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-primary { 
            background-color: var(--system-blue); 
            color: white; 
            box-shadow: 0 1px 3px rgba(0, 122, 255, 0.3);
        }
        .btn-primary:hover:not(:disabled) { 
            background-color: #006ee6; 
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 122, 255, 0.3);
        }
        .btn-primary:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 122, 255, 0.3);
        }
        .btn-secondary { 
            background-color: var(--system-gray-6); 
            color: var(--system-label); 
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .btn-secondary:hover:not(:disabled) { 
            background-color: var(--system-gray-5); 
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .btn:disabled { 
            background-color: var(--system-gray-6); 
            color: var(--system-tertiary-label);
            cursor: not-allowed; 
            opacity: 0.7; 
            box-shadow: none;
        }
        
        .file-input-label { 
            display: block; 
            padding: 12px 16px; 
            background-color: var(--system-gray-6); 
            color: var(--system-label); 
            border-radius: 10px; 
            text-align: center; 
            cursor: pointer; 
            transition: all 0.2s;
            font-weight: 500;
            border: 1px dashed var(--system-gray-4);
        }
        .file-input-label:hover { 
            background-color: var(--system-gray-5); 
            border-color: var(--system-blue);
        }
        
        .results-grid { 
            display: grid; 
            grid-template-columns: repeat(3, minmax(80px, 1fr)); 
            gap: 12px; 
        }
        .result-card { 
            background-color: var(--system-gray-6); 
            padding: 12px; 
            border-radius: 10px; 
            text-align: center; 
            transition: all 0.2s; 
        }
        .result-card-label { 
            font-size: 12px; 
            color: var(--system-secondary-label); 
            margin-bottom: 4px;
        }
        .result-card-value { 
            font-size: 18px; 
            font-weight: 700; 
            color: var(--system-label); 
        }
        
        .fit-checkbox { 
            -webkit-appearance: none; 
            appearance: none; 
            background-color: var(--system-gray-6); 
            width: 22px; 
            height: 22px; 
            border: 1px solid var(--system-gray-4); 
            border-radius: 6px; 
            cursor: pointer; 
            display: inline-block; 
            position: relative; 
            transition: all 0.2s;
        }
        .fit-checkbox:checked { 
            background-color: var(--system-blue); 
            border-color: var(--system-blue); 
        }
        .fit-checkbox:checked::after { 
            content: '✓'; 
            color: white; 
            position: absolute; 
            left: 50%; 
            top: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 14px; 
            font-weight: bold;
        }
        
        .tab-buttons { 
            display: flex; 
            background-color: var(--system-gray-6);
            border-radius: 10px;
            padding: 4px;
            margin-bottom: 16px;
        }
        .tab-btn { 
            flex: 1; 
            padding: 8px 12px; 
            background: none; 
            border: none; 
            color: var(--system-secondary-label); 
            font-weight: 500; 
            cursor: pointer; 
            border-radius: 8px;
            transition: all 0.2s; 
            font-size: 14px; 
        }
        .tab-btn:hover { 
            color: var(--system-label); 
            background-color: rgba(255,255,255,0.5);
        }
        .tab-btn.active { 
            color: var(--system-blue); 
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .tab-content-panels { 
            position: relative; 
            padding-top: 0; 
        }
        .tab-content-panel { 
            display: none; 
            flex-direction: column; 
        }
        .tab-content-panel.active { 
            display: flex; 
        }

        .tab-content-panel > .control-group {
            border-top: none;
        }

        #lattice-parameters-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .bottom-actions { 
            margin-top: auto; 
            padding-top: 16px;
        }

        .slider-value-track { 
            display: grid; 
            grid-template-columns: 1fr; 
            grid-template-rows: 1fr; 
            align-items: center; 
        }
        .slider-value-track > * { 
            grid-column: 1; 
            grid-row: 1; 
        }
        .slider-value-display { 
            text-align: center; 
            color: var(--system-secondary-label); 
            font-weight: 500; 
            font-size: 13px; 
            pointer-events: none; 
        }
        input[type="range"].custom-slider { 
            -webkit-appearance: none; 
            appearance: none; 
            width: 100%; 
            height: 36px; 
            background: var(--system-gray-6); 
            border-radius: 6px; 
            outline: none; 
            padding: 0; 
            margin: 0; 
        }
        input[type="range"].custom-slider::-webkit-slider-thumb { 
            -webkit-appearance: none; 
            appearance: none; 
            width: 22px; 
            height: 22px; 
            background: var(--system-blue); 
            border-radius: 50%; 
            cursor: pointer; 
            border: 3px solid white; 
            box-sizing: border-box; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        input[type="range"].custom-slider::-moz-range-thumb { 
            width: 22px; 
            height: 22px; 
            background: var(--system-blue); 
            border-radius: 50%; 
            cursor: pointer; 
            border: 3px solid white; 
            box-sizing: border-box; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        input[type="range"].custom-slider:disabled { 
            background: var(--system-gray-6); 
        }
        input[type="range"].custom-slider:disabled::-webkit-slider-thumb { 
            background: var(--system-gray-3); 
        }
        input[type="range"].custom-slider:disabled::-moz-range-thumb { 
            background: var(--system-gray-3); 
        }

        /* --- UNIFIED UI & SPACING STYLES --- */
        #tab-panel-sample > .control-group, #tab-panel-background > .control-group {
            display: flex; 
            flex-direction: column; 
            gap: 16px; 
        } 
        
        /* Add these styles anywhere inside the <style> tag */
        .anchor-point-item {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            background-color: var(--system-gray-6);
            border-radius: 8px;
        }

        .anchor-point-item span {
    font-size: 15px;
    padding: 0 4px;
    text-align: right;
}

        .anchor-point-item .control-input {
            height: 36px;
            padding: 8px 12px;
        }

        .anchor-remove-btn {
            background-color: transparent;
            border: none;
            color: var(--system-gray-1);
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            padding: 0 8px;
            line-height: 1;
            transition: color 0.2s;
        }
        .anchor-remove-btn:hover {
            color: #ff453a; /* systemRed */
        }

        .control-group h2, .profile-section-header {
            margin: 0 0 16px 0; 
            padding-bottom: 12px; 
            border-bottom: 1px solid var(--system-separator);
            color: var(--system-label); 
            font-size: 17px; 
            font-weight: 600;
        }

.profile-controls-container + .profile-controls-container {
    margin-top: 24px;
}

        .parameter-grid-3col, .parameter-grid-2col, .slider-group, .form-row {
            display: grid; 
            gap: 12px; 
            align-items: center;
        }
        .parameter-grid-3col { 
            grid-template-columns: minmax(100px, auto) 1fr auto; 
        }
        .parameter-grid-2col, .slider-group, .form-row { 
            grid-template-columns: minmax(100px, auto) 1fr; 
        }
        
        .parameter-grid-3col > .control-label, .parameter-grid-2col > .control-label,
        .slider-group > .control-label, .form-row > .control-label {
            grid-column: 1; 
            margin-bottom: 0;
        }
        
        .parameter-grid-2col > *:not(label), .slider-group > .slider-value-track,
        .form-row > *:not(label) { 
            grid-column: 2; 
        }
        .parameter-grid-3col > .control-input { 
            grid-column: 2; 
        }
        .parameter-grid-3col > .fit-checkbox { 
            grid-column: 3; 
            justify-self: center; 
        }

        .profile-controls-container {
            display: grid; 
            grid-template-columns: minmax(100px, auto) 1fr auto;
            gap: 16px 12px; 
            align-items: center;
        }
        .profile-controls-container > .control-label { 
            grid-column: 1; 
            text-align: left; 
            margin-bottom: 0; 
        }
        .profile-controls-container > input[type="number"] { 
            grid-column: 2; 
        }
        .profile-controls-container > input[type="checkbox"] { 
            grid-column: 3; 
            justify-self: center; 
        }
        .profile-controls-container > .profile-section-header { 
            grid-column: 1 / -1; 
        }
        
        
        .bottom-actions > .control-group {
            display: grid; 
            grid-template-columns: minmax(100px, auto) 1fr;
            gap: 16px; 
            align-items: center; 
            border: none; 
            padding: 0;
        }
        .bottom-actions > .control-group > h2,
        .bottom-actions > .control-group > .slider-group,
        .bottom-actions > .control-group > #progress-bar-container,
        .bottom-actions > .control-group > .results-grid {
            grid-column: 1 / -1;
        }
        .bottom-actions > .control-group > label[for="algorithm-select"] {
            grid-column: 1; 
            margin-bottom: 0;
        }
        .bottom-actions > .control-group > #algorithm-select {
            grid-column: 2; 
            margin-bottom: 0;
        }
        
        /* --- TOOLTIP AND SCROLLBAR FIX --- */
        .help-tooltip-container { 
            position: relative; 
            display: inline-block; 
        }
.help-icon { 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    width: 24px; 
    height: 24px; 
    background-color: #4a5568; /* Darker background for icon */
    color: white; /* White question mark */
    border-radius: 50%; 
    font-weight: 500; 
    font-size: 14px; 
    cursor: help; 
    transition: all 0.2s; 
}
.help-icon:hover { 
    background-color: #2d3748; /* Even darker on hover */
    color: white;
}
        
.tooltip-content {
    visibility: hidden; 
    opacity: 0; 
    width: 280px;
    background-color: #2d3748; /* Darker background for better contrast */
    color: #f7fafc; /* Light text color */
    text-align: left;
    border-radius: 10px; 
    padding: 16px;
    position: absolute; 
    z-index: 1001;
    top: -15px;
    right: 115%;
    margin-right: 10px;
    transition: opacity 0.3s; 
    font-size: 15px; 
    border: 1px solid #4a5568; /* Darker border */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); /* Stronger shadow */
}
.tooltip-content::after {
    content: ""; 
    position: absolute;
    top: 20px;
    left: 100%;
    margin-top: -5px; 
    border-width: 5px; 
    border-style: solid;
    border-color: transparent transparent transparent #2d3748; /* Match tooltip background */
}

.tooltip-content.visible {
    visibility: visible;
    opacity: 1;
}

.tooltip-content h4 { 
    color: #fff; /* White for headings */
    font-size: 15px; 
    margin-top: 0; 
    margin-bottom: 8px; 
    font-weight: 600; 
}
.tooltip-content p { 
    margin-top: 0; 
    margin-bottom: 6px; 
    line-height: 1.4; 
    color: #e2e8f0; /* Lighter gray for paragraph text */
}
.tooltip-content hr { 
    border: none; 
    border-top: 1px solid #4a5568; /* Darker separator */
    margin: 12px 0; 
}
        .hidden { 
            display: none !important; 
        }

        #controls-panel::-webkit-scrollbar { 
            width: 5px; 
        }
        #controls-panel::-webkit-scrollbar-track { 
            background: transparent; 
        }
        #controls-panel::-webkit-scrollbar-thumb { 
            background: var(--system-gray-4); 
            border-radius: 3px; 
        }
        #controls-panel::-webkit-scrollbar-thumb:hover { 
            background: var(--system-gray-3); 
        }

        /* Apple-style progress bar */
        #progress-bar-container {
            height: 5px;
            background-color: var(--system-gray-5);
            border-radius: 3px;
            overflow: hidden;
        }
        #progress-bar {
            height: 100%;
            background-color: var(--system-blue);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        /* Apple-style placeholder */
        #placeholder {
            background-color: var(--system-background);
            border-radius: 12px;
            padding: 40px;
        }
        #placeholder svg {
            color: var(--system-gray-3);
        }

        /* Subtle animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .control-group {
            animation: fadeIn 0.3s ease;
        }

        /* Improved focus states for accessibility */
        .btn:focus-visible,
        .control-input:focus-visible,
        .control-select:focus-visible,
        .fit-checkbox:focus-visible {
            outline: 2px solid var(--system-blue);
            outline-offset: 2px;
        }

    </style>
</head>

<body>

    <div id="app-container">
        <div id="controls-panel">
            
            <div class="control-group" style="padding-top: 16px;">
                 <div style="display: flex; align-items: center; gap: 10px;">
                     <label for="file-input" class="file-input-label" style="flex-grow: 1;">
                        <span id="file-name">Select Data File</span>
                    </label>
                     
                    <div class="help-tooltip-container">
    <span class="help-icon">?</span>

    <div class="tooltip-content">
    <h4>LeBail Fit version 2.5</h4>
    <p>Determine unit cell parameters using the LeBail method. <a href="LeBail_help.html" target="_blank" style="color: #6495ED;">Method Guide &rarr;</a></p>
    <hr>
    <h4>Supported File Formats:</h4>
    <p>Generic 2-column (2θ intensity), .xrdml, .brml, .ras, .uxd, .udf, GSAS .esd/.xra</p>
    <hr>
    <h4>Chart Interaction:</h4>
    <p><b>Zoom:</b> Use the mouse wheel over the chart or an axis.</p>
    <p><b>Pan:</b> Click and drag the chart to pan.</p>
    <p><b>Reset View:</b> Right-click on the chart.</p>
    <p><b>Add BG Anchor:</b> Hold <b>Ctrl</b> and click on the chart to manually add an anchor point.</p>
</div>
</div>




                </div>
                <input type="file" id="file-input" class="hidden" accept=".brml,.csv,.ras,.txt,.esd,.gsa,.std,.udf,.xra,.xrdml,.xy">
            </div>

            <div class="tab-buttons">
                <button class="tab-btn active" data-tab="sample">Sample</button>
                <button class="tab-btn" data-tab="background">Background</button>
                <button class="tab-btn" data-tab="profile">Profile</button>
            </div>

            <div class="tab-content-panels">
                <div id="tab-panel-sample" class="tab-content-panel active">
                    <div class="control-group">
                        <h2>Structural Parameters</h2>
                        <div class="parameter-grid-2col">
                            <label for="bravais-lattice" class="control-label">System</label>
                            <select id="bravais-lattice" class="control-select">
                                <option value="cubic_F" selected>Cubic (F)</option>
                                <option value="cubic_I">Cubic (I)</option>
                                <option value="cubic_P">Cubic (P)</option>
                                <option value="hexagonal_P">Hexagonal (P)</option>
                                <option value="rhombohedral_P">Rhombohedral (H-axes)</option>
                                <option value="tetragonal_I">Tetragonal (I)</option>
                                <option value="tetragonal_P">Tetragonal (P)</option>
                                <option value="orthorhombic_F">Orthorhombic (F)</option>
                                <option value="orthorhombic_I">Orthorhombic (I)</option>
                                <option value="orthorhombic_C">Orthorhombic (C)</option>
                                <option value="orthorhombic_P">Orthorhombic (P)</option>
                                <option value="monoclinic_C">Monoclinic (C)</option>
                                <option value="monoclinic_P">Monoclinic (P)</option>
                            </select>
                        </div>
<div class="parameter-grid-2col">
    <label for="space-group-select" class="control-label">Space Group</label>
    <select id="space-group-select" class="control-select"></select>
</div>

                        <div id="lattice-parameters-container">
                        </div>
                    </div>

                    <div class="control-group">
                        <h2>Instrumental Parameters</h2>

                        <div class="parameter-grid-3col">
                            <label for="zero-shift" class="control-label">Zero (°)</label>
                            <input type="number" id="zero-shift" value="0.0" step="0.001" class="control-input">
                            <input type="checkbox" id="fit-zero-shift" class="fit-checkbox" title="Fit this parameter" >
                        </div>

                        <div class="form-row">
                            <label for="wavelength" class="control-label">Radiation 1 (Å)</label>
                            <input type="number" id="wavelength" value="1.54056" step="0.0001" class="control-input" min="0.01" title="Cu K-alpha 1">
                        </div>

                        <div class="form-row">
                            <label for="wavelength2" class="control-label">Radiation 2 (Å)</label>
                            <input type="number" id="wavelength2" value="1.54439" step="0.0001" class="control-input" min="0.01" title="Cu K-alpha 2">
                        </div>

                        <div class="form-row">
                            <label for="ratio21" class="control-label">Ratio (I₂/I₁)</label>
                            <input type="number" id="ratio21" value="0.497" step="0.01" class="control-input" min="0">
                        </div>
                    </div>

                </div>



                <div id="tab-panel-background" class="tab-content-panel">
                    <div class="control-group">
                        <h2>Background (Chebyshev Polynomial)</h2>
                        <div id="background-params-container" class="profile-controls-container">
                            </div>
                                                    
                        <h2>Background (Amorphous Hump)</h2>
                        <div class="profile-controls-container">
                             <label class="control-label">Hump Height</label>
                             <input type="number" id="param-hump-h" value="50" step="10" class="control-input">
                             <input type="checkbox" id="fit-hump-h" class="fit-checkbox"checked>
                             
                             <label class="control-label">Hump Position (°2θ)</label>
                             <input type="number" id="param-hump-p" value="25" step="0.1" class="control-input">
                             <input type="checkbox" id="fit-hump-p" class="fit-checkbox" checked>

                             <label class="control-label">Hump FWHM (°2θ)</label>
                             <input type="number" id="param-hump-w" value="12" step="0.1" class="control-input" min="0.01">
                             <input type="checkbox" id="fit-hump-w" class="fit-checkbox" checked>
                        </div>

                       <div style="padding-top: 16px; border-top: 1px solid var(--system-separator);">
                            <h2 style="margin-bottom: 6px;">Background Anchor Points</h2>
                            <p class="control-label" style="margin-bottom: 16px;">Use <b>Ctrl+Click</b> on the chart to select an experimental data point as a background anchor. This gives the point a higher weight during refinement.</p>
                            
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                 <label for="show-anchors-checkbox" class="control-label" style="margin-bottom:0;">Show Anchors on Chart</label>
                                 <input type="checkbox" id="show-anchors-checkbox" class="fit-checkbox" checked>
                            </div>

                            <div id="anchor-points-list">
                                </div>
                        </div>
                      
                    </div>



                </div>

                <div id="tab-panel-profile" class="tab-content-panel">
                     <div class="control-group">
                        <div class="parameter-grid-2col" style="margin-bottom: 24px;">
                             <label for="profile-function-select" class="control-label">Profile Function</label>
<select id="profile-function-select" class="control-select">
   <option value="4" selected>Simple pVoigt</option>
   <option value="3">Anisotropy</option>
</select>
                        </div>

                        <div id="simple-pvoigt-params-container" class="profile-controls-container">
    <h3 class="profile-section-header">Gaussian Broadening</h3>
    <label class="control-label">GU</label>
    <input type="number" id="param-gu" value="0.035" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-gu" class="fit-checkbox">
    <label class="control-label">GV</label>
    <input type="number" id="param-gv" value="-0.03" step="0.01" class="control-input">
    <input type="checkbox" id="fit-gv" class="fit-checkbox" >
    <label class="control-label">GW</label>
    <input type="number" id="param-gw" value="0.02" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-gw" class="fit-checkbox" >
     <label class="control-label">GP</label>
    <input type="number" id="param-gp" value="0.0" step="0.001" class="control-input">
    <input type="checkbox" id="fit-gp" class="fit-checkbox">
    <h3 class="profile-section-header">Lorentzian Broadening</h3>
    <label class="control-label">LX</label>
    <input type="number" id="param-lx" value="0.05" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-lx" class="fit-checkbox" >
     <h3 class="profile-section-header">Peak Shape & Position</h3>
     <label class="control-label">eta (Mixing)</label>
    <input type="number" id="param-eta" value="0.74" step="0.01" min="0" max="1" class="control-input">
    <input type="checkbox" id="fit-eta" class="fit-checkbox">
     <label class="control-label">shft (Displ.)</label>
    <input type="number" id="param-shft" value="0" step="0.01" class="control-input">
    <input type="checkbox" id="fit-shft" class="fit-checkbox" >
     <label class="control-label">trns (Transp.)</label>
    <input type="number" id="param-trns" value="0" step="0.01" class="control-input">
    <input type="checkbox" id="fit-trns" class="fit-checkbox">
</div>

<div id="anisotropy-params-container" class="profile-controls-container hidden">
    <h3 class="profile-section-header">Isotropic Gaussian (TCH)</h3>
    <label class="control-label">U</label>
    <input type="number" id="param-u" value="0.04" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-u" class="fit-checkbox">
    <label class="control-label">V</label>
    <input type="number" id="param-v" value="-0.03" step="0.01" class="control-input">
    <input type="checkbox" id="fit-v" class="fit-checkbox" >
    <label class="control-label">W</label>
    <input type="number" id="param-w" value="0.02" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-w" class="fit-checkbox" >
    
    <h3 class="profile-section-header">Isotropic Lorentzian (TCH)</h3>
    <label class="control-label">X</label>
    <input type="number" id="param-x" value="0.0" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-x" class="fit-checkbox" >
    <label class="control-label">Y</label>
    <input type="number" id="param-y" value="0.0" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-y" class="fit-checkbox" >

        <h3 class="profile-section-header">Peak Asymmetry</h3>
    <label class="control-label">S/L</label>
    <input type="number" id="param-sl" value="0.0" step="0.001" class="control-input">
    <input type="checkbox" id="fit-sl" class="fit-checkbox">
    <label class="control-label">H/L</label>
    <input type="number" id="param-hl" value="0.0" step="0.001" class="control-input">
    <input type="checkbox" id="fit-hl" class="fit-checkbox" >


    <h3 class="profile-section-header">Anisotropic Broadening (Stephens)</h3>
    <label class="control-label">S400</label>
    <input type="number" id="param-s400" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s400" class="fit-checkbox">
    <label class="control-label">S040</label>
    <input type="number" id="param-s040" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s040" class="fit-checkbox">
    <label class="control-label">S004</label>
    <input type="number" id="param-s004" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s004" class="fit-checkbox">
    <label class="control-label">S220</label>
    <input type="number" id="param-s220" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s220" class="fit-checkbox">
     <label class="control-label">S202</label>
    <input type="number" id="param-s202" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s202" class="fit-checkbox">
    <label class="control-label">S022</label>
    <input type="number" id="param-s022" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s022" class="fit-checkbox">
    

</div>

                    </div>
                </div>
            </div>

            <div class="bottom-actions"> 
                 <div class="control-group" style="border-top: none; padding-top: 0;">
                     <h2>Refinement</h2>
                     <label for="algorithm-select" class="control-label">Method</label>
                     <select id="algorithm-select" class="control-select">
                        <option value="lm">Levenberg-Marquardt</option>
                        <option value="sa" selected>Simulated Annealing</option>
                     </select>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Min</label>
                         <div class="slider-value-track">
                            <input type="range" id="tth-min-slider" class="custom-slider" disabled>
                            <span id="tth-min-value" class="slider-value-display">10.0</span>
                         </div>
                     </div>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Max</label>
                         <div class="slider-value-track">
                             <input type="range" id="tth-max-slider" class="custom-slider" disabled>
                             <span id="tth-max-value" class="slider-value-display">80.0</span>
                         </div>
                     </div>

                     <div class="slider-group">
                         <label class="control-label">Max Iterations</label>
                         <div class="slider-value-track">
                            <input type="range" id="iterations-slider" min="2" max="200" value="120" step="1" class="custom-slider">
                            <span id="iterations-value" class="slider-value-display">120</span>
                         </div>
                     </div>

                     <div id="progress-bar-container" class="hidden" style="width: 100%; border-radius: 3px; height: 5px;">
                        <div id="progress-bar" style="height: 100%; width: 0%; border-radius: 3px;"></div>
                     </div>
                     <div class="results-grid">
                        <div class="result-card">
                            <div class="result-card-label">Rp (%)</div>
                            <div id="rp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">Rwp (%)</div>
                            <div id="rwp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">χ² (GOF)</div>
                            <div id="chi2-result" class="result-card-value">-</div>
                        </div>
                     </div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 16px; margin-top: 16px;">

                    <button id="fit-button" class="btn btn-primary" disabled>Load Data to Start Fit</button>

                    <div style="display: flex; gap: 10px;">
                        <button id="save-data-button" class="btn btn-secondary" style="flex: 1;" disabled>Save Report</button>
                        <button id="report-button" class="btn btn-secondary" style="flex: 1;" disabled>Generate PDF</button>
                    </div>
                </div>
            </div>
        </div>


        <div id="drag-handle"></div>

<div id="results-area" style="position: relative; flex-grow: 1; min-height: 0;">
    <div id="placeholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: var(--system-secondary-label);">
        <svg xmlns="http://www.w3.org/2000/svg" style="width: 64px; height: 64px; margin-bottom: 16px;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
        <h2 style="font-size: 22px; font-weight: 600; margin-bottom: 8px;">Awaiting Data</h2>
        <p style="font-size: 16px; color: var(--system-secondary-label);">Load a data file to begin.</p>
    </div>

    <div id="results-container" style="width: 100%; height: 100%; display: none; flex-direction: column; position: relative;">
        <canvas id="main-chart"></canvas>
    </div>

    <div style="position: absolute; bottom: 6px; right: 12px; font-size: 10px; color: var(--system-secondary-label);">
        2.5, 05 Oct 2025
    </div>
</div>




<script>
    document.addEventListener('DOMContentLoaded', () => {      

        //DOM Content
 
const tooltipContainer = document.querySelector('.help-tooltip-container');
const tooltipContent = document.querySelector('.tooltip-content');
let tooltipTimer;

if (tooltipContainer && tooltipContent) {
    tooltipContainer.addEventListener('mouseenter', () => {
        // If a timer is set to hide the tooltip, cancel it
        clearTimeout(tooltipTimer);
        // Add the 'visible' class to show the tooltip
        tooltipContent.classList.add('visible');
    });

    tooltipContainer.addEventListener('mouseleave', () => {
        // Start a new timer to hide the tooltip after 1 second
        tooltipTimer = setTimeout(() => {
            tooltipContent.classList.remove('visible');
        }, 1000); //  milliseconds 
    });
}


        const controls = {
            fileInput: document.getElementById('file-input'),
            fileName: document.getElementById('file-name'),
            bravaisLattice: document.getElementById('bravais-lattice'),
            spaceGroupSelect: document.getElementById('space-group-select'),

            latticeParamsContainer: document.getElementById('lattice-parameters-container'),
            wavelength: document.getElementById('wavelength'),
      wavelength2: document.getElementById('wavelength2'), // le 29 sept, dublet Ka
        ratio21: document.getElementById('ratio21'),      
            zeroShift: document.getElementById('zero-shift'),
            fitZeroShift: document.getElementById('fit-zero-shift'),
            profileSelect: document.getElementById('profile-function-select'),
            simplePVoigtParamsContainer: document.getElementById('simple-pvoigt-params-container'),
            anisotropyParamsContainer: document.getElementById('anisotropy-params-container'),
            paramGU: document.getElementById('param-gu'), fitGU: document.getElementById('fit-gu'),
            paramGV: document.getElementById('param-gv'), fitGV: document.getElementById('fit-gv'),
            paramGW: document.getElementById('param-gw'), fitGW: document.getElementById('fit-gw'),
            paramGP: document.getElementById('param-gp'), fitGP: document.getElementById('fit-gp'),
            paramLX: document.getElementById('param-lx'), fitLX: document.getElementById('fit-lx'),
            paramEta: document.getElementById('param-eta'), fitEta: document.getElementById('fit-eta'),
            paramShft: document.getElementById('param-shft'), fitShft: document.getElementById('fit-shft'),
            paramTrns: document.getElementById('param-trns'), fitTrns: document.getElementById('fit-trns'),
            paramU: document.getElementById('param-u'), fitU: document.getElementById('fit-u'),
            paramV: document.getElementById('param-v'), fitV: document.getElementById('fit-v'),
            paramW: document.getElementById('param-w'), fitW: document.getElementById('fit-w'),
            paramX: document.getElementById('param-x'), fitX: document.getElementById('fit-x'),
            paramY: document.getElementById('param-y'), fitY: document.getElementById('fit-y'),
            paramSL: document.getElementById('param-sl'), fitSL: document.getElementById('fit-sl'),
            paramHL: document.getElementById('param-hl'), fitHL: document.getElementById('fit-hl'),
            paramS400: document.getElementById('param-s400'), fitS400: document.getElementById('fit-s400'),
            paramS040: document.getElementById('param-s040'), fitS040: document.getElementById('fit-s040'),
            paramS004: document.getElementById('param-s004'), fitS004: document.getElementById('fit-s004'),
            paramS220: document.getElementById('param-s220'), fitS220: document.getElementById('fit-s220'),
            paramS202: document.getElementById('param-s202'), fitS202: document.getElementById('fit-s202'),
            paramS022: document.getElementById('param-s022'), fitS022: document.getElementById('fit-s022'),
            algorithmSelect: document.getElementById('algorithm-select'),
            iterationsSlider: document.getElementById('iterations-slider'),
            iterationsValue: document.getElementById('iterations-value'),
            tthMinSlider: document.getElementById('tth-min-slider'),
            tthMinValue: document.getElementById('tth-min-value'),
            tthMaxSlider: document.getElementById('tth-max-slider'),
            tthMaxValue: document.getElementById('tth-max-value'),
            fitButton: document.getElementById('fit-button'),
            reportButton: document.getElementById('report-button'),
            saveDataButton: document.getElementById('save-data-button'),
            progressBar: document.getElementById('progress-bar'),
            progressBarContainer: document.getElementById('progress-bar-container'),
            rpResult: document.getElementById('rp-result'),
            rwpResult: document.getElementById('rwp-result'),
            chi2Result: document.getElementById('chi2-result'),
            mainChartCanvas: document.getElementById('main-chart'),
            placeholder: document.getElementById('placeholder'),
            resultsContainer: document.getElementById('results-container'),
                    };

                            const bgContainer = document.getElementById('background-params-container');
        if (bgContainer) { 
            let bgHtml = '';
            const initialBgValues = [100, 5, 0, 0, 0, 0]; // Initial guess for B0 to B5.. on estime mieux (le 4 oct, version 2.3)
            for (let i = 0; i < 6; i++) {
                bgHtml += `
                    <label class="control-label">B${i}</label>
                    <input type="number" id="param-b${i}" value="${initialBgValues[i]}" step="1" class="control-input">
                    <input type="checkbox" id="fit-b${i}" class="fit-checkbox" checked>
                `;
            }
            bgContainer.innerHTML = bgHtml;
        }

        // --- Global State ---
        let profileParamCache = { "3": {}, "4": {} };
        let currentProfile = "4";
        let fullExperimentalData = { tth: [], intensity: [] };
        let calculatedBackground = [];
        let workingDataCache = { tth: [], intensity: [], background: [], isValid: false };
        let fitResults = null;
        let mainChart;
        let isFitting = false;
        let lastGeneratedHklList = [];
        let backgroundAnchors = []; // Stores {tth, y} objects
        const HIGH_WEIGHT_MULTIPLIER = 50.0
         let masterHklList = [];


          const spaceGroups = [
    //modifié le 5 oct, quelques erreurs dans les règles, eg TiO2, 136
    // --- Triclinic ---
    {"number": 1, "name": "P1", "system": "triclinic", "laue_class": "-1", "rule_tree": {}},
    {"number": 2, "name": "P-1", "system": "triclinic", "laue_class": "-1", "rule_tree": {}},
    // --- Monoclinic ---
    {"number": 3, "name": "P2", "system": "monoclinic", "laue_class": "2/m", "rule_tree": {}},
    {"number": 4, "name": "P21", "system": "monoclinic", "laue_class": "2/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}},
    {"number": 5, "name": "C2", "system": "monoclinic", "laue_class": "2/m", "rule_tree": {"type": "expression_check", "expression": "h+k", "divisor": 2}},
    {"number": 6, "name": "Pm", "system": "monoclinic", "laue_class": "2/m", "rule_tree": {}},
    {"number": 7, "name": "Pc", "system": "monoclinic", "laue_class": "2/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 8, "name": "Cm", "system": "monoclinic", "laue_class": "2/m", "rule_tree": {"type": "expression_check", "expression": "h+k", "divisor": 2}},
    {"number": 9, "name": "Cc", "system": "monoclinic", "laue_class": "2/m", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 10, "name": "P2/m", "system": "monoclinic", "laue_class": "2/m", "rule_tree": {}},
    {"number": 11, "name": "P21/m", "system": "monoclinic", "laue_class": "2/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}},
    {"number": 12, "name": "C2/m", "system": "monoclinic", "laue_class": "2/m", "rule_tree": {"type": "expression_check", "expression": "h+k", "divisor": 2}},
    {"number": 13, "name": "P2/c", "system": "monoclinic", "laue_class": "2/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 14, "name": "P21/c", "system": "monoclinic", "laue_class": "2/m", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 15, "name": "C2/c", "system": "monoclinic", "laue_class": "2/m", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    // --- Orthorhombic ---
    {"number": 16, "name": "P222", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {}},
    {"number": 17, "name": "P2221", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 18, "name": "P21212", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 19, "name": "P212121", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 20, "name": "C2221", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 21, "name": "C222", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"type": "expression_check", "expression": "h+k", "divisor": 2}},
    {"number": 22, "name": "F222", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}},
    {"number": 23, "name": "I222", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},
    {"number": 24, "name": "I212121", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 25, "name": "Pmm2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {}},
    {"number": 26, "name": "Pmc21", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 27, "name": "Pcc2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 28, "name": "Pma2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}},
    {"number": 29, "name": "Pca21", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 30, "name": "Pnc2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 31, "name": "Pmn21", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 32, "name": "Pba2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}},
    {"number": 33, "name": "Pna21", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k+l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}]}},
    {"number": 34, "name": "Pnn2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "h+l", "divisor": 2}]}},
    {"number": 35, "name": "Cmm2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"type": "expression_check", "expression": "h+k", "divisor": 2}},
    {"number": 36, "name": "Cmc21", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 37, "name": "Ccc2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 38, "name": "Amm2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"type": "expression_check", "expression": "k+l", "divisor": 2}},
    {"number": 39, "name": "Abm2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 40, "name": "Ama2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}]}},
    {"number": 41, "name": "Aea2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 42, "name": "Fmm2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}},
    {"number": 43, "name": "Fdd2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k+l", "divisor": 4}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "h+l", "divisor": 4}]}]}},
    {"number": 44, "name": "Imm2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},
    {"number": 45, "name": "Iba2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 46, "name": "Ima2", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}]}},
    {"number": 47, "name": "Pmmm", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {}},
    {"number": 48, "name": "Pnnn", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k+l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "h+l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}]}},
    {"number": 49, "name": "Pccm", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 50, "name": "Pban", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}]}},
    {"number": 51, "name": "Pmma", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}},
    {"number": 52, "name": "Pnna", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k+l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}]}},
    {"number": 53, "name": "Pmna", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 54, "name": "Pcca", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}]}},
    {"number": 55, "name": "Pbam", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}},
    {"number": 56, "name": "Pccn", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k+l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "h+l", "divisor": 2}]}]}},
    {"number": 57, "name": "Pbcm", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 58, "name": "Pnnm", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "h+l", "divisor": 2}]}},
    {"number": 59, "name": "Pmmn", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 60, "name": "Pbcn", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}]}},
    {"number": 61, "name": "Pbca", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}]}},
    {"number": 62, "name": "Pnma", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k+l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}]}},
    {"number": 63, "name": "Cmcm", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 64, "name": "Cmce", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"logic": "AND", "rules": [{"type": "expression_check", "expression": "k", "divisor": 2}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 65, "name": "Cmmm", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"type": "expression_check", "expression": "h+k", "divisor": 2}},
    {"number": 66, "name": "Cccm", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 67, "name": "Cmma", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}]}},
    {"number": 68, "name": "Ccca", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}]}},
    {"number": 69, "name": "Fmmm", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}},
    {"number": 70, "name": "Fddd", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k+l", "divisor": 4}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "h+l", "divisor": 4}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 4}]}]}},
    {"number": 71, "name": "Immm", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},
    {"number": 72, "name": "Ibam", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 73, "name": "Ibca", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 74, "name": "Imma", "system": "orthorhombic", "laue_class": "mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k+l", "divisor": 2}]}]}},
    // --- Tetragonal ---
    {"number": 75, "name": "P4", "system": "tetragonal", "laue_class": "4/m", "rule_tree": {}},
    {"number": 76, "name": "P41", "system": "tetragonal", "laue_class": "4/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 4}]}},
    {"number": 77, "name": "P42", "system": "tetragonal", "laue_class": "4/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 78, "name": "P43", "system": "tetragonal", "laue_class": "4/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 4}]}},
    {"number": 79, "name": "I4", "system": "tetragonal", "laue_class": "4/m", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},
    {"number": 80, "name": "I41", "system": "tetragonal", "laue_class": "4/m", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 4}]}]}},
    {"number": 81, "name": "P-4", "system": "tetragonal", "laue_class": "4/m", "rule_tree": {}},
    {"number": 82, "name": "I-4", "system": "tetragonal", "laue_class": "4/m", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},
    {"number": 83, "name": "P4/m", "system": "tetragonal", "laue_class": "4/m", "rule_tree": {}},
    {"number": 84, "name": "P42/m", "system": "tetragonal", "laue_class": "4/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 85, "name": "P4/n", "system": "tetragonal", "laue_class": "4/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}},
    {"number": 86, "name": "P42/n", "system": "tetragonal", "laue_class": "4/m", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 87, "name": "I4/m", "system": "tetragonal", "laue_class": "4/m", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},

    {"number": 88, "name": "I41/a", "system": "tetragonal", "laue_class": "4/m", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 4}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hhl", "inverse": true}, {"type": "expression_check", "expression": "2h+l", "divisor": 4}]}]}},
    
    {"number": 89, "name": "P422", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 90, "name": "P4212", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}},
    {"number": 91, "name": "P4122", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 4}]}},
    {"number": 92, "name": "P41212", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 4}]}]}},
    {"number": 93, "name": "P4222", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 94, "name": "P42212", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}},
    {"number": 95, "name": "P4322", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 4}]}},
    {"number": 96, "name": "P43212", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 4}]}]}},
    {"number": 97, "name": "I422", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},
    {"number": 98, "name": "I4122", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 4}]}]}},
    {"number": 99, "name": "P4mm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {}},
    {"number": 100, "name": "P4bm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}},
    {"number": 101, "name": "P42cm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}},
    {"number": 102, "name": "P42nm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}]}},
    {"number": 103, "name": "P4cc", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 104, "name": "P4nc", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}},
    {"number": 105, "name": "P42mc", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 106, "name": "P42bc", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 107, "name": "I4mm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},
    {"number": 108, "name": "I4cm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}]}},
    {"number": 109, "name": "I41md", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hhl", "inverse": true}, {"type": "expression_check", "expression": "2h+l", "divisor": 4}]}]}},
    {"number": 110, "name": "I41cd", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hhl", "inverse": true}, {"type": "expression_check", "expression": "2h+l", "divisor": 4}]}]}},
    {"number": 111, "name": "P-42m", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}},
    {"number": 112, "name": "P-42c", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 113, "name": "P-421m", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {}},
    {"number": 114, "name": "P-421c", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 115, "name": "P-4m2", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {}},
    {"number": 116, "name": "P-4c2", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 117, "name": "P-4b2", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}},
    {"number": 118, "name": "P-4n2", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}},
    {"number": 119, "name": "I-4m2", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},
    {"number": 120, "name": "I-4c2", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 121, "name": "I-42m", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 122, "name": "I-42d", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hhl", "inverse": true}, {"type": "expression_check", "expression": "2h+l", "divisor": 4}]}]}},
    {"number": 123, "name": "P4/mmm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {}},
    {"number": 124, "name": "P4/mcc", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 125, "name": "P4/nbm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 126, "name": "P4/nnc", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}},
    {"number": 127, "name": "P4/mbm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}},
    {"number": 128, "name": "P4/mnc", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "h+l", "divisor": 2}]}},
    {"number": 129, "name": "P4/nmm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}},
    {"number": 130, "name": "P4/ncc", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 131, "name": "P42/mmc", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 132, "name": "P42/mcm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0k0", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}]}},
    {"number": 133, "name": "P42/nbc", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 134, "name": "P42/nnm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "h+l", "divisor": 2}]}]}},
    {"number": 135, "name": "P42/mbc", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    
    {"number": 136, "name": "P42/mnm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    
    {"number": 137, "name": "P42/nmc", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h", "divisor": 2}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}]}},
    {"number": 138, "name": "P42/ncm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "h+l", "divisor": 2}]}]}},
    {"number": 139, "name": "I4/mmm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},
    {"number": 140, "name": "I4/mcm", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},

{"number": 141, "name": "I41/amd", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hhl", "inverse": true}, {"type": "expression_check", "expression": "2h+l", "divisor": 4}]}]}},
{"number": 142, "name": "I41/acd", "system": "tetragonal", "laue_class": "4/mmm", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"logic": "AND", "rules": [{"type": "expression_check", "expression": "k", "divisor": 2}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hhl", "inverse": true}, {"type": "expression_check", "expression": "2h+l", "divisor": 4}]}]}},

// --- Trigonal --- (Hexagonal Axes)
    {"number": 143, "name": "P3", "system": "trigonal", "laue_class": "-3", "rule_tree": {}},
    {"number": 144, "name": "P31", "system": "trigonal", "laue_class": "-3", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 3}]}},
    {"number": 145, "name": "P32", "system": "trigonal", "laue_class": "-3", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 3}]}},
    {"number": 146, "name": "R3", "system": "trigonal", "laue_class": "-3", "rule_tree": {"type": "expression_check", "expression": "-h+k+l", "divisor": 3}},
    {"number": 147, "name": "P-3", "system": "trigonal", "laue_class": "-3", "rule_tree": {}},
    {"number": 148, "name": "R-3", "system": "trigonal", "laue_class": "-3", "rule_tree": {"type": "expression_check", "expression": "-h+k+l", "divisor": 3}},
    {"number": 149, "name": "P312", "system": "trigonal", "laue_class": "-3m", "rule_tree": {}},
    {"number": 150, "name": "P321", "system": "trigonal", "laue_class": "-3m", "rule_tree": {}},
    {"number": 151, "name": "P3112", "system": "trigonal", "laue_class": "-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 3}]}},
    {"number": 152, "name": "P3121", "system": "trigonal", "laue_class": "-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 3}]}},
    {"number": 153, "name": "P3212", "system": "trigonal", "laue_class": "-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 3}]}},
    {"number": 154, "name": "P3221", "system": "trigonal", "laue_class": "-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 3}]}},
    {"number": 155, "name": "R32", "system": "trigonal", "laue_class": "-3m", "rule_tree": {"type": "expression_check", "expression": "-h+k+l", "divisor": 3}},
    {"number": 156, "name": "P3m1", "system": "trigonal", "laue_class": "-3m", "rule_tree": {}},
    {"number": 157, "name": "P31m", "system": "trigonal", "laue_class": "-3m", "rule_tree": {}},
    {"number": 158, "name": "P3c1", "system": "trigonal", "laue_class": "-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 159, "name": "P31c", "system": "trigonal", "laue_class": "-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 160, "name": "R3m", "system": "trigonal", "laue_class": "-3m", "rule_tree": {"type": "expression_check", "expression": "-h+k+l", "divisor": 3}},
    {"number": 161, "name": "R3c", "system": "trigonal", "laue_class": "-3m", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "-h+k+l", "divisor": 3}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 162, "name": "P-31m", "system": "trigonal", "laue_class": "-3m", "rule_tree": {}},
    {"number": 163, "name": "P-31c", "system": "trigonal", "laue_class": "-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 164, "name": "P-3m1", "system": "trigonal", "laue_class": "-3m", "rule_tree": {}},
    {"number": 165, "name": "P-3c1", "system": "trigonal", "laue_class": "-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 166, "name": "R-3m", "system": "trigonal", "laue_class": "-3m", "rule_tree": {"type": "expression_check", "expression": "-h+k+l", "divisor": 3}},
    {"number": 167, "name": "R-3c", "system": "trigonal", "laue_class": "-3m", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "-h+k+l", "divisor": 3}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    // --- Hexagonal ---
    {"number": 168, "name": "P6", "system": "hexagonal", "laue_class": "6/m", "rule_tree": {}},
    {"number": 169, "name": "P61", "system": "hexagonal", "laue_class": "6/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 6}]}},
    {"number": 170, "name": "P65", "system": "hexagonal", "laue_class": "6/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 6}]}},
    {"number": 171, "name": "P62", "system": "hexagonal", "laue_class": "6/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 3}]}},
    {"number": 172, "name": "P64", "system": "hexagonal", "laue_class": "6/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 3}]}},
    {"number": 173, "name": "P63", "system": "hexagonal", "laue_class": "6/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 174, "name": "P-6", "system": "hexagonal", "laue_class": "6/m", "rule_tree": {}},
    {"number": 175, "name": "P6/m", "system": "hexagonal", "laue_class": "6/m", "rule_tree": {}},
    {"number": 176, "name": "P63/m", "system": "hexagonal", "laue_class": "6/m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 177, "name": "P622", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {}},
    {"number": 178, "name": "P6122", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 6}]}},
    {"number": 179, "name": "P6522", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 6}]}},
    {"number": 180, "name": "P6222", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 3}]}},
    {"number": 181, "name": "P6422", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 3}]}},
    {"number": 182, "name": "P6322", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 183, "name": "P6mm", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {}},
    {"number": 184, "name": "P6cc", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 185, "name": "P63cm", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 186, "name": "P63mc", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 187, "name": "P-6m2", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {}},
    {"number": 188, "name": "P-6c2", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 189, "name": "P-62m", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {}},
    {"number": 190, "name": "P-62c", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 191, "name": "P6/mmm", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {}},
    {"number": 192, "name": "P6/mcc", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}},
    {"number": 193, "name": "P63/mcm", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 194, "name": "P63/mmc", "system": "hexagonal", "laue_class": "6/mmm", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "h0l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "00l", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    // --- Cubic ---
    {"number": 195, "name": "P23", "system": "cubic", "laue_class": "m-3", "rule_tree": {}},
    {"number": 196, "name": "F23", "system": "cubic", "laue_class": "m-3", "rule_tree": {"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}},
    {"number": 197, "name": "I23", "system": "cubic", "laue_class": "m-3", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},
    {"number": 198, "name": "P213", "system": "cubic", "laue_class": "m-3", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}},
    {"number": 199, "name": "I213", "system": "cubic", "laue_class": "m-3", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}]}},
    {"number": 200, "name": "Pm-3", "system": "cubic", "laue_class": "m-3", "rule_tree": {}},

    {"number": 201, "name": "Pn-3", "system": "cubic", "laue_class": "m-3", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "hkl", "inverse": true}, {"type": "expression_check", "expression": "k+l", "divisor": 2}]}},
    
    {"number": 202, "name": "Fm-3", "system": "cubic", "laue_class": "m-3", "rule_tree": {"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}},
  
{"number": 203, "name": "Fd-3", "system": "cubic", "laue_class": "m-3", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k+l", "divisor": 4}]}]}},

    {"number": 204, "name": "Im-3", "system": "cubic", "laue_class": "m-3", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},
    {"number": 205, "name": "Pa-3", "system": "cubic", "laue_class": "m-3", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}},

    {"number": 206, "name": "Ia-3", "system": "cubic", "laue_class": "m-3", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"logic": "AND", "rules": [{"type": "expression_check", "expression": "k", "divisor": 2}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}]}},
   
    {"number": 207, "name": "P432", "system": "cubic", "laue_class": "m-3m", "rule_tree": {}},
    {"number": 208, "name": "P4232", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 2}]}},
    {"number": 209, "name": "F432", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}},
    {"number": 210, "name": "F4132", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 4}]}]}},
    {"number": 211, "name": "I432", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},
    {"number": 212, "name": "P4332", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 4}]}},
    {"number": 213, "name": "P4132", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 4}]}},
    {"number": 214, "name": "I4132", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "h00", "inverse": true}, {"type": "expression_check", "expression": "h", "divisor": 4}]}]}},
    {"number": 215, "name": "P-43m", "system": "cubic", "laue_class": "m-3m", "rule_tree": {}},
    {"number": 216, "name": "F-43m", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}},
    {"number": 217, "name": "I-43m", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},
    {"number": 218, "name": "P-43n", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "hhl", "inverse": true}, {"type": "expression_check", "expression": "h+l", "divisor": 2}]}},
    {"number": 219, "name": "F-43c", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hhl", "inverse": true}, {"type": "expression_check", "expression": "h+l", "divisor": 2}]}]}},
    {"number": 220, "name": "I-43d", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hhl", "inverse": true}, {"type": "expression_check", "expression": "2h+l", "divisor": 4}]}]}},
    {"number": 221, "name": "Pm-3m", "system": "cubic", "laue_class": "m-3m", "rule_tree": {}},
    {"number": 222, "name": "Pn-3n", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k+l", "divisor": 2}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hhl", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 223, "name": "Pm-3n", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "hk0", "inverse": true}, {"type": "expression_check", "expression": "h+k", "divisor": 2}]}},
  
{"number": 224, "name": "Pn-3m", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k+l", "divisor": 2}]}},
    
    {"number": 225, "name": "Fm-3m", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}},
    {"number": 226, "name": "Fm-3c", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hhl", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},

    {"number": 227, "name": "Fd-3m", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k+l", "divisor": 4}]}]}},

{"number": 228, "name": "Fd-3c", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "AND", "rules": [{"logic": "OR", "rules": [{"type": "parity", "rule": "all_even"}, {"type": "parity", "rule": "all_odd"}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"type": "expression_check", "expression": "k+l", "divisor": 4}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hhl", "inverse": true}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}},
    {"number": 229, "name": "Im-3m", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"type": "expression_check", "expression": "h+k+l", "divisor": 2}},
    {"number": 230, "name": "Ia-3d", "system": "cubic", "laue_class": "m-3m", "rule_tree": {"logic": "AND", "rules": [{"type": "expression_check", "expression": "h+k+l", "divisor": 2}, {"logic": "OR", "rules": [{"type": "family_check", "family": "0kl", "inverse": true}, {"logic": "AND", "rules": [{"type": "expression_check", "expression": "k", "divisor": 2}, {"type": "expression_check", "expression": "l", "divisor": 2}]}]}, {"logic": "OR", "rules": [{"type": "family_check", "family": "hhl", "inverse": true}, {"type": "expression_check", "expression": "2h+l", "divisor": 4}]}]}}
];
   
   

         updateSpaceGroupUI();

// ANCHORs MANAGEMENT
        function updateAnchorPointsOnChart() {
            if (!mainChart) return;

            const anchorDataset = mainChart.data.datasets.find(d => d.label === 'Anchor Points');
            if (anchorDataset) {
                // Map the anchors to the {x, y} format required by Chart.js scatter plots
                anchorDataset.data = backgroundAnchors.map(anchor => ({
                    x: anchor.tth,
                    y: anchor.y
                }));
               mainChart.update('none'); // Redraw the chart without animation
            }
        }

        // function to find the nearest data point to a click
        function findClosestExperimentalPoint(targetTth) {
            if (!fullExperimentalData || fullExperimentalData.tth.length === 0) {
                return null;
            }

            let closestIndex = -1;
            let minDiff = Infinity;

            // This is a simple linear search. .. j'aurais pu utiliser la librairie JS.. mais bon, c'est autonome
            for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                const diff = Math.abs(fullExperimentalData.tth[i] - targetTth);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIndex = i;
                }
            }

            return {
                index: closestIndex,
                tth: fullExperimentalData.tth[closestIndex],
                y: fullExperimentalData.intensity[closestIndex]
            };
        }

        // display non-editable points
        function renderAnchorList() {
            const listContainer = document.getElementById('anchor-points-list');
            listContainer.innerHTML = ''; 

            if (backgroundAnchors.length === 0) {
                listContainer.innerHTML = '<p class="control-label" style="text-align: center;">No anchor points defined.</p>';
            } else {
                backgroundAnchors.forEach((anchor, index) => {
                    const item = document.createElement('div');
                    item.className = 'anchor-point-item';
                    // Display values as text, not inputs
                    item.innerHTML = `
                        <span title="2-theta">${anchor.tth.toFixed(3)}</span>
                        <span title="Intensity">${anchor.y.toFixed(1)}</span>
                        <button class="anchor-remove-btn" data-index="${index}" title="Remove point">&times;</button>
                    `;
                    listContainer.appendChild(item);
                });
            }
            updateAnchorPointsOnChart();
        }

        // Simplified function to only handle removing points
        function handleAnchorListInteraction(e) {
            if (e.target.classList.contains('anchor-remove-btn')) {
                const index = parseInt(e.target.dataset.index, 10);
                if (!isNaN(index)) {
                    backgroundAnchors.splice(index, 1);
                    renderAnchorList();
                    updateBackgroundForPreview();
                }
            }
        }
    


   function calculateChebyshevBackground(tthAxis, backgroundParams) {
            const tthMin = tthAxis[0];
            const tthMax = tthAxis[tthAxis.length - 1];
            const tthRange = tthMax - tthMin;
            if (tthRange <= 0) return new Array(tthAxis.length).fill(0);

            const coefficients = [];
            for (let i = 0; i < 5; i++) { // Look for up to N coefficients
                if (backgroundParams[`B${i}`] !== undefined) {
                    coefficients[i] = backgroundParams[`B${i}`];
                }
            }
            if (coefficients.length === 0) return new Array(tthAxis.length).fill(0);

            return tthAxis.map(tth => {
                // Scale 2-theta to the required [-1, 1] range
                const x_prime = (2 * (tth - tthMin) / tthRange) - 1;

                // Calculate the Chebyshev polynomials T_n(x') iteratively
                let t_n_minus_1 = 1; // T_0(x)
                let t_n = x_prime;     // T_1(x)
                
                let backgroundValue = (coefficients[0] || 0) * t_n_minus_1;
                if (coefficients.length > 1) {
                    backgroundValue += (coefficients[1] || 0) * t_n;
                }

                for (let n = 2; n < coefficients.length; n++) {
                    const t_n_plus_1 = 2 * x_prime * t_n - t_n_minus_1;
                    backgroundValue += (coefficients[n] || 0) * t_n_plus_1;
                    t_n_minus_1 = t_n;
                    t_n = t_n_plus_1;
                }
                return backgroundValue;
            });
        }

        function calculateAmorphousHump(tthAxis, humpParams) {
            const height = humpParams.hump_H || 0;
            if (height === 0) return new Array(tthAxis.length).fill(0);
            
            const position = humpParams.hump_P || 0;
            const fwhm = humpParams.hump_W || 1;
            const hwhm_sq = (fwhm / 2) * (fwhm / 2);
            if (hwhm_sq === 0) return new Array(tthAxis.length).fill(0);

            return tthAxis.map(tth => {
                const diff = tth - position;
                return height / (1 + (diff * diff) / hwhm_sq);
            });
        }

        function calculateTotalBackground(tthAxis, params) {
            const chebyshevParams = {};
            const humpParams = {};
            
            for(const key in params) {
                if(key.startsWith('B')) chebyshevParams[key] = params[key];
                if(key.startsWith('hump_')) humpParams[key] = params[key];
            }

            const chebyshevBG = calculateChebyshevBackground(tthAxis, chebyshevParams);
            const humpBG = calculateAmorphousHump(tthAxis, humpParams);

            return chebyshevBG.map((val, i) => val + humpBG[i]);
        }


        function updateStephensAnisotropyUI() {
            const { system } = getSystemAndCentering();
            const sParams = { s400: { input: controls.paramS400, fit: controls.fitS400 }, s040: { input: controls.paramS040, fit: controls.fitS040 }, s004: { input: controls.paramS004, fit: controls.fitS004 }, s220: { input: controls.paramS220, fit: controls.fitS220 }, s202: { input: controls.paramS202, fit: controls.fitS202 }, s022: { input: controls.paramS022, fit: controls.fitS022 }, };
            for (const key in sParams) { sParams[key].input.disabled = false; sParams[key].fit.disabled = false; sParams[key].input.style.backgroundColor = ''; }
            switch (system) {
                case 'cubic':
                    sParams.s040.input.value = sParams.s400.input.value; sParams.s004.input.value = sParams.s400.input.value; sParams.s040.fit.checked = sParams.s400.fit.checked; sParams.s004.fit.checked = sParams.s400.fit.checked; sParams.s202.input.value = sParams.s220.input.value; sParams.s022.input.value = sParams.s220.input.value; sParams.s202.fit.checked = sParams.s220.fit.checked; sParams.s022.fit.checked = sParams.s220.fit.checked;
                    [sParams.s040, sParams.s004, sParams.s202, sParams.s022].forEach(p => { p.input.disabled = true; p.fit.disabled = true; p.input.style.backgroundColor = 'var(--system-gray-5)'; });
                    break;
                case 'hexagonal': case 'tetragonal': case 'rhombohedral':
                    sParams.s040.input.value = sParams.s400.input.value; sParams.s040.fit.checked = sParams.s400.fit.checked; sParams.s022.input.value = sParams.s202.input.value; sParams.s022.fit.checked = sParams.s202.fit.checked;
                    [sParams.s040, sParams.s022].forEach(p => { p.input.disabled = true; p.fit.disabled = true; p.input.style.backgroundColor = 'var(--system-gray-5)'; });
                    break;
            }
        }

        const verticalCursorLine = { id: 'verticalCursorLine', afterDraw: chart => { if (chart.tooltip?._active?.length) { let x = chart.tooltip._active[0].element.x, yAxis = chart.scales.y, ctx = chart.ctx; ctx.save(); ctx.beginPath(); ctx.moveTo(x, yAxis.top); ctx.lineTo(x, yAxis.bottom); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)'; ctx.setLineDash([4, 4]); ctx.stroke(); ctx.restore(); } } };
        Chart.register(verticalCursorLine);
        Chart.Tooltip.positioners.experimentalAnchor = function(items) { if (!items.length) return false; const experimentalItem = items.find(item => item.datasetIndex === 0) || items[0]; return { x: experimentalItem.element.x, y: experimentalItem.element.y }; };
        
                function getSystemAndCentering() {
            let [system, centering] = controls.bravaisLattice.value.split('_');
            // 9. r Rhombohedral, maille hex
            if (system === "rhombohedral") {
                centering = "R"; // Force centering to 'R' for rhombohedral system
            }
            return { system, centering };
        }

        function saveProfileState(profileId) { const state = {}; const container = document.getElementById((profileId === '4') ? 'simple-pvoigt-params-container' : 'anisotropy-params-container'); if (container) container.querySelectorAll('input[type="number"], input[type="checkbox"]').forEach(input => { state[input.id] = (input.type === 'checkbox') ? input.checked : input.value; }); profileParamCache[profileId] = state; }
        function restoreProfileState(profileId) { const state = profileParamCache[profileId]; if (!state || Object.keys(state).length === 0) return; const container = document.getElementById((profileId === '4') ? 'simple-pvoigt-params-container' : 'anisotropy-params-container'); if (container) container.querySelectorAll('input[type="number"], input[type="checkbox"]').forEach(input => { if (state[input.id] !== undefined) input.type === 'checkbox' ? (input.checked = state[input.id]) : (input.value = state[input.id]); }); }
        
        // Data mapping systems to their possible Laue classes...peut etre mieux de les mettres dans la const spaceGroups ?
        const laueClassMap = {
            'cubic': [{ value: 'm-3m', text: 'm-3m' }, { value: 'm-3', text: 'm-3' }],
            'hexagonal': [{ value: '6/mmm', text: '6/mmm' }, { value: '6/m', text: '6/m' }],
            'rhombohedral': [{ value: '-3m', text: '-3m (Rhom. axes)' }, { value: '-3', text: '-3 (Rhom. axes)' }],
            'tetragonal': [{ value: '4/mmm', text: '4/mmm' }, { value: '4/m', text: '4/m' }],
            'orthorhombic': [{ value: 'mmm', text: 'mmm' }],
            'monoclinic': [{ value: '2/m', text: '2/m' }],
        };


function getSpaceGroupCentering(spaceGroupName) {
    const firstLetter = spaceGroupName.charAt(0).toUpperCase();
    if (firstLetter === "R") return "R"; // rhombohedral
    return firstLetter; // P, I, F, C, A, etc.
}


function updateSpaceGroupUI() {
            const { system } = getSystemAndCentering();
            if (!spaceGroups.length) return; // Wait until data is defined

            const filteredGroups = spaceGroups.filter(sg => {
                // 9. Rhombohedral: search for 'R' groups under the 'hexagonal' system
                if (system === 'rhombohedral') {
                    return sg.system === 'hexagonal' && sg.name.startsWith('R');
                }
                
                // Logic for all other 
                const selectedCentering = controls.bravaisLattice.value.split('_')[1];
                const sgCentering = sg.name.charAt(0).toUpperCase();
                return sg.system === system && sgCentering === selectedCentering;
            });

            controls.spaceGroupSelect.innerHTML = "";
            filteredGroups.forEach(sg => {
                const opt = document.createElement("option");
                opt.value = sg.number;
                opt.textContent = `${sg.number} – ${sg.name}`;
                controls.spaceGroupSelect.appendChild(opt);
            });
        }

        function calculateAmorphousHump(tthAxis, humpParams) {
            const height = humpParams.hump_H || 0;
            if (height === 0) return new Array(tthAxis.length).fill(0);
            
            const position = humpParams.hump_P || 0;
            const fwhm = humpParams.hump_W || 1;
            const hwhm_sq = (fwhm / 2) * (fwhm / 2);
            if (hwhm_sq === 0) return new Array(tthAxis.length).fill(0);

            return tthAxis.map(tth => {
                const diff = tth - position;
                return height / (1 + (diff * diff) / hwhm_sq);
            });
        }

        function calculateTotalBackground(tthAxis, params) {
            const chebyshevParams = {};
            const humpParams = {};
            
            for(const key in params) {
                if(key.startsWith('B')) chebyshevParams[key] = params[key];
                if(key.startsWith('hump_')) humpParams[key] = params[key];
            }

            const chebyshevBG = calculateChebyshevBackground(tthAxis, chebyshevParams);
            const humpBG = calculateAmorphousHump(tthAxis, humpParams);

            return chebyshevBG.map((val, i) => val + humpBG[i]);
        }


        function updateLatticeParamUI() {
            const currentValues = {}; const container = controls.latticeParamsContainer;
            container.querySelectorAll('input[type="number"]').forEach(input => { const name = input.id.replace('lattice-param-', ''); if (input.value) currentValues[name] = input.value; });
            const { system } = getSystemAndCentering(); container.innerHTML = '';
            const createInput = (name, label, defaultValue, step, isAngle = false) => {
                const valueToUse = currentValues[name] !== undefined ? currentValues[name] : defaultValue; const id_base = `lattice-param-${name}`; const unit = isAngle ? '°' : 'Å'; const minAttribute = isAngle ? '' : 'min="0.001"';
                const row = document.createElement('div'); row.className = 'parameter-grid-3col'; row.innerHTML = `<label for="${id_base}" class="control-label">${label} (${unit})</label><input type="number" id="${id_base}" value="${valueToUse}" step="${step}" class="control-input" ${minAttribute}><input type="checkbox" id="fit-lattice-${name}" class="fit-checkbox" title="Fit this parameter" checked>`; container.appendChild(row);
            };
            const params = { cubic: [{ name: 'a', label: 'a', value: 4.23, step: 0.001 }], tetragonal: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'c', label: 'c', value: 5.0, step: 0.001 }], orthorhombic: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'b', label: 'b', value: 5.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }], hexagonal: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }], rhombohedral: [{ name: 'a', label: 'a', value: 5.5, step: 0.001 }, { name: 'c', label: 'c', value: 15.0, step: 0.001 }], monoclinic: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'b', label: 'b', value: 5.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }, { name: 'beta', label: 'β', value: 105.0, step: 0.01, isAngle: true }] };
            if(params[system]) params[system].forEach(p => createInput(p.name, p.label, p.value, p.step, p.isAngle));
        }


        function updateUIForSystemChange() {
            updateLatticeParamUI();
            updateSpaceGroupUI();
            updateStephensAnisotropyUI();
        }

        // This event listener triggers all UI updates.
        controls.bravaisLattice.addEventListener('change', updateUIForSystemChange);

        const detectAndParseFile = (fileName, fileContent) => {
    const name = fileName.toLowerCase();
    const lines = fileContent.trim().split(/\r?\n/);
    const firstLine = lines.length > 0 ? lines[0].trim() : '';
    
    if (name.endsWith('.uxd') || firstLine.startsWith('_FILEVERSION')) return parseUxdFile(fileContent);
    if (name.endsWith('.xrdml') || (fileContent.includes('<?xml') && fileContent.includes('<xrdMeasurement'))) return parseXrdmlFile(fileContent);
    if (name.endsWith('.brml') || (fileContent.includes('<?xml') && fileContent.includes('<RawDataFile'))) return parseBrukerBrmlFile(fileContent);
    if (name.endsWith('.ras') || fileContent.toUpperCase().includes('*RAS_HEADER_START')) return parseRigakuRasFile(fileContent);
    if (name.endsWith('.udf')) return parsePhilipsUdfFile(fileContent);

    // GSAS detection logic
    const bankLine = lines.find(line => line.trim().toUpperCase().startsWith('BANK'));
    if (bankLine) {
        // XRA format has 'STD' on the same line as 'BANK'
        if (bankLine.toUpperCase().includes('STD')) {
            return parseGsasXraFile(fileContent);
        }
        // Otherwise, assume it's the ESD format (Y, sigY pairs)
        return parseGsasEsdFile(fileContent);
    }

    // Fallback to generic two-column parser
    return parseDataFile(fileContent);
};
        
        const parseDataFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; lines.forEach(line => { if (line.startsWith('#') || line.startsWith('//') || line.trim() === '') return; const parts = line.trim().split(/[\s,;]+/); if (parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } }); return { tth, intensity }; };
        const parseXrdmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing XRDML file."); } let wavelength = null; const kAlpha1Node = xmlDoc.querySelector("kAlpha1"); if (kAlpha1Node?.textContent) wavelength = parseFloat(kAlpha1Node.textContent); const intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts"); if (!intensityNode) throw new Error("Could not find <intensities> or <counts> in XRDML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]'); if (!positionsNode) throw new Error("Could not find <positions> in XRDML file."); const startPosNode = positionsNode.querySelector("startPosition"); const endPosNode = positionsNode.querySelector("endPosition"); if (!startPosNode || !endPosNode) throw new Error("Could not find start/end positions in XRDML."); const startPos = parseFloat(startPosNode.textContent); const endPos = parseFloat(endPosNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * (endPos - startPos) / (intensity.length - 1)); return { tth, intensity, wavelength }; };
        const parseBrukerBrmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing BRML file."); } let wavelength = null; const wlNode = xmlDoc.querySelector('usedWavelength'); if (wlNode) { const kAlpha1 = wlNode.getAttribute('kAlpha1'); if (kAlpha1) wavelength = parseFloat(kAlpha1); } const intensityNode = xmlDoc.querySelector("dataPoints > counts"); if (!intensityNode) throw new Error("No <counts> data found in BRML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const startPosNode = xmlDoc.querySelector('startPosition[axis="TwoTheta"]'); const stepSizeNode = xmlDoc.querySelector('increment[axis="TwoTheta"]'); if (!startPosNode || !stepSizeNode) throw new Error("Could not find scan parameters in BRML file."); const startPos = parseFloat(startPosNode.textContent); const stepSize = parseFloat(stepSizeNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * stepSize); return { tth, intensity, wavelength }; };
        const parseRigakuRasFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const upperLine = line.toUpperCase(); if (upperLine.startsWith('*WAVE_LENGTH') || upperLine.startsWith('*MEAS_COND_XG_WAVE_LENGTH')) { const parts = line.trim().split(/\s+/); if (parts.length > 1) { const wl = parseFloat(parts[1]); if (!isNaN(wl)) wavelength = wl; } } if (upperLine.startsWith('*RAS_INT_START')) { inDataSection = true; continue; } if (upperLine.startsWith('*RAS_INT_END')) break; if (inDataSection) { const parts = line.trim().split(/[\s,]+/); if (parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No data found in RAS file data section."); return { tth, intensity, wavelength }; };
        const parseGsasEsdFile = (text) => { const lines = text.trim().split(/\r?\n/); let wavelength = null; let startTth, stepSize; let dataStartIndex = -1; lines.forEach((line, index) => { const upperLine = line.toUpperCase(); if (upperLine.includes('WAVELENGTH')) { const match = line.match(/wavelength\s+([0-9.]+)/i); if (match && match[1]) wavelength = parseFloat(match[1]); } if (upperLine.startsWith('BANK')) { const parts = line.trim().split(/\s+/); if (parts.length >= 6 && parts[4].toUpperCase() === 'CONST') { startTth = parseFloat(parts[5]) / 100.0; stepSize = parseFloat(parts[6]) / 100.0; dataStartIndex = index + 1; } } }); if (startTth === undefined || stepSize === undefined) throw new Error("GSAS Parse Error: Could not find a valid 'BANK' line with CONST scan parameters."); if (dataStartIndex !== -1 && lines[dataStartIndex]?.toUpperCase().includes('STD')) dataStartIndex++; if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS Parse Error: Found scan parameters but no subsequent data lines."); const intensity = []; for (let i = dataStartIndex; i < lines.length; i++) { const parts = lines[i].trim().split(/\s+/); for (let j = 1; j < parts.length; j += 2) { const val = parseFloat(parts[j]); if (!isNaN(val)) intensity.push(val); } } if (intensity.length === 0) throw new Error("GSAS Parse Error: No intensity data could be parsed."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
        
        const parseGsasXraFile = (text) => {
    const lines = text.trim().split(/\r?\n/);
    let wavelength = null;
    let startTth, stepSize;
    let dataStartIndex = -1;
    lines.forEach((line, index) => {
        const upperLine = line.toUpperCase();
        if (upperLine.includes('WAVELENGTH')) {
            const match = line.match(/wavelength\s+([0-9.]+)/i);
            if (match && match[1]) wavelength = parseFloat(match[1]);
        }
        if (upperLine.startsWith('BANK')) {
            const parts = line.trim().split(/\s+/);
            // This format has CONST at index 4, start at 5, step at 6
            if (parts.length >= 7 && parts[4].toUpperCase() === 'CONST') {
                startTth = parseFloat(parts[5]) / 100.0;
                stepSize = parseFloat(parts[6]) / 100.0;
                dataStartIndex = index + 1; // Data starts on the next line
            }
        }
    });

    if (startTth === undefined || stepSize === undefined) throw new Error("GSAS XRA Parse Error: Could not find a valid 'BANK' line with CONST scan parameters.");
    if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS XRA Parse Error: Found scan parameters but no subsequent data lines.");

    const intensity = [];
    for (let i = dataStartIndex; i < lines.length; i++) {
        // Ignore blank lines that might be at the end of the file
        if (lines[i].trim() === '') continue;
        const parts = lines[i].trim().split(/\s+/);
        // This loop reads every value, as XRA format is intensity-only
        for (let j = 0; j < parts.length; j++) {
            const val = parseFloat(parts[j]);
            if (!isNaN(val)) intensity.push(val);
        }
    }
    if (intensity.length === 0) throw new Error("GSAS XRA Parse Error: No intensity data could be parsed.");
    const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize);
    return { tth, intensity, wavelength };
};
        
        const parseUxdFile = (text) => { const lines = text.trim().split(/\r?\n/); const intensity = []; let startTth, stepSize, wavelength; let inDataSection = false; for (const line of lines) { const trimmedLine = line.trim(); if (inDataSection) { const parts = trimmedLine.split(/\s+/); parts.forEach(part => { const val = parseFloat(part); if (!isNaN(val)) intensity.push(val); }); } else { if (trimmedLine.toUpperCase().startsWith('_START=')) startTth = parseFloat(trimmedLine.substring(7)); else if (trimmedLine.toUpperCase().startsWith('_STEPSIZE=')) stepSize = parseFloat(trimmedLine.substring(10)); else if (trimmedLine.toUpperCase().startsWith('_WL1=')) wavelength = parseFloat(trimmedLine.substring(5)); else if (trimmedLine.toUpperCase() === '_COUNTS') inDataSection = true; } } if (startTth === undefined || stepSize === undefined) throw new Error("Could not find _START and _STEPSIZE in UXD file."); if (intensity.length === 0) throw new Error("No intensity data found after _COUNTS in UXD file."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
        const parsePhilipsUdfFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const trimmedLine = line.trim(); if (trimmedLine.toUpperCase().startsWith('LAMBDA')) { const parts = trimmedLine.split('='); if (parts.length > 1) wavelength = parseFloat(parts[1]); } if (trimmedLine.toUpperCase() === '[DATA]') { inDataSection = true; continue; } if (trimmedLine.startsWith('[') && trimmedLine.toUpperCase() !== '[DATA]') inDataSection = false; if (inDataSection) { const parts = trimmedLine.split(/,/).map(p => p.trim()); if(parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No [Data] section found in UDF file."); return { tth, intensity, wavelength }; };



        // Global cache for the data used in fitting, 
        let workingData = {
            tth: [],
            intensity: [],
            weights: [],
            startIndex: 0, // Store the starting index from the full dataset
            lastRawDifference: [],
            isValid: false
        };

        /**
         * This function is the new single source of truth for refinement data.
         * It slices the fullExperimentalData based on slider values and, critically,
         * pre-calculates the weights array, correctly applying high weights for anchors.
         */
        function updateWorkingData() {
            if (fullExperimentalData.tth.length === 0) {
                workingData.isValid = false;
                return;
            }
            const minTth = parseFloat(controls.tthMinSlider.value);
            const maxTth = parseFloat(controls.tthMaxSlider.value);

            // Find the start and end indices in the master 'fullExperimentalData' array
            let startIndex = fullExperimentalData.tth.findIndex(t => t >= minTth);
            if (startIndex === -1) startIndex = 0;

            let endIndex = fullExperimentalData.tth.findIndex(t => t > maxTth);
            if (endIndex === -1) endIndex = fullExperimentalData.tth.length;

            // Slice the master arrays
            workingData.tth = fullExperimentalData.tth.slice(startIndex, endIndex);
            workingData.intensity = fullExperimentalData.intensity.slice(startIndex, endIndex);
            workingData.startIndex = startIndex; // Store the offset

            // Pre-calculate weights for this specific slice, weight points have different weight, je les modifie où ?
            const anchorIndices = new Set(backgroundAnchors.map(a => a.index));
            
            const yMax = Math.max(...workingData.intensity);
const floor = 0.001 * yMax; // Floor is 0.1% of maximum
workingData.weights = workingData.intensity.map((y, i) => {
    let weight = 1 / Math.max(floor, y);
    if (anchorIndices.has(startIndex + i)) {
        weight *= HIGH_WEIGHT_MULTIPLIER;
    }
    return weight;
});
         //   workingData.lastRawDifference = []
            workingData.isValid = true;
        }

        function evaluateExpression(expr, h, k, l) {
            switch (expr.trim()) {
                case 'h+k': return h + k;
                case 'k+l': return k + l;
                case 'h+l': return h + l;
                case 'h+k+l': return h + k + l;
                case '-h+k+l': return -h + k + l;
                case 'h-k+l': return h - k + l;
                case '2h+l': return 2 * h + l;
                case 'h': return h;
                case 'k': return k;
                case 'l': return l;
                default: return NaN; // Return NaN for unknown expressions
            }
        }

                function isReflectionAllowed(h, k, l, spaceGroupData) {
            const ruleNode = spaceGroupData.rule_tree;

            if (!ruleNode || Object.keys(ruleNode).length === 0) {
                return true;
            }

            const evaluateExpression = (expr, h, k, l) => {
                switch (expr.trim()) {
                    case 'h+k': return h + k;
                    case 'k+l': return k + l;
                    case 'h+l': return h + l;
                    case 'h+k+l': return h + k + l;
                    case '-h+k+l': return -h + k + l;
                    case '2h+l': return 2 * h + l;
                    case 'h': return h;
                    case 'k': return k;
                    case 'l': return l;
                    default: return NaN;
                }
            };

            const evaluateNode = (node) => {
                if (node.type) {
                    if (node.type === "family_check") {
                        let match = false;
                        if (node.family === '0kl' && h === 0 && k !== 0 && l !== 0) match = true;
                        else if (node.family === 'h0l' && k === 0 && h !== 0 && l !== 0) match = true;
                        else if (node.family === 'hk0' && l === 0 && h !== 0 && k !== 0) match = true;
                        else if (node.family === 'h00' && k === 0 && l === 0 && h !== 0) match = true;
                        else if (node.family === '0k0' && h === 0 && l === 0 && k !== 0) match = true;
                        else if (node.family === '00l' && h === 0 && k === 0 && l !== 0) match = true;
                        else if (node.family === 'hhl' && h === k && h !== 0 && l !== 0) match = true;
                        return node.inverse ? !match : match;
                    }
                    if (node.type === "parity") {
                        const isAllEven = h % 2 === 0 && k % 2 === 0 && l % 2 === 0;
                        const isAllOdd = h % 2 !== 0 && k % 2 !== 0 && l % 2 !== 0;
                        if (node.rule === "all_even") return isAllEven;
                        if (node.rule === "all_odd") return isAllOdd;
                    }
                    if (node.type === "expression_check") {
                        const value = evaluateExpression(node.expression, h, k, l);
                        return !isNaN(value) && value % node.divisor === 0;
                    }
                    return true;
                }

                if (node.logic === "AND") {
                    return node.rules.every(subNode => evaluateNode(subNode));
                }
                if (node.logic === "OR") {
                    return node.rules.some(subNode => evaluateNode(subNode));
                }
                return true;
            };

            return evaluateNode(ruleNode);
        }

        // 3. MASTER HKL LIST GENERATION
        function generateMasterHklList() {
            if (fullExperimentalData.tth.length === 0 || spaceGroups.length === 0) {
                masterHklList = [];
                return;
            }

            const selectedSgNumber = parseInt(controls.spaceGroupSelect.value, 10);
            const selectedSg = spaceGroups.find(sg => sg.number === selectedSgNumber);
            if (!selectedSg) {
                masterHklList = [];
                console.error("Cannot generate HKL list: selected space group not found.");
                return;
            }

            // Use the full range of the data to not miss any reflections, add buffer
            const maxTth = Math.max(...fullExperimentalData.tth) + 2.0;
            const params = getAllParams(); // Needed for lambda and an estimate of cell size

            const fullList = generateHKL(maxTth, params, selectedSg);
            
            // Store a simplified version containing only the immutable information
            masterHklList = fullList.map(peak => ({
                hkl_list: peak.hkl_list,
                multiplicity: peak.multiplicity,
                // Store the original h,k,l for accurate position recalculation
                h_orig: peak.h_orig,
                k_orig: peak.k_orig,
                l_orig: peak.l_orig
            }));
            
            // Trigger a preview update with the new list
            updatePreviewPattern();
        }

        //  2-THETA UPDATE FUNCTION

        function updateHklPositions(hklList, params, system) {
            const { a, b, c, alpha, beta, lambda } = params;
            if (!a || !lambda || a <= 0 || lambda <= 0) return;
            
            const deg2rad = Math.PI / 180;
            const alpha_rad = (alpha || 90) * deg2rad;
            const beta_rad = (beta || 90) * deg2rad;
            const cos_alpha = Math.cos(alpha_rad);
            const cos_beta = Math.cos(beta_rad);
            const sin_beta = Math.sin(beta_rad);

            hklList.forEach(peak => {
                if (!peak || peak.h_orig === undefined) return;
                const h = peak.h_orig;
                const k = peak.k_orig;
                const l = peak.l_orig;
                
                let inv_d_sq = 0;
                switch(system) {
                    case 'cubic': 
                        inv_d_sq = (h*h + k*k + l*l) / (a*a); 
                        break;
                    case 'tetragonal': 
                        const c_tet = c || a;
                        inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c_tet*c_tet); 
                        break;
                    case 'orthorhombic': 
                        const b_orth = b || a;
                        const c_orth = c || a;
                        inv_d_sq = (h*h)/(a*a) + (k*k)/(b_orth*b_orth) + (l*l)/(c_orth*c_orth); 
                        break;
                case 'hexagonal': 
                case 'rhombohedral': // Rhombohedral system uses the hexagonal formula
                    const c_hex = c || a;
                    inv_d_sq = 4 * (h*h + h*k + k*k) / (3 * a*a) + (l*l) / (c_hex*c_hex); 
                    break;
                    case 'monoclinic':
                        const b_mono = b || a;
                        const c_mono = c || a;
                        inv_d_sq = (1/(sin_beta*sin_beta)) * ((h*h)/(a*a) + (k*k*sin_beta*sin_beta)/(b_mono*b_mono) + (l*l)/(c_mono*c_mono) - (2*h*l*cos_beta)/(a*c_mono));
                        break;
                }
                
                if (inv_d_sq > 1e-12) {
                    const sinThetaSq = (lambda*lambda / 4) * inv_d_sq;
                    if (sinThetaSq <= 1 && sinThetaSq > 0) {
                        peak.tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                        peak.d = 1 / Math.sqrt(inv_d_sq);
                    } else {
                        peak.tth = null;
                        peak.d = null;
                    }
                } else {
                    peak.tth = null;
                    peak.d = null;
                }
            });
        }

        function updateBackgroundForPreview() {
            if (fullExperimentalData.tth.length === 0 || isFitting) return;

            const params = getAllParams();
            //  calculate the background based on the UI controls
            calculatedBackground = calculateTotalBackground(fullExperimentalData.tth, params);

            if (mainChart) {
                const backgroundDataset = mainChart.data.datasets.find(d => d.label === 'Background');
                if (backgroundDataset) {
                    backgroundDataset.data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: calculatedBackground[i] }));
                }
                //  update the manual simulation to reflect the new background
                updatePreviewPattern(); 
            }
        }

        function getMultiplicityAndCanonicalHKL(h, k, l, laue_class) {
            if (h === 0 && k === 0 && l === 0) {
                return { multiplicity: 1, canonical_hkl_obj: [0, 0, 0] };
            }

            let m = 0;
            switch (laue_class) {
                case 'm-3m':
                    if (h > k && k > l && l > 0) m = 48; else if (h === k && k > l && l > 0) m = 24; else if (h > k && k === l && l > 0) m = 24; else if (h > k && k > 0 && l === 0) m = 24; else if (h === k && k === l && l > 0) m = 8; else if (h === k && k > 0 && l === 0) m = 12; else if (h > 0 && k === 0 && l === 0) m = 6;
                    break;
                case 'm-3':
                    if (h > k && k > l && l > 0) m = 24; else if (h === k && k > l && l > 0) m = 12; else if (h > k && k === l && l > 0) m = 12; else if (h > k && k > 0 && l === 0) m = 12; else if (h === k && k === l && l > 0) m = 8; else if (h === k && k > 0 && l === 0) m = 6; else if (h > 0 && k === 0 && l === 0) m = 6;
                    break;
                case '6/mmm':
                    if (l > 0) { if (h > k && k > 0) m = 24; else if (h === k && k > 0) m = 12; else if (h > 0 && k === 0) m = 12; else if (h === 0 && k === 0) m = 2; } else { if (h > k && k > 0) m = 12; else if (h === k && k > 0) m = 6; else if (h > 0 && k === 0) m = 6; }
                    break;
                case '6/m':
                     if (l > 0) { if (h > 0 || k > 0) m = 12; else m = 2; } else { if (h > 0 || k > 0) m = 6; }
                    break;
                case '-3m':
                     if (h > k && k > l) m = 12; else if (h === k && k > l) m = 6; else if (h > k && k === l) m = 6; else if (h === k && k === l) m = 2;
                     break;
                case '-3':
                    m = 6; if (h === k && k === l) m = 2;
                    break;
                case '4/mmm':
                    if (l > 0) { if (h > k && k > 0) m = 16; else if (h === k && k > 0) m = 8; else if (h > 0 && k === 0) m = 8; else if (h === 0 && k === 0) m = 2; } else { if (h > k && k > 0) m = 8; else if (h === k && k > 0) m = 4; else if (h > 0 && k === 0) m = 4; }
                    break;
                case '4/m':
                    if (l > 0) { if (h > k && k > 0) m = 8; else if (h === k && k > 0) m = 4; else if (h > 0 && k === 0) m = 8; else if (h === 0 && k === 0) m = 2; } else { if (h > k && k > 0) m = 4; else if (h === k && k > 0) m = 4; else if (h > 0 && k === 0) m = 4; }
                    break;
                case 'mmm':
                    if (h > 0 && k > 0 && l > 0) m = 8; else if ((h > 0 && k > 0 && l === 0) || (h > 0 && k === 0 && l > 0) || (h === 0 && k > 0 && l > 0)) m = 4; else m = 2;
                    break;
                case '2/m':
                    if (k > 0 || l > 0) m = 4; else if (h > 0) m = 2;
                    break;
                case '-1':
                    m = 2;
                    break;
                default:
                    m = 1; // Failsafe
                    break;
            }
            return { multiplicity: m, canonical_hkl_obj: [h, k, l] };
        }


            function generateHKL(maxTth, params, selectedSg) {
            const { a, b, c, alpha, beta, lambda } = params;
            const { system, laue_class } = selectedSg;

            if (!a || !lambda || a <= 0 || lambda <= 0 || !laue_class) {
                return [];
            }

            const maxDimension = Math.max(a || 0, b || a, c || a);
            const maxIndex = Math.ceil(2 * maxDimension / lambda * Math.sin(maxTth * Math.PI / 360)) + 5;
            
            let uniqueReflections = [];
            const maxOtherIndex = Math.floor(maxIndex / 1.5);

            const loopAndAdd = (h, k, l) => {
                if (h === 0 && k === 0 && l === 0) return;
                if (isReflectionAllowed(h, k, l, selectedSg)) {
                    uniqueReflections.push({ h, k, l });
                }
            };
            // generates the asymmetric unit of reflections
            switch (laue_class) {
                case 'm-3m': case 'm-3':
                    for (let l = 0; l < maxIndex; l++) for (let k = l; k < maxIndex; k++) for (let h = k; h < maxIndex; h++) loopAndAdd(h, k, l);
                    break;
                case '6/mmm': case '6/m':
                    for (let l = 0; l < maxIndex; l++) for (let k = 0; k < maxIndex; k++) for (let h = k; h < maxIndex; h++) loopAndAdd(h, k, l);
                    break;
                case '-3m': case '-3':
                    for (let l = -maxOtherIndex; l < maxOtherIndex; l++) for (let k = l; k < maxIndex; k++) for (let h = k; h < maxIndex; h++) loopAndAdd(h, k, l);
                    break;
                case '4/mmm': case '4/m':
                    for (let l = 0; l < maxIndex; l++) for (let k = 0; k < maxIndex; k++) for (let h = k; h < maxIndex; h++) loopAndAdd(h, k, l);
                    break;
                case 'mmm':
                    for (let l = 0; l < maxIndex; l++) for (let k = 0; k < maxIndex; k++) for (let h = 0; h < maxIndex; h++) loopAndAdd(h, k, l);
                    break;
                case '2/m':
                    for (let k = 0; k < maxIndex; k++) for (let l = 0; l < maxIndex; l++) for (let h = -maxOtherIndex; h < maxIndex; h++) if (!((k === 0 && h < 0) || (l === 0 && h < 0))) loopAndAdd(h, k, l);
                    break;
                case '-1':
                    for (let k = 0; k < maxIndex; k++) for (let h = -maxOtherIndex; h < maxIndex; h++) for (let l = -maxOtherIndex; l < maxIndex; l++) if (!(k > 0 || l < 0)) loopAndAdd(h, k, l);
                    break;
                default:
                    console.warn(`Unknown laue class: ${laue_class}. Using default hkl generation.`);
                    for (let h = 0; h < maxIndex; h++) for (let k = 0; k < maxIndex; k++) for (let l = 0; l < maxIndex; l++) loopAndAdd(h, k, l);
                    break;
            }

            const finalReflections = [];
            const deg2rad = Math.PI / 180;
            const alpha_rad = (alpha || 90) * deg2rad;
            const beta_rad = (beta || 90) * deg2rad;

            for (const { h, k, l } of uniqueReflections) {
                let inv_d_sq = 0;
                switch (system) {
                    case 'cubic': { inv_d_sq = (h * h + k * k + l * l) / (a * a); break; }
                    case 'tetragonal': { const c_tet = c || a; inv_d_sq = (h * h + k * k) / (a * a) + (l * l) / (c_tet * c_tet); break; }
                    case 'orthorhombic': { const b_orth = b || a; const c_orth = c || a; inv_d_sq = (h * h) / (a * a) + (k * k) / (b_orth * b_orth) + (l * l) / (c_orth * c_orth); break; }
                    case 'hexagonal': { const c_hex = c || a; inv_d_sq = 4 * (h * h + h * k + k * k) / (3 * a * a) + (l * l) / (c_hex * c_hex); break; }
                    case 'rhombohedral': { const cos_alpha_rhomb = Math.cos(alpha_rad); const term1 = (h*h + k*k + l*l) * Math.pow(Math.sin(alpha_rad), 2); const term2 = 2 * (h*k + k*l + l*h) * (cos_alpha_rhomb*cos_alpha_rhomb - cos_alpha_rhomb); const denominator = a*a * (1 - 3*cos_alpha_rhomb*cos_alpha_rhomb + 2*Math.pow(cos_alpha_rhomb, 3)); if (Math.abs(denominator) > 1e-12) { inv_d_sq = (term1 + term2) / denominator; } break; }
                    case 'monoclinic': { const b_mono = b || a; const c_mono = c || a; const sin_beta = Math.sin(beta_rad); const cos_beta = Math.cos(beta_rad); inv_d_sq = (1 / (sin_beta * sin_beta)) * ((h * h) / (a * a) + (k * k * sin_beta * sin_beta) / (b_mono * b_mono) + (l * l) / (c_mono * c_mono) - (2 * h * l * cos_beta) / (a * c_mono)); break; }
                }

                if (inv_d_sq <= 1e-12) continue;
                const sinThetaSq = (lambda * lambda / 4) * inv_d_sq;
                if (sinThetaSq > 1 || sinThetaSq <= 0) continue;
                
                const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                if (tth > maxTth) continue;

                const d = 1 / Math.sqrt(inv_d_sq);
                const { multiplicity } = getMultiplicityAndCanonicalHKL(h, k, l, laue_class);
                finalReflections.push({ tth, d, hkl_list: [`(${h},${k},${l})`], multiplicity, intensity: 0, h_orig: h, k_orig: k, l_orig: l });
            }

            finalReflections.sort((a, b) => a.tth - b.tth);
            return finalReflections;
        }

        function calculatePeakShift(tth, params) { if (params.profileType === "4") { const thetaRad = tth * (Math.PI / 180) / 2; const cosTheta = Math.cos(thetaRad); const sin2Theta = Math.sin(2 * thetaRad); const displacementShift = -(params.shft / 1000) * cosTheta * (180 / Math.PI); const transparencyShift = params.trns * sin2Theta * (180 / Math.PI); return displacementShift + transparencyShift; } else { return 0; } }

function calculateProfileWidths(tth, hkl, params) {
    const profileType = params.profileType || controls.profileSelect.value || "4";
    const thetaRad = tth * (Math.PI / 180) / 2;
    const tanTheta = Math.tan(thetaRad);
    const cosTheta = Math.cos(thetaRad);
    
    let gamma_G = 0;
    let gamma_L = 0;
    
    if (profileType === "4") {
        // --- Simple pVoigt Calculation , a revoir ce truc
        const gamma_G_sq = (params.GU || 0) * tanTheta * tanTheta + 
                          (params.GV || 0) * tanTheta + 
                          (params.GW || 0) + 
                          (params.GP || 0) / (cosTheta * cosTheta);
        gamma_G = Math.sqrt(Math.max(1e-6, gamma_G_sq));
        gamma_L = (params.LX || 0) / cosTheta;

    } else {
        // --- TCH Profile Calculation (Profile 3) ---
        const gamma_G_sq = (params.U || 0) * tanTheta * tanTheta + 
                          (params.V || 0) * tanTheta + 
                          (params.W || 0);
        gamma_G = Math.sqrt(Math.max(1e-6, gamma_G_sq));
        gamma_L = (params.X || 0) * tanTheta + (params.Y || 0) / cosTheta;

        // Add anisotropic broadening only if using TCH profile
        if (profileType === "3" && hkl && hkl.d) {
            const d_inv_sq = 1 / (hkl.d * hkl.d);
            const [h_val, k_val, l_val] = hkl.hkl_list[0].replace(/[()]/g, '').split(',').map(Number);
            const h2 = h_val * h_val, k2 = k_val * k_val, l2 = l_val * l_val;
            
            let H_aniso = (params.S400 || 0) * h2 * h2 + 
                          (params.S040 || 0) * k2 * k2 + 
                          (params.S004 || 0) * l2 * l2 + 
                          (params.S220 || 0) * h2 * k2 + 
                          (params.S202 || 0) * h2 * l2 + 
                          (params.S022 || 0) * k2 * l2;
            H_aniso *= d_inv_sq * d_inv_sq;
            gamma_L += Math.abs(H_aniso) / 1000;
        }
    }
    
    return { gamma_G, gamma_L };
}



// pour calculer les surfaces des pics, pour les rapports
function getPseudoVoigtArea(gamma_G, gamma_L, params) {
    // Area of a Gaussian with FWHM = H_G is H_G * sqrt(pi / (4*ln(2)))
    const area_G = gamma_G * 1.0644677; // Pre-calculated constant
    // Area of a Lorentzian with FWHM = H_L is H_L * pi / 2
    const area_L = gamma_L * 1.5707963; // Pre-calculated constant

    let currentEta;
    if (params.profileType === "4") {
        currentEta = params.eta || 0.5;
    } else { // TCH profile logic to find its internal eta
        const fwhm_pow5 = Math.pow(gamma_G, 5) +
                          2.69269 * Math.pow(gamma_G, 4) * gamma_L +
                          2.42843 * Math.pow(gamma_G, 3) * Math.pow(gamma_L, 2) +
                          4.47163 * Math.pow(gamma_G, 2) * Math.pow(gamma_L, 3) +
                          0.07842 * gamma_G * Math.pow(gamma_L, 4) +
                          Math.pow(gamma_L, 5);
        const fwhm = Math.max(1e-9, Math.pow(fwhm_pow5, 0.2));
        const ratio = gamma_L / fwhm;
        const eta_calc = 1.36603 * ratio - 0.47719 * (ratio * ratio) + 0.11116 * Math.pow(ratio, 3);
        currentEta = Math.max(0, Math.min(1, eta_calc));
    }

    // The area of the pseudo-Voigt is the linear combination of the two areas
    return currentEta * area_L + (1 - currentEta) * area_G;
}


        //  pseudoVoigt function with proper profile handling
function pseudoVoigt(x, x0, tth_peak, gamma_G, gamma_L, params) {
    // Handle degenerate cases where width is zero
    if (gamma_G <= 1e-9 && gamma_L <= 1e-9) {
        return Math.abs(x - x0) < 1e-6 ? 1e10 : 0.0;
    }

    // Apply asymmetry correction to the peak position difference
    const corrected_delta = applyAsymmetry(x, x0, tth_peak, params);

    // For Simple pVoigt (profile 4), changé le 4 oct

        if (params.profileType === "4") {
     
            const currentEta = params.eta || 0.5;
        const Cg = 4 * Math.log(2); // Constant: 2.7725887...

        // Use the individual, separate FWHMs for each shape.
        const H_G = Math.max(1e-9, gamma_G); // Gaussian FWHM
        const H_L = Math.max(1e-9, gamma_L); // Lorentzian FWHM

        const gaussianShape = Math.exp(-Cg * Math.pow(corrected_delta / H_G, 2));
        const lorentzianShape = 1 / (1 + 4 * Math.pow(corrected_delta / H_L, 2));

        // Return the linear combination of the two independent shapes.
        return currentEta * lorentzianShape + (1 - currentEta) * gaussianShape;


    }
    // For TCH profile (profile 3): Use proper TCH formulas
    else {
        // TCH formula for combining FWHM
        const fwhm_pow5 = Math.pow(gamma_G, 5) +
                          2.69269 * Math.pow(gamma_G, 4) * gamma_L +
                          2.42843 * Math.pow(gamma_G, 3) * Math.pow(gamma_L, 2) +
                          4.47163 * Math.pow(gamma_G, 2) * Math.pow(gamma_L, 3) +
                          0.07842 * gamma_G * Math.pow(gamma_L, 4) +
                          Math.pow(gamma_L, 5);
        const fwhm = Math.pow(fwhm_pow5, 0.2);
        
        if (fwhm <= 1e-9) {
            return Math.abs(corrected_delta) < 1e-6 ? 1e10 : 0.0;
        }

        // TCH formula for eta
        const ratio = gamma_L / fwhm;
        const eta_calc = 1.36603 * ratio - 0.47719 * (ratio * ratio) + 0.11116 * Math.pow(ratio, 3);
        const currentEta = Math.max(0, Math.min(1, eta_calc));
        
        // Calculate shapes using TCH combined FWHM
        const Cg = 4 * Math.log(2);
        const gaussianShape = Math.exp(-Cg * Math.pow(corrected_delta / fwhm, 2));
        const lorentzianShape = 1 / (1 + 4 * Math.pow(corrected_delta / fwhm, 2));
        
        return currentEta * lorentzianShape + (1 - currentEta) * gaussianShape;
    }
}

        function applyAsymmetry(x, x0, tth_peak, params) { if (params.profileType === "4" || (!params.SL && !params.HL)) return x - x0; const delta_2theta = x - x0; if (Math.abs(delta_2theta) < 1e-9) return 0; const theta_rad = tth_peak * (Math.PI / 180) / 2.0; if (Math.abs(theta_rad - Math.PI / 2.0) < 1e-6) return delta_2theta; const cot_theta = 1.0 / Math.tan(theta_rad); const asymmetry_param = (params.SL || 0) * cot_theta + (params.HL || 0); const asymmetry_factor = 1.0 - (asymmetry_param / 100.0) * Math.sign(delta_2theta) * delta_2theta; return delta_2theta / Math.max(1e-6, asymmetry_factor); }


    function calculatePattern(tthAxis, hklList, params) {
    const pattern = new Array(tthAxis.length).fill(0);
    const n_points = tthAxis.length;
    const deg2rad = Math.PI / 180;

    // --- Calculate K-alpha 1 pattern ---
    hklList.forEach(peak => {
        if (!peak.intensity || peak.intensity <= 0 || !peak.tth) return;

        // K-alpha 1 position and widths
        const basePos1 = peak.tth + params.zeroShift;
        const shift1 = calculatePeakShift(basePos1, params);
        const peakPos1 = basePos1 + shift1;
        const { gamma_G, gamma_L } = calculateProfileWidths(basePos1, peak, params);

        //Calculate the area of the un-normalized shape function ***
        const shapeArea1 = getPseudoVoigtArea(gamma_G, gamma_L, params);

        // Determine the calculation window
        const window = 20 * Math.max(0.01, gamma_G + gamma_L);
        const min_tth = peakPos1 - window;
        const max_tth = peakPos1 + window;

        let startIndex = 0;
        while(startIndex < n_points && tthAxis[startIndex] < min_tth) startIndex++;

        // Add the peak shape to the pattern
        for (let i = startIndex; i < n_points; i++) {
            const current_tth = tthAxis[i];
            if (current_tth > max_tth) break;

            const intensityAtPoint = pseudoVoigt(current_tth, peakPos1, basePos1, gamma_G, gamma_L, params);
            
            // Normalize the shape by its area before scaling by integrated intensity
            if (shapeArea1 > 1e-9) {
                pattern[i] += peak.intensity * (intensityAtPoint / shapeArea1);
            }
        }
    });

    // --- Calculate and Add K-alpha 2 pattern (si 0 ou valeurs differentes)
    const doubletEnabled = params.ratio > 0 && params.lambda2 > 0 && Math.abs(params.lambda - params.lambda2) > 1e-6;
    if (doubletEnabled) {
        const lambdaRatio = params.lambda2 / params.lambda;

        hklList.forEach(peak => {
            if (!peak.intensity || peak.intensity <= 0 || !peak.tth) return;

            // Calculate K-alpha 2 position from K-alpha 1... la largeur est aussi un peu differente, mais bon, pas très differente
            const sinTheta1 = Math.sin(peak.tth * deg2rad / 2.0);
            if (Math.abs(sinTheta1) >= 1) return;
            
            const sinTheta2 = sinTheta1 * lambdaRatio;
            if (Math.abs(sinTheta2) >= 1) return;

            const tth2 = 2 * Math.asin(sinTheta2) / deg2rad;
            const basePos2 = tth2 + params.zeroShift;
            const shift2 = calculatePeakShift(basePos2, params);
            const peakPos2 = basePos2 + shift2;

            // Calculate NEW widths at the K-alpha 2 position... peut etre inutile
            const { gamma_G: gamma_G2, gamma_L: gamma_L2 } = calculateProfileWidths(basePos2, peak, params);
            
            // Calculate the area for the K-alpha 2 shape function 
            const shapeArea2 = getPseudoVoigtArea(gamma_G2, gamma_L2, params);

            // Determine the calculation window
            const window2 = 8 * Math.max(0.01, gamma_G2 + gamma_L2);
            const min_tth2 = peakPos2 - window2;
            const max_tth2 = peakPos2 + window2;

            let startIndex2 = 0;
            while(startIndex2 < n_points && tthAxis[startIndex2] < min_tth2) startIndex2++;

            // Add the K-alpha 2 peak shape to the pattern
            for (let i = startIndex2; i < n_points; i++) {
                const current_tth = tthAxis[i];
                if (current_tth > max_tth2) break;

                const intensityAtPoint = pseudoVoigt(current_tth, peakPos2, basePos2, gamma_G2, gamma_L2, params);

                // Normalize the shape and apply the intensity ratio ***
                if (shapeArea2 > 1e-9) {
                    pattern[i] += peak.intensity * params.ratio * (intensityAtPoint / shapeArea2);
                }
            }
        });
    }

    return pattern;
}

function redrawFitForNewRange() {
    // First, update the working data to the new slider range
    updateWorkingData();

    // If no fit has been run yet, just show a manual preview pattern
    if (!fitResults) {
        updatePreviewPattern();
        updatePlotRange(true);
        rescalePlot(false);
        mainChart.update('none');
        return;
    }

    // --- A fit exists, so redraw the fit results in the new range ---
    const params = fitResults.params;
    const scaleFactor = fitResults.stats.scaleFactor;
    
    // Recalculate the background and peak pattern for the new, sliced data range
    const background_sliced = calculateTotalBackground(workingData.tth, params);
    const unscaledPeakPattern_sliced = calculatePattern(workingData.tth, fitResults.hklList, params);
    const totalCalcPattern = unscaledPeakPattern_sliced.map((y, i) => (y * scaleFactor) + background_sliced[i]);
    
    // Recalculate and store the difference for the new range
    workingData.lastRawDifference = workingData.intensity.map((y, i) => y - totalCalcPattern[i]);
    
    // Update the chart datasets with the newly calculated sliced patterns
    const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
    findDataset('Calculated').data = workingData.tth.map((t, i) => ({ x: t, y: totalCalcPattern[i] }));
    findDataset('Background').data = workingData.tth.map((t, i) => ({ x: t, y: background_sliced[i] }));
    findDataset('Simulation (Manual)').data = []; // Ensure the manual preview line is hidden

    // update the plot's view and redraw the difference plot
    updatePlotRange(true);
    rescalePlot(false);
}


// pour pas commencer avec un bruit de fond débile
function estimateBackgroundParameters(tth, intensity) {
    if (tth.length < 100) return null; // Not enough data for a reliable estimate

    // --- 1. Identify background points by finding the minimum in chunks ---
    const backgroundPoints = [];
    // Divide the pattern into roughly 50 chunks to find local minima
    const chunkSize = Math.max(50, Math.floor(tth.length / 50)); 
    for (let i = 0; i < tth.length; i += chunkSize) {
        const chunkIntensity = intensity.slice(i, i + chunkSize);
        const chunkTth = tth.slice(i, i + chunkSize);
        if (chunkIntensity.length === 0) continue;

        let minVal = Infinity;
        let minIndex = -1;
        for (let j = 0; j < chunkIntensity.length; j++) {
            if (chunkIntensity[j] < minVal) {
                minVal = chunkIntensity[j];
                minIndex = j;
            }
        }
        if (minIndex !== -1) {
            backgroundPoints.push({ x: chunkTth[minIndex], y: minVal });
        }
    }

    if (backgroundPoints.length < 6) return null; // Need N+1 points for N-degree polynomial

    // --- 2. Perform a 5-term Chebyshev polynomial fit on these points ---
    const N = 5; // Fit B0 to B4
    const M = backgroundPoints.length;
    const tthMin = tth[0];
    const tthMax = tth[tth.length - 1];
    const tthRange = tthMax - tthMin;
    if (tthRange <= 0) return null;

    const A = []; // Matrix for normal equations
    const b = []; // Vector for normal equations

    backgroundPoints.forEach(point => {
        const x_prime = (2 * (point.x - tthMin) / tthRange) - 1;
        const row = [];
        let T_prev = 1;       // T0
        let T_curr = x_prime; // T1
        row.push(T_prev);
        if (N > 1) row.push(T_curr);

        for (let n = 2; n < N; n++) {
            const T_next = 2 * x_prime * T_curr - T_prev;
            row.push(T_next);
            T_prev = T_curr;
            T_curr = T_next;
        }
        A.push(row);
        b.push(point.y);
    });

    try {
        const At = transpose(A);
        const AtA = multiply(At, A);
        const Atb = multiply(At, b);
        const coeffs = solve(AtA, Atb);

        if (coeffs && coeffs.length === N) {
            const bgParams = {};
            coeffs.forEach((c, i) => bgParams[`B${i}`] = c);
            return bgParams;
        }
    } catch (error) {
        console.error("Background estimation fit failed:", error);
        return null;
    }

    return null;
}



                // -runLEBailFit
        function runLeBailFit() {
            if (isFitting) return;
            isFitting = true;
            setUIState(true);
            updateWorkingData();
            
            if (masterHklList.length === 0) {
                alert("Could not find a list of reflections. Please select a space group first. Aborting fit.");
                isFitting = false; setUIState(false); return;
            }

            fitResults = null;
            // await new Promise(resolve => setTimeout(resolve, 10)); // Can be removed for speed

            let currentParams = getAllParams();
            const fitFlags = getFitFlags();
            const selectedSgNumber = parseInt(controls.spaceGroupSelect.value, 10);
            const selectedSg = spaceGroups.find(sg => sg.number === selectedSgNumber);
            if (!selectedSg) { 
                alert("Error: Could not find selected space group data.");
                isFitting = false; setUIState(false); return;
            }
            const system = selectedSg.system;
            const maxIterations = parseInt(controls.iterationsSlider.value);
            const algorithm = controls.algorithmSelect.value;
          
            if (!workingData.isValid || workingData.tth.length === 0) {
                alert("No data in the selected 2-theta range. Aborting fit.");
                isFitting = false; setUIState(false); return;
            }

            let currentHklList = JSON.parse(JSON.stringify(masterHklList));
            currentHklList.forEach(p => { if(p.tth) p.intensity = 100.0; });
            
            const LE_BAIL_CYCLES = 8; 
            let lastRefinementCycleResults = null; 

            (async () => {
                for (let cycle = 0; cycle < LE_BAIL_CYCLES; cycle++) {
                    const progress = (cycle + 1) / LE_BAIL_CYCLES;
                    controls.progressBar.style.width = `${progress * 100}%`;
                    await new Promise(resolve => setTimeout(resolve, 0));

                    let refinementResults;
                    if (algorithm === 'lm') {
                        refinementResults = await refineParametersLM(currentParams, fitFlags, maxIterations, currentHklList, system, null);
                    } else { 
                        refinementResults = await refineParametersSA(currentParams, fitFlags, maxIterations, currentHklList, system, null);
                    }
                    
                    lastRefinementCycleResults = refinementResults;

                    if (refinementResults && refinementResults.params) {
                        currentParams = refinementResults.params;
                    } else {
                        console.error("Refinement failed in cycle", cycle);
                        break; 
                    }

                    const updatedBackground = calculateTotalBackground(workingData.tth, currentParams);
                    leBailIntensityExtraction({ tth: workingData.tth, intensity: workingData.intensity, background: updatedBackground }, currentHklList, currentParams);
                }
                
                const finalNetPatternForStats = calculatePattern(workingData.tth, currentHklList, currentParams);
                const finalBackgroundForStats = calculateTotalBackground(workingData.tth, currentParams);
                // Pass 'currentParams' to calculateStatistics
                const finalStats = calculateStatistics(workingData, finalNetPatternForStats, fitFlags, finalBackgroundForStats, currentParams);
                
                const finalNetPatternForUI = finalNetPatternForStats;
                const finalBackgroundForUI = finalBackgroundForStats;

                fitResults = { 
                    params: currentParams, 
                    hklList: currentHklList, 
                    stats: finalStats, 
                    algorithm: algorithm, 
                    fitFlags: fitFlags,
                    paramMapping: lastRefinementCycleResults ? lastRefinementCycleResults.paramMapping : getParameterMapping(fitFlags, currentParams).paramMapping,
                    JtJ: lastRefinementCycleResults ? lastRefinementCycleResults.JtJ : null,
                    ss_res: lastRefinementCycleResults ? lastRefinementCycleResults.ss_res : null
                };

                updateUI(fitResults.params, fitResults.stats, finalNetPatternForUI, finalBackgroundForUI, fitResults.stats.scaleFactor, fitResults.hklList);

                isFitting = false;
                setUIState(false);
            })(); //  invoke the async function
        }


        
        function leBailIntensityExtraction(expData, hklList, params) {
    if (expData.tth.length !== expData.background.length || expData.tth.length !== expData.intensity.length) {
        console.error("CRITICAL ERROR in leBailIntensityExtraction: Mismatched array lengths!");
        return;
    }

    const deg2rad = Math.PI / 180;
    const doubletEnabled = params.ratio > 0 && params.lambda2 > 0 && Math.abs(params.lambda - params.lambda2) > 1e-6;
    const lambdaRatio = doubletEnabled ? params.lambda2 / params.lambda : 1.0;

    // Reset intensities for the new extraction cycle, 8 c'est trop ?
    hklList.forEach(p => p.intensity = 0);

    for (let i = 0; i < expData.tth.length; i++) {
        let totalProfileAtPoint = 0;
        const contributingPeaks = [];

        // Find all K-alpha 1 peaks that contribute
        hklList.forEach((peak, peakIdx) => {
            const basePos = peak.tth + params.zeroShift;
            const shift = calculatePeakShift(basePos, params);
            const peakPos = basePos + shift;
            const { gamma_G, gamma_L } = calculateProfileWidths(basePos, peak, params);
            const window = 20 * Math.max(0.01, gamma_G, gamma_L);

            if (Math.abs(expData.tth[i] - peakPos) < window) {
                const profileVal = pseudoVoigt(expData.tth[i], peakPos, basePos, gamma_G, gamma_L, params);
                totalProfileAtPoint += profileVal;
                contributingPeaks.push({ idx: peakIdx, val: profileVal });
            }
        });

        // Find all K-alpha 2 peaks that contribute (if doublet is enabled)
        if (doubletEnabled) {
            hklList.forEach((peak, peakIdx) => {
                if (!peak.tth) return;

                const sinTheta1 = Math.sin(peak.tth * deg2rad / 2.0);
                if (Math.abs(sinTheta1) > 1) return;

                const sinTheta2 = sinTheta1 * lambdaRatio;
                if (Math.abs(sinTheta2) >= 1) return;

                const tth2 = 2 * Math.asin(sinTheta2) / deg2rad;
                const basePos2 = tth2 + params.zeroShift;
                const shift2 = calculatePeakShift(basePos2, params);
                const peakPos2 = basePos2 + shift2;
                const { gamma_G: gamma_G2, gamma_L: gamma_L2 } = calculateProfileWidths(basePos2, peak, params);
                const window = 8 * Math.max(0.01, gamma_G2, gamma_L2);

                if (Math.abs(expData.tth[i] - peakPos2) < window) {
                    const profileVal = pseudoVoigt(expData.tth[i], peakPos2, basePos2, gamma_G2, gamma_L2, params);
                    const weightedProfileVal = profileVal * params.ratio;
                    totalProfileAtPoint += weightedProfileVal;
                    // Add this as a separate contribution from the same peak
                    contributingPeaks.push({ idx: peakIdx, val: weightedProfileVal });
                }
            });
        }

        if (totalProfileAtPoint > 1e-9 && contributingPeaks.length > 0) {
            const obsIntensityNet = expData.intensity[i] - (expData.background[i] || 0);

            if (obsIntensityNet > 0) {
                contributingPeaks.forEach(p => {
                    hklList[p.idx].intensity += obsIntensityNet * (p.val / totalProfileAtPoint);
                });
            }
        }
    }

    // Ensure all final intensities are non-negative
    hklList.forEach(p => {
        if (p.intensity < 0) {
            p.intensity = 0;
        }
    });

        let DAMPING_FACTOR=0.7;
    hklList.forEach(p => {
        // Store previous intensity if it doesn't exist
        
        if (p.intensity_previous === undefined) {
            p.intensity_previous = p.intensity;
        } else {
            // Apply damping: mix old and new intensities
            const newIntensity = p.intensity;
            p.intensity = (1.0 - DAMPING_FACTOR) * newIntensity + DAMPING_FACTOR * p.intensity_previous;
            // Update the stored previous value
            p.intensity_previous = newIntensity;
        }
    });

}


           function calculateStatistics(workingData, netCalcPattern, fitFlags, finalBackground, params) {
            const y_obs = workingData.intensity;
            const y_bkg = finalBackground;
            const weights = workingData.weights;
            const N = y_obs.length;

            if (N === 0 || y_obs.length !== netCalcPattern.length || y_obs.length !== y_bkg.length) {
                console.error("Statistics calculation error: Mismatched array lengths.");
                return { r_p: -1, rwp: -1, chi2: -1, scaleFactor: 1, sum_w_res_sq: 0 };
            }

            let sum_w_y_net_y_calc = 0;
            let sum_w_y_calc_sq = 0;
            for (let i = 0; i < N; i++) {
                const y_obs_net = y_obs[i] - y_bkg[i];
                sum_w_y_net_y_calc += weights[i] * y_obs_net * netCalcPattern[i];
                sum_w_y_calc_sq += weights[i] * netCalcPattern[i] * netCalcPattern[i];
            }
            const scaleFactor = (sum_w_y_calc_sq > 1e-9) ? sum_w_y_net_y_calc / sum_w_y_calc_sq : 1.0;
            
            const y_calc = netCalcPattern.map((y, i) => (scaleFactor * y) + y_bkg[i]);
            let sum_w_res_sq = 0, sum_w_obs_sq = 0, sum_abs_res = 0, sum_abs_obs = 0;
            for (let i = 0; i < N; i++) {
                const res = y_obs[i] - y_calc[i];
                sum_w_res_sq += weights[i] * res * res;
                sum_w_obs_sq += weights[i] * y_obs[i] * y_obs[i];
                sum_abs_res += Math.abs(res);
                sum_abs_obs += Math.abs(y_obs[i]);
            }

            const Rp = 100 * (sum_abs_res / sum_abs_obs);
            const Rwp = 100 * Math.sqrt(sum_w_res_sq / sum_w_obs_sq);

            // Pass 'params' to getParameterMapping to get the correct number of refined parameters
            const P = getParameterMapping(fitFlags, params).paramMapping.length;
            
            const Rexp_denominator = sum_w_obs_sq;
            if (N <= P || Rexp_denominator <= 0) {
                 return { r_p: Rp, rwp: Rwp, chi2: 0, scaleFactor, sum_w_res_sq };
            }

            const Rexp = 100 * Math.sqrt((N - P) / Rexp_denominator);
            //const GOF = sum_w_res_sq / (N - P); //reduced chi2

            const GOF = (Rexp > 1e-6) ? Math.pow(Rwp / Rexp, 2) : 0; // GOF style dans GSAS,  (Rwp/Rexp)^2

            return { r_p: Rp, rwp: Rwp, chi2: GOF, scaleFactor, sum_w_res_sq };
        }
   
        // --- Levenberg-Marquardt Algorithm ---
                async function refineParametersLM(initialParams, fitFlags, maxIter, hklList, system, progressCallback) {
            // CHANGED on 4th oct: Pass initialParams to get the dynamically scaled mapping
            const { paramMapping } = getParameterMapping(fitFlags, initialParams);
            if (paramMapping.length === 0) return { params: initialParams, hklList: hklList };

            let params = JSON.parse(JSON.stringify(initialParams));
            if (workingData.tth.length === 0) return { params, hklList };
            
            let workingHklList = hklList; 
            
            let finalJtJ, finalResiduals, ss_res;
            let lambda = 0.001;
            let last_cost_iter = Infinity;
            
            const y_obs = workingData.intensity;
            const weights = workingData.weights;
            const sqrt_weights = weights.map(w => Math.sqrt(w));

            for (let iter = 0; iter < maxIter; iter++) {
                updateHklPositions(workingHklList, params, system);
                
                const y_bkg = calculateTotalBackground(workingData.tth, params);
                const netCalcPattern = calculatePattern(workingData.tth, workingHklList, params);

                let sum_w_y_net_y_calc = 0, sum_w_y_calc_sq = 0;
                for (let i = 0; i < y_obs.length; i++) {
                    const y_obs_net = y_obs[i] - y_bkg[i];
                    sum_w_y_net_y_calc += weights[i] * y_obs_net * netCalcPattern[i];
                    sum_w_y_calc_sq += weights[i] * netCalcPattern[i] * netCalcPattern[i];
                }
                const scaleFactor = (sum_w_y_calc_sq > 1e-9) ? sum_w_y_net_y_calc / sum_w_y_calc_sq : 1.0;

                const y_calc_total = netCalcPattern.map((y, i) => (scaleFactor * y) + y_bkg[i]);
                const residuals = y_obs.map((y, i) => (y - y_calc_total[i]) * sqrt_weights[i]);
                const cost = dot(residuals, residuals);
                
                finalResiduals = residuals;
                ss_res = cost;

                if (iter > 0 && Math.abs(last_cost_iter - cost) < 1e-9 * last_cost_iter) break;
                last_cost_iter = cost;

                // This vector contains NORMALIZED parameter values (~1.0)
                const p_current_vec = paramMapping.map(m => m.get(params));
                const jacobian_unscaled = [];
                const original_hkl_tth = workingHklList.map(p => p.tth);
                
                for (let i = 0; i < p_current_vec.length; i++) {
                    const p_plus = [...p_current_vec];
                    const step = 1e-4; 
                    p_plus[i] += step;

                    let tempParams = JSON.parse(JSON.stringify(params));
                    paramMapping.forEach((m, j) => m.set(tempParams, p_plus[j]));
                    
                    updateHklPositions(workingHklList, tempParams, system);

                    const background_plus = calculateTotalBackground(workingData.tth, tempParams);
                    const net_pattern_plus = calculatePattern(workingData.tth, workingHklList, tempParams);
                    
                    let sum_w_y_net_y_calc_plus = 0, sum_w_y_calc_sq_plus = 0;
                    for (let j = 0; j < y_obs.length; j++) {
                        const y_obs_net = y_obs[j] - background_plus[j];
                        sum_w_y_net_y_calc_plus += weights[j] * y_obs_net * net_pattern_plus[j];
                        sum_w_y_calc_sq_plus += weights[j] * net_pattern_plus[j] * net_pattern_plus[j];
                    }
                    const scaleFactor_plus = (sum_w_y_calc_sq_plus > 1e-9) ? sum_w_y_net_y_calc_plus / sum_w_y_calc_sq_plus : 1.0;
                    
                    const final_pattern_plus = net_pattern_plus.map((y, idx) => (y * scaleFactor_plus) + background_plus[idx]);
                    
                    const deriv = scale(subtract(final_pattern_plus, y_calc_total), 1 / step);
                    jacobian_unscaled.push(deriv);
                    workingHklList.forEach((p, idx) => p.tth = original_hkl_tth[idx]);
                }
                
                const Jm_T = jacobian_unscaled.map(col => col.map((val, i) => val * sqrt_weights[i]));
                const Jm = transpose(Jm_T);
                finalJtJ = multiply(Jm_T, Jm);
                const Jtr = multiply(Jm_T, residuals);
                const A_lm = JSON.parse(JSON.stringify(finalJtJ));
                for (let i = 0; i < A_lm.length; i++) { if(!A_lm[i]) continue; A_lm[i][i] *= (1.0 + lambda); }
                const p_step = solve(A_lm, Jtr);

                if (p_step.some(isNaN)) break;

                const p_new_vec = add(p_current_vec, p_step);
                let newParams = JSON.parse(JSON.stringify(params));
                // Update params using the mapping to denormalize
                paramMapping.forEach((m, i) => m.set(newParams, p_new_vec[i]));
                
                const new_y_bkg = calculateTotalBackground(workingData.tth, newParams);
                const newNetPattern = calculatePattern(workingData.tth, workingHklList, newParams);
                let new_sum_w_y_net_y_calc = 0, new_sum_w_y_calc_sq = 0;
                for (let i = 0; i < y_obs.length; i++) {
                    const y_obs_net = y_obs[i] - new_y_bkg[i];
                    new_sum_w_y_net_y_calc += weights[i] * y_obs_net * newNetPattern[i];
                    new_sum_w_y_calc_sq += weights[i] * newNetPattern[i] * newNetPattern[i];
                }
                const newScaleFactor = (new_sum_w_y_calc_sq > 1e-9) ? new_sum_w_y_net_y_calc / new_sum_w_y_calc_sq : 1.0;
                const new_y_calc_total = newNetPattern.map((y, i) => (newScaleFactor * y) + new_y_bkg[i]);
                const new_residuals = y_obs.map((y, i) => (y - new_y_calc_total[i]) * sqrt_weights[i]);
                const new_cost = dot(new_residuals, new_residuals);
                
                if (new_cost < cost && isFinite(new_cost)) {
                    params = newParams; // Accept the new parameters
                    lambda = Math.max(lambda / 2, 1e-9);
                } else {
                    lambda = Math.min(lambda * 2, 1e9);
                }
                if (progressCallback) await progressCallback((iter + 1) / maxIter);
            }
            return { params: params, hklList: hklList, JtJ: finalJtJ, finalResiduals: finalResiduals, paramMapping, ss_res, algorithm: 'lm', fitFlags };
        }

        // --- Simulated Annealing Algorithm ---
        async function refineParametersSA(initialParams, fitFlags, maxIter, hklList, system, progressCallback) {
    const { paramMapping } = getParameterMapping(fitFlags, initialParams);
    if (paramMapping.length === 0) return { params: initialParams, hklList: hklList };

    const objective = (p_vec_normalized, params_template) => {
        const tempParams = JSON.parse(JSON.stringify(params_template));
        paramMapping.forEach((m, i) => m.set(tempParams, p_vec_normalized[i]));

        try {
            updateHklPositions(hklList, tempParams, system);
            const netCalcPattern = calculatePattern(workingData.tth, hklList, tempParams);
            const y_bkg = calculateTotalBackground(workingData.tth, tempParams);
            const y_obs = workingData.intensity;
            const weights = workingData.weights;

            let sum_w_y_net_y_calc = 0, sum_w_y_calc_sq = 0;
            for (let i = 0; i < y_obs.length; i++) {
                const y_obs_net = y_obs[i] - y_bkg[i];
                sum_w_y_net_y_calc += weights[i] * y_obs_net * netCalcPattern[i];
                sum_w_y_calc_sq += weights[i] * netCalcPattern[i] * netCalcPattern[i];
            }
            const scaleFactor = (sum_w_y_calc_sq > 1e-9) ? sum_w_y_net_y_calc / sum_w_y_calc_sq : 1.0;
            const y_calc_total = netCalcPattern.map((y, i) => (scaleFactor * y) + y_bkg[i]);

            let sum_w_res_sq = 0;
            for (let i = 0; i < y_obs.length; i++) {
                const res = y_obs[i] - y_calc_total[i];
                sum_w_res_sq += weights[i] * res * res;
            }
            return isFinite(sum_w_res_sq) ? sum_w_res_sq : 1e12;
        } catch (err) { return 1e12; }
    };

    let bestOverallParams = JSON.parse(JSON.stringify(initialParams));
    
    // Calculate initial cost to scale temperature appropriately
    let current_x_norm = paramMapping.map(m => m.get(bestOverallParams));
    let current_cost = objective(current_x_norm, bestOverallParams);
    
    // Set initial temperature as fraction of initial cost
    let T = current_cost * 0.05; // Start at 5% of initial cost
    const T_min = current_cost * 0.001; // End at 0.1% of initial cost
    const coolingRate = Math.pow(T_min / T, 1.0 / maxIter);
    
    let best_x_norm = current_x_norm.slice();
    let best_cost = current_cost;

    for (let step = 0; step < maxIter; step++) {
        const neighbor_x_norm = current_x_norm.map((val, idx) => {
            const mapping = paramMapping[idx];
            // Step size scales with temperature but has minimum
            const baseStep = mapping.step || 0.2;
            const T_ratio = T / (current_cost * 0.1); // Normalized temperature
            const effectiveStep = baseStep * Math.max(0.05, T_ratio);
            return val + (Math.random() - 0.5) * 2 * effectiveStep;
        });

        const neighbor_cost = objective(neighbor_x_norm, bestOverallParams);
        const deltaE = neighbor_cost - current_cost;

        // Standard Metropolis criterion with proper temperature scaling
        if (deltaE < 0 || Math.exp(-deltaE / T) > Math.random()) {
            current_x_norm = neighbor_x_norm.slice();
            current_cost = neighbor_cost;
        }
        
        if (current_cost < best_cost) {
            best_x_norm = current_x_norm.slice();
            best_cost = current_cost;
        }
        
        T *= coolingRate;
        if (T < T_min) T = T_min;
        
        if (progressCallback) await progressCallback((step + 1) / maxIter);
    }
    
    paramMapping.forEach((m, i) => m.set(bestOverallParams, best_x_norm[i]));
    
    return { params: bestOverallParams, hklList: hklList, algorithm: 'sa', paramMapping, fitFlags, ss_res: best_cost };
}

        const getAllParams = () => {
            const profileType = controls.profileSelect.value;
            let params = {
                lambda: parseFloat(controls.wavelength.value),
                lambda2: parseFloat(controls.wavelength2.value), 
                ratio: parseFloat(controls.ratio21.value),       
                zeroShift: parseFloat(controls.zeroShift.value),
                profileType: profileType
            };
            
            document.querySelectorAll('#lattice-parameters-container input[type="number"]').forEach(input => {
                if (input.id.startsWith('lattice-param-')) {
                    const paramName = input.id.replace('lattice-param-', '');
                    params[paramName] = parseFloat(input.value);
                }
            });

            const { system } = getSystemAndCentering();

            switch(system) {
                case 'cubic': case 'tetragonal': case 'orthorhombic': 
                    params.alpha = params.beta = params.gamma = 90; 
                    break;
                case 'rhombohedral':
                case 'hexagonal': 
                    params.alpha = params.beta = 90; params.gamma = 120; 
                    break;
                case 'monoclinic': 
                    params.alpha = params.gamma = 90; 
                    break;
            }

            if (profileType === "4") {
                Object.assign(params, { 
                    GU: parseFloat(controls.paramGU.value), GV: parseFloat(controls.paramGV.value), 
                    GW: parseFloat(controls.paramGW.value), GP: parseFloat(controls.paramGP.value), 
                    LX: parseFloat(controls.paramLX.value), eta: parseFloat(controls.paramEta.value), 
                    shft: parseFloat(controls.paramShft.value), trns: parseFloat(controls.paramTrns.value) 
                });
            } else {
                Object.assign(params, { 
                    U: parseFloat(controls.paramU.value), V: parseFloat(controls.paramV.value), 
                    W: parseFloat(controls.paramW.value), X: parseFloat(controls.paramX.value), 
                    Y: parseFloat(controls.paramY.value), SL: parseFloat(controls.paramSL.value), 
                    HL: parseFloat(controls.paramHL.value), S400: parseFloat(controls.paramS400.value), 
                    S040: parseFloat(controls.paramS040.value), S004: parseFloat(controls.paramS004.value), 
                    S220: parseFloat(controls.paramS220.value), S202: parseFloat(controls.paramS202.value), 
                    S022: parseFloat(controls.paramS022.value) 
                });
            }

            // Add Chebyshev and Hump parameters
            for (let i = 0; i < 6; i++) {
                const input = document.getElementById(`param-b${i}`);
                if (input) params[`B${i}`] = parseFloat(input.value);
            }
            params['hump_H'] = parseFloat(document.getElementById('param-hump-h').value);
            params['hump_P'] = parseFloat(document.getElementById('param-hump-p').value);
            params['hump_W'] = parseFloat(document.getElementById('param-hump-w').value);

            return params;
        };
       
        const getFitFlags = () => {
            const profileType = controls.profileSelect.value;
            let flags = {
                a: document.getElementById('fit-lattice-a')?.checked ?? false,
                b: document.getElementById('fit-lattice-b')?.checked ?? false,
                c: document.getElementById('fit-lattice-c')?.checked ?? false,
                alpha: document.getElementById('fit-lattice-alpha')?.checked ?? false,
                beta: document.getElementById('fit-lattice-beta')?.checked ?? false,
                gamma: document.getElementById('fit-lattice-gamma')?.checked ?? false,
                zeroShift: controls.fitZeroShift.checked,
            };
            if (profileType === "4") {
                Object.assign(flags, { GU: controls.fitGU.checked, GV: controls.fitGV.checked, GW: controls.fitGW.checked, GP: controls.fitGP.checked, LX: controls.fitLX.checked, eta: controls.fitEta.checked, shft: controls.fitShft.checked, trns: controls.fitTrns.checked });
            } else {
                Object.assign(flags, { U: controls.fitU.checked, V: controls.fitV.checked, W: controls.fitW.checked, X: controls.fitX.checked, Y: controls.fitY.checked, SL: controls.fitSL.checked, HL: controls.fitHL.checked });
                if (profileType === "3") {
                    Object.assign(flags, { S400: controls.fitS400.checked, S040: controls.fitS040.checked, S004: controls.fitS004.checked, S220: controls.fitS220.checked, S202: controls.fitS202.checked, S022: controls.fitS022.checked });
                    const { system } = getSystemAndCentering();
                    switch (system) {
                        case 'cubic': flags.S040 = flags.S004 = flags.S202 = flags.S022 = false; break;
                        case 'hexagonal': case 'tetragonal': case 'rhombohedral': flags.S040 = flags.S022 = false; break;
                    }
                }
            }

            // Add Chebyshev and Hump flags
            for (let i = 0; i < 6; i++) {
                const checkbox = document.getElementById(`fit-b${i}`);
                if (checkbox) flags[`B${i}`] = checkbox.checked;
            }
            flags['hump_H'] = document.getElementById('fit-hump-h').checked;
            flags['hump_P'] = document.getElementById('fit-hump-p').checked;
            flags['hump_W'] = document.getElementById('fit-hump-w').checked;

            return flags;
        };



        function getParameterMapping(fitFlags, initialParams) {
            const mappings = [];


            const createMapping = (flag, name, defaultScale = 1.0, minVal = -Infinity, maxVal = Infinity, step = 0.2) => {
    if (!flag) return null; 

    const initialValue = initialParams[name] ?? 0;
    // If initialValue is near zero, use the provided defaultScale instead of 1.0
    const scale = Math.abs(initialValue) > 1e-9 ? initialValue : defaultScale; 

    return {
        name: name,
        scale: scale, // Use the more robust scale
        step: step,
        get: p => p[name] / scale,
        set: (p, v) => {
            let rawValue = v * scale;
            if (rawValue < minVal) rawValue = minVal;
            if (rawValue > maxVal) rawValue = maxVal;
            p[name] = rawValue;
        }
    };
};

            const profileType = initialParams.profileType || controls.profileSelect.value;
            
            // changement de pas, le 4 oct, v 2.3
            // Lattice Parameters (require small steps)
            mappings.push(createMapping(fitFlags.a, 'a', 4.0, 0.1, undefined, 0.01));
            mappings.push(createMapping(fitFlags.b, 'b', 4.0, 0.1, undefined, 0.01));
            mappings.push(createMapping(fitFlags.c, 'c', 6.0, 0.1, undefined, 0.01));
            mappings.push(createMapping(fitFlags.alpha, 'alpha', 90.0, undefined, undefined, 0.05));
            mappings.push(createMapping(fitFlags.beta, 'beta', 90.0, undefined, undefined, 0.05));
            mappings.push(createMapping(fitFlags.gamma, 'gamma', 120.0, undefined, undefined, 0.05));
            
            // Instrumental Parameters
            mappings.push(createMapping(fitFlags.zeroShift, 'zeroShift', 0.01, undefined, undefined, 0.1));

            // Profile Parameters
            if (profileType === "4") {
                mappings.push(createMapping(fitFlags.GU, 'GU', 0.1, 0, undefined, 0.05));
                mappings.push(createMapping(fitFlags.GV, 'GV', -0.1, undefined, undefined, 0.05));
                mappings.push(createMapping(fitFlags.GW, 'GW', 0.1, 1e-6, undefined, 0.05));
                mappings.push(createMapping(fitFlags.GP, 'GP', 0.0, undefined, undefined, 0.1));
                mappings.push(createMapping(fitFlags.LX, 'LX', 0.1, 1e-6, undefined, 0.2));
                mappings.push(createMapping(fitFlags.eta, 'eta', 0.5, 0, 1, 0.1));
                mappings.push(createMapping(fitFlags.shft, 'shft', 0.0, undefined, undefined, 0.1));
                mappings.push(createMapping(fitFlags.trns, 'trns', 0.0, undefined, undefined, 0.1));
            } else {
                mappings.push(createMapping(fitFlags.U, 'U', 0.1, undefined, undefined, 0.2));
                mappings.push(createMapping(fitFlags.V, 'V', -0.1, undefined, undefined, 0.2));
                mappings.push(createMapping(fitFlags.W, 'W', 0.1, 1e-6, undefined, 0.2));
                mappings.push(createMapping(fitFlags.X, 'X', 0.1, 1e-6, undefined, 0.2));
                mappings.push(createMapping(fitFlags.Y, 'Y', 0.1, 1e-6, undefined, 0.2));
                mappings.push(createMapping(fitFlags.SL, 'SL', 0.0, undefined, undefined, 0.1));
                mappings.push(createMapping(fitFlags.HL, 'HL', 0.0, undefined, undefined, 0.1));
                 if (profileType === "3") {
                    mappings.push(createMapping(fitFlags.S400, 'S400', 0.0, undefined, undefined, 0.2));
                    mappings.push(createMapping(fitFlags.S040, 'S040', 0.0, undefined, undefined, 0.2));
                    mappings.push(createMapping(fitFlags.S004, 'S004', 0.0, undefined, undefined, 0.2));
                    mappings.push(createMapping(fitFlags.S220, 'S220', 0.0, undefined, undefined, 0.2));
                    mappings.push(createMapping(fitFlags.S202, 'S202', 0.0, undefined, undefined, 0.2));
                    mappings.push(createMapping(fitFlags.S022, 'S022', 0.0, undefined, undefined, 0.2));
                }
            }

            // Background Parameters (can take larger steps)
            for (let i = 0; i < 6; i++) {
                mappings.push(createMapping(fitFlags[`B${i}`], `B${i}`, i === 0 ? 100 : 1.0, undefined, undefined, 0.3));
            }
            mappings.push(createMapping(fitFlags.hump_H, 'hump_H', 100.0, undefined, undefined, 0.2));
            mappings.push(createMapping(fitFlags.hump_P, 'hump_P', 30.0, undefined, undefined, 0.1));
            mappings.push(createMapping(fitFlags.hump_W, 'hump_W', 5.0, 0.01, undefined, 0.1));

            const paramMapping = mappings.filter(Boolean);
            return { paramMapping };
        }




        const dot = (v1, v2) => { let s = 0; for(let i=0; i<v1.length; i++) s += v1[i] * v2[i]; return s; }; const add = (v1, v2) => v1.map((x, i) => x + v2[i]); const subtract = (v1, v2) => v1.map((x, i) => x - v2[i]); const scale = (v, s) => v.map(x => x * s); const transpose = (m) => { if (!m || m.length === 0 || !Array.isArray(m[0])) return m.map(x => [x]); return m[0].map((_, colIndex) => m.map(row => row[colIndex])); }; const multiply = (A, B) => { if (!Array.isArray(B[0])) return A.map(row => dot(row, B)); const Bt = transpose(B); return A.map(rowA => Bt.map(colB => dot(rowA, colB))); }; const solve = (A, b) => { const n = A.length; const Ab = A.map((row, i) => [...row, b[i]]); for (let i = 0; i < n; i++) { let max = i; for (let k = i + 1; k < n; k++) if (Math.abs(Ab[k][i]) > Math.abs(Ab[max][i])) max = k; [Ab[i], Ab[max]] = [Ab[max], Ab[i]]; if (Math.abs(Ab[i][i]) < 1e-12) continue; for (let k = i + 1; k < n; k++) { const factor = Ab[k][i] / Ab[i][i]; if (!isFinite(factor)) continue; for (let j = i; j < n + 1; j++) Ab[k][j] -= factor * Ab[i][j]; } } const x = new Array(n).fill(0); for (let i = n - 1; i >= 0; i--) { let sum = 0; for (let j = i + 1; j < n; j++) sum += Ab[i][j] * x[j]; if (Math.abs(Ab[i][i]) > 1e-12) x[i] = (Ab[i][n] - sum) / Ab[i][i]; } return x; };
        function calculateDeterminant(A) { const n = A.length; if (n === 1) return A[0][0]; if (n === 2) return A[0][0] * A[1][1] - A[0][1] * A[1][0]; const U = A.map(row => [...row]); let det = 1; for (let i = 0; i < n; i++) { let maxRow = i; for (let k = i + 1; k < n; k++) if (Math.abs(U[k][i]) > Math.abs(U[maxRow][i])) maxRow = k; if (maxRow !== i) { [U[i], U[maxRow]] = [U[maxRow], U[i]]; det *= -1; } if (Math.abs(U[i][i]) < 1e-15) return 0; det *= U[i][i]; for (let k = i + 1; k < n; k++) { const factor = U[k][i] / U[i][i]; for (let j = i; j < n; j++) U[k][j] -= factor * U[i][j]; } } return det; }
        function matrixInverse(A) { const n = A.length; if (n === 0) return []; const det = calculateDeterminant(A); if (Math.abs(det) < 1e-15) { console.warn("Matrix is singular or near-singular, determinant =", det); return null; } const augmented = A.map((row, i) => [...row, ...Array.from({ length: n }, (_, j) => (i === j ? 1 : 0))]); for (let i = 0; i < n; i++) { let maxRow = i; for (let j = i + 1; j < n; j++) if (Math.abs(augmented[j][i]) > Math.abs(augmented[maxRow][i])) maxRow = j; [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]]; if (Math.abs(augmented[i][i]) < 1e-15) { console.warn("Zero pivot encountered during matrix inversion"); return null; } const pivot = augmented[i][i]; for (let j = 0; j < 2 * n; j++) augmented[i][j] /= pivot; for (let j = 0; j < n; j++) { if (i !== j) { const factor = augmented[j][i]; for (let k = 0; k < 2 * n; k++) augmented[j][k] -= factor * augmented[i][k]; } } } return augmented.map(row => row.slice(n)); }
        function enforceSymmetryConstraints(params) { const { system } = getSystemAndCentering(); switch (system) { case 'cubic': if (params.S400 !== undefined) params.S040 = params.S004 = params.S400; if (params.S220 !== undefined) params.S202 = params.S022 = params.S220; break; case 'hexagonal': case 'tetragonal': case 'rhombohedral': if (params.S400 !== undefined) params.S040 = params.S400; if (params.S202 !== undefined) params.S022 = params.S202; break; } }
        
        function updatePreviewPattern() {
            if (!mainChart || !workingData.isValid || isFitting) return;

            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            const params = getAllParams();
            if (isNaN(params.lambda) || params.lambda <= 0 || isNaN(params.a) || params.a <= 0) return;
            
            let hklList = JSON.parse(JSON.stringify(masterHklList));
            const selectedSg = spaceGroups.find(sg => sg.number === parseInt(controls.spaceGroupSelect.value, 10));
            if (!selectedSg) return;
            
            updateHklPositions(hklList, params, selectedSg.system);
            lastGeneratedHklList = hklList;
            
                        const globalYMax = mainChart.options.globalYMax; 
            const diffPlotHeightRatio = 0.2; 
            const constantNegSpaceHeight = globalYMax * diffPlotHeightRatio;
            const markerBottom = -(constantNegSpaceHeight * 0.05); 
            const markerTop = -(constantNegSpaceHeight * 0.20);
            const minTth = parseFloat(controls.tthMinSlider.value); 
            const maxTth = parseFloat(controls.tthMaxSlider.value);

            findDataset('HKL Markers').data = hklList
                .filter(hkl => {
                    if (!hkl.tth) return false;
                    const peakPos = hkl.tth + params.zeroShift;
                    return peakPos >= minTth && peakPos <= maxTth;
                })
                .map(hkl => ({
                    x: hkl.tth + params.zeroShift,
   //                 y: [markerTop, markerBottom], on laisse l'autre HKL marker position
                    hkl: `${hkl.hkl_list[0]} [m=${hkl.multiplicity}]`
                }));
            
            hklList.forEach(p => p.intensity = 1000);

            // Calculate patterns and difference based on workingData
            const background_sliced = calculateTotalBackground(workingData.tth, params);
            const unscaledPeakPattern_sliced = calculatePattern(workingData.tth, hklList, params);
            const y_obs_net_sliced = workingData.intensity.map((y, i) => Math.max(0, y - background_sliced[i]));
            
            const sum_obs_calc = dot(y_obs_net_sliced, unscaledPeakPattern_sliced);
            const sum_calc_sq = dot(unscaledPeakPattern_sliced, unscaledPeakPattern_sliced);
            const scaleFactor = (sum_calc_sq > 1e-9) ? sum_obs_calc / sum_calc_sq : 1.0;
            const totalCalcPattern = unscaledPeakPattern_sliced.map((y, i) => (y * scaleFactor) + background_sliced[i]);
            
            // Store the newly calculated difference in the workingData object
            workingData.lastRawDifference = workingData.intensity.map((y, i) => y - totalCalcPattern[i]);

            // Set the data for the plot lines
            findDataset('Simulation (Manual)').data = workingData.tth.map((t, i) => ({ x: t, y: totalCalcPattern[i] }));
            findDataset('Calculated').data = []; // Hide the blue 'Calculated' line during preview
        }

        function setUIState(fitting) { isFitting = fitting; controls.fitButton.disabled = fitting; controls.reportButton.disabled = fitting; controls.saveDataButton.disabled = fitting; controls.fitButton.textContent = fitting ? 'Refining...' : 'Run Refinement'; controls.progressBarContainer.classList.toggle('hidden', !fitting); document.body.style.cursor = fitting ? 'wait' : 'default'; if (fitting) { controls.rpResult.textContent = '...'; controls.rwpResult.textContent = '...'; controls.chi2Result.textContent = '...'; } if (!fitting) { controls.progressBar.style.width = '0%'; if(fitResults) { controls.reportButton.disabled = false; controls.saveDataButton.disabled = false; } controls.rwpResult.parentElement.parentElement.querySelectorAll('.result-card').forEach(c => c.style.background = ''); } }
       
        function updateUI(params, stats, netPeakPattern_full, background_full, scaleFactor, hklList) {
            const safeUpdate = (paramValue, controlElement, digits) => { 
                if (controlElement && typeof paramValue === 'number' && isFinite(paramValue)) {
                    controlElement.value = paramValue.toFixed(digits);
                }
            };
            
            if (stats && typeof stats.r_p === 'number') controls.rpResult.textContent = stats.r_p.toFixed(2);
            if (stats && typeof stats.rwp === 'number') controls.rwpResult.textContent = stats.rwp.toFixed(2);
            if (stats && typeof stats.chi2 === 'number') controls.chi2Result.textContent = stats.chi2.toFixed(3);
            
            // Update lattice, zero shift, and profile parameters
            safeUpdate(params.a, document.getElementById('lattice-param-a'), 4);
            safeUpdate(params.b, document.getElementById('lattice-param-b'), 4);
            safeUpdate(params.c, document.getElementById('lattice-param-c'), 4);
            safeUpdate(params.alpha, document.getElementById('lattice-param-alpha'), 3);
            safeUpdate(params.beta, document.getElementById('lattice-param-beta'), 3);
            safeUpdate(params.gamma, document.getElementById('lattice-param-gamma'), 3);
            safeUpdate(params.zeroShift, controls.zeroShift, 4);
            
            const profileType = params.profileType || controls.profileSelect.value;
            if (profileType === "4") {
                safeUpdate(params.GU, controls.paramGU, 4); safeUpdate(params.GV, controls.paramGV, 4);
                safeUpdate(params.GW, controls.paramGW, 4); safeUpdate(params.GP, controls.paramGP, 4);
                safeUpdate(params.LX, controls.paramLX, 4); safeUpdate(params.eta, controls.paramEta, 4);
                safeUpdate(params.shft, controls.paramShft, 4); safeUpdate(params.trns, controls.paramTrns, 4);
            } else {
                safeUpdate(params.U, controls.paramU, 4); safeUpdate(params.V, controls.paramV, 4);
                safeUpdate(params.W, controls.paramW, 4); safeUpdate(params.X, controls.paramX, 4);
                safeUpdate(params.Y, controls.paramY, 4); safeUpdate(params.SL, controls.paramSL, 4);
                safeUpdate(params.HL, controls.paramHL, 4);
                if (profileType === "3") {
                    safeUpdate(params.S400, controls.paramS400, 4); safeUpdate(params.S040, controls.paramS040, 4);
                    safeUpdate(params.S004, controls.paramS004, 4); safeUpdate(params.S220, controls.paramS220, 4);
                    safeUpdate(params.S202, controls.paramS202, 4); safeUpdate(params.S022, controls.paramS022, 4);
                }
            }
            
            // --- Update background parameter inputs 
            for (let i = 0; i < 6; i++) {
                safeUpdate(params[`B${i}`], document.getElementById(`param-b${i}`), 4);
            }
            safeUpdate(params.hump_H, document.getElementById('param-hump-h'), 4);
            safeUpdate(params.hump_P, document.getElementById('param-hump-p'), 4);
            safeUpdate(params.hump_W, document.getElementById('param-hump-w'), 4);

            if (netPeakPattern_full && background_full && hklList) {
                updateChart(netPeakPattern_full, background_full, hklList, params, scaleFactor);
            }
        }

        function updateChart(netPeakPattern_sliced, background_sliced, hklList, params, scaleFactor = 1.0) {
            if (!mainChart) return;
            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            
            // Clear the manual simulation line
            findDataset('Simulation (Manual)').data = [];

            // Calculate the final total pattern and the difference
            const totalCalcPattern = netPeakPattern_sliced.map((y, i) => (y * scaleFactor) + background_sliced[i]);
            workingData.lastRawDifference = workingData.intensity.map((y, i) => y - totalCalcPattern[i]);

            // Set the data for the plot lines
            findDataset('Calculated').data = workingData.tth.map((t, i) => ({x: t, y: totalCalcPattern[i]}));
            findDataset('Background').data = workingData.tth.map((t, i) => ({x: t, y: background_sliced[i]}));
            
            // Now that all data is ready, update the plot visuals
            rescalePlot(); 
            mainChart.update('none');
        }

        function getPeakInfoAt(tth) {
            if (!lastGeneratedHklList || lastGeneratedHklList.length === 0 || !mainChart) return { peak: null, inRegion: false };
            let closestPeak = null, minDiff = Infinity; const currentParams = getAllParams(); const zeroShift = currentParams.zeroShift || 0;
            for (const hkl of lastGeneratedHklList) { const peakShift = calculatePeakShift(hkl.tth, currentParams); const peakPos = hkl.tth + zeroShift + peakShift; const diff = Math.abs(tth - peakPos); if (diff < minDiff) { minDiff = diff; closestPeak = hkl; } }
            if (closestPeak) { 
                const threshold = 0.2;
                   if (minDiff < threshold) return { peak: closestPeak, inRegion: true }; }
            return { peak: null, inRegion: false };
        }

        function initializeChart() {
            if (mainChart) mainChart.destroy();
            const experimentalPoints = fullExperimentalData.tth.map((t, i) => ({x: t, y: fullExperimentalData.intensity[i]}));
            const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
            mainChart = new Chart(controls.mainChartCanvas, {
                type: 'line',
                data: { 
                    datasets: [
                        { label: 'Experimental', data: experimentalPoints, borderColor: 'rgba(107, 114, 128, 0.7)', borderWidth: 0.5, pointRadius: 1, pointBackgroundColor: 'rgba(107, 114, 128, 0.7)', order: 1 },
                        { label: 'Simulation (Manual)', data: [], borderColor: 'rgba(249, 115, 22, 0.8)', borderWidth: 2, pointRadius: 0, borderDash: [8, 4], order: 2 },
                        { label: 'Calculated', data: [], borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 2, pointRadius: 0, order: 3 },
                        { label: 'Background', data: [], borderColor: 'rgba(217, 119, 6, 0.8)', borderWidth: 1.5, pointRadius: 0, borderDash: [5, 5], order: 4 },
                        { label: 'Difference', data: [], borderColor: 'rgba(239, 68, 68, 0.8)', borderWidth: 1.5, pointRadius: 0, order: 5 },
                        { label: 'Difference Zero', data: [], borderColor: 'rgba(156, 163, 175, 0.8)', borderWidth: 1, pointRadius: 0, borderDash: [2, 2], order: 6 },
                        { type: 'bar', label: 'HKL Markers', data: [], backgroundColor: 'rgba(22, 163, 74, 0.9)', barThickness: 1, categoryPercentage: 1.0, barPercentage: 1.0, order: 0 },
                        
             
                        // The 'Anchor Points' object now correctly sits INSIDE the datasets array.
                        {
                            label: 'Anchor Points',
                            type: 'scatter',
                            data: [], // Initially empty
                            showLine: false,
                            pointBackgroundColor: 'rgba(34, 197, 94, 1)', // A vibrant green
                            pointBorderColor: 'rgba(255, 255, 255, 0.9)',
                            pointRadius: 5,
                            pointHoverRadius: 7,
                            pointBorderWidth: 1.5,
                            order: -1 // Render on top of everything
                        }
                    ] // The datasets array now closes AFTER the Anchor Points object.
                },
                options: {
                    responsive: true, maintainAspectRatio: false, animation: false,
                    scales: {
                        x: { type: 'linear', title: { display: true, text: '2θ (degrees)', font: { size: 14 }}},
                        y: { type: 'linear', position: 'left', title: { display: true, text: 'Intensity (a.u.)', font: { size: 14 }},
                            min: -yMax * 0.3, max: Math.ceil(yMax * 1.1),
                            ticks: { callback: function(value, index, ticks) { return value >= 0 ? value.toFixed(1) : null; }}
                        }
                    },
                    plugins: {
                        zoom: {
                            pan: { enabled: true, mode: 'xy', threshold: 5, onPanComplete: () => rescalePlot(false) },
                            zoom: { wheel: { enabled: false }, pinch: { enabled: true }, drag: { enabled: false }, onZoomComplete: () => rescalePlot(false) }
                        },
                        legend: { labels: { filter: item => item.text !== 'Difference Zero' && item.text !== 'Simulation (Manual)' && item.text !== 'Anchor Points'}},
                        tooltip: {
                            enabled: true,
                            mode: 'nearest',
                            intersect: false,
                            position: 'experimentalAnchor',
                            filter: function(tooltipItem) {
                                const tth = tooltipItem.parsed.x;
                                const peakInfo = getPeakInfoAt(tth);
                                return peakInfo.inRegion;
                            },
                            callbacks: {
                                title: function(tooltipItems) {
                                    if (!tooltipItems.length) return '';
                                    const tth = tooltipItems[0].parsed.x;
                                    const peakInfo = getPeakInfoAt(tth);
                                    if (peakInfo.inRegion) {
                                        const closestPeak = peakInfo.peak;
                                        return `d: ${closestPeak.d.toFixed(2)} Å, HKL: ${closestPeak.hkl_list[0]}`;
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    return null;
                                }
                            }
                        }
                    }
                }
            });
            mainChart.options.globalYMax = yMax;
        }

    function updatePlotRange(recalculateYMax = false) {
            if (!mainChart || workingData.tth.length === 0) {
                return;
            }
            const minTth = parseFloat(controls.tthMinSlider.value);
            const maxTth = parseFloat(controls.tthMaxSlider.value);

            // Explicitly set the x-axis limits
            mainChart.options.scales.x.min = minTth;
            mainChart.options.scales.x.max = maxTth;

            // Recalculate Y-axis if needed
            if (recalculateYMax) {
                // Find the max intensity within the current workingData range
                const currentMaxY = Math.max(...workingData.intensity);
                let newYMax = currentMaxY * 1.1; // Add 10% padding
                if (newYMax < 100) newYMax = 100; // Minimum Y-max

                // Constant negative space for difference plot
                mainChart.options.globalYMax = newYMax; // Store this globally
                mainChart.options.scales.y.max = newYMax;
                mainChart.options.scales.y.min = -(newYMax * 0.3); // Allocate 30% for difference plot
            }
            
            mainChart.update('none');
        }        

    function rescalePlot(updateY = false) {
    // === CONFIGURABLE PARAMETERS FOR DIFFERENCE PLOT ===
    const DIFF_PLOT_MIN_RATIO = 0.1;  // Minimum allocation: 10% of Y scale
    const DIFF_PLOT_MAX_RATIO = 0.3;  // Maximum allocation: 40% of Y scale
    const DIFF_PLOT_PADDING = 1.1;     // Padding factor (1.2 = 20% extra space)
    // =======

    if (!mainChart || !workingData.isValid) return;

    const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
    const globalYMax = mainChart.options.globalYMax;

    // --- DYNAMIC DIFFERENCE PLOT ALLOCATION ---
    let diffPlotHeightRatio = 0.15; // Default allocation

    // This is the source of truth for the difference plot's magnitude
    const diffData = workingData.lastRawDifference || [];
    
    if (diffData.length > 0) {
        const maxAbsDiff = Math.max(...diffData.map(Math.abs));
        const requiredRatio = (maxAbsDiff * DIFF_PLOT_PADDING) / globalYMax;
        diffPlotHeightRatio = Math.max(DIFF_PLOT_MIN_RATIO, Math.min(DIFF_PLOT_MAX_RATIO, requiredRatio));
    }

    const constantNegSpaceHeight = globalYMax * diffPlotHeightRatio;

    // Update Y-axis 
    if (updateY) {
        mainChart.options.scales.y.max = globalYMax;
    }
    mainChart.options.scales.y.min = -constantNegSpaceHeight;
    
    
    // Draw HKL Markers with a fixed pixel height
    const hklDataset = findDataset('HKL Markers');
    if (hklDataset && hklDataset.data.length > 0) {
        //PIXELS
        const HKL_MARKER_PIXEL_HEIGHT = 30; // e.g., 30 pixels tall

        const y_scale = mainChart.scales.y;
        
        // Find the data value that corresponds to the zero-line on the chart
        const zeroLineValue = 0; 

        // Get the pixel position of the zero line and calculate the top pixel
        const bottomPixel = y_scale.getPixelForValue(zeroLineValue);
        const topPixel = bottomPixel + HKL_MARKER_PIXEL_HEIGHT; // Subtract for upward direction

        // Convert these pixel positions back to data values for the chart
        const markerBottom = zeroLineValue;
        const markerTop = y_scale.getValueForPixel(topPixel);

        hklDataset.data.forEach(point => point.y = [markerTop, markerBottom]);
    }


    // --- Plot TRUE difference from the stored `lastRawDifference` array ---
    if (diffData.length > 0 && diffData.length === workingData.tth.length) {
        const constantDiffPlotSpaceTop = -(constantNegSpaceHeight * 0.25);
        const diffPlotZeroLine = -constantNegSpaceHeight + (constantNegSpaceHeight - constantDiffPlotSpaceTop) / 2;

        findDataset('Difference').data = workingData.tth.map((tthPoint, i) => {
            const difference = diffData[i];
            return { x: tthPoint, y: difference + diffPlotZeroLine };
        });

        findDataset('Difference Zero').data = [
            { x: workingData.tth[0], y: diffPlotZeroLine },
            { x: workingData.tth[workingData.tth.length - 1], y: diffPlotZeroLine }
        ];
    } else {
        // If there's no valid difference data, clear the lines.
        findDataset('Difference').data = [];
        findDataset('Difference Zero').data = [];
    }
}

        function getIntegratedIntensity(tth_peak, fwhm, expData, bkgData, multiplier = 2.0) { if (!expData || expData.tth.length === 0 || fwhm <= 0) return 0; const window = fwhm * multiplier; const tth_min = tth_peak - window / 2; const tth_max = tth_peak + window / 2; let integrated_intensity = 0; let startIndex = expData.tth.findIndex(t => t >= tth_min); if(startIndex === -1) return 0; if(startIndex > 0) startIndex--; for (let i = startIndex; i < expData.tth.length; i++) { const current_tth = expData.tth[i]; if (current_tth > tth_max && i > startIndex) break; if (current_tth < tth_min) continue; if (i > startIndex) { const prev_tth = expData.tth[i-1]; const net_intensity = expData.intensity[i] - (bkgData[i] || 0); const prev_net_intensity = expData.intensity[i-1] - (bkgData[i-1] || 0); const step_width = current_tth - prev_tth; integrated_intensity += (net_intensity + prev_net_intensity) / 2 * step_width; } } return Math.max(0, integrated_intensity); }
        
        function downloadTextFile(content, filename) {
            const element = document.createElement('a');
            const file = new Blob([content], {type: 'text/plain;charset=utf-8'});
            element.href = URL.createObjectURL(file);
            element.download = filename;
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }


        // report, fait appel au calcul de surface de voigt
        function generateReportContent(format = 'summary') {
    if (!fitResults || !fitResults.params || !workingData.isValid) {
        return "Error: Fit results are not available.";
    }

    const now = new Date();
    const { params: finalParams, stats, fitFlags, hklList, algorithm } = fitResults;
    const mainScaleFactor = stats.scaleFactor || 1.0;
    
    // --- Helper function for consistent table formatting ---
    const formatLine = (cols, widths) => {
        return cols.map((col, i) => (col || '-').padEnd(widths[i])).join(' ');
    };

    // --- Report Header ---
    const header = [
        'Le Bail Refinement Report',
        '========================================================================',
        '',
        `LeBail Fit, version 2.5`,
        `https://nitad54448.github.io/Enseignement/LeBail.html`,
        `Report Generated: ${now.toLocaleString()}`,
        `Data File: ${controls.fileName.textContent}`,
        ''
    ];

    // --- Refinement Statistics ---
    const profileName = finalParams.profileType === "4" ? "Simple pVoigt" : "TCH w/ Anisotropy";
    const selectedSg = spaceGroups.find(sg => sg.number === parseInt(controls.spaceGroupSelect.value, 10));
    const spaceGroupName = selectedSg ? `${selectedSg.number} – ${selectedSg.name}` : 'N/A';
    
    const statsSection = [
        '--- Refinement Statistics ---',
        `Rp (%):       ${stats.r_p.toFixed(3)}`,
        `Rwp (%):      ${stats.rwp.toFixed(3)}`,
        `χ² (GOF):     ${stats.chi2.toFixed(3)}`,
        `Algorithm:    ${algorithm === 'lm' ? 'Levenberg-Marquardt' : 'Simulated Annealing'}`,
        `Profile:      ${profileName} (#${finalParams.profileType})`,
        `Space Group:  ${spaceGroupName}`,
        ''
    ];

    // --- Parameter Tables ---
    let esds = {};
    let esdWarning = null;
    if (fitResults.algorithm === 'lm' && fitResults.JtJ && fitResults.paramMapping) {
        const N = workingData.intensity.length;
        const P = fitResults.paramMapping.length;
        if (N > P && fitResults.ss_res !== undefined) {
            const reduced_chi_sq = fitResults.ss_res / (N - P);
            const cov_matrix = matrixInverse(fitResults.JtJ);
            if (cov_matrix) {
                fitResults.paramMapping.forEach((p_map, i) => {
                    if (cov_matrix[i] && cov_matrix[i][i] !== undefined) {
                        esds[p_map.name] = Math.sqrt(Math.abs(reduced_chi_sq * cov_matrix[i][i])) * p_map.scale;
                    }
                });
            } else { esdWarning = 'Matrix inversion failed (parameter correlation).'; }
        } else { esdWarning = "N <= P, cannot calculate reliable errors."; }
    } else if (fitResults.algorithm !== 'lm') { 
        esdWarning = "ESDs only available for Levenberg-Marquardt."; 
    }

    const paramWidths = [24, 18, 10, 18];
    const paramHeader = formatLine(['Parameter', 'Value', 'Fitted', 'ESD'], paramWidths);
    const paramLines = [];
    const paramGroups = {};
    
    paramGroups['Structural & Instrumental'] = [ { name: 'a (Å)', value: finalParams.a, flag: fitFlags.a, esd: 'a' }, { name: 'b (Å)', value: finalParams.b, flag: fitFlags.b, esd: 'b' }, { name: 'c (Å)', value: finalParams.c, flag: fitFlags.c, esd: 'c' }, { name: 'alpha (°)', value: finalParams.alpha, flag: fitFlags.alpha, esd: 'alpha' }, { name: 'beta (°)', value: finalParams.beta, flag: fitFlags.beta, esd: 'beta' }, { name: 'gamma (°)', value: finalParams.gamma, flag: fitFlags.gamma, esd: 'gamma' }, { name: 'Radiation 1 (Å)', value: finalParams.lambda }, { name: 'Radiation 2 (Å)', value: finalParams.lambda2 }, { name: 'Ratio (I2/I1)', value: finalParams.ratio }, { name: 'Zero Shift (°)', value: finalParams.zeroShift, flag: fitFlags.zeroShift, esd: 'zeroShift' }, { name: '2theta Min (°)', value: parseFloat(controls.tthMinSlider.value) }, { name: '2theta Max (°)', value: parseFloat(controls.tthMaxSlider.value) }];
    paramGroups['Profile Parameters'] = [];
    paramGroups['Background Parameters'] = [];
    if (finalParams.profileType === "4") { paramGroups['Profile Parameters'].push(...[ { name: 'GU', value: finalParams.GU, flag: fitFlags.GU, esd: 'GU' }, { name: 'GV', value: finalParams.GV, flag: fitFlags.GV, esd: 'GV' }, { name: 'GW', value: finalParams.GW, flag: fitFlags.GW, esd: 'GW' }, { name: 'GP', value: finalParams.GP, flag: fitFlags.GP, esd: 'GP' }, { name: 'LX', value: finalParams.LX, flag: fitFlags.LX, esd: 'LX' }, { name: 'eta (Mixing)', value: finalParams.eta, flag: fitFlags.eta, esd: 'eta' }, { name: 'shft (Displ.)', value: finalParams.shft, flag: fitFlags.shft, esd: 'shft' }, { name: 'trns (Transp.)', value: finalParams.trns, flag: fitFlags.trns, esd: 'trns' } ]); } else { paramGroups['Profile Parameters'].push(...[ { name: 'U', value: finalParams.U, flag: fitFlags.U, esd: 'U' }, { name: 'V', value: finalParams.V, flag: fitFlags.V, esd: 'V' }, { name: 'W', value: finalParams.W, flag: fitFlags.W, esd: 'W' }, { name: 'X', value: finalParams.X, flag: fitFlags.X, esd: 'X' }, { name: 'Y', value: finalParams.Y, flag: fitFlags.Y, esd: 'Y' }, { name: 'S/L (Asymm)', value: finalParams.SL, flag: fitFlags.SL, esd: 'SL' }, { name: 'H/L (Asymm)', value: finalParams.HL, flag: fitFlags.HL, esd: 'HL' } ]); if (finalParams.profileType === "3") { paramGroups['Profile Parameters'].push(...[ { name: 'S400', value: finalParams.S400, flag: fitFlags.S400, esd: 'S400' }, { name: 'S040', value: finalParams.S040, flag: fitFlags.S040, esd: 'S040' }, { name: 'S004', value: finalParams.S004, flag: fitFlags.S004, esd: 'S004' }, { name: 'S220', value: finalParams.S220, flag: fitFlags.S220, esd: 'S220' }, { name: 'S202', value: finalParams.S202, flag: fitFlags.S202, esd: 'S202' }, { name: 'S022', value: finalParams.S022, flag: fitFlags.S022, esd: 'S022' } ]); } }
    for (let i = 0; i < 6; i++) { paramGroups['Background Parameters'].push({ name: `B${i}`, value: finalParams[`B${i}`], flag: fitFlags[`B${i}`], esd: `B${i}` }); }
    paramGroups['Background Parameters'].push(...[ { name: 'Hump Height', value: finalParams.hump_H, flag: fitFlags.hump_H, esd: 'hump_H' }, { name: 'Hump Position', value: finalParams.hump_P, flag: fitFlags.hump_P, esd: 'hump_P' }, { name: 'Hump FWHM', value: finalParams.hump_W, flag: fitFlags.hump_W, esd: 'hump_W' } ]);

    for (const groupName in paramGroups) {
        paramLines.push(`--- ${groupName} ---`, paramHeader, '-'.repeat(paramHeader.length));
        paramGroups[groupName].forEach(p => {
            if (p.value !== undefined && !isNaN(p.value)) {
                const valStr = p.value.toExponential(6);
                const fitStr = (p.flag === undefined) ? '' : (p.flag ? 'Yes' : 'No');
                
                // THIS IS THE CORRECTED LOGIC THAT PREVENTS THE CRASH
                const esdValue = esds[p.esd];
                const esdStr = (p.flag && typeof esdValue === 'number' && isFinite(esdValue)) 
                    ? `(${esdValue.toExponential(2)})` 
                    : '';
                
                paramLines.push(formatLine([p.name, valStr, fitStr, esdStr], paramWidths));
            }
        });
        paramLines.push('');
    }
    if (esdWarning) paramLines.push(`NOTE: ${esdWarning}`);

    // --- Reflections List --- (No changes needed here)
    const reflectionsSection = [];
    if (hklList && hklList.length > 0) {
        const reflWidths = [15, 18, 18, 18];
        const reflHeader = formatLine(['h,k,l', '2th_corr (°)', 'I_calc', 'I_exp'], reflWidths);
        reflectionsSection.push('', '--- Reflections List (Integrated Intensities) ---', reflHeader, '-'.repeat(reflHeader.length));
        
        const finalBkg = calculateTotalBackground(workingData.tth, finalParams);
        hklList.filter(hkl => hkl.tth && hkl.tth >= workingData.tth[0] && hkl.tth <= workingData.tth[workingData.tth.length - 1])
            .forEach(hkl => {
                const peakShift = calculatePeakShift(hkl.tth, finalParams);
                const tthCorr = hkl.tth + finalParams.zeroShift + peakShift;
                const { gamma_G, gamma_L } = calculateProfileWidths(hkl.tth, hkl, finalParams);
                const i_exp = getIntegratedIntensity(tthCorr, Math.sqrt(gamma_G*gamma_G + gamma_L*gamma_L), workingData, finalBkg);
                const profileArea = getPseudoVoigtArea(gamma_G, gamma_L, finalParams);
                const scaled_i_calc_area = hkl.intensity * profileArea * mainScaleFactor;
                if (i_exp > 0.1 || scaled_i_calc_area > 0.1) {
                    reflectionsSection.push(formatLine([
                        hkl.hkl_list[0], tthCorr.toFixed(4), scaled_i_calc_area.toFixed(1), i_exp.toFixed(1)
                    ], reflWidths));
                }
            });
    }

    // --- Point-by-Point Data (for 'full' report) --- (No changes needed here)
    const dataSection = [];
    if (format === 'full') {
        dataSection.push('', '--- Point-by-Point Intensity Data (Fitted Range Only) ---',
            ['2theta', 'I_obs', 'I_calc', 'Difference'].join('\t'),
            '-----------------------------------------------------');
        
        const finalBkg = calculateTotalBackground(workingData.tth, finalParams);
        const finalNetPattern = calculatePattern(workingData.tth, hklList, finalParams);
        for (let i = 0; i < workingData.tth.length; i++) {
            const i_calc = (finalNetPattern[i] * mainScaleFactor) + finalBkg[i];
            dataSection.push([
                workingData.tth[i].toFixed(4),
                workingData.intensity[i].toFixed(2),
                i_calc.toFixed(2),
                (workingData.intensity[i] - i_calc).toFixed(2)
            ].join('\t'));
        }
    }
    
    return [...header, ...statsSection, ...paramLines, ...reflectionsSection, ...dataSection].join('\n');
}

        // --- EVENT LISTENERS ---

        controls.fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                try {
                    const parsedData = detectAndParseFile(file.name, evt.target.result);
                    if (!parsedData || parsedData.tth.length === 0) throw new Error("No valid data points parsed.");
                    if (parsedData.wavelength) controls.wavelength.value = parsedData.wavelength.toFixed(5);
                    
                    fullExperimentalData = { tth: parsedData.tth, intensity: parsedData.intensity };
                    lastRawDifference = [];
                    calculatedBackground = new Array(fullExperimentalData.tth.length).fill(0);
                    workingDataCache.isValid = false;
                    
                    controls.fileName.textContent = file.name;
                    controls.placeholder.style.display = 'none';
                    controls.resultsContainer.style.display = 'flex';
                    controls.fitButton.disabled = false;
                    controls.fitButton.textContent = 'Run Refinement';
                    
                    initializeChart();
                    
                    // Get the true min and max from the data
                    const min = fullExperimentalData.tth[0];
                    const max = fullExperimentalData.tth[fullExperimentalData.tth.length - 1];
                    const step = (max - min) / 2000;

                    // Set the absolute boundaries of the sliders to the full data range
                    [controls.tthMinSlider, controls.tthMaxSlider].forEach(slider => {
                        slider.min = min;
                        slider.max = max;
                        slider.step = step;
                        slider.disabled = false;
                    });
                    
            
                    // Set the initial slider positions to the full data range
                    controls.tthMinSlider.value = min;
                    controls.tthMaxSlider.value = max;
                    controls.tthMinValue.textContent = min.toFixed(2);
                    controls.tthMaxValue.textContent = max.toFixed(2);
                    
             //estimate a good background, version 2.3, i'll erase it if it's flaky      
              const estimatedBgParams = estimateBackgroundParameters(fullExperimentalData.tth, fullExperimentalData.intensity);
            if (estimatedBgParams) {
                for (let i = 0; i < 5; i++) {
                    const input = document.getElementById(`param-b${i}`);
                    if (input && estimatedBgParams[`B${i}`] !== undefined) {
                        input.value = estimatedBgParams[`B${i}`].toFixed(2);
                    }
                }
            }


            updateWorkingData();
            updatePlotRange(true);
            generateMasterHklList();      
            updateBackgroundForPreview();
            rescalePlot(false); 
            mainChart.update('none');


                    mainChart.update('none');  // This commits all changes to the display

                } catch (error) {
                    alert(`Error reading file: ${error.message}`);
                    console.error(error);
                }
            };
            reader.onerror = () => alert('Error reading file.');
            reader.readAsText(file);
        });

        controls.fitButton.addEventListener('click', runLeBailFit);


        document.getElementById('tab-panel-background').addEventListener('input', (e) => {
            // Check if the event was triggered by the anchor visibility checkbox
            if (e.target.id === 'show-anchors-checkbox') {
                // If so, do nothing and exit the function.
                return;
            }
            // Otherwise, run the preview update as normal for all other controls.
            updateBackgroundForPreview();
        });

document.querySelector('.tab-buttons').addEventListener('click', (e) => { const clickedTab = e.target.closest('.tab-btn'); if (clickedTab && !clickedTab.disabled) { e.currentTarget.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active')); clickedTab.classList.add('active'); document.querySelectorAll('.tab-content-panel').forEach(panel => panel.classList.remove('active')); document.getElementById(`tab-panel-${clickedTab.dataset.tab}`).classList.add('active'); } });
        
        const resizer = document.getElementById('drag-handle'); const leftPanel = document.getElementById('controls-panel');
        resizer.addEventListener('mousedown', (e) => { e.preventDefault(); document.body.style.cursor = 'col-resize'; const moveHandler = (moveEvent) => { if (moveEvent.clientX > 350 && moveEvent.clientX < window.innerWidth - 350) leftPanel.style.width = `${moveEvent.clientX}px`; }; const upHandler = () => { document.body.style.cursor = 'default'; window.removeEventListener('mousemove', moveHandler); window.removeEventListener('mouseup', upHandler); }; window.addEventListener('mousemove', moveHandler); window.addEventListener('mouseup', upHandler); });
        
        // Regenerate the master list when the space group or system is changed
                    controls.bravaisLattice.addEventListener('change', () => {
            updateUIForSystemChange();
            generateMasterHklList();
                rescalePlot(false);
    mainChart.update('none');
        });

controls.spaceGroupSelect.addEventListener('change', () => {
    generateMasterHklList();
    rescalePlot(false);
    mainChart.update('none');
});

        controls.fileInput.addEventListener('change', (e) => {

            generateMasterHklList();
        });



        document.getElementById('anchor-points-list').addEventListener('input', handleAnchorListInteraction);
        document.getElementById('anchor-points-list').addEventListener('click', handleAnchorListInteraction);


        document.getElementById('show-anchors-checkbox').addEventListener('change', (e) => {
            if (mainChart) {
                const isVisible = e.target.checked;
                const anchorDataset = mainChart.data.datasets.find(d => d.label === 'Anchor Points');
                
                if (anchorDataset) {
                    anchorDataset.hidden = !isVisible;
                    mainChart.update('none');
                }
            }
        });


        controls.mainChartCanvas.addEventListener('click', e => {
    if (e.ctrlKey && mainChart) {
        e.preventDefault();
        e.stopPropagation();

        // --- NEW: Store the current Y-axis zoom level ---
        const currentYMin = mainChart.scales.y.min;
        const currentYMax = mainChart.scales.y.max;

        const rect = controls.mainChartCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        
        const tthValue = mainChart.scales.x.getValueForPixel(x);
        const closestPoint = findClosestExperimentalPoint(tthValue);

        if (closestPoint) {
            const isAlreadyAdded = backgroundAnchors.some(a => a.index === closestPoint.index);
            if (!isAlreadyAdded) {
                backgroundAnchors.push(closestPoint);
                backgroundAnchors.sort((a, b) => a.tth - b.tth); 
                renderAnchorList();
                // This call will still trigger the unwanted Y-axis change
                updateBackgroundForPreview();
            }
        }

        // --- NEW: Forcefully restore the Y-axis to its previous state ---
        mainChart.options.scales.y.min = currentYMin;
        mainChart.options.scales.y.max = currentYMax;
        
        // Apply the restored zoom level
        mainChart.update('none');
    }
});
      
        const controlsPanel = document.getElementById('controls-panel');
        controlsPanel.addEventListener('input', (event) => {
            const target = event.target;

            // Exit if the chart doesn't exist yet or if fitting is in progress.
            if (!mainChart || isFitting) {
                return;
            }
            
            // Ignore controls that have their own specific listeners or shouldn't trigger a live preview.
            if (target.id.startsWith('tth-') || target.id === 'iterations-slider' || target.id === 'algorithm-select') {
                return;
            }

            // For parameters that change the hkl positions, regenerate the list first.
            if (target.id === 'wavelength' || target.id.startsWith('lattice-param-')) {
                generateMasterHklList(); // This internally calls updatePreviewPattern
            } else {
                // For all other parameters (profile, background, etc.), just update the preview.
                updatePreviewPattern();
            }

            // After any calculation, redraw the chart to show the changes.
            rescalePlot(false);
            mainChart.update('none');
});
        
        controls.iterationsSlider.addEventListener('input', () => controls.iterationsValue.textContent = controls.iterationsSlider.value);
        

        
controls.tthMinSlider.addEventListener('input', () => { 
    let minVal = parseFloat(controls.tthMinSlider.value); 
    let maxVal = parseFloat(controls.tthMaxSlider.value); 
    if (minVal >= maxVal) { 
        minVal = maxVal - parseFloat(controls.tthMinSlider.step); 
        controls.tthMinSlider.value = minVal; 
    } 
    controls.tthMinValue.textContent = minVal.toFixed(2); 

    redrawFitForNewRange();
});

controls.tthMaxSlider.addEventListener('input', () => { 
    let minVal = parseFloat(controls.tthMinSlider.value); 
    let maxVal = parseFloat(controls.tthMaxSlider.value); 
    if (maxVal <= minVal) { 
        maxVal = minVal + parseFloat(controls.tthMaxSlider.step); 
        controls.tthMaxSlider.value = maxVal; 
    } 
    controls.tthMaxValue.textContent = maxVal.toFixed(2); 

    redrawFitForNewRange();
});
        
controls.mainChartCanvas.addEventListener('wheel', e => {
    e.preventDefault();
    const chart = mainChart;
    if (!chart || !chart.chartArea) return;

    const { left, right, top, bottom } = chart.chartArea;
    const xPixel = e.offsetX;
    const yPixel = e.offsetY;
    
    // Zoom in = smaller range (factor < 1), zoom out = larger range (factor > 1)
    const zoomFactor = e.deltaY < 0 ? 0.9 : 1.1;

    // Helper function to perform anchored zoom on a specific axis
    const zoomOnAxis = (axisID, factor, focalPixel) => {
        const axis = chart.scales[axisID];
        if (!axis) return;

        // Get the data value directly under the mouse cursor
        const focalValue = axis.getValueForPixel(focalPixel);
        
        const currentRange = axis.max - axis.min;
        const newRange = currentRange * factor;
        
        // Determine where the mouse is proportionally on the current axis (from 0.0 to 1.0)
        const focalRatio = (focalValue - axis.min) / currentRange;
        
        // Calculate the new min and max to keep the focal point stationary
        const newMin = focalValue - (newRange * focalRatio);
        const newMax = newMin + newRange;
        
        // Apply the new limits directly to the chart options
        chart.options.scales[axisID].min = newMin;
        chart.options.scales[axisID].max = newMax;
    };

    // Determine which axis/axes to zoom based on cursor position
    if (yPixel > bottom) { // Zooming on X-axis
        zoomOnAxis('x', zoomFactor, xPixel);
    } else if (xPixel < left) { // Zooming on Y-axis
        zoomOnAxis('y', zoomFactor, yPixel);
    } else if (xPixel >= left && xPixel <= right && yPixel >= top && yPixel <= bottom) { // Zooming on both
        zoomOnAxis('x', zoomFactor, xPixel);
        zoomOnAxis('y', zoomFactor, yPixel);
    }
   
    chart.update('none');
    rescalePlot(false); 
});


//changé le 04 oct, version 2.3
controls.mainChartCanvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    if (!mainChart) return;

    // 1. Manually reset the X-axis to the CURRENT SLIDER range
    mainChart.options.scales.x.min = parseFloat(controls.tthMinSlider.value); // Use .value
    mainChart.options.scales.x.max = parseFloat(controls.tthMaxSlider.value); // Use .value
    
    // 2. Manually reset the Y-axis using the original max value we stored
    const globalYMax = mainChart.options.globalYMax;
    mainChart.options.scales.y.max = globalYMax;
    mainChart.options.scales.y.min = -(globalYMax * 0.3); // Restore the default 30% space for the diff plot

    // 3. Update the chart to apply these new axis limits and redraw the difference plot
    mainChart.update('none');
    rescalePlot(false);
});


        controls.profileSelect.addEventListener('change', (e) => { const newProfile = e.target.value; saveProfileState(currentProfile); controls.simplePVoigtParamsContainer.classList.toggle('hidden', newProfile !== '4'); controls.anisotropyParamsContainer.classList.toggle('hidden', newProfile !== '3'); restoreProfileState(newProfile); currentProfile = newProfile; if (fullExperimentalData.tth.length > 0) updatePreviewPattern(); });
        
        // This now uses the new helper function
        controls.bravaisLattice.addEventListener('change', updateUIForSystemChange);
        
        controls.paramS400.addEventListener('input', updateStephensAnisotropyUI); controls.fitS400.addEventListener('change', updateStephensAnisotropyUI); controls.paramS220.addEventListener('input', updateStephensAnisotropyUI); controls.fitS220.addEventListener('change', updateStephensAnisotropyUI); controls.paramS202.addEventListener('input', updateStephensAnisotropyUI); controls.fitS202.addEventListener('change', updateStephensAnisotropyUI);


        controls.saveDataButton.addEventListener('click', () => {
            if (!fitResults) {
                alert("Please run a refinement before saving data.");
                return;
            }
            const originalText = controls.saveDataButton.textContent;
            controls.saveDataButton.textContent = 'Saving...';
            controls.saveDataButton.disabled = true;
            try {
                // MODIFIED: Calls the new central function to get the full report text.
                const textContent = generateReportContent('full');
                const timestamp = new Date().toISOString().slice(0, 16).replace(/[-:]/g, '').replace('T', '_');
                downloadTextFile(textContent, `LeBail-Data-${timestamp}.txt`);
            } catch (error) {
                console.error("Failed to save data:", error);
                alert("An error occurred while saving the data file.");
            } finally {
                controls.saveDataButton.textContent = 'Save Report';
                controls.saveDataButton.disabled = false;
            }
        });


        controls.reportButton.addEventListener('click', async () => {
    if (!fitResults) {
        alert("Cannot generate report: Fit results are missing.");
        return;
    }

    const originalText = controls.reportButton.textContent;
    controls.reportButton.textContent = 'Generating...';
    controls.reportButton.disabled = true;

    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
        const margin = 15;
        const contentWidth = doc.internal.pageSize.getWidth() - 2 * margin;
        let yPosition = 20;

        // Get the summary report (we don't need the full data dump in the PDF)
        const summaryText = generateReportContent('summary');

        // Replace special characters with PDF-safe equivalents
        const pdfText = summaryText
            .replace(/χ²/g, 'Chi^2')
            .replace(/°/g, 'deg')
            .replace(/β/g, 'Beta');

        const lines = pdfText.split('\n');

        // Set Courier as the single font for the entire text portion
        doc.setFont('Courier');

        for (const line of lines) {
            if (yPosition > doc.internal.pageSize.getHeight() - 20) {
                doc.addPage();
                yPosition = 20;
            }

            const isHeader = line.startsWith('---');
            const isTitle = line.includes('Le Bail Refinement Report');

            // Set font size and style based on line type
            let fontSize = 9;
            let fontStyle = 'normal';

            if (isTitle) {
                fontSize = 14;
                fontStyle = 'bold';
                yPosition += 6; // Extra space for title
            } else if (isHeader) {
                fontSize = 10;
                fontStyle = 'bold';
                yPosition += 4; // Extra space for headers
            }
            
            doc.setFontSize(fontSize);
            doc.setFont(undefined, fontStyle);

            // Print the line
            doc.text(line, margin, yPosition);
            yPosition += fontSize * 0.4; // Move y-position for the next line
        }

        // Add Chart Image on a new page
        doc.addPage();
        const chartCanvas = await html2canvas(controls.mainChartCanvas, { backgroundColor: '#ffffff', scale: 2 });
        const mainImgData = chartCanvas.toDataURL('image/png', 0.95);
        const mainImgProps = doc.getImageProperties(mainImgData);
        const mainImgHeight = Math.min((mainImgProps.height * contentWidth) / mainImgProps.width, 250); 
        doc.addImage(mainImgData, 'PNG', margin, 20, contentWidth, mainImgHeight);
        
        doc.save(`LeBail-Report-${new Date().toISOString().slice(0, 10)}.pdf`);

    } catch (error) {
        console.error("Failed to generate report:", error);
        alert(`An error occurred while generating the report: ${error.message}`);
    } finally {
        controls.reportButton.textContent = 'Generate PDF';
        if (fitResults) {
            controls.reportButton.disabled = false;
        }
    }
});

        updateUIForSystemChange();
    });

</script>


</body>
</html>