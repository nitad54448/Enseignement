<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Le Bail Fit</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        :root {
            --system-blue: #007AFF;
            --system-gray-1: #8E8E93;
            --system-gray-2: #AEAEB2;
            --system-gray-3: #C7C7CC;
            --system-gray-4: #D1D1D6;
            --system-gray-5: #E5E5EA;
            --system-gray-6: #F2F2F7;
            --system-background: #FFFFFF;
            --system-grouped-background: #F2F2F7;
            --system-material-thin: rgba(255, 255, 255, 0.7);
            --system-material-regular: rgba(255, 255, 255, 0.8);
            --system-label: #000000;
            --system-secondary-label: rgba(60, 60, 67, 0.6);
            --system-tertiary-label: rgba(60, 60, 67, 0.3);
            --system-separator: rgba(60, 60, 67, 0.29);
            --system-fill: rgba(120, 120, 128, 0.2);
            --system-secondary-fill: rgba(120, 120, 128, 0.16);
            --system-shadow: rgba(0, 0, 0, 0.1);
        }

        #fit-button { width: 100%; }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif; 
            margin: 0; 
            background-color: var(--system-grouped-background); 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            overflow: hidden; 
            color: var(--system-label);
        }
        #app-container { 
            display: flex; 
            width: 100%; 
            flex-grow: 1; 
            min-height: 0; 
            background-color: var(--system-grouped-background);
        }
        
        #controls-panel { 
            width: 380px; 
            min-width: 320px; 
            max-width: 500px; 
            flex-shrink: 0; 
            padding: 16px; 
            background-color: var(--system-background); 
            border-right: 1px solid var(--system-separator); 
            display: flex; 
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            z-index: 20;
            box-shadow: 0 0 20px rgba(0,0,0,0.05);
            border-radius: 0 12px 12px 0;
        }
        
        #drag-handle { 
            width: 6px; 
            cursor: col-resize; 
            background-color: var(--system-gray-5); 
            flex-shrink: 0; 
            transition: background-color 0.2s; 
        }
        #drag-handle:hover, #drag-handle:active { 
            background-color: var(--system-blue); 
        }
        
        #results-area { 
            flex-grow: 1; 
            position: relative; 
            background-color: var(--system-background); 
            min-width: 0; 
            display: flex; 
            flex-direction: column; 
            padding: 20px; 
            z-index: 10;
            border-radius: 12px 0 0 12px;
            margin: 8px 8px 8px 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
        }
        
        .control-group { 
            padding: 16px; 
            margin-bottom: 16px;
            background-color: var(--system-background);
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .control-group:first-child { 
            padding-top: 0; 
            margin-top: 0;
        }
        .control-label { 
            display: block; 
            font-weight: 500; 
            color: var(--system-secondary-label); 
            font-size: 13px; 
            margin-bottom: 6px;
        }
        
        .control-input, .control-select { 
            width: 100%; 
            background-color: var(--system-gray-6); 
            border: 1px solid var(--system-gray-4); 
            color: var(--system-label); 
            border-radius: 8px; 
            padding: 10px 14px; 
            transition: all 0.2s ease; 
            box-sizing: border-box;
            font-size: 15px;
            height: 40px;
        }
        .control-input:focus, .control-select:focus { 
            outline: none; 
            border-color: var(--system-blue); 
            box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2); 
        }
        .control-input:disabled { 
            background-color: var(--system-gray-6);
            color: var(--system-tertiary-label);
            cursor: not-allowed; 
        }
        
        .btn { 
            padding: 12px 20px; 
            border-radius: 10px; 
            font-weight: 600; 
            transition: all 0.2s; 
            cursor: pointer; 
            border: none; 
            text-align: center; 
            font-size: 15px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-primary { 
            background-color: var(--system-blue); 
            color: white; 
            box-shadow: 0 1px 3px rgba(0, 122, 255, 0.3);
        }
        .btn-primary:hover:not(:disabled) { 
            background-color: #006ee6; 
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 122, 255, 0.3);
        }
        .btn-primary:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 122, 255, 0.3);
        }
        .btn-secondary { 
            background-color: var(--system-gray-6); 
            color: var(--system-label); 
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .btn-secondary:hover:not(:disabled) { 
            background-color: var(--system-gray-5); 
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .btn:disabled { 
            background-color: var(--system-gray-6); 
            color: var(--system-tertiary-label);
            cursor: not-allowed; 
            opacity: 0.7; 
            box-shadow: none;
        }
        
        .file-input-label { 
            display: block; 
            padding: 12px 16px; 
            background-color: var(--system-gray-6); 
            color: var(--system-label); 
            border-radius: 10px; 
            text-align: center; 
            cursor: pointer; 
            transition: all 0.2s;
            font-weight: 500;
            border: 1px dashed var(--system-gray-4);
        }
        .file-input-label:hover { 
            background-color: var(--system-gray-5); 
            border-color: var(--system-blue);
        }
        
        .results-grid { 
            display: grid; 
            grid-template-columns: repeat(3, minmax(80px, 1fr)); 
            gap: 12px; 
        }
        .result-card { 
            background-color: var(--system-gray-6); 
            padding: 12px; 
            border-radius: 10px; 
            text-align: center; 
            transition: all 0.2s; 
        }
        .result-card-label { 
            font-size: 12px; 
            color: var(--system-secondary-label); 
            margin-bottom: 4px;
        }
        .result-card-value { 
            font-size: 18px; 
            font-weight: 700; 
            color: var(--system-label); 
        }
        
        .fit-checkbox { 
            -webkit-appearance: none; 
            appearance: none; 
            background-color: var(--system-gray-6); 
            width: 22px; 
            height: 22px; 
            border: 1px solid var(--system-gray-4); 
            border-radius: 6px; 
            cursor: pointer; 
            display: inline-block; 
            position: relative; 
            transition: all 0.2s;
        }
        .fit-checkbox:checked { 
            background-color: var(--system-blue); 
            border-color: var(--system-blue); 
        }
        .fit-checkbox:checked::after { 
            content: '✓'; 
            color: white; 
            position: absolute; 
            left: 50%; 
            top: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 14px; 
            font-weight: bold;
        }
        
        .tab-buttons { 
            display: flex; 
            background-color: var(--system-gray-6);
            border-radius: 10px;
            padding: 4px;
            margin-bottom: 16px;
        }
        .tab-btn { 
            flex: 1; 
            padding: 8px 12px; 
            background: none; 
            border: none; 
            color: var(--system-secondary-label); 
            font-weight: 500; 
            cursor: pointer; 
            border-radius: 8px;
            transition: all 0.2s; 
            font-size: 14px; 
        }
        .tab-btn:hover { 
            color: var(--system-label); 
            background-color: rgba(255,255,255,0.5);
        }
        .tab-btn.active { 
            color: var(--system-blue); 
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .tab-content-panels { 
            position: relative; 
            padding-top: 0; 
        }
        .tab-content-panel { 
            display: none; 
            flex-direction: column; 
        }
        .tab-content-panel.active { 
            display: flex; 
        }

        .tab-content-panel > .control-group {
            border-top: none;
        }

        #lattice-parameters-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .bottom-actions { 
            margin-top: auto; 
            padding-top: 16px;
        }

        .slider-value-track { 
            display: grid; 
            grid-template-columns: 1fr; 
            grid-template-rows: 1fr; 
            align-items: center; 
        }
        .slider-value-track > * { 
            grid-column: 1; 
            grid-row: 1; 
        }
        .slider-value-display { 
            text-align: center; 
            color: var(--system-secondary-label); 
            font-weight: 500; 
            font-size: 13px; 
            pointer-events: none; 
        }
        input[type="range"].custom-slider { 
            -webkit-appearance: none; 
            appearance: none; 
            width: 100%; 
            height: 36px; 
            background: var(--system-gray-6); 
            border-radius: 6px; 
            outline: none; 
            padding: 0; 
            margin: 0; 
        }
        input[type="range"].custom-slider::-webkit-slider-thumb { 
            -webkit-appearance: none; 
            appearance: none; 
            width: 22px; 
            height: 22px; 
            background: var(--system-blue); 
            border-radius: 50%; 
            cursor: pointer; 
            border: 3px solid white; 
            box-sizing: border-box; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        input[type="range"].custom-slider::-moz-range-thumb { 
            width: 22px; 
            height: 22px; 
            background: var(--system-blue); 
            border-radius: 50%; 
            cursor: pointer; 
            border: 3px solid white; 
            box-sizing: border-box; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        input[type="range"].custom-slider:disabled { 
            background: var(--system-gray-6); 
        }
        input[type="range"].custom-slider:disabled::-webkit-slider-thumb { 
            background: var(--system-gray-3); 
        }
        input[type="range"].custom-slider:disabled::-moz-range-thumb { 
            background: var(--system-gray-3); 
        }

        /* --- UNIFIED UI & SPACING STYLES --- */
        #tab-panel-sample > .control-group, #tab-panel-background > .control-group {
            display: flex; 
            flex-direction: column; 
            gap: 16px; 
        }
        
        .control-group h2, .profile-section-header {
            margin: 0 0 16px 0; 
            padding-bottom: 12px; 
            border-bottom: 1px solid var(--system-separator);
            color: var(--system-label); 
            font-size: 17px; 
            font-weight: 600;
        }

.profile-controls-container + .profile-controls-container {
    margin-top: 24px;
}

        .parameter-grid-3col, .parameter-grid-2col, .slider-group, .form-row {
            display: grid; 
            gap: 12px; 
            align-items: center;
        }
        .parameter-grid-3col { 
            grid-template-columns: minmax(100px, auto) 1fr auto; 
        }
        .parameter-grid-2col, .slider-group, .form-row { 
            grid-template-columns: minmax(100px, auto) 1fr; 
        }
        
        .parameter-grid-3col > .control-label, .parameter-grid-2col > .control-label,
        .slider-group > .control-label, .form-row > .control-label {
            grid-column: 1; 
            margin-bottom: 0;
        }
        
        .parameter-grid-2col > *:not(label), .slider-group > .slider-value-track,
        .form-row > *:not(label) { 
            grid-column: 2; 
        }
        .parameter-grid-3col > .control-input { 
            grid-column: 2; 
        }
        .parameter-grid-3col > .fit-checkbox { 
            grid-column: 3; 
            justify-self: center; 
        }

        .profile-controls-container {
            display: grid; 
            grid-template-columns: minmax(100px, auto) 1fr auto;
            gap: 16px 12px; 
            align-items: center;
        }
        .profile-controls-container > .control-label { 
            grid-column: 1; 
            text-align: left; 
            margin-bottom: 0; 
        }
        .profile-controls-container > input[type="number"] { 
            grid-column: 2; 
        }
        .profile-controls-container > input[type="checkbox"] { 
            grid-column: 3; 
            justify-self: center; 
        }
        .profile-controls-container > .profile-section-header { 
            grid-column: 1 / -1; 
        }
        
        #tab-panel-sample > .control-group:nth-of-type(2) {
            display: grid; 
            grid-template-columns: minmax(100px, auto) 1fr;
            gap: 16px; 
            align-items: center;
        }
        #tab-panel-sample > .control-group:nth-of-type(2) > h2,
        #tab-panel-sample > .control-group:nth-of-type(2) > .parameter-grid-3col {
            grid-column: 1 / -1;
        }
        #tab-panel-sample > .control-group:nth-of-type(2) > label[for="wavelength"] {
            grid-column: 1; 
            margin-bottom: 0;
        }
        #tab-panel-sample > .control-group:nth-of-type(2) > .flex {
            grid-column: 2; 
            display: flex;
        }
        
        .bottom-actions > .control-group {
            display: grid; 
            grid-template-columns: minmax(100px, auto) 1fr;
            gap: 16px; 
            align-items: center; 
            border: none; 
            padding: 0;
        }
        .bottom-actions > .control-group > h2,
        .bottom-actions > .control-group > .slider-group,
        .bottom-actions > .control-group > #progress-bar-container,
        .bottom-actions > .control-group > .results-grid {
            grid-column: 1 / -1;
        }
        .bottom-actions > .control-group > label[for="algorithm-select"] {
            grid-column: 1; 
            margin-bottom: 0;
        }
        .bottom-actions > .control-group > #algorithm-select {
            grid-column: 2; 
            margin-bottom: 0;
        }
        
        /* --- FINAL TOOLTIP AND SCROLLBAR FIX --- */
        .help-tooltip-container { 
            position: relative; 
            display: inline-block; 
        }
.help-icon { 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    width: 24px; 
    height: 24px; 
    background-color: #4a5568; /* Darker background for icon */
    color: white; /* White question mark */
    border-radius: 50%; 
    font-weight: 500; 
    font-size: 14px; 
    cursor: help; 
    transition: all 0.2s; 
}
.help-icon:hover { 
    background-color: #2d3748; /* Even darker on hover */
    color: white;
}
        
.tooltip-content {
    visibility: hidden; 
    opacity: 0; 
    width: 280px;
    background-color: #2d3748; /* Darker background for better contrast */
    color: #f7fafc; /* Light text color */
    text-align: left;
    border-radius: 10px; 
    padding: 16px;
    position: absolute; 
    z-index: 1001;
    top: -15px;
    right: 115%;
    margin-right: 10px;
    transition: opacity 0.3s; 
    font-size: 13px; 
    border: 1px solid #4a5568; /* Darker border */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); /* Stronger shadow */
}
.tooltip-content::after {
    content: ""; 
    position: absolute;
    top: 20px;
    left: 100%;
    margin-top: -5px; 
    border-width: 5px; 
    border-style: solid;
    border-color: transparent transparent transparent #2d3748; /* Match tooltip background */
}
        .help-tooltip-container:hover .tooltip-content { 
            visibility: visible; 
            opacity: 1; 
        }
.tooltip-content h4 { 
    color: #fff; /* White for headings */
    font-size: 15px; 
    margin-top: 0; 
    margin-bottom: 8px; 
    font-weight: 600; 
}
.tooltip-content p { 
    margin-top: 0; 
    margin-bottom: 12px; 
    line-height: 1.4; 
    color: #e2e8f0; /* Lighter gray for paragraph text */
}
.tooltip-content hr { 
    border: none; 
    border-top: 1px solid #4a5568; /* Darker separator */
    margin: 12px 0; 
}
        .hidden { 
            display: none !important; 
        }

        #controls-panel::-webkit-scrollbar { 
            width: 5px; 
        }
        #controls-panel::-webkit-scrollbar-track { 
            background: transparent; 
        }
        #controls-panel::-webkit-scrollbar-thumb { 
            background: var(--system-gray-4); 
            border-radius: 3px; 
        }
        #controls-panel::-webkit-scrollbar-thumb:hover { 
            background: var(--system-gray-3); 
        }

        /* Apple-style progress bar */
        #progress-bar-container {
            height: 5px;
            background-color: var(--system-gray-5);
            border-radius: 3px;
            overflow: hidden;
        }
        #progress-bar {
            height: 100%;
            background-color: var(--system-blue);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        /* Apple-style placeholder */
        #placeholder {
            background-color: var(--system-background);
            border-radius: 12px;
            padding: 40px;
        }
        #placeholder svg {
            color: var(--system-gray-3);
        }

        /* Subtle animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .control-group {
            animation: fadeIn 0.3s ease;
        }

        /* Improved focus states for accessibility */
        .btn:focus-visible,
        .control-input:focus-visible,
        .control-select:focus-visible,
        .fit-checkbox:focus-visible {
            outline: 2px solid var(--system-blue);
            outline-offset: 2px;
        }

    </style>
</head>

<body>

    <div id="app-container">
        <div id="controls-panel">
            
            <div class="control-group" style="padding-top: 16px;">
                 <div style="display: flex; align-items: center; gap: 10px;">
                     <label for="file-input" class="file-input-label" style="flex-grow: 1;">
                        <span id="file-name">Select Data File</span>
                    </label>
                     

                    <a href="LeBail_help.html" target="_blank" title="Open Help Documentation" style="text-decoration: none;">
                        <span class="help-icon">?</span>
                    </a>


                </div>
                <input type="file" id="file-input" class="hidden" accept=".brml,.csv,.ras,.txt,.esd,.gsa,.std,.udf,.xrdml,.xy">
            </div>

            <div class="tab-buttons">
                <button class="tab-btn active" data-tab="sample">Sample</button>
                <button class="tab-btn" data-tab="background">Background</button>
                <button class="tab-btn" data-tab="profile">Profile</button>
            </div>

            <div class="tab-content-panels">
                <div id="tab-panel-sample" class="tab-content-panel active">
                    <div class="control-group">
                        <h2>Structural Parameters</h2>
                        <div class="parameter-grid-2col">
                            <label for="bravais-lattice" class="control-label">System</label>
                            <select id="bravais-lattice" class="control-select">
                                <option value="cubic_F" selected>Cubic (F)</option>
                                <option value="cubic_I">Cubic (I)</option>
                                <option value="cubic_P">Cubic (P)</option>
                                <option value="hexagonal_P">Hexagonal (P)</option>
                                <option value="hexagonal_R">Trigonal (R, Hex. axes)</option>
                                <option value="rhombohedral_P">Rhombohedral (Rhom. axes)</option>
                                <option value="tetragonal_I">Tetragonal (I)</option>
                                <option value="tetragonal_P">Tetragonal (P)</option>
                                <option value="orthorhombic_F">Orthorhombic (F)</option>
                                <option value="orthorhombic_I">Orthorhombic (I)</option>
                                <option value="orthorhombic_C">Orthorhombic (C)</option>
                                <option value="orthorhombic_P">Orthorhombic (P)</option>
                                <option value="monoclinic_C">Monoclinic (C)</option>
                                <option value="monoclinic_P">Monoclinic (P)</option>
                            </select>
                        </div>
                        <div id="lattice-parameters-container">
                        </div>
                    </div>
                    <div class="control-group">
                        <h2>Instrumental Parameters</h2>
                        <label for="wavelength" class="control-label">Radiation (Å)</label>
                        <input type="number" id="wavelength" value="1.54056" step="0.0001" class="control-input" min="0.01">



                        <div class="parameter-grid-3col">
                            <label for="zero-shift" class="control-label">Zero (°)</label>
                            <input type="number" id="zero-shift" value="0.0" step="0.001" class="control-input">
                            <input type="checkbox" id="fit-zero-shift" class="fit-checkbox" title="Fit this parameter" checked>
                        </div>

                    </div>
                </div>

                <div id="tab-panel-background" class="tab-content-panel">
                    <div class="control-group">
                        <h2>Background (Rolling Ball)</h2>
                        
                        <div class="slider-group">
                             <label class="control-label">Ball Radius (pts)</label>
                             <div class="slider-value-track">
                                <input type="range" id="ball-radius-slider" class="custom-slider" min="1" max="150" value="30" step="1">
                                <span id="ball-radius-value" class="slider-value-display">30</span>
                             </div>
                        </div>

                         <div class="slider-group">
                             <label class="control-label">Smoothing (pts)</label>
                             <div class="slider-value-track">
                                <input type="range" id="smoothing-width-slider" class="custom-slider" min="1" max="50" value="5" step="1">
                                <span id="smoothing-width-value" class="slider-value-display">5</span>
                             </div>
                        </div>
                    </div>
                </div>

                <div id="tab-panel-profile" class="tab-content-panel">
                     <div class="control-group">
                        <div class="parameter-grid-2col" style="margin-bottom: 24px;">
                             <label for="profile-function-select" class="control-label">Profile Function</label>
<select id="profile-function-select" class="control-select">
   <option value="4" selected>Simple pVoigt</option>
   <option value="3">Anisotropy</option>
</select>
                        </div>

                        <div id="simple-pvoigt-params-container" class="profile-controls-container">
    <h3 class="profile-section-header">Gaussian Broadening</h3>
    <label class="control-label">GU</label>
    <input type="number" id="param-gu" value="0.70" step="0.1" class="control-input" min="0">
    <input type="checkbox" id="fit-gu" class="fit-checkbox">
    <label class="control-label">GV</label>
    <input type="number" id="param-gv" value="-1.7" step="0.1" class="control-input">
    <input type="checkbox" id="fit-gv" class="fit-checkbox" >
    <label class="control-label">GW</label>
    <input type="number" id="param-gw" value="0.34" step="0.1" class="control-input" min="0">
    <input type="checkbox" id="fit-gw" class="fit-checkbox" >
     <label class="control-label">GP</label>
    <input type="number" id="param-gp" value="0.120" step="0.1" class="control-input">
    <input type="checkbox" id="fit-gp" class="fit-checkbox">
    <h3 class="profile-section-header">Lorentzian Broadening</h3>
    <label class="control-label">LX</label>
    <input type="number" id="param-lx" value=".1" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-lx" class="fit-checkbox" >
     <h3 class="profile-section-header">Peak Shape & Position</h3>
     <label class="control-label">eta (Mixing)</label>
    <input type="number" id="param-eta" value="0.74" step="0.01" min="0" max="1" class="control-input">
    <input type="checkbox" id="fit-eta" class="fit-checkbox">
     <label class="control-label">shft (Displ.)</label>
    <input type="number" id="param-shft" value="0" step="0.01" class="control-input">
    <input type="checkbox" id="fit-shft" class="fit-checkbox" >
     <label class="control-label">trns (Transp.)</label>
    <input type="number" id="param-trns" value="0" step="0.01" class="control-input">
    <input type="checkbox" id="fit-trns" class="fit-checkbox">
</div>

<div id="anisotropy-params-container" class="profile-controls-container hidden">
    <h3 class="profile-section-header">Isotropic Gaussian (TCH)</h3>
    <label class="control-label">U</label>
    <input type="number" id="param-u" value="1.64" step="0.1" class="control-input" min="0">
    <input type="checkbox" id="fit-u" class="fit-checkbox">
    <label class="control-label">V</label>
    <input type="number" id="param-v" value="-1.32" step="0.1" class="control-input">
    <input type="checkbox" id="fit-v" class="fit-checkbox" >
    <label class="control-label">W</label>
    <input type="number" id="param-w" value="0.026" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-w" class="fit-checkbox" >
    
    <h3 class="profile-section-header">Isotropic Lorentzian (TCH)</h3>
    <label class="control-label">X</label>
    <input type="number" id="param-x" value="0.120" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-x" class="fit-checkbox" >
    <label class="control-label">Y</label>
    <input type="number" id="param-y" value="0.06" step="0.01" class="control-input" min="0">
    <input type="checkbox" id="fit-y" class="fit-checkbox" >

        <h3 class="profile-section-header">Peak Asymmetry</h3>
    <label class="control-label">S/L</label>
    <input type="number" id="param-sl" value="0.0" step="0.001" class="control-input">
    <input type="checkbox" id="fit-sl" class="fit-checkbox">
    <label class="control-label">H/L</label>
    <input type="number" id="param-hl" value="0.0" step="0.001" class="control-input">
    <input type="checkbox" id="fit-hl" class="fit-checkbox" >


    <h3 class="profile-section-header">Anisotropic Broadening (Stephens)</h3>
    <label class="control-label">S400</label>
    <input type="number" id="param-s400" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s400" class="fit-checkbox">
    <label class="control-label">S040</label>
    <input type="number" id="param-s040" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s040" class="fit-checkbox">
    <label class="control-label">S004</label>
    <input type="number" id="param-s004" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s004" class="fit-checkbox">
    <label class="control-label">S220</label>
    <input type="number" id="param-s220" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s220" class="fit-checkbox">
     <label class="control-label">S202</label>
    <input type="number" id="param-s202" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s202" class="fit-checkbox">
    <label class="control-label">S022</label>
    <input type="number" id="param-s022" value="0.0" step="0.1" class="control-input">
    <input type="checkbox" id="fit-s022" class="fit-checkbox">
    

</div>

                    </div>
                </div>
            </div>

            <div class="bottom-actions"> 
                 <div class="control-group" style="border-top: none; padding-top: 0;">
                     <h2>Refinement</h2>
                     <label for="algorithm-select" class="control-label">Method</label>
                     <select id="algorithm-select" class="control-select">
                        <option value="lm">Levenberg-Marquardt</option>
                        <option value="sa" selected>Simulated Annealing</option>
                     </select>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Min</label>
                         <div class="slider-value-track">
                            <input type="range" id="tth-min-slider" class="custom-slider" disabled>
                            <span id="tth-min-value" class="slider-value-display">10.0</span>
                         </div>
                     </div>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Max</label>
                         <div class="slider-value-track">
                             <input type="range" id="tth-max-slider" class="custom-slider" disabled>
                             <span id="tth-max-value" class="slider-value-display">80.0</span>
                         </div>
                     </div>

                     <div class="slider-group">
                         <label class="control-label">Max Iterations</label>
                         <div class="slider-value-track">
                            <input type="range" id="iterations-slider" min="2" max="200" value="120" step="1" class="custom-slider">
                            <span id="iterations-value" class="slider-value-display">120</span>
                         </div>
                     </div>

                     <div id="progress-bar-container" class="hidden" style="width: 100%; border-radius: 3px; height: 5px;">
                        <div id="progress-bar" style="height: 100%; width: 0%; border-radius: 3px;"></div>
                     </div>
                     <div class="results-grid">
                        <div class="result-card">
                            <div class="result-card-label">Rp (%)</div>
                            <div id="rp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">Rwp (%)</div>
                            <div id="rwp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">χ² (GOF)</div>
                            <div id="chi2-result" class="result-card-value">-</div>
                        </div>
                     </div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 16px; margin-top: 16px;">

                    <button id="fit-button" class="btn btn-primary" disabled>Load Data to Start Fit</button>

                    <div style="display: flex; gap: 10px;">
                        <button id="save-data-button" class="btn btn-secondary" style="flex: 1;" disabled>Save Report</button>
                        <button id="report-button" class="btn btn-secondary" style="flex: 1;" disabled>Generate PDF</button>
                    </div>
                </div>
            </div>
        </div>


        <div id="drag-handle"></div>

<div id="results-area" style="position: relative; flex-grow: 1; min-height: 0;">
    <div id="placeholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: var(--system-secondary-label);">
        <svg xmlns="http://www.w3.org/2000/svg" style="width: 64px; height: 64px; margin-bottom: 16px;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
        <h2 style="font-size: 22px; font-weight: 600; margin-bottom: 8px;">Awaiting Data</h2>
        <p style="font-size: 16px; color: var(--system-secondary-label);">Load a data file to begin.</p>
    </div>

    <div id="results-container" style="width: 100%; height: 100%; display: none; flex-direction: column; position: relative;">
        <canvas id="main-chart"></canvas>
    </div>

    <div style="position: absolute; bottom: 6px; right: 12px; font-size: 12px; color: var(--system-secondary-label);">
        NitaD, Univ Paris-Saclay, 19 Sept 2025
    </div>
</div>


<script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- UI Elements ---
        const controls = {
            fileInput: document.getElementById('file-input'),
            fileName: document.getElementById('file-name'),
            bravaisLattice: document.getElementById('bravais-lattice'),
            latticeParamsContainer: document.getElementById('lattice-parameters-container'),
            wavelength: document.getElementById('wavelength'),
            zeroShift: document.getElementById('zero-shift'),
            fitZeroShift: document.getElementById('fit-zero-shift'),
            profileSelect: document.getElementById('profile-function-select'),
            simplePVoigtParamsContainer: document.getElementById('simple-pvoigt-params-container'),
            anisotropyParamsContainer: document.getElementById('anisotropy-params-container'),
            paramGU: document.getElementById('param-gu'), fitGU: document.getElementById('fit-gu'),
            paramGV: document.getElementById('param-gv'), fitGV: document.getElementById('fit-gv'),
            paramGW: document.getElementById('param-gw'), fitGW: document.getElementById('fit-gw'),
            paramGP: document.getElementById('param-gp'), fitGP: document.getElementById('fit-gp'),
            paramLX: document.getElementById('param-lx'), fitLX: document.getElementById('fit-lx'),
            paramEta: document.getElementById('param-eta'), fitEta: document.getElementById('fit-eta'),
            paramShft: document.getElementById('param-shft'), fitShft: document.getElementById('fit-shft'),
            paramTrns: document.getElementById('param-trns'), fitTrns: document.getElementById('fit-trns'),
            paramU: document.getElementById('param-u'), fitU: document.getElementById('fit-u'),
            paramV: document.getElementById('param-v'), fitV: document.getElementById('fit-v'),
            paramW: document.getElementById('param-w'), fitW: document.getElementById('fit-w'),
            paramX: document.getElementById('param-x'), fitX: document.getElementById('fit-x'),
            paramY: document.getElementById('param-y'), fitY: document.getElementById('fit-y'),
            paramSL: document.getElementById('param-sl'), fitSL: document.getElementById('fit-sl'),
            paramHL: document.getElementById('param-hl'), fitHL: document.getElementById('fit-hl'),
            paramS400: document.getElementById('param-s400'), fitS400: document.getElementById('fit-s400'),
            paramS040: document.getElementById('param-s040'), fitS040: document.getElementById('fit-s040'),
            paramS004: document.getElementById('param-s004'), fitS004: document.getElementById('fit-s004'),
            paramS220: document.getElementById('param-s220'), fitS220: document.getElementById('fit-s220'),
            paramS202: document.getElementById('param-s202'), fitS202: document.getElementById('fit-s202'),
            paramS022: document.getElementById('param-s022'), fitS022: document.getElementById('fit-s022'),
            algorithmSelect: document.getElementById('algorithm-select'),
            iterationsSlider: document.getElementById('iterations-slider'),
            iterationsValue: document.getElementById('iterations-value'),
            tthMinSlider: document.getElementById('tth-min-slider'),
            tthMinValue: document.getElementById('tth-min-value'),
            tthMaxSlider: document.getElementById('tth-max-slider'),
            tthMaxValue: document.getElementById('tth-max-value'),
            fitButton: document.getElementById('fit-button'),
            reportButton: document.getElementById('report-button'),
            saveDataButton: document.getElementById('save-data-button'),
            progressBar: document.getElementById('progress-bar'),
            progressBarContainer: document.getElementById('progress-bar-container'),
            rpResult: document.getElementById('rp-result'),
            rwpResult: document.getElementById('rwp-result'),
            chi2Result: document.getElementById('chi2-result'),
            mainChartCanvas: document.getElementById('main-chart'),
            placeholder: document.getElementById('placeholder'),
            resultsContainer: document.getElementById('results-container'),
            ballRadiusSlider: document.getElementById('ball-radius-slider'),
            ballRadiusValue: document.getElementById('ball-radius-value'),
            smoothingWidthSlider: document.getElementById('smoothing-width-slider'),
            smoothingWidthValue: document.getElementById('smoothing-width-value'),
        };

        // --- Global State ---
        let profileParamCache = { "3": {}, "4": {} };
        let currentProfile = "4";
        let fullExperimentalData = { tth: [], intensity: [] };
        let calculatedBackground = [];
        let workingDataCache = { tth: [], intensity: [], background: [], isValid: false };
        let fitResults = null;
        let mainChart;
        let isFitting = false;
        let lastGeneratedHklList = [];
        let lastRawDifference = [];

        function updateStephensAnisotropyUI() {
            const { system } = getSystemAndCentering();
            const sParams = { s400: { input: controls.paramS400, fit: controls.fitS400 }, s040: { input: controls.paramS040, fit: controls.fitS040 }, s004: { input: controls.paramS004, fit: controls.fitS004 }, s220: { input: controls.paramS220, fit: controls.fitS220 }, s202: { input: controls.paramS202, fit: controls.fitS202 }, s022: { input: controls.paramS022, fit: controls.fitS022 }, };
            for (const key in sParams) { sParams[key].input.disabled = false; sParams[key].fit.disabled = false; sParams[key].input.style.backgroundColor = ''; }
            switch (system) {
                case 'cubic':
                    sParams.s040.input.value = sParams.s400.input.value; sParams.s004.input.value = sParams.s400.input.value; sParams.s040.fit.checked = sParams.s400.fit.checked; sParams.s004.fit.checked = sParams.s400.fit.checked; sParams.s202.input.value = sParams.s220.input.value; sParams.s022.input.value = sParams.s220.input.value; sParams.s202.fit.checked = sParams.s220.fit.checked; sParams.s022.fit.checked = sParams.s220.fit.checked;
                    [sParams.s040, sParams.s004, sParams.s202, sParams.s022].forEach(p => { p.input.disabled = true; p.fit.disabled = true; p.input.style.backgroundColor = 'var(--system-gray-5)'; });
                    break;
                case 'hexagonal': case 'tetragonal': case 'rhombohedral':
                    sParams.s040.input.value = sParams.s400.input.value; sParams.s040.fit.checked = sParams.s400.fit.checked; sParams.s022.input.value = sParams.s202.input.value; sParams.s022.fit.checked = sParams.s202.fit.checked;
                    [sParams.s040, sParams.s022].forEach(p => { p.input.disabled = true; p.fit.disabled = true; p.input.style.backgroundColor = 'var(--system-gray-5)'; });
                    break;
            }
        }

        const verticalCursorLine = { id: 'verticalCursorLine', afterDraw: chart => { if (chart.tooltip?._active?.length) { let x = chart.tooltip._active[0].element.x, yAxis = chart.scales.y, ctx = chart.ctx; ctx.save(); ctx.beginPath(); ctx.moveTo(x, yAxis.top); ctx.lineTo(x, yAxis.bottom); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)'; ctx.setLineDash([4, 4]); ctx.stroke(); ctx.restore(); } } };
        Chart.register(verticalCursorLine);
        Chart.Tooltip.positioners.experimentalAnchor = function(items) { if (!items.length) return false; const experimentalItem = items.find(item => item.datasetIndex === 0) || items[0]; return { x: experimentalItem.element.x, y: experimentalItem.element.y }; };
        
        function getSystemAndCentering() { const [system, centering] = controls.bravaisLattice.value.split('_'); return { system, centering }; }
        function saveProfileState(profileId) { const state = {}; const container = document.getElementById((profileId === '4') ? 'simple-pvoigt-params-container' : 'anisotropy-params-container'); if (container) container.querySelectorAll('input[type="number"], input[type="checkbox"]').forEach(input => { state[input.id] = (input.type === 'checkbox') ? input.checked : input.value; }); profileParamCache[profileId] = state; }
        function restoreProfileState(profileId) { const state = profileParamCache[profileId]; if (!state || Object.keys(state).length === 0) return; const container = document.getElementById((profileId === '4') ? 'simple-pvoigt-params-container' : 'anisotropy-params-container'); if (container) container.querySelectorAll('input[type="number"], input[type="checkbox"]').forEach(input => { if (state[input.id] !== undefined) input.type === 'checkbox' ? (input.checked = state[input.id]) : (input.value = state[input.id]); }); }
        
        function updateLatticeParamUI() {
            const currentValues = {}; const container = controls.latticeParamsContainer;
            container.querySelectorAll('input[type="number"]').forEach(input => { const name = input.id.replace('lattice-param-', ''); if (input.value) currentValues[name] = input.value; });
            const { system } = getSystemAndCentering(); container.innerHTML = '';
            const createInput = (name, label, defaultValue, step, isAngle = false) => {
                const valueToUse = currentValues[name] !== undefined ? currentValues[name] : defaultValue; const id_base = `lattice-param-${name}`; const unit = isAngle ? '°' : 'Å'; const minAttribute = isAngle ? '' : 'min="0.001"';
                const row = document.createElement('div'); row.className = 'parameter-grid-3col'; row.innerHTML = `<label for="${id_base}" class="control-label">${label} (${unit})</label><input type="number" id="${id_base}" value="${valueToUse}" step="${step}" class="control-input" ${minAttribute}><input type="checkbox" id="fit-lattice-${name}" class="fit-checkbox" title="Fit this parameter" checked>`; container.appendChild(row);
            };
            const params = { cubic: [{ name: 'a', label: 'a', value: 4.23, step: 0.001 }], tetragonal: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'c', label: 'c', value: 5.0, step: 0.001 }], orthorhombic: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'b', label: 'b', value: 5.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }], hexagonal: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }], rhombohedral: [{ name: 'a', label: 'a', value: 5.0, step: 0.001 }, { name: 'alpha', label: 'α', value: 60.0, step: 0.01, isAngle: true }], monoclinic: [{ name: 'a', label: 'a', value: 4.0, step: 0.001 }, { name: 'b', label: 'b', value: 5.0, step: 0.001 }, { name: 'c', label: 'c', value: 6.0, step: 0.001 }, { name: 'beta', label: 'β', value: 105.0, step: 0.01, isAngle: true }] };
            if(params[system]) params[system].forEach(p => createInput(p.name, p.label, p.value, p.step, p.isAngle));
        }

        function updateUIForSystemChange() {
            updateLatticeParamUI();
            updateStephensAnisotropyUI();
        }

        const detectAndParseFile = (fileName, fileContent) => { const name = fileName.toLowerCase(); const lines = fileContent.trim().split(/\r?\n/); const firstLine = lines.length > 0 ? lines[0].trim() : ''; if (name.endsWith('.uxd') || firstLine.startsWith('_FILEVERSION')) return parseUxdFile(fileContent); if (name.endsWith('.xrdml') || (fileContent.includes('<?xml') && fileContent.includes('<xrdMeasurement'))) return parseXrdmlFile(fileContent); if (name.endsWith('.brml') || (fileContent.includes('<?xml') && fileContent.includes('<RawDataFile'))) return parseBrukerBrmlFile(fileContent); if (name.endsWith('.ras') || fileContent.toUpperCase().includes('*RAS_HEADER_START')) return parseRigakuRasFile(fileContent); if (name.endsWith('.udf')) return parsePhilipsUdfFile(fileContent); if (lines.length > 2 && lines[1].toUpperCase().includes('BANK')) return parseGsasEsdFile(fileContent); return parseDataFile(fileContent); };
        const parseDataFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; lines.forEach(line => { if (line.startsWith('#') || line.startsWith('//') || line.trim() === '') return; const parts = line.trim().split(/[\s,;]+/); if (parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } }); return { tth, intensity }; };
        const parseXrdmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing XRDML file."); } let wavelength = null; const kAlpha1Node = xmlDoc.querySelector("kAlpha1"); if (kAlpha1Node?.textContent) wavelength = parseFloat(kAlpha1Node.textContent); const intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts"); if (!intensityNode) throw new Error("Could not find <intensities> or <counts> in XRDML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]'); if (!positionsNode) throw new Error("Could not find <positions> in XRDML file."); const startPosNode = positionsNode.querySelector("startPosition"); const endPosNode = positionsNode.querySelector("endPosition"); if (!startPosNode || !endPosNode) throw new Error("Could not find start/end positions in XRDML."); const startPos = parseFloat(startPosNode.textContent); const endPos = parseFloat(endPosNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * (endPos - startPos) / (intensity.length - 1)); return { tth, intensity, wavelength }; };
        const parseBrukerBrmlFile = (xmlString) => { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "application/xml"); if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing BRML file."); } let wavelength = null; const wlNode = xmlDoc.querySelector('usedWavelength'); if (wlNode) { const kAlpha1 = wlNode.getAttribute('kAlpha1'); if (kAlpha1) wavelength = parseFloat(kAlpha1); } const intensityNode = xmlDoc.querySelector("dataPoints > counts"); if (!intensityNode) throw new Error("No <counts> data found in BRML file."); const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number); const startPosNode = xmlDoc.querySelector('startPosition[axis="TwoTheta"]'); const stepSizeNode = xmlDoc.querySelector('increment[axis="TwoTheta"]'); if (!startPosNode || !stepSizeNode) throw new Error("Could not find scan parameters in BRML file."); const startPos = parseFloat(startPosNode.textContent); const stepSize = parseFloat(stepSizeNode.textContent); const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * stepSize); return { tth, intensity, wavelength }; };
        const parseRigakuRasFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const upperLine = line.toUpperCase(); if (upperLine.startsWith('*WAVE_LENGTH') || upperLine.startsWith('*MEAS_COND_XG_WAVE_LENGTH')) { const parts = line.trim().split(/\s+/); if (parts.length > 1) { const wl = parseFloat(parts[1]); if (!isNaN(wl)) wavelength = wl; } } if (upperLine.startsWith('*RAS_INT_START')) { inDataSection = true; continue; } if (upperLine.startsWith('*RAS_INT_END')) break; if (inDataSection) { const parts = line.trim().split(/[\s,]+/); if (parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No data found in RAS file data section."); return { tth, intensity, wavelength }; };
        const parseGsasEsdFile = (text) => { const lines = text.trim().split(/\r?\n/); let wavelength = null; let startTth, stepSize; let dataStartIndex = -1; lines.forEach((line, index) => { const upperLine = line.toUpperCase(); if (upperLine.includes('WAVELENGTH')) { const match = line.match(/wavelength\s+([0-9.]+)/i); if (match && match[1]) wavelength = parseFloat(match[1]); } if (upperLine.startsWith('BANK')) { const parts = line.trim().split(/\s+/); if (parts.length >= 6 && parts[4].toUpperCase() === 'CONST') { startTth = parseFloat(parts[5]) / 100.0; stepSize = parseFloat(parts[6]) / 100.0; dataStartIndex = index + 1; } } }); if (startTth === undefined || stepSize === undefined) throw new Error("GSAS Parse Error: Could not find a valid 'BANK' line with CONST scan parameters."); if (dataStartIndex !== -1 && lines[dataStartIndex]?.toUpperCase().includes('STD')) dataStartIndex++; if (dataStartIndex === -1 || dataStartIndex >= lines.length) throw new Error("GSAS Parse Error: Found scan parameters but no subsequent data lines."); const intensity = []; for (let i = dataStartIndex; i < lines.length; i++) { const parts = lines[i].trim().split(/\s+/); for (let j = 1; j < parts.length; j += 2) { const val = parseFloat(parts[j]); if (!isNaN(val)) intensity.push(val); } } if (intensity.length === 0) throw new Error("GSAS Parse Error: No intensity data could be parsed."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
        const parseUxdFile = (text) => { const lines = text.trim().split(/\r?\n/); const intensity = []; let startTth, stepSize, wavelength; let inDataSection = false; for (const line of lines) { const trimmedLine = line.trim(); if (inDataSection) { const parts = trimmedLine.split(/\s+/); parts.forEach(part => { const val = parseFloat(part); if (!isNaN(val)) intensity.push(val); }); } else { if (trimmedLine.toUpperCase().startsWith('_START=')) startTth = parseFloat(trimmedLine.substring(7)); else if (trimmedLine.toUpperCase().startsWith('_STEPSIZE=')) stepSize = parseFloat(trimmedLine.substring(10)); else if (trimmedLine.toUpperCase().startsWith('_WL1=')) wavelength = parseFloat(trimmedLine.substring(5)); else if (trimmedLine.toUpperCase() === '_COUNTS') inDataSection = true; } } if (startTth === undefined || stepSize === undefined) throw new Error("Could not find _START and _STEPSIZE in UXD file."); if (intensity.length === 0) throw new Error("No intensity data found after _COUNTS in UXD file."); const tth = Array.from({ length: intensity.length }, (_, i) => startTth + i * stepSize); return { tth, intensity, wavelength }; };
        const parsePhilipsUdfFile = (text) => { const lines = text.trim().split(/\r?\n/); const tth = [], intensity = []; let inDataSection = false; let wavelength = null; for (const line of lines) { const trimmedLine = line.trim(); if (trimmedLine.toUpperCase().startsWith('LAMBDA')) { const parts = trimmedLine.split('='); if (parts.length > 1) wavelength = parseFloat(parts[1]); } if (trimmedLine.toUpperCase() === '[DATA]') { inDataSection = true; continue; } if (trimmedLine.startsWith('[') && trimmedLine.toUpperCase() !== '[DATA]') inDataSection = false; if (inDataSection) { const parts = trimmedLine.split(/,/).map(p => p.trim()); if(parts.length >= 2) { const x = parseFloat(parts[0]); const y = parseFloat(parts[1]); if (!isNaN(x) && !isNaN(y)) { tth.push(x); intensity.push(y); } } } } if (tth.length === 0) throw new Error("No [Data] section found in UDF file."); return { tth, intensity, wavelength }; };

        function updateWorkingDataCache() {
            if (fullExperimentalData.tth.length === 0) { workingDataCache.isValid = false; return; }
            const minTth = parseFloat(controls.tthMinSlider.value); const maxTth = parseFloat(controls.tthMaxSlider.value);
            let startIndex = fullExperimentalData.tth.findIndex(t => t >= minTth); if (startIndex === -1) startIndex = 0;
            let endIndex = fullExperimentalData.tth.findIndex(t => t > maxTth); if (endIndex === -1) endIndex = fullExperimentalData.tth.length;
            workingDataCache.tth = fullExperimentalData.tth.slice(startIndex, endIndex); workingDataCache.intensity = fullExperimentalData.intensity.slice(startIndex, endIndex); workingDataCache.background = calculatedBackground.slice(startIndex, endIndex); workingDataCache.isValid = true;
            console.log("Working data cache updated:", { range: `${minTth.toFixed(2)} - ${maxTth.toFixed(2)}°`, points: workingDataCache.tth.length, startIndex, endIndex, intensity_length: workingDataCache.intensity.length, background_length: workingDataCache.background.length });
            if (workingDataCache.tth.length !== workingDataCache.background.length) console.error("CRITICAL ERROR: Mismatch in cached data lengths!");
        }

        function getWorkingData() {
            if (!workingDataCache.isValid) updateWorkingDataCache();
            if (!workingDataCache.isValid) return { tth: [], intensity: [], background: [] };
            return { tth: workingDataCache.tth.slice(), intensity: workingDataCache.intensity.slice(), background: workingDataCache.background.slice() };
        }

        function rollingBallBackground(y, radius, smoothingWidth) {
            const n = y.length; if (n === 0 || radius <= 0) return new Array(n).fill(0); let smoothed_y = y;
            if (smoothingWidth > 1) { smoothed_y = new Array(n); const halfWidth = Math.floor(smoothingWidth / 2); for (let i = 0; i < n; i++) { const start = Math.max(0, i - halfWidth); const end = Math.min(n, i + halfWidth + 1); let sum = 0; for (let j = start; j < end; j++) sum += y[j]; smoothed_y[i] = sum / (end - start); } }
            const eroded = new Array(n); for (let i = 0; i < n; i++) { const start = Math.max(0, i - radius); const end = Math.min(n, i + radius + 1); let min = Infinity; for (let j = start; j < end; j++) if (smoothed_y[j] < min) min = smoothed_y[j]; eroded[i] = min; }
            const background = new Array(n); for (let i = 0; i < n; i++) { const start = Math.max(0, i - radius); const end = Math.min(n, i + radius + 1); let max = -Infinity; for (let j = start; j < end; j++) if (eroded[j] > max) max = eroded[j]; background[i] = max; }
            return background;
        }

        function updateAndApplyBackground() {
            if (fullExperimentalData.intensity.length === 0) return;
            const radius = parseInt(controls.ballRadiusSlider.value, 10); const smoothing = parseInt(controls.smoothingWidthSlider.value, 10);
            calculatedBackground = rollingBallBackground(fullExperimentalData.intensity, radius, smoothing);
            workingDataCache.isValid = false; updateWorkingDataCache();
            if (mainChart) { const backgroundDataset = mainChart.data.datasets.find(d => d.label === 'Background'); if (backgroundDataset) backgroundDataset.data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: calculatedBackground[i] })); updatePreviewPattern(); }
        }

        function getMultiplicityAndCanonicalHKL(h, k, l, system) { let H = Math.abs(h), K = Math.abs(k), L = Math.abs(l); let canonical_hkl = `(${H},${K},${L})`; let multiplicity = 1; switch (system) { case 'cubic': [H, K, L] = [H, K, L].sort((a, b) => b - a); canonical_hkl = `(${H},${K},${L})`; if (H > K && K > L && L > 0) multiplicity = 48; else if (H === K && K > L && L > 0) multiplicity = 24; else if (H > K && K === L && L > 0) multiplicity = 24; else if (H > K && K > 0 && L === 0) multiplicity = 24; else if (H === K && K > 0 && L === 0) multiplicity = 12; else if (H === K && K === L && L > 0) multiplicity = 8; else if (H > 0 && K === 0 && L === 0) multiplicity = 6; break; case 'hexagonal': case 'rhombohedral': canonical_hkl = `(${H},${K},${L})`; if (H > 0 && K > 0 && L > 0 && H !== K) multiplicity = 24; else if (H > 0 && K > 0 && L > 0) multiplicity = 12; else if (H > 0 && K > 0 && L === 0 && H !== K) multiplicity = 12; else if (H > 0 && K === 0 && L > 0) multiplicity = 12; else if (H > 0 && K === H && L === 0) multiplicity = 6; else if (H > 0 && K === 0 && L === 0) multiplicity = 6; else if (H === 0 && K === 0 && L > 0) multiplicity = 2; break; case 'tetragonal': if (K > H) [H, K] = [K, H]; canonical_hkl = `(${H},${K},${L})`; if (H > K && K > 0 && L > 0) multiplicity = 16; else if (H === K && K > 0 && L > 0) multiplicity = 8; else if (H > 0 && K === 0 && L > 0) multiplicity = 8; else if (H > K && K > 0 && L === 0) multiplicity = 8; else if (H === K && K > 0 && L === 0) multiplicity = 4; else if (H > 0 && K === 0 && L === 0) multiplicity = 4; else if (H === 0 && K === 0 && L > 0) multiplicity = 2; break; case 'orthorhombic': canonical_hkl = `(${H},${K},${L})`; if (H > 0 && K > 0 && L > 0) multiplicity = 8; else if (H > 0 && K > 0 && L === 0) multiplicity = 4; else if (H > 0 && K === 0 && L > 0) multiplicity = 4; else if (H === 0 && K > 0 && L > 0) multiplicity = 4; else if (H > 0 && K === 0 && L === 0) multiplicity = 2; else if (H === 0 && K > 0 && L === 0) multiplicity = 2; else if (H === 0 && K === 0 && L > 0) multiplicity = 2; break; case 'monoclinic': canonical_hkl = `(${H},${K},${L})`; if (H > 0 && L > 0) multiplicity = (K > 0) ? 4 : 2; else if (H > 0 || L > 0) multiplicity = (K > 0) ? 4 : 2; else if (K > 0) multiplicity = 2; break; } return { canonical_hkl, multiplicity }; }
        function generateHKL(maxTth, params, system, centering) { const { a, b, c, alpha, beta, gamma, lambda } = params; if (!a || !lambda || a <= 0) return []; const reflections = new Map(); const maxIndex = Math.ceil(2 * Math.max(a || 0, b || 0, c || 0) / lambda * Math.sin(maxTth / 2 * Math.PI / 180)) + 2; const deg2rad = Math.PI / 180; const sin_b = Math.sin((beta || 90) * deg2rad); const cos_b = Math.cos((beta || 90) * deg2rad); for (let h = -maxIndex; h <= maxIndex; h++) { for (let k = -maxIndex; k <= maxIndex; k++) { for (let l = 0; l <= maxIndex; l++) { if (h === 0 && k === 0 && l === 0) continue; let allowed = false; switch(centering) { case 'P': allowed = true; break; case 'I': allowed = (h + k + l) % 2 === 0; break; case 'F': allowed = (h % 2 === k % 2) && (k % 2 === l % 2); break; case 'C': allowed = (h + k) % 2 === 0; break; case 'R': if (system === 'hexagonal') allowed = (-h + k + l) % 3 === 0; else allowed = true; break; default: allowed = true; } if (!allowed) continue; let inv_d_sq = 0; switch(system) { case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break; case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break; case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break; case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break; case 'monoclinic': inv_d_sq = (1/(sin_b*sin_b)) * ( (h*h)/(a*a) + (k*k*sin_b*sin_b)/(b*b) + (l*l)/(c*c) - (2*h*l*cos_b)/(a*c) ); break; case 'rhombohedral': const term1 = (h*h + k*k + l*l) * Math.sin(alpha*deg2rad)**2; const term2 = 2 * (h*k + k*l + l*h) * (Math.cos(alpha*deg2rad)**2 - Math.cos(alpha*deg2rad)); const denominator = a*a * (1 - 3*Math.cos(alpha*deg2rad)**2 + 2*Math.cos(alpha*deg2rad)**3); if(Math.abs(denominator) < 1e-9) continue; inv_d_sq = (term1 + term2) / denominator; break; } if (inv_d_sq <= 0) continue; const sinThetaSq = (lambda*lambda / 4) * inv_d_sq; if (sinThetaSq <= 1) { const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI); if (tth > maxTth * 1.05) continue; const d = 1 / Math.sqrt(inv_d_sq); const key = Math.round(tth * 1000); if (!reflections.has(key)) { const { canonical_hkl, multiplicity } = getMultiplicityAndCanonicalHKL(h, k, l, system); reflections.set(key, { tth: tth, d: d, hkl_list: [canonical_hkl], multiplicity: multiplicity, intensity: 0 }); } } } } } return Array.from(reflections.values()).sort((a, b) => a.tth - b.tth); }
        function calculatePeakShift(tth, params) { if (params.profileType === "4") { const thetaRad = tth * (Math.PI / 180) / 2; const cosTheta = Math.cos(thetaRad); const sin2Theta = Math.sin(2 * thetaRad); const displacementShift = -(params.shft / 1000) * cosTheta * (180 / Math.PI); const transparencyShift = params.trns * sin2Theta * (180 / Math.PI); return displacementShift + transparencyShift; } else { return 0; } }
        function calculateProfileWidths(tth, hkl, params) { const profileType = params.profileType || controls.profileSelect.value || "2"; const thetaRad = tth * (Math.PI / 180) / 2; const tanTheta = Math.tan(thetaRad); const cosTheta = Math.cos(thetaRad); let gamma_G_sq, gamma_L; if (profileType === "4") { gamma_G_sq = (params.GU || 0) * tanTheta * tanTheta + (params.GV || 0) * tanTheta + (params.GW || 1) + (params.GP || 0) / (cosTheta * cosTheta); gamma_L = (params.LX || 1) / cosTheta; } else { gamma_G_sq = (params.U || 0) * tanTheta * tanTheta + (params.V || 0) * tanTheta + (params.W || 1); gamma_L = (params.X || 0) * tanTheta + (params.Y || 0) / cosTheta; } if (profileType === "3" && hkl) { const d_inv_sq = 1 / (hkl.d * hkl.d); const [h_val, k_val, l_val] = hkl.hkl_list[0].replace(/[()]/g, '').split(',').map(Number); const h2 = h_val*h_val, k2=k_val*k_val, l2=l_val*l_val; let H_aniso = (params.S400 || 0) * h2*h2 + (params.S040 || 0) * k2*k2 + (params.S004 || 0) * l2*l2 + (params.S220 || 0) * h2*k2 + (params.S202 || 0) * h2*l2 + (params.S022 || 0) * k2*l2; H_aniso *= d_inv_sq * d_inv_sq; gamma_L += Math.abs(H_aniso) / 1000; } const gamma_G = Math.sqrt(Math.max(1e-6, gamma_G_sq)); return { gamma_G, gamma_L }; }
        function pseudoVoigt(x, x0, tth_peak, gamma_G, gamma_L, params) { if (gamma_G <= 1e-6 && gamma_L <= 1e-6) return 0.0; let currentEta = params.eta || 0.5; if (params.profileType !== "4") { const fwhm_pow5 = Math.pow(gamma_G, 5) + 2.69269 * Math.pow(gamma_G, 4) * gamma_L + 2.42843 * Math.pow(gamma_G, 3) * gamma_L*gamma_L + 4.47163 * Math.pow(gamma_G, 2) * Math.pow(gamma_L, 3) + 0.07842 * gamma_G * Math.pow(gamma_L, 4) + Math.pow(gamma_L, 5); const fwhm = Math.pow(fwhm_pow5, 0.2); if (fwhm > 1e-6) { const ratio = gamma_L / fwhm; currentEta = 1.36603 * ratio - 0.47719 * (ratio*ratio) + 0.11116 * (ratio*ratio*ratio); currentEta = Math.max(0, Math.min(1, currentEta)); } } const corrected_delta = applyAsymmetry(x, x0, tth_peak, params); const fwhm_g_to_sigma = 1 / (2 * Math.sqrt(2 * Math.log(2))); const sigma = gamma_G * fwhm_g_to_sigma; const normalizedGaussian = sigma > 1e-9 ? Math.exp(-0.5 * (corrected_delta * corrected_delta) / (sigma * sigma)) : (Math.abs(corrected_delta) < 1e-6 ? 1 : 0); const hwhm_l = gamma_L / 2.0; const normalizedLorentzian = hwhm_l > 1e-9 ? (hwhm_l * hwhm_l) / (corrected_delta * corrected_delta + (hwhm_l * hwhm_l)) : (Math.abs(corrected_delta) < 1e-6 ? 1 : 0); if (gamma_L < 1e-6) return normalizedGaussian; if (gamma_G < 1e-6) return normalizedLorentzian; return currentEta * normalizedLorentzian + (1 - currentEta) * normalizedGaussian; }
        function applyAsymmetry(x, x0, tth_peak, params) { if (params.profileType === "4" || (!params.SL && !params.HL)) return x - x0; const delta_2theta = x - x0; if (Math.abs(delta_2theta) < 1e-9) return 0; const theta_rad = tth_peak * (Math.PI / 180) / 2.0; if (Math.abs(theta_rad - Math.PI / 2.0) < 1e-6) return delta_2theta; const cot_theta = 1.0 / Math.tan(theta_rad); const asymmetry_param = (params.SL || 0) * cot_theta + (params.HL || 0); const asymmetry_factor = 1.0 - (asymmetry_param / 100.0) * Math.sign(delta_2theta) * delta_2theta; return delta_2theta / Math.max(1e-6, asymmetry_factor); }
        function calculatePattern(tthAxis, hklList, params) { const pattern = new Float32Array(tthAxis.length).fill(0); const n_points = tthAxis.length; hklList.forEach(peak => { if (peak.intensity === 0) return; const basePos = peak.tth + params.zeroShift; const shift = calculatePeakShift(basePos, params); const peakPos = basePos + shift; const { gamma_G, gamma_L } = calculateProfileWidths(basePos, peak, params); const window = 8 * Math.max(0.01, gamma_G + gamma_L); const min_tth = peakPos - window; const max_tth = peakPos + window; let startIndex = 0; while(startIndex < n_points && tthAxis[startIndex] < min_tth) startIndex++; for (let i = startIndex; i < n_points; i++) { const current_tth = tthAxis[i]; if (current_tth > max_tth) break; pattern[i] += peak.intensity * pseudoVoigt(current_tth, peakPos, basePos, gamma_G, gamma_L, params); } }); return pattern; }
        function updateHklPositions(hklList, params, system) { const { a, b, c, alpha, beta, gamma, lambda } = params; if (!a || !lambda || a <= 0) return; const deg2rad = Math.PI / 180; const sin_b = Math.sin((beta || 90) * deg2rad); const cos_b = Math.cos((beta || 90) * deg2rad); hklList.forEach(peak => { const [h, k, l] = peak.hkl_list[0].replace(/[()]/g, '').split(',').map(Number); let inv_d_sq = 0; switch(system) { case 'cubic': inv_d_sq = (h*h + k*k + l*l) / (a*a); break; case 'tetragonal': inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c); break; case 'orthorhombic': inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c); break; case 'hexagonal': inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c); break; case 'monoclinic': inv_d_sq = (1/(sin_b*sin_b)) * ( (h*h)/(a*a) + (k*k*sin_b*sin_b)/(b*b) + (l*l)/(c*c) - (2*h*l*cos_b)/(a*c) ); break; case 'rhombohedral': const term1 = (h*h + k*k + l*l) * Math.sin(alpha*deg2rad)**2; const term2 = 2 * (h*k + k*l + l*h) * (Math.cos(alpha*deg2rad)**2 - Math.cos(alpha*deg2rad)); const denominator = a*a * (1 - 3*Math.cos(alpha*deg2rad)**2 + 2*Math.cos(alpha*deg2rad)**3); if(Math.abs(denominator) > 1e-9) inv_d_sq = (term1 + term2) / denominator; break; } if (inv_d_sq > 1e-9) { const sinThetaSq = (lambda*lambda / 4) * inv_d_sq; if (sinThetaSq <= 1 && sinThetaSq > 0) { peak.tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI); peak.d = 1 / Math.sqrt(inv_d_sq); } } }); }
        function leBailIntensityExtraction(expData, hklList, params) { console.log(`leBailIntensityExtraction called with data lengths: tth=${expData.tth.length}, intensity=${expData.intensity.length}, background=${expData.background.length}`); if (expData.tth.length !== expData.background.length || expData.tth.length !== expData.intensity.length) { console.error("CRITICAL ERROR in leBailIntensityExtraction: Mismatched array lengths in input data!"); alert("Internal error: Data array mismatch during intensity extraction. Check console."); return; } hklList.forEach(p => p.intensity = 0); for(let i = 0; i < expData.tth.length; i++) { let totalProfileAtPoint = 0; const contributingPeaks = []; hklList.forEach((peak, peakIdx) => { const basePos = peak.tth + params.zeroShift; const shift = calculatePeakShift(basePos, params); const peakPos = basePos + shift; const { gamma_G, gamma_L } = calculateProfileWidths(basePos, peak, params); const window = 8 * Math.max(0.01, gamma_G, gamma_L); if(Math.abs(expData.tth[i] - peakPos) < window) { const profileVal = pseudoVoigt(expData.tth[i], peakPos, basePos, gamma_G, gamma_L, params); totalProfileAtPoint += profileVal; contributingPeaks.push({idx: peakIdx, val: profileVal}); } }); if(totalProfileAtPoint > 1e-9) { const obsIntensityNet = expData.intensity[i] - (expData.background[i] || 0); if (obsIntensityNet < 0) continue; contributingPeaks.forEach(p => { hklList[p.idx].intensity += obsIntensityNet * (p.val / totalProfileAtPoint); }); } } }
        function calculateStatistics(workingData, netCalcPattern, fitFlags) { const y_obs_total = workingData.intensity; const y_bkg = workingData.background; const N = y_obs_total.length; if (N === 0 || y_obs_total.length !== netCalcPattern.length || y_obs_total.length !== y_bkg.length) { console.error("Statistics calculation error: Mismatched array lengths.", {obs: y_obs_total.length, calc: netCalcPattern.length, bkg: y_bkg.length}); return { r_p: -1, rwp: -1, chi2: -1, scaleFactor: 1, sum_w_res_sq: 0 }; } const y_obs_net = y_obs_total.map((y, i) => Math.max(0, y - y_bkg[i])); let sum_obs_net_calc_net = dot(y_obs_net, netCalcPattern); let sum_calc_net_sq = dot(netCalcPattern, netCalcPattern); const scaleFactor = sum_calc_net_sq > 1e-9 ? Math.max(0, sum_obs_net_calc_net / sum_calc_net_sq) : 1.0; const y_calc_total = netCalcPattern.map((y, i) => (scaleFactor * y) + y_bkg[i]); const weights = y_obs_total.map(y => 1 / Math.max(y, 1)); let sum_w_res_sq = 0, sum_w_obs_sq = 0, sum_abs_res = 0, sum_abs_obs = 0; for (let i = 0; i < N; i++) { const res = y_obs_total[i] - y_calc_total[i]; sum_w_res_sq += weights[i] * res * res; sum_w_obs_sq += weights[i] * y_obs_total[i] * y_obs_total[i]; sum_abs_res += Math.abs(res); sum_abs_obs += Math.abs(y_obs_total[i]); } const r_p = sum_abs_obs > 0 ? 100 * (sum_abs_res / sum_abs_obs) : 0; const rwp = sum_w_obs_sq > 0 ? 100 * Math.sqrt(sum_w_res_sq / sum_w_obs_sq) : 0; const P = getParameterMapping(fitFlags).paramMapping.length; const degreesOfFreedom = Math.max(1, N - P); const chi2 = sum_w_res_sq / degreesOfFreedom; return { r_p, rwp, chi2, scaleFactor, sum_w_res_sq }; }

        async function refineParametersLM(initialParams, fitFlags, maxIter, system, centering, progressCallback) {
            const { paramMapping } = getParameterMapping(fitFlags);
            if (paramMapping.length === 0) {
            //    console.log("LM Refinement stopped: No parameters selected for fitting.");
                return { params: initialParams, algorithm: 'lm', paramMapping, fitFlags };
            }

            // console.log("%cStarting Levenberg-Marquardt Refinement...", "color: blue; font-weight: bold;");
            const paramNames = paramMapping.map(p => p.name);
          //  console.log("Parameters being refined:", paramNames);

            let params = JSON.parse(JSON.stringify(initialParams));
            let lambda = 0.001;
            
            const workingData = getWorkingData();
            const workingDataNet = {
                tth: workingData.tth,
                intensity: workingData.intensity.map((y, i) => Math.max(0, y - workingData.background[i]))
            };
            
            if(workingData.tth.length === 0) {
                console.error("LM Refinement failed: Working data has zero points.");
                return { params: initialParams, algorithm: 'lm', paramMapping, fitFlags };
            }

            const calculateScaledPatternWithFixedIntensities = (p_vec, current_params, hklListWithFixedIntensities) => {
                let tempParams = JSON.parse(JSON.stringify(current_params));
                paramMapping.forEach((m, i) => m.set(tempParams, p_vec[i]));
                let tempHklList = JSON.parse(JSON.stringify(hklListWithFixedIntensities));
                updateHklPositions(tempHklList, tempParams, system);
                const pattern = calculatePattern(workingData.tth, tempHklList, tempParams);
                const sum_obs_calc = dot(workingDataNet.intensity, pattern);
                const sum_calc_sq = dot(pattern, pattern);
                const scaleFactor = (sum_calc_sq > 1e-9) ? sum_obs_calc / sum_calc_sq : 1.0;
                return scale(pattern, scaleFactor);
            };

            let hklList = generateHKL(Math.max(...workingData.tth), params, system, centering);
            leBailIntensityExtraction(workingData, hklList, params);
            
            let last_cost = Infinity, JtJ, finalResiduals;
            for (let iter = 0; iter < maxIter; iter++) {
                console.group(`LM Iteration: ${iter + 1}`);

                updateHklPositions(hklList, params, system);
                const unscaledPattern = calculatePattern(workingData.tth, hklList, params);
                const sum_obs_calc_main = dot(workingDataNet.intensity, unscaledPattern);
                const sum_calc_sq_main = dot(unscaledPattern, unscaledPattern);
                const scaleFactor_main = (sum_calc_sq_main > 1e-9) ? sum_obs_calc_main / sum_calc_sq_main : 1.0;
                const currentPattern = scale(unscaledPattern, scaleFactor_main);
                const residuals = subtract(workingDataNet.intensity, currentPattern);
                const weights = workingDataNet.intensity.map(y => 1 / Math.max(y, 1));
                const weightedResiduals = residuals.map((r, i) => r * Math.sqrt(weights[i]));
                finalResiduals = residuals;
                const cost = dot(weightedResiduals, weightedResiduals);

              //  console.log(`Current Cost (Chi^2): ${cost.toExponential(5)}`);

                if (iter > 0 && Math.abs(last_cost - cost) < 1e-9 * cost) {
                   // console.log("Convergence reached. Change in cost is minimal.");
                    console.groupEnd();
                    if (progressCallback) await progressCallback(1, params);
                    break;
                }
                last_cost = cost;

                let p_current_vec = paramMapping.map(m => m.get(params));
                const jacobian = [];
                for (let i = 0; i < p_current_vec.length; i++) {
                    const p_plus = [...p_current_vec];
                    const step = (paramMapping[i].step || 1e-5) * (Math.abs(p_plus[i]) > 1e-5 ? Math.abs(p_plus[i]) : 1);
                    p_plus[i] += step;
                    const pattern_plus = calculateScaledPatternWithFixedIntensities(p_plus, params, hklList);
                    const res_plus = subtract(workingDataNet.intensity, pattern_plus);
                    const weighted_res_plus = res_plus.map((r, j) => r * Math.sqrt(weights[j]));
                    const deriv = scale(subtract(weighted_res_plus, weightedResiduals), -1 / step);
                    jacobian.push(deriv);
                }
                for(let i = 0; i < jacobian.length; i++) { for(let j = 0; j < jacobian[i].length; j++) { if (!isFinite(jacobian[i][j])) jacobian[i][j] = 0; } }

                // --- DIAGNOSTIC LOGS ---
                const jacobianForTable = transpose(jacobian).map(row => {
                    const obj = {};
                    row.forEach((val, i) => { obj[paramNames[i]] = val; });
                    return obj;
                });
                // console.log("Jacobian Matrix (J) - showing first 10 rows:");
                // console.table(jacobianForTable.slice(0, 10));

                const J = transpose(jacobian);
                JtJ = multiply(transpose(J), J);
                
               // console.log("A = J^T * J Matrix:");
                // console.table(JtJ);
                

                const Jtr = multiply(transpose(J), weightedResiduals);
                const A_lm = JSON.parse(JSON.stringify(JtJ));
                for (let i = 0; i < A_lm.length; i++) { A_lm[i][i] += lambda * (A_lm[i][i] || 1.0); }
                const p_step = solve(A_lm, Jtr);

                if (p_step.some(isNaN)) {
                    console.error("Fit failed: Parameter step contains NaN. This is likely due to a singular matrix. Check the Jacobian for columns of zeros or correlated columns.");
                    console.groupEnd();
                    break;
                }

                const p_new_vec = add(p_current_vec, p_step);
                const new_pattern = calculateScaledPatternWithFixedIntensities(p_new_vec, params, hklList);
                const new_residuals = subtract(workingDataNet.intensity, new_pattern);
                const weighted_new_residuals = new_residuals.map((r, i) => r * Math.sqrt(weights[i]));
                const new_cost = dot(weighted_new_residuals, weighted_new_residuals);

                if (new_cost < cost && isFinite(new_cost)) {
                  //  console.log(`Step accepted. New Cost: ${new_cost.toExponential(5)}`);
                    paramMapping.forEach((m, i) => m.set(params, p_new_vec[i]));
                    lambda = Math.max(lambda / 2, 1e-9);
                } else {
                    // console.log(`Step rejected. New Cost: ${new_cost.toExponential(5)}`);
                    lambda = Math.min(lambda * 2, 1e9);
                }
                console.groupEnd();
                if (progressCallback) await progressCallback((iter + 1) / maxIter, params);
            }
            return { params, JtJ, finalResiduals, paramMapping, ss_res: last_cost, algorithm: 'lm', fitFlags };
        }

        async function refineParametersSA(initialParams, fitFlags, maxIter, system, centering, progressCallback) { const { paramMapping } = getParameterMapping(fitFlags); if (!paramMapping || paramMapping.length === 0) return { params: initialParams, algorithm: 'sa', paramMapping, fitFlags }; const workingData = getWorkingData(); const workingDataNet = { tth: workingData.tth, intensity: workingData.intensity.map((y, i) => Math.max(0, y - workingData.background[i])) }; console.log("SA refinement starting with working data points:", workingData.tth.length); const objective = (p_vec, params_template) => { const tempParams = JSON.parse(JSON.stringify(params_template)); paramMapping.forEach((m, i) => { if (m.set) m.set(tempParams, p_vec[i]); }); if ((tempParams.a && tempParams.a <= 0) || (tempParams.profileType !== "4" && tempParams.W <= 0)) return 1e12; try { const newHklList = generateHKL(Math.max(...workingData.tth), tempParams, system, centering); if (!newHklList || newHklList.length === 0) return 1e12; leBailIntensityExtraction(workingData, newHklList, tempParams); const pattern = calculatePattern(workingData.tth, newHklList, tempParams); const sum_obs_calc = dot(workingDataNet.intensity, pattern); const sum_calc_sq = dot(pattern, pattern); if (sum_calc_sq < 1e-9) return 1e12; const scaleFactor = sum_obs_calc / sum_calc_sq; const scaledPattern = scale(pattern, scaleFactor); const diff = subtract(workingDataNet.intensity, scaledPattern); const cost = dot(diff, diff); return isFinite(cost) ? cost : 1e12; } catch (err) { console.error("Objective function error:", err); return 1e12; } }; let bestOverallParams = JSON.parse(JSON.stringify(initialParams)); const LE_BAIL_CYCLES = 10; const stepsPerCycle = Math.max(1, Math.floor(maxIter / LE_BAIL_CYCLES)); const coolingRate = 0.99; for (let cycle = 0; cycle < LE_BAIL_CYCLES; cycle++) { let hklListFixed = generateHKL(Math.max(...workingData.tth), bestOverallParams, system, centering); leBailIntensityExtraction(workingData, hklListFixed, bestOverallParams); let current_x = paramMapping.map(m => m.get(bestOverallParams)); let current_cost = objective(current_x, bestOverallParams); let best_x_cycle = current_x.slice(); let best_cost_cycle = current_cost; let T = 1.0; for (let step = 0; step < stepsPerCycle; step++) { const neighbor_x = current_x.map((val, idx) => { const mapping = paramMapping[idx]; const stepSize = (mapping.step || 0.1) * T; let newVal = val + (Math.random() - 0.5) * 2 * stepSize; if (mapping.set) { let tmp = {}; mapping.set(tmp, newVal); newVal = tmp[mapping.name]; } return newVal; }); const neighbor_cost = objective(neighbor_x, bestOverallParams); const deltaE = neighbor_cost - current_cost; if (deltaE < 0 || Math.exp(-deltaE / T) > Math.random()) { current_x = neighbor_x.slice(); current_cost = neighbor_cost; } if (current_cost < best_cost_cycle) { best_x_cycle = current_x.slice(); best_cost_cycle = current_cost; } T *= coolingRate; if (T < 1e-8) break; if (progressCallback) { const progress = (cycle * stepsPerCycle + step) / (LE_BAIL_CYCLES * stepsPerCycle); let tmpParams = JSON.parse(JSON.stringify(bestOverallParams)); paramMapping.forEach((m, j) => { if (m.set) m.set(tmpParams, best_x_cycle[j]); }); await progressCallback(progress, tmpParams); } } paramMapping.forEach((m, i) => { if (m.set) m.set(bestOverallParams, best_x_cycle[i]); }); } return { params: bestOverallParams, algorithm: 'sa', paramMapping, fitFlags }; }
        async function runLeBailFit() { if (isFitting) return; isFitting = true; fitResults = null; setUIState(true); if (mainChart) { const manualSimDataset = mainChart.data.datasets.find(d => d.label === 'Simulation (Manual)'); if (manualSimDataset) manualSimDataset.data = []; } await new Promise(resolve => setTimeout(resolve, 10)); const fitFlags = getFitFlags(); let params = getAllParams(); const { system, centering } = getSystemAndCentering(); const maxIterations = parseInt(controls.iterationsSlider.value); const algorithm = controls.algorithmSelect.value; const progressCallback = async (progress, currentParams) => { controls.progressBar.style.width = `${progress * 100}%`; await new Promise(resolve => setTimeout(resolve, 0)); }; const LE_BAIL_CYCLES = 5; let lastRwp = Infinity; let lastSuccessfulResults = {}; for (let cycle = 1; cycle <= LE_BAIL_CYCLES; cycle++) { console.group(`--- Le Bail Cycle ${cycle}/${LE_BAIL_CYCLES} ---`); let cycleParams = JSON.parse(JSON.stringify(params)); const workingDataForCycle = getWorkingData(); console.log(`Cycle ${cycle} using ${workingDataForCycle.tth.length} data points for calculation.`); if (workingDataForCycle.tth.length === 0) { alert("Error: No data in the selected 2-theta range. Aborting fit."); break; } let results; if (algorithm === 'lm') { results = await refineParametersLM(cycleParams, fitFlags, maxIterations, system, centering, progressCallback); } else if (algorithm === 'sa') { results = await refineParametersSA(cycleParams, fitFlags, maxIterations, system, centering, progressCallback); } params = results.params; enforceSymmetryConstraints(params); const hklListForStats = generateHKL(Math.max(...fullExperimentalData.tth), params, system, centering); leBailIntensityExtraction(workingDataForCycle, hklListForStats, params); const netPattern_working = calculatePattern(workingDataForCycle.tth, hklListForStats, params); const stats = calculateStatistics(workingDataForCycle, netPattern_working, fitFlags); lastSuccessfulResults = { hklList: hklListForStats, stats: stats, lmResults: results }; console.log(`Cycle ${cycle} complete. Rwp: ${stats.rwp.toFixed(4)}`); if (cycle > 1 && Math.abs(lastRwp - stats.rwp) < 1e-3) { console.log("Le Bail process has converged."); console.groupEnd(); break; } lastRwp = stats.rwp; console.groupEnd(); } const finalParams = params; const finalHklList = lastSuccessfulResults.hklList; const finalStats = lastSuccessfulResults.stats; const finalNetPattern_full = calculatePattern(fullExperimentalData.tth, finalHklList, finalParams); fitResults = { ...lastSuccessfulResults.lmResults, params: finalParams, stats: finalStats, ss_res: finalStats.sum_w_res_sq }; updateUI(finalParams, fitResults.stats, finalNetPattern_full, calculatedBackground, finalStats.scaleFactor); isFitting = false; setUIState(false); }
        const getAllParams = () => { const profileType = controls.profileSelect.value; let params = { lambda: parseFloat(controls.wavelength.value), zeroShift: parseFloat(controls.zeroShift.value), profileType: profileType }; document.querySelectorAll('#lattice-parameters-container input[type="number"]').forEach(input => { if (input.id.startsWith('lattice-param-')) { const paramName = input.id.replace('lattice-param-', ''); params[paramName] = parseFloat(input.value); } }); const { system } = getSystemAndCentering(); switch(system) { case 'cubic': case 'tetragonal': case 'orthorhombic': params.alpha = params.beta = params.gamma = 90; break; case 'hexagonal': params.alpha = params.beta = 90; params.gamma = 120; break; case 'monoclinic': params.alpha = params.gamma = 90; break; } if (profileType === "4") { Object.assign(params, { GU: parseFloat(controls.paramGU.value) || 2.5, GV: parseFloat(controls.paramGV.value) || -2.8, GW: parseFloat(controls.paramGW.value) || 1.6, GP: parseFloat(controls.paramGP.value) || 0.0, LX: parseFloat(controls.paramLX.value) || .10, eta: parseFloat(controls.paramEta.value) || 1., shft: parseFloat(controls.paramShft.value) || 0.0, trns: parseFloat(controls.paramTrns.value) || 0.0 }); } else { Object.assign(params, { U: parseFloat(controls.paramU.value) || 2.0, V: parseFloat(controls.paramV.value) || -1.0, W: parseFloat(controls.paramW.value) || 1.0, X: parseFloat(controls.paramX.value) || 1.0, Y: parseFloat(controls.paramY.value) || 0.5, SL: parseFloat(controls.paramSL.value) || 0.0, HL: parseFloat(controls.paramHL.value) || 0.0, S400: parseFloat(controls.paramS400.value) || 0.0, S040: parseFloat(controls.paramS040.value) || 0.0, S004: parseFloat(controls.paramS004.value) || 0.0, S220: parseFloat(controls.paramS220.value) || 0.0, S202: parseFloat(controls.paramS202.value) || 0.0, S022: parseFloat(controls.paramS022.value) || 0.0 }); } return params; };
        const getFitFlags = () => { const profileType = controls.profileSelect.value; const { system } = getSystemAndCentering(); let flags = { a: document.getElementById('fit-lattice-a')?.checked, b: document.getElementById('fit-lattice-b')?.checked, c: document.getElementById('fit-lattice-c')?.checked, alpha: document.getElementById('fit-lattice-alpha')?.checked, beta: document.getElementById('fit-lattice-beta')?.checked, gamma: document.getElementById('fit-lattice-gamma')?.checked, zeroShift: controls.fitZeroShift.checked, }; if (profileType === "4") { Object.assign(flags, { GU: controls.fitGU.checked, GV: controls.fitGV.checked, GW: controls.fitGW.checked, GP: controls.fitGP.checked, LX: controls.fitLX.checked, eta: controls.fitEta.checked, shft: controls.fitShft.checked, trns: controls.fitTrns.checked, }); } else { Object.assign(flags, { U: controls.fitU.checked, V: controls.fitV.checked, W: controls.fitW.checked, X: controls.fitX.checked, Y: controls.fitY.checked, SL: controls.fitSL.checked, HL: controls.fitHL.checked, }); } if (profileType === "3") { Object.assign(flags, { S400: controls.fitS400.checked, S040: controls.fitS040.checked, S004: controls.fitS004.checked, S220: controls.fitS220.checked, S202: controls.fitS202.checked, S022: controls.fitS022.checked, }); switch (system) { case 'cubic': flags.S040 = flags.S004 = flags.S202 = flags.S022 = false; break; case 'hexagonal': case 'tetragonal': case 'rhombohedral': flags.S040 = flags.S022 = false; break; } } return flags; };
        const dot = (v1, v2) => { let s = 0; for(let i=0; i<v1.length; i++) s += v1[i] * v2[i]; return s; }; const add = (v1, v2) => v1.map((x, i) => x + v2[i]); const subtract = (v1, v2) => v1.map((x, i) => x - v2[i]); const scale = (v, s) => v.map(x => x * s); const transpose = (m) => { if (!m || m.length === 0 || !Array.isArray(m[0])) return m.map(x => [x]); return m[0].map((_, colIndex) => m.map(row => row[colIndex])); }; const multiply = (A, B) => { if (!Array.isArray(B[0])) return A.map(row => dot(row, B)); const Bt = transpose(B); return A.map(rowA => Bt.map(colB => dot(rowA, colB))); }; const solve = (A, b) => { const n = A.length; const Ab = A.map((row, i) => [...row, b[i]]); for (let i = 0; i < n; i++) { let max = i; for (let k = i + 1; k < n; k++) if (Math.abs(Ab[k][i]) > Math.abs(Ab[max][i])) max = k; [Ab[i], Ab[max]] = [Ab[max], Ab[i]]; if (Math.abs(Ab[i][i]) < 1e-12) continue; for (let k = i + 1; k < n; k++) { const factor = Ab[k][i] / Ab[i][i]; if (!isFinite(factor)) continue; for (let j = i; j < n + 1; j++) Ab[k][j] -= factor * Ab[i][j]; } } const x = new Array(n).fill(0); for (let i = n - 1; i >= 0; i--) { let sum = 0; for (let j = i + 1; j < n; j++) sum += Ab[i][j] * x[j]; if (Math.abs(Ab[i][i]) > 1e-12) x[i] = (Ab[i][n] - sum) / Ab[i][i]; } return x; };
        function calculateDeterminant(A) { const n = A.length; if (n === 1) return A[0][0]; if (n === 2) return A[0][0] * A[1][1] - A[0][1] * A[1][0]; const U = A.map(row => [...row]); let det = 1; for (let i = 0; i < n; i++) { let maxRow = i; for (let k = i + 1; k < n; k++) if (Math.abs(U[k][i]) > Math.abs(U[maxRow][i])) maxRow = k; if (maxRow !== i) { [U[i], U[maxRow]] = [U[maxRow], U[i]]; det *= -1; } if (Math.abs(U[i][i]) < 1e-15) return 0; det *= U[i][i]; for (let k = i + 1; k < n; k++) { const factor = U[k][i] / U[i][i]; for (let j = i; j < n; j++) U[k][j] -= factor * U[i][j]; } } return det; }
        function matrixInverse(A) { const n = A.length; if (n === 0) return []; const det = calculateDeterminant(A); if (Math.abs(det) < 1e-15) { console.warn("Matrix is singular or near-singular, determinant =", det); return null; } const augmented = A.map((row, i) => [...row, ...Array.from({ length: n }, (_, j) => (i === j ? 1 : 0))]); for (let i = 0; i < n; i++) { let maxRow = i; for (let j = i + 1; j < n; j++) if (Math.abs(augmented[j][i]) > Math.abs(augmented[maxRow][i])) maxRow = j; [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]]; if (Math.abs(augmented[i][i]) < 1e-15) { console.warn("Zero pivot encountered during matrix inversion"); return null; } const pivot = augmented[i][i]; for (let j = 0; j < 2 * n; j++) augmented[i][j] /= pivot; for (let j = 0; j < n; j++) { if (i !== j) { const factor = augmented[j][i]; for (let k = 0; k < 2 * n; k++) augmented[j][k] -= factor * augmented[i][k]; } } } return augmented.map(row => row.slice(n)); }
        function getParameterMapping(fitFlags) { const paramMapping = []; const profileType = controls.profileSelect.value; const paramDefs = [ { flag: fitFlags.a, name: 'a', get: p => p.a, set: (p, v) => p.a = Math.max(0.1, v), step: 1e-3 }, { flag: fitFlags.b, name: 'b', get: p => p.b, set: (p, v) => p.b = Math.max(0.1, v), step: 1e-3 }, { flag: fitFlags.c, name: 'c', get: p => p.c, set: (p, v) => p.c = Math.max(0.1, v), step: 1e-3 }, { flag: fitFlags.alpha, name: 'alpha', get: p => p.alpha, set: (p, v) => p.alpha = v, step: 1e-2 }, { flag: fitFlags.beta, name: 'beta', get: p => p.beta, set: (p, v) => p.beta = v, step: 1e-2 }, { flag: fitFlags.gamma, name: 'gamma', get: p => p.gamma, set: (p, v) => p.gamma = v, step: 1e-2 }, { flag: fitFlags.zeroShift, name: 'zeroShift', get: p => p.zeroShift, set: (p, v) => p.zeroShift = v, step: 1e-3 }, ]; if (profileType === "4") { paramDefs.push( { flag: fitFlags.GU, name: 'GU', get: p => p.GU, set: (p, v) => p.GU = Math.max(0, v), step: 0.1 }, { flag: fitFlags.GV, name: 'GV', get: p => p.GV, set: (p, v) => p.GV = v, step: 0.1 }, { flag: fitFlags.GW, name: 'GW', get: p => p.GW, set: (p, v) => p.GW = Math.max(0, v), step: 0.1 }, { flag: fitFlags.GP, name: 'GP', get: p => p.GP, set: (p, v) => p.GP = v, step: 0.1 }, { flag: fitFlags.LX, name: 'LX', get: p => p.LX, set: (p, v) => p.LX = Math.max(0, v), step: 0.2 }, { flag: fitFlags.eta, name: 'eta', get: p => p.eta, set: (p, v) => p.eta = Math.max(0, Math.min(1, v)), step: 0.05 }, { flag: fitFlags.shft, name: 'shft', get: p => p.shft, set: (p, v) => p.shft = v, step: 0.01 }, { flag: fitFlags.trns, name: 'trns', get: p => p.trns, set: (p, v) => p.trns = v, step: 0.01 } ); } else { paramDefs.push( { flag: fitFlags.U, name: 'U', get: p => p.U, set: (p, v) => p.U = v, step: 0.1 }, { flag: fitFlags.V, name: 'V', get: p => p.V, set: (p, v) => p.V = v, step: 0.1 }, { flag: fitFlags.W, name: 'W', get: p => p.W, set: (p, v) => p.W = Math.max(0, v), step: 0.1 }, { flag: fitFlags.X, name: 'X', get: p => p.X, set: (p, v) => p.X = Math.max(0, v), step: 0.1 }, { flag: fitFlags.Y, name: 'Y', get: p => p.Y, set: (p, v) => p.Y = Math.max(0, v), step: 0.1 }, { flag: fitFlags.SL, name: 'SL', get: p => p.SL, set: (p, v) => p.SL = v, step: 0.01 }, { flag: fitFlags.HL, name: 'HL', get: p => p.HL, set: (p, v) => p.HL = v, step: 0.01 } ); } if (profileType === "3") { paramDefs.push( { flag: fitFlags.S400, name: 'S400', get: p => p.S400, set: (p, v) => p.S400 = v, step: 0.1 }, { flag: fitFlags.S040, name: 'S040', get: p => p.S040, set: (p, v) => p.S040 = v, step: 0.1 }, { flag: fitFlags.S004, name: 'S004', get: p => p.S004, set: (p, v) => p.S004 = v, step: 0.1 }, { flag: fitFlags.S220, name: 'S220', get: p => p.S220, set: (p, v) => p.S220 = v, step: 0.1 }, { flag: fitFlags.S202, name: 'S202', get: p => p.S202, set: (p, v) => p.S202 = v, step: 0.1 }, { flag: fitFlags.S022, name: 'S022', get: p => p.S022, set: (p, v) => p.S022 = v, step: 0.1 } ); } paramDefs.forEach(def => { if (def.flag) paramMapping.push(def); }); return { paramMapping }; }
        function enforceSymmetryConstraints(params) { const { system } = getSystemAndCentering(); switch (system) { case 'cubic': if (params.S400 !== undefined) params.S040 = params.S004 = params.S400; if (params.S220 !== undefined) params.S202 = params.S022 = params.S220; break; case 'hexagonal': case 'tetragonal': case 'rhombohedral': if (params.S400 !== undefined) params.S040 = params.S400; if (params.S202 !== undefined) params.S022 = params.S202; break; } }
        
        function updatePreviewPattern() {
            if (!mainChart || fullExperimentalData.tth.length === 0 || isFitting) return;
            
            const { system, centering } = getSystemAndCentering();
            const params = getAllParams();

            if (isNaN(params.lambda) || params.lambda <= 0 || isNaN(params.a) || params.a <= 0) return;

            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            
            const workingData = getWorkingData();
            if (workingData.tth.length === 0) return;

            let hklList = generateHKL(Math.max(...fullExperimentalData.tth), params, system, centering);
            lastGeneratedHklList = hklList;
            
            hklList.forEach(p => p.intensity = 1000);

            const unscaledPeakPattern_full = calculatePattern(fullExperimentalData.tth, hklList, params);
            const y_obs_net_full = fullExperimentalData.intensity.map((y, i) => Math.max(0, y - calculatedBackground[i]));

            const sum_obs_calc = dot(y_obs_net_full, unscaledPeakPattern_full);
            const sum_calc_sq = dot(unscaledPeakPattern_full, unscaledPeakPattern_full);
            const scaleFactor = (sum_calc_sq > 1e-9) ? sum_obs_calc / sum_calc_sq : 1.0;
            const totalCalcPattern = unscaledPeakPattern_full.map((y, i) => (y * scaleFactor) + calculatedBackground[i]);
            
            findDataset('Simulation (Manual)').data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: totalCalcPattern[i] }));
            
            // --- updates the HKL markers in real-time ---
            const globalYMax = mainChart.options.globalYMax;
            const diffPlotHeightRatio = 0.3;
            const constantNegSpaceHeight = globalYMax * diffPlotHeightRatio;
            const markerBottom = -(constantNegSpaceHeight * 0.05);
            const markerTop = -(constantNegSpaceHeight * 0.20);
            const minTth = parseFloat(controls.tthMinSlider.value);
            const maxTth = parseFloat(controls.tthMaxSlider.value);

            findDataset('HKL Markers').data = hklList
                .filter(hkl => {
                    const peakPos = hkl.tth + (params.zeroShift || 0);
                    return peakPos >= minTth && peakPos <= maxTth;
                })
                .map(hkl => ({
                    x: hkl.tth + params.zeroShift,
                    y: [markerTop, markerBottom],
                    hkl: `${hkl.hkl_list[0]} [m=${hkl.multiplicity}]`
                }));
            

            lastRawDifference = fullExperimentalData.intensity.map((y, i) => y - totalCalcPattern[i]);
            
            rescalePlot();
            mainChart.update('none');
        }

        function setUIState(fitting) { isFitting = fitting; controls.fitButton.disabled = fitting; controls.reportButton.disabled = fitting; controls.saveDataButton.disabled = fitting; controls.fitButton.textContent = fitting ? 'Refining...' : 'Run Refinement'; controls.progressBarContainer.classList.toggle('hidden', !fitting); document.body.style.cursor = fitting ? 'wait' : 'default'; if (fitting) { controls.rpResult.textContent = '...'; controls.rwpResult.textContent = '...'; controls.chi2Result.textContent = '...'; } if (!fitting) { controls.progressBar.style.width = '0%'; if(fitResults) { controls.reportButton.disabled = false; controls.saveDataButton.disabled = false; } controls.rwpResult.parentElement.parentElement.querySelectorAll('.result-card').forEach(c => c.style.background = ''); } }
        function updateUI(params, stats, netPeakPattern_full, background_full, scaleFactor) {
            const safeUpdate = (paramValue, controlElement, digits) => { if (controlElement && typeof paramValue === 'number' && isFinite(paramValue)) controlElement.value = paramValue.toFixed(digits); };
            if (stats && typeof stats.r_p === 'number') controls.rpResult.textContent = stats.r_p.toFixed(2); if (stats && typeof stats.rwp === 'number') controls.rwpResult.textContent = stats.rwp.toFixed(2); if (stats && typeof stats.chi2 === 'number') controls.chi2Result.textContent = stats.chi2.toFixed(3);
            safeUpdate(params.a, document.getElementById('lattice-param-a'), 4); safeUpdate(params.b, document.getElementById('lattice-param-b'), 4); safeUpdate(params.c, document.getElementById('lattice-param-c'), 4); safeUpdate(params.alpha, document.getElementById('lattice-param-alpha'), 3); safeUpdate(params.beta, document.getElementById('lattice-param-beta'), 3); safeUpdate(params.gamma, document.getElementById('lattice-param-gamma'), 3); safeUpdate(params.zeroShift, controls.zeroShift, 4);
            const profileType = params.profileType || controls.profileSelect.value;
            if (profileType === "4") { safeUpdate(params.GU, controls.paramGU, 4); safeUpdate(params.GV, controls.paramGV, 4); safeUpdate(params.GW, controls.paramGW, 4); safeUpdate(params.GP, controls.paramGP, 4); safeUpdate(params.LX, controls.paramLX, 4); safeUpdate(params.eta, controls.paramEta, 4); safeUpdate(params.shft, controls.paramShft, 4); safeUpdate(params.trns, controls.paramTrns, 4); } 
            else { safeUpdate(params.U, controls.paramU, 4); safeUpdate(params.V, controls.paramV, 4); safeUpdate(params.W, controls.paramW, 4); safeUpdate(params.X, controls.paramX, 4); safeUpdate(params.Y, controls.paramY, 4); safeUpdate(params.SL, controls.paramSL, 4); safeUpdate(params.HL, controls.paramHL, 4); if (profileType === "3") { safeUpdate(params.S400, controls.paramS400, 4); safeUpdate(params.S040, controls.paramS040, 4); safeUpdate(params.S004, controls.paramS004, 4); safeUpdate(params.S220, controls.paramS220, 4); safeUpdate(params.S202, controls.paramS202, 4); safeUpdate(params.S022, controls.paramS022, 4); } }
            if (netPeakPattern_full && background_full) { const { system, centering } = getSystemAndCentering(); const hklList = generateHKL(Math.max(...fullExperimentalData.tth), params, system, centering); lastGeneratedHklList = hklList; updateChart(netPeakPattern_full, background_full, hklList, params, scaleFactor); }
        }
        function updateChart(netPeakPattern_full, background_full, hklList, params, scaleFactor = 1.0) {
            if (!mainChart) return;
            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            findDataset('Simulation (Manual)').data = [];
            const totalCalcPattern = netPeakPattern_full.map((y, i) => (y * scaleFactor) + background_full[i]);
            findDataset('Calculated').data = fullExperimentalData.tth.map((t, i) => ({x: t, y: totalCalcPattern[i]}));
            findDataset('Background').data = fullExperimentalData.tth.map((t, i) => ({x: t, y: background_full[i]}));
            lastRawDifference = fullExperimentalData.intensity.map((y, i) => y - totalCalcPattern[i]);
            mainChart.update('none');
            const globalYMax = mainChart.options.globalYMax; const diffPlotHeightRatio = 0.3; const constantNegSpaceHeight = globalYMax * diffPlotHeightRatio;
            const markerBottom = -(constantNegSpaceHeight * 0.05); const markerTop = -(constantNegSpaceHeight * 0.20);
            const minTth = parseFloat(controls.tthMinSlider.value); const maxTth = parseFloat(controls.tthMaxSlider.value);
            findDataset('HKL Markers').data = hklList.filter(hkl => { const peakPos = hkl.tth + (params.zeroShift || 0); return peakPos >= minTth && peakPos <= maxTth; }).map(hkl => ({ x: hkl.tth + params.zeroShift, y: [markerTop, markerBottom], hkl: `${hkl.hkl_list[0]} [m=${hkl.multiplicity}]` }));
            const constantDiffPlotSpaceTop = -(constantNegSpaceHeight * 0.25); const diffPlotZeroLine = -constantNegSpaceHeight + (constantNegSpaceHeight - constantDiffPlotSpaceTop) / 2; const diffPlotAmplitude = (constantNegSpaceHeight - constantDiffPlotSpaceTop) / 2 * 0.95;
            let dYmax = Math.max(...lastRawDifference.map(Math.abs)); if (!isFinite(dYmax) || dYmax === 0) dYmax = 1;
            const scalingFactorForDiffPlot = diffPlotAmplitude / dYmax;
            findDataset('Difference').data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: (lastRawDifference[i] * scalingFactorForDiffPlot) + diffPlotZeroLine }));
            findDataset('Difference Zero').data = [{x: fullExperimentalData.tth[0], y: diffPlotZeroLine}, {x: fullExperimentalData.tth[fullExperimentalData.tth.length-1], y: diffPlotZeroLine}];
            mainChart.update('none');
        }

        function getPeakInfoAt(tth) {
            if (!lastGeneratedHklList || lastGeneratedHklList.length === 0 || !mainChart) return { peak: null, inRegion: false };
            let closestPeak = null, minDiff = Infinity; const currentParams = getAllParams(); const zeroShift = currentParams.zeroShift || 0;
            for (const hkl of lastGeneratedHklList) { const peakShift = calculatePeakShift(hkl.tth, currentParams); const peakPos = hkl.tth + zeroShift + peakShift; const diff = Math.abs(tth - peakPos); if (diff < minDiff) { minDiff = diff; closestPeak = hkl; } }
            if (closestPeak) { const N = 1; const plottedXRange = parseFloat(controls.tthMaxSlider.value) - parseFloat(controls.tthMinSlider.value); const threshold = (plottedXRange * N) / 100.0; if (minDiff < threshold) return { peak: closestPeak, inRegion: true }; }
            return { peak: null, inRegion: false };
        }

        function initializeChart() {
            if (mainChart) mainChart.destroy();
            const experimentalPoints = fullExperimentalData.tth.map((t, i) => ({x: t, y: fullExperimentalData.intensity[i]}));
            const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
            mainChart = new Chart(controls.mainChartCanvas, {
                type: 'line',
                data: { datasets: [
                    { label: 'Experimental', data: experimentalPoints, borderColor: 'rgba(107, 114, 128, 0.7)', borderWidth: 1.5, pointRadius: 0, order: 1 },
                    { label: 'Simulation (Manual)', data: [], borderColor: 'rgba(249, 115, 22, 0.8)', borderWidth: 2, pointRadius: 0, borderDash: [8, 4], order: 2 },
                    { label: 'Calculated', data: [], borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 2, pointRadius: 0, order: 3 },
                    { label: 'Background', data: [], borderColor: 'rgba(217, 119, 6, 0.8)', borderWidth: 1.5, pointRadius: 0, borderDash: [5, 5], order: 4 },
                    { label: 'Difference', data: [], borderColor: 'rgba(239, 68, 68, 0.8)', borderWidth: 1.5, pointRadius: 0, order: 5 },
                    { label: 'Difference Zero', data: [], borderColor: 'rgba(156, 163, 175, 0.8)', borderWidth: 1, pointRadius: 0, borderDash: [2, 2], order: 6 },
                    { type: 'bar', label: 'HKL Markers', data: [], backgroundColor: 'rgba(22, 163, 74, 0.9)', barThickness: 2, categoryPercentage: 1.0, barPercentage: 1.0, order: 0 },
                ]},
                options: {
                    responsive: true, maintainAspectRatio: false, animation: false,
                    scales: {
                        x: { type: 'linear', title: { display: true, text: '2θ (degrees)', font: { size: 14 }}},
                        y: { type: 'linear', position: 'left', title: { display: true, text: 'Intensity (a.u.)', font: { size: 14 }},
                            min: -yMax * 0.3, max: Math.ceil(yMax * 1.1),
                            ticks: { callback: function(value, index, ticks) { return value >= 0 ? value.toFixed(1) : null; }}
                        }
                    },
                    plugins: {
                        zoom: {
                            pan: { enabled: true, mode: 'xy', threshold: 5, onPanComplete: () => rescalePlot(false) },
                            zoom: { wheel: { enabled: false }, pinch: { enabled: true }, drag: { enabled: false }, onZoomComplete: () => rescalePlot(false) }
                        },
                        legend: { labels: { filter: item => item.text !== 'Difference Zero' && item.text !== 'Simulation (Manual)'}},
                        tooltip: {
                            enabled: true,
                            mode: 'x',
                            intersect: false,
                            position: 'experimentalAnchor',
                            // This filter function is the key. It tells the chart to only
                            // show a tooltip if the cursor is in a peak region.
                            filter: function(tooltipItem) {
                                const tth = tooltipItem.parsed.x;
                                const peakInfo = getPeakInfoAt(tth);
                                return peakInfo.inRegion;
                            },
                            callbacks: {
                                title: function(tooltipItems) {
                                    // This function will now only run when the filter returns true.
                                    if (!tooltipItems.length) return '';
                                    const tth = tooltipItems[0].parsed.x;
                                    const peakInfo = getPeakInfoAt(tth);
                                    if (peakInfo.inRegion) {
                                        const closestPeak = peakInfo.peak;
                                        return `2θ: ${tth.toFixed(2)}°, HKL: ${closestPeak.hkl_list[0]}`;
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    // This ensures no other data (Experimental, Calculated, etc.) is shown.
                                    return null;
                                }
                            }
                        }
                    }
                }
            });
            mainChart.options.globalYMax = yMax;
        }

        function updatePlotRange(updateY = false) { if(!mainChart || !fullExperimentalData || fullExperimentalData.tth.length === 0) return; const min = parseFloat(controls.tthMinSlider.value); const max = parseFloat(controls.tthMaxSlider.value); mainChart.options.scales.x.min = min; mainChart.options.scales.x.max = max; if (updateY) { let yMaxInRange = 1; for (let i = 0; i < fullExperimentalData.tth.length; i++) { if (fullExperimentalData.tth[i] >= min && fullExperimentalData.tth[i] <= max) { if (fullExperimentalData.intensity[i] > yMaxInRange) yMaxInRange = fullExperimentalData.intensity[i]; } } const diffPlotHeightRatio = 0.33; mainChart.options.scales.y.max = Math.ceil(yMaxInRange * 1.1); mainChart.options.scales.y.min = -yMaxInRange * diffPlotHeightRatio; } }
        function rescalePlot(updateY = false) { if (!mainChart || !fullExperimentalData.tth.length) return; mainChart.update('none'); const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label); const globalYMax = mainChart.options.globalYMax; const diffPlotHeightRatio = 0.3; const constantNegSpaceHeight = globalYMax * diffPlotHeightRatio; const hklDataset = findDataset('HKL Markers'); if (hklDataset && hklDataset.data.length > 0) { const markerBottom = -(constantNegSpaceHeight * 0.05); const markerTop = -(constantNegSpaceHeight * 0.20); hklDataset.data.forEach(point => point.y = [markerTop, markerBottom]); } if (lastRawDifference && lastRawDifference.length > 0) { const constantDiffPlotSpaceTop = -(constantNegSpaceHeight * 0.25); const diffPlotZeroLine = -constantNegSpaceHeight + (constantNegSpaceHeight - constantDiffPlotSpaceTop) / 2; const diffPlotAmplitude = (constantNegSpaceHeight - constantDiffPlotSpaceTop) / 2 * 0.95; let dYmax = Math.max(...lastRawDifference.map(Math.abs)); if (!isFinite(dYmax) || dYmax === 0) dYmax = 1; const scalingFactor = diffPlotAmplitude / dYmax; findDataset('Difference').data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: (lastRawDifference[i] * scalingFactor) + diffPlotZeroLine })); findDataset('Difference Zero').data = [ {x: fullExperimentalData.tth[0], y: diffPlotZeroLine}, {x: fullExperimentalData.tth[fullExperimentalData.tth.length-1], y: diffPlotZeroLine} ]; } mainChart.update('none'); }
        function getIntegratedIntensity(tth_peak, fwhm, expData, bkgData, multiplier = 2.0) { if (!expData || expData.tth.length === 0 || fwhm <= 0) return 0; const window = fwhm * multiplier; const tth_min = tth_peak - window / 2; const tth_max = tth_peak + window / 2; let integrated_intensity = 0; let startIndex = expData.tth.findIndex(t => t >= tth_min); if(startIndex === -1) return 0; if(startIndex > 0) startIndex--; for (let i = startIndex; i < expData.tth.length; i++) { const current_tth = expData.tth[i]; if (current_tth > tth_max && i > startIndex) break; if (current_tth < tth_min) continue; if (i > startIndex) { const prev_tth = expData.tth[i-1]; const net_intensity = expData.intensity[i] - (bkgData[i] || 0); const prev_net_intensity = expData.intensity[i-1] - (bkgData[i-1] || 0); const step_width = current_tth - prev_tth; integrated_intensity += (net_intensity + prev_net_intensity) / 2 * step_width; } } return Math.max(0, integrated_intensity); }
        
        function downloadTextFile(content, filename) {
            const element = document.createElement('a');
            const file = new Blob([content], {type: 'text/plain;charset=utf-8'});
            element.href = URL.createObjectURL(file);
            element.download = filename;
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }

        function generateTextReportContent() {
            if (!fitResults || typeof fitResults.params !== 'object' || fitResults.params === null) return "Error: Fit results missing.";
            const reportLines = []; const now = new Date(); const finalParams = fitResults.params; const fitFlags = fitResults.fitFlags; const algorithm = fitResults.algorithm; const stats = fitResults.stats;
            
            // This block determines the correct profile name
            const profileName = finalParams.profileType === "4"
                ? "Simple pVoigt"
                : "TCH w/ Anisotropy";

            reportLines.push('==============================================================', '            Le Bail Refinement Report', '==============================================================', `Report Generated: ${now.toLocaleString()}`, `Data File: ${controls.fileName.textContent}`, '', '--- Refinement Statistics ---', `Rp (%):      ${stats.r_p.toFixed(2)}`, `Rwp (%):     ${stats.rwp.toFixed(2)}`, `χ² (GOF):    ${stats.chi2.toFixed(3)}`, `Algorithm:   ${algorithm === 'lm' ? 'Levenberg-Marquardt' : 'Simulated Annealing'}`, `Profile:     ${profileName} (#${finalParams.profileType})`, '');
            
            let esds = {}; let esdWarning = null;
            if (fitResults.algorithm === 'lm' && fitResults.JtJ) {
                const workingDataForStats = getWorkingData();
                const workingDataNet = { intensity: workingDataForStats.intensity.map((y, i) => Math.max(0, y - workingDataForStats.background[i])) };
                const N = workingDataNet.intensity.length; const P = fitResults.paramMapping.length;
                if (N > P && fitResults.ss_res !== undefined) {
                    const reduced_chi_sq = fitResults.ss_res / (N - P); const cov_matrix = matrixInverse(fitResults.JtJ);
                    if (cov_matrix) { fitResults.paramMapping.forEach((p, i) => { if (cov_matrix[i] && cov_matrix[i][i] !== undefined) { esds[p.name] = Math.sqrt(Math.abs(reduced_chi_sq * cov_matrix[i][i])); } }); } 
                    else { esdWarning = 'ESD calculation failed (unstable refinement or correlated parameters).'; }
                }
            }
            const formatParamLine = (name, value, isFitted, esd) => { let valStr = (value !== null && value !== undefined) ? value.toExponential(6).padStart(15) : 'N/A'.padStart(15); const fitStr = (isFitted === undefined) ? '' : (isFitted ? 'Yes' : 'No').padStart(6); const esdStr = (isFitted && esd !== undefined) ? `(${esd.toExponential(2)})`.padStart(15) : '-'.padStart(15); return `${name.padEnd(20)}${valStr}    ${fitStr}    ${esdStr}`; };
            const allParams = [ { name: 'a (Å)', value: finalParams.a, flag: fitFlags.a, esd_name: 'a' }, { name: 'b (Å)', value: finalParams.b, flag: fitFlags.b, esd_name: 'b' }, { name: 'c (Å)', value: finalParams.c, flag: fitFlags.c, esd_name: 'c' }, { name: 'alpha (°)', value: finalParams.alpha, flag: fitFlags.alpha, esd_name: 'alpha' }, { name: 'beta (°)', value: finalParams.beta, flag: fitFlags.beta, esd_name: 'beta' }, { name: 'gamma (°)', value: finalParams.gamma, flag: fitFlags.gamma, esd_name: 'gamma' }, { name: 'Radiation (Å)', value: finalParams.lambda, flag: false, esd_name: null }, { name: 'Zero Shift (°)', value: finalParams.zeroShift, flag: fitFlags.zeroShift, esd_name: 'zeroShift' }, ];
            if (finalParams.profileType === "4") { allParams.push( { name: 'GU', value: finalParams.GU, flag: fitFlags.GU, esd_name: 'GU' }, { name: 'GV', value: finalParams.GV, flag: fitFlags.GV, esd_name: 'GV' }, { name: 'GW', value: finalParams.GW, flag: fitFlags.GW, esd_name: 'GW' }, { name: 'GP', value: finalParams.GP, flag: fitFlags.GP, esd_name: 'GP' }, { name: 'LX', value: finalParams.LX, flag: fitFlags.LX, esd_name: 'LX' }, { name: 'eta', value: finalParams.eta, flag: fitFlags.eta, esd_name: 'eta' }, { name: 'shft', value: finalParams.shft, flag: fitFlags.shft, esd_name: 'shft' }, { name: 'trns', value: finalParams.trns, flag: fitFlags.trns, esd_name: 'trns' } ); } 
            else { allParams.push( { name: 'U', value: finalParams.U, flag: fitFlags.U, esd_name: 'U' }, { name: 'V', value: finalParams.V, flag: fitFlags.V, esd_name: 'V' }, { name: 'W', value: finalParams.W, flag: fitFlags.W, esd_name: 'W' }, { name: 'X', value: finalParams.X, flag: fitFlags.X, esd_name: 'X' }, { name: 'Y', value: finalParams.Y, flag: fitFlags.Y, esd_name: 'Y' }, { name: 'S/L', value: finalParams.SL, flag: fitFlags.SL, esd_name: 'SL' }, { name: 'H/L', value: finalParams.HL, flag: fitFlags.HL, esd_name: 'HL' } ); if (finalParams.profileType === "3") { allParams.push( { name: 'S400', value: finalParams.S400, flag: fitFlags.S400, esd_name: 'S400' }, { name: 'S040', value: finalParams.S040, flag: fitFlags.S040, esd_name: 'S040' }, { name: 'S004', value: finalParams.S004, flag: fitFlags.S004, esd_name: 'S004' }, { name: 'S220', value: finalParams.S220, flag: fitFlags.S220, esd_name: 'S220' }, { name: 'S202', value: finalParams.S202, flag: fitFlags.S202, esd_name: 'S202' }, { name: 'S022', value: finalParams.S022, flag: fitFlags.S022, esd_name: 'S022' } ); } }
            reportLines.push('--- Structural & Instrumental Parameters ---', 'Parameter'.padEnd(20) + 'Value'.padStart(15) + '    Fitted' + '    ESD'.padStart(19), '-'.repeat(70));
            const selectedOption = controls.bravaisLattice.options[controls.bravaisLattice.selectedIndex]; reportLines.push(`System: ${selectedOption.text}`);
            allParams.forEach(p => { if (p.value !== undefined && p.value !== null && !isNaN(p.value)) { reportLines.push(formatParamLine(p.name, p.value, p.flag, esds[p.esd_name])); } });
            if (esdWarning) { reportLines.push('', `Warning: ${esdWarning}`); }
            const { system, centering } = getSystemAndCentering(); const hklListForReport = generateHKL(Math.max(...fullExperimentalData.tth), finalParams, system, centering);
            const dataForExtraction = { tth: fullExperimentalData.tth, intensity: fullExperimentalData.intensity, background: calculatedBackground };
            leBailIntensityExtraction(dataForExtraction, hklListForReport, finalParams);
            reportLines.push('', '--- Reflections List (Integrated Intensities) ---');
            const intensities = hklListForReport.map(hkl => { const peakShift = calculatePeakShift(hkl.tth, finalParams); const tthCorr = hkl.tth + finalParams.zeroShift + peakShift; const { gamma_G, gamma_L } = calculateProfileWidths(hkl.tth, hkl, finalParams); const fwhm = gamma_G + gamma_L; const i_exp = getIntegratedIntensity(tthCorr, fwhm, fullExperimentalData, calculatedBackground); return { i_calc_norm: hkl.intensity, i_exp: i_exp, hkl_data: hkl, tthCorr: tthCorr }; });
            const i_calc_norm_values = intensities.map(i => i.i_calc_norm); const i_exp_values = intensities.map(i => i.i_exp); const sum_exp_calc = dot(i_exp_values, i_calc_norm_values); const sum_calc_sq = dot(i_calc_norm_values, i_calc_norm_values); const intensityScaleFactor = (sum_calc_sq > 1e-9) ? sum_exp_calc / sum_calc_sq : 1.0;
            reportLines.push(['h,k,l'.padEnd(12), '2th_corr (°)' .padStart(15), 'I_calc'.padStart(12), 'I_exp'.padStart(12)].join('  '), '-'.repeat(55));
            intensities.forEach(item => { if (item.i_exp > 0 || item.i_calc_norm > 0) { const final_i_calc = item.i_calc_norm * intensityScaleFactor; const line = [item.hkl_data.hkl_list[0].padEnd(12), item.tthCorr.toFixed(4).padStart(15), final_i_calc.toFixed(1).padStart(12), item.i_exp.toFixed(1).padStart(12)].join('  '); reportLines.push(line); } });
            reportLines.push('', '--- Point-by-Point Intensity Data ---', ['2theta'.padEnd(12), 'I_obs'.padStart(12), 'I_calc'.padStart(12), 'Difference'.padStart(12)].join('  '), '-'.repeat(60));
            const finalCalcPatternNet = calculatePattern(fullExperimentalData.tth, hklListForReport, finalParams);
            let sum_obs_net_calc_net = 0, sum_calc_net_sq_main = 0;
            const y_obs_net = fullExperimentalData.intensity.map((y, i) => y - calculatedBackground[i]);
            for (let i = 0; i < y_obs_net.length; i++) { sum_obs_net_calc_net += y_obs_net[i] * finalCalcPatternNet[i]; sum_calc_net_sq_main += finalCalcPatternNet[i] * finalCalcPatternNet[i]; }
            const mainScaleFactor = sum_calc_net_sq_main > 0 ? sum_obs_net_calc_net / sum_calc_net_sq_main : 1.0;
            for (let i = 0; i < fullExperimentalData.tth.length; i++) { const i_calc = (finalCalcPatternNet[i] * mainScaleFactor) + calculatedBackground[i]; const diff = fullExperimentalData.intensity[i] - i_calc; const line = [fullExperimentalData.tth[i].toFixed(4).padEnd(12), fullExperimentalData.intensity[i].toFixed(2).padStart(12), i_calc.toFixed(2).padStart(12), diff.toFixed(2).padStart(12)].join('  '); reportLines.push(line); }
            return reportLines.join('\n');
        }

        // --- EVENT LISTENERS ---
        controls.fileInput.addEventListener('change', (e) => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (evt) => { try { const parsedData = detectAndParseFile(file.name, evt.target.result); if (!parsedData || parsedData.tth.length === 0) throw new Error("No valid data points parsed."); if (parsedData.wavelength) controls.wavelength.value = parsedData.wavelength.toFixed(5); fullExperimentalData = { tth: parsedData.tth, intensity: parsedData.intensity }; lastRawDifference = []; calculatedBackground = new Array(fullExperimentalData.tth.length).fill(0); workingDataCache.isValid = false; controls.fileName.textContent = file.name; controls.placeholder.style.display = 'none'; controls.resultsContainer.style.display = 'flex'; controls.fitButton.disabled = false; controls.fitButton.textContent = 'Run Refinement'; initializeChart(); const min = fullExperimentalData.tth[0]; const max = fullExperimentalData.tth[fullExperimentalData.tth.length - 1]; const step = (max - min) / 2000; [controls.tthMinSlider, controls.tthMaxSlider].forEach(slider => { slider.min = min; slider.max = max; slider.step = step; slider.disabled = false; }); const initialMin = Math.floor(min); const initialMax = Math.ceil(max); controls.tthMinSlider.value = initialMin; controls.tthMaxSlider.value = initialMax; controls.tthMinValue.textContent = initialMin.toFixed(2); controls.tthMaxValue.textContent = initialMax.toFixed(2); updateAndApplyBackground(); updatePlotRange(true); rescalePlot(false); } catch (error) { alert(`Error reading file: ${error.message}`); console.error(error); } }; reader.onerror = () => alert('Error reading file.'); reader.readAsText(file); });
        
        controls.fitButton.addEventListener('click', runLeBailFit);
        
        document.querySelector('.tab-buttons').addEventListener('click', (e) => { const clickedTab = e.target.closest('.tab-btn'); if (clickedTab && !clickedTab.disabled) { e.currentTarget.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active')); clickedTab.classList.add('active'); document.querySelectorAll('.tab-content-panel').forEach(panel => panel.classList.remove('active')); document.getElementById(`tab-panel-${clickedTab.dataset.tab}`).classList.add('active'); } });
        
        const resizer = document.getElementById('drag-handle'); const leftPanel = document.getElementById('controls-panel');
        resizer.addEventListener('mousedown', (e) => { e.preventDefault(); document.body.style.cursor = 'col-resize'; const moveHandler = (moveEvent) => { if (moveEvent.clientX > 350 && moveEvent.clientX < window.innerWidth - 350) leftPanel.style.width = `${moveEvent.clientX}px`; }; const upHandler = () => { document.body.style.cursor = 'default'; window.removeEventListener('mousemove', moveHandler); window.removeEventListener('mouseup', upHandler); }; window.addEventListener('mousemove', moveHandler); window.addEventListener('mouseup', upHandler); });
        
        // Use event delegation on the parent panel to capture events from dynamically created inputs
        const controlsPanel = document.getElementById('controls-panel');
        controlsPanel.addEventListener('input', (event) => {
            // Check if the event came from a control that should trigger a preview update
            if (event.target.matches('.control-input, .control-select, .fit-checkbox')) {
                // Exclude the 2-theta range sliders, as they have their own specific listeners
                if (event.target.type !== 'range') {
                    updatePreviewPattern();
                }
            }
        });
        
        controls.iterationsSlider.addEventListener('input', () => controls.iterationsValue.textContent = controls.iterationsSlider.value);
        
        controls.tthMinSlider.addEventListener('input', () => { let minVal = parseFloat(controls.tthMinSlider.value); let maxVal = parseFloat(controls.tthMaxSlider.value); if (minVal >= maxVal) { minVal = maxVal - parseFloat(controls.tthMinSlider.step); controls.tthMinSlider.value = minVal; } controls.tthMinValue.textContent = minVal.toFixed(2); workingDataCache.isValid = false; updatePlotRange(true); rescalePlot(false); updatePreviewPattern(); });
        
        controls.tthMaxSlider.addEventListener('input', () => { let minVal = parseFloat(controls.tthMinSlider.value); let maxVal = parseFloat(controls.tthMaxSlider.value); if (maxVal <= minVal) { maxVal = minVal + parseFloat(controls.tthMaxSlider.step); controls.tthMaxSlider.value = maxVal; } controls.tthMaxValue.textContent = maxVal.toFixed(2); workingDataCache.isValid = false; updatePlotRange(true); rescalePlot(false); updatePreviewPattern(); });
        
        controls.mainChartCanvas.addEventListener('wheel', e => { e.preventDefault(); const chart = mainChart; if (!chart || !chart.chartArea) return; const { left, right, top, bottom } = chart.chartArea; const x = e.offsetX, y = e.offsetY; const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9; if (y > bottom) chart.zoom({ x: zoomFactor }, {x, y}); else if (x < left) chart.zoom({ y: zoomFactor }, {x, y}); else if (x >= left && x <= right && y >= top && y <= bottom) chart.zoom({ x: zoomFactor, y: zoomFactor }, {x, y}); });
        
        controls.mainChartCanvas.addEventListener('contextmenu', e => { e.preventDefault(); if (mainChart) { mainChart.resetZoom(); rescalePlot(true); } });
        
        controls.ballRadiusSlider.addEventListener('input', () => { controls.ballRadiusValue.textContent = controls.ballRadiusSlider.value; updateAndApplyBackground(); });
        
        controls.smoothingWidthSlider.addEventListener('input', () => { controls.smoothingWidthValue.textContent = controls.smoothingWidthSlider.value; updateAndApplyBackground(); });
        
        controls.profileSelect.addEventListener('change', (e) => { const newProfile = e.target.value; saveProfileState(currentProfile); controls.simplePVoigtParamsContainer.classList.toggle('hidden', newProfile !== '4'); controls.anisotropyParamsContainer.classList.toggle('hidden', newProfile !== '3'); restoreProfileState(newProfile); currentProfile = newProfile; if (fullExperimentalData.tth.length > 0) updatePreviewPattern(); });
        
        // This now uses the new helper function
        controls.bravaisLattice.addEventListener('change', updateUIForSystemChange);
        
        controls.paramS400.addEventListener('input', updateStephensAnisotropyUI); controls.fitS400.addEventListener('change', updateStephensAnisotropyUI); controls.paramS220.addEventListener('input', updateStephensAnisotropyUI); controls.fitS220.addEventListener('change', updateStephensAnisotropyUI); controls.paramS202.addEventListener('input', updateStephensAnisotropyUI); controls.fitS202.addEventListener('change', updateStephensAnisotropyUI);
        
        controls.saveDataButton.addEventListener('click', () => { if (!fitResults) { alert("Please run a refinement before saving data."); return; } const originalText = controls.saveDataButton.textContent; controls.saveDataButton.textContent = 'Saving...'; controls.saveDataButton.disabled = true; try { const textContent = generateTextReportContent(); const timestamp = new Date().toISOString().slice(0, 16).replace(/[-:]/g, '').replace('T', '_'); downloadTextFile(textContent, `LeBail-Data-${timestamp}.txt`); } catch (error) { console.error("Failed to save data:", error); alert("An error occurred while saving the data file."); } finally { controls.saveDataButton.textContent = 'Save Report'; controls.saveDataButton.disabled = false; } });
        
controls.reportButton.addEventListener('click', async () => { 
            if (!fitResults || typeof fitResults.params !== 'object' || fitResults.params === null) { 
                alert("Cannot generate report: Fit results are missing or invalid."); 
                return; 
            } 
            const originalText = controls.reportButton.textContent; 
            controls.reportButton.textContent = 'Generating...'; 
            controls.reportButton.disabled = true; 
            try { 
                if (typeof window.jspdf === 'undefined' || !window.jspdf.jsPDF) throw new Error('jsPDF library is not loaded properly'); 
                const now = new Date(); 
                const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}`; 
                const baseFilename = `LeBail-Report-${timestamp}`; 
                const { jsPDF } = window.jspdf; 
                const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' }); 
                const margin = 15; 
                const pageWidth = doc.internal.pageSize.getWidth(); 
                const pageHeight = doc.internal.pageSize.getHeight(); 
                const contentWidth = pageWidth - 2 * margin; 
                doc.setFontSize(18); 
                doc.text('Le Bail Refinement Report', pageWidth/2, 15, { align: 'center' }); 
                doc.setFontSize(10); 
                doc.text(`Report Generated: ${now.toLocaleString()}`, margin, 25); 
                doc.text(`Data File: ${controls.fileName.textContent}`, margin, 30); 
                try { 
                    if (controls.mainChartCanvas && typeof html2canvas !== 'undefined') { 
                        const chartCanvas = await html2canvas(controls.mainChartCanvas, { backgroundColor: '#ffffff', scale: 1, logging: false }); 
                        const mainImgData = chartCanvas.toDataURL('image/png'); 
                        const mainImgProps = doc.getImageProperties(mainImgData); 
                        const mainImgHeight = Math.min((mainImgProps.height * contentWidth) / mainImgProps.width, 150); 
                        doc.addImage(mainImgData, 'PNG', margin, 40, contentWidth, mainImgHeight); 
                    } else { 
                        doc.setFontSize(12); 
                        doc.text('Chart capture not available', margin, 50); 
                    } 
                } catch (chartError) { 
                    console.warn('Chart capture failed:', chartError); 
                    doc.setFontSize(12); doc.text('Chart capture failed', margin, 50); 
                } 
                doc.addPage(); 
                let yPos = 20; 
                const finalParams = { ...fitResults.params }; 
                const fitFlags = fitResults.fitFlags; 
                const addText = (text, fontSize = 9, isBold = false, font = 'Helvetica') => { if (yPos > pageHeight - 20) { doc.addPage(); yPos = 20; } doc.setFont(font, isBold ? 'bold' : 'normal'); doc.setFontSize(fontSize); doc.text(text, margin, yPos); yPos += fontSize * 0.5 + 1; }; 
                const addHeader = (text) => { yPos += 4; addText(text, 14, true); yPos += 2; }; 
                let esds = {}; 
                let esdWarning = null; 
                if (fitResults.algorithm === 'lm' && fitResults.JtJ) { 
                    const workingDataForStats = getWorkingData(); 
                    const N = workingDataForStats.intensity.length; 
                    const P = fitResults.paramMapping.length; 
                    if (N > P && fitResults.ss_res !== undefined) { 
                        const reduced_chi_sq = fitResults.ss_res / (N - P); 
                        const cov_matrix = matrixInverse(fitResults.JtJ); 
                        if (cov_matrix) { 
                            fitResults.paramMapping.forEach((p, i) => { if (cov_matrix[i] && cov_matrix[i][i] !== undefined) esds[p.name] = Math.sqrt(Math.abs(reduced_chi_sq * cov_matrix[i][i])); }); 
                        } else { 
                            esdWarning = 'ESD calculation failed (unstable refinement).'; 
                        } 
                    } 
                } 
                addHeader('Refinement Statistics'); 
                addText(`Rp (%): ${fitResults.stats.r_p.toFixed(2)}`); 
                addText(`Rwp (%): ${fitResults.stats.rwp.toFixed(2)}`); 
                addText(`Chi² (GOF): ${fitResults.stats.chi2.toFixed(3)}`); 
                addText(`Algorithm: ${fitResults.algorithm === 'lm' ? 'Levenberg-Marquardt' : 'Simulated Annealing'}`); 
                
                // This block determines the correct profile name
                const profileName = finalParams.profileType === "4"
                    ? "Simple pVoigt"
                    : "TCH w/ Anisotropy";
                addText(`Profile: ${profileName} (#${finalParams.profileType})`); 

                if (esdWarning) addText(esdWarning, 8); 
                addHeader('Structural & Instrumental Parameters'); 
                const allParams = [ { name: 'a (Å)', value: finalParams.a, flag: fitFlags.a, esd_name: 'a' }, { name: 'b (Å)', value: finalParams.b, flag: fitFlags.b, esd_name: 'b' }, { name: 'c (Å)', value: finalParams.c, flag: fitFlags.c, esd_name: 'c' }, { name: 'alpha (°)', value: finalParams.alpha, flag: fitFlags.alpha, esd_name: 'alpha' }, { name: 'beta (°)', value: finalParams.beta, flag: fitFlags.beta, esd_name: 'beta' }, { name: 'gamma (°)', value: finalParams.gamma, flag: fitFlags.gamma, esd_name: 'gamma' }, { name: 'Radiation (Å)', value: finalParams.lambda, flag: false, esd_name: null }, { name: 'Zero Shift (°)', value: finalParams.zeroShift, flag: fitFlags.zeroShift, esd_name: 'zeroShift' }, ]; 
                if (finalParams.profileType === "4") { allParams.push( { name: 'GU', value: finalParams.GU, flag: fitFlags.GU, esd_name: 'GU' }, { name: 'GV', value: finalParams.GV, flag: fitFlags.GV, esd_name: 'GV' }, { name: 'GW', value: finalParams.GW, flag: fitFlags.GW, esd_name: 'GW' }, { name: 'GP', value: finalParams.GP, flag: fitFlags.GP, esd_name: 'GP' }, { name: 'LX', value: finalParams.LX, flag: fitFlags.LX, esd_name: 'LX' }, { name: 'eta', value: finalParams.eta, flag: fitFlags.eta, esd_name: 'eta' }, { name: 'shft', value: finalParams.shft, flag: fitFlags.shft, esd_name: 'shft' }, { name: 'trns', value: finalParams.trns, flag: fitFlags.trns, esd_name: 'trns' } ); } 
                else { allParams.push( { name: 'U', value: finalParams.U, flag: fitFlags.U, esd_name: 'U' }, { name: 'V', value: finalParams.V, flag: fitFlags.V, esd_name: 'V' }, { name: 'W', value: finalParams.W, flag: fitFlags.W, esd_name: 'W' }, { name: 'X', value: finalParams.X, flag: fitFlags.X, esd_name: 'X' }, { name: 'Y', value: finalParams.Y, flag: fitFlags.Y, esd_name: 'Y' }, { name: 'S/L', value: finalParams.SL, flag: fitFlags.SL, esd_name: 'SL' }, { name: 'H/L', value: finalParams.HL, flag: fitFlags.HL, esd_name: 'HL' } ); if (finalParams.profileType === "3") { allParams.push( { name: 'S400', value: finalParams.S400, flag: fitFlags.S400, esd_name: 'S400' }, { name: 'S040', value: finalParams.S040, flag: fitFlags.S040, esd_name: 'S040' }, { name: 'S004', value: finalParams.S004, flag: fitFlags.S004, esd_name: 'S004' }, { name: 'S220', value: finalParams.S220, flag: fitFlags.S220, esd_name: 'S220' }, { name: 'S202', value: finalParams.S202, flag: fitFlags.S202, esd_name: 'S202' }, { name: 'S022', value: finalParams.S022, flag: fitFlags.S022, esd_name: 'S022' } ); } } 
                const selectedOption = controls.bravaisLattice.options[controls.bravaisLattice.selectedIndex]; 
                addText(`System: ${selectedOption.text}`, 9, false, 'Courier'); 
                yPos += 2; 
                const header = 'Parameter'.padEnd(20) + 'Value'.padStart(15) + 'Fitted'.padStart(8) + 'ESD'.padStart(15); 
                addText(header, 8, true, 'Courier'); 
                addText('-'.repeat(header.length), 8, false, 'Courier'); 
                allParams.forEach(p => { if (p.value !== undefined && p.value !== null && !isNaN(p.value)) { const nameStr = p.name.padEnd(20); const valStr = p.value.toExponential(6).padStart(15); const fitStr = (p.flag === undefined ? ' ' : (p.flag ? 'Yes' : 'No')).padStart(8); const esdStr = (p.flag && esds[p.esd_name]) ? `(${esds[p.esd_name].toExponential(2)})`.padStart(15) : '-'.padStart(15); addText(`${nameStr}${valStr}${fitStr}${esdStr}`, 8, false, 'Courier'); } }); 
                doc.addPage(); 
                yPos = 20; 
                addHeader('Peak List (Top 20 Reflections)'); 
                const hklListForReport = generateHKL(Math.max(...fullExperimentalData.tth), finalParams, getSystemAndCentering().system, getSystemAndCentering().centering); 
                leBailIntensityExtraction({ tth: fullExperimentalData.tth, intensity: fullExperimentalData.intensity, background: calculatedBackground }, hklListForReport, finalParams); 
                const reflectionsForPdf = hklListForReport.map(hkl => { const peakShift = calculatePeakShift(hkl.tth, finalParams); const tthCorr = hkl.tth + finalParams.zeroShift + peakShift; const { gamma_G, gamma_L } = calculateProfileWidths(hkl.tth, hkl, finalParams); const fwhm = gamma_G + gamma_L; const i_exp = getIntegratedIntensity(tthCorr, fwhm, fullExperimentalData, calculatedBackground); return { i_calc_norm: hkl.intensity, i_exp: i_exp, hkl_string: hkl.hkl_list[0], d: hkl.d, tthCorr: tthCorr }; }); 
                const i_calc_norm_values = reflectionsForPdf.map(i => i.i_calc_norm); 
                const i_exp_values = reflectionsForPdf.map(i => i.i_exp); 
                const sum_exp_calc = dot(i_exp_values, i_calc_norm_values); 
                const sum_calc_sq = dot(i_calc_norm_values, i_calc_norm_values); 
                const intensityScaleFactor = (sum_calc_sq > 1e-9) ? sum_exp_calc / sum_calc_sq : 1.0; 
                const topPeaks = reflectionsForPdf.sort((a, b) => b.i_calc_norm - a.i_calc_norm).slice(0, 20); 
                const peakListHeader = 'HKL         2-theta(°)  d(Å)      I_calc      I_exp'; 
                addText(peakListHeader, 8, true, 'Courier'); 
                addText('-'.repeat(peakListHeader.length + 2), 8, false, 'Courier'); 
                topPeaks.forEach(peak => { const final_i_calc = peak.i_calc_norm * intensityScaleFactor; const line = `${peak.hkl_string.padEnd(12)}${peak.tthCorr.toFixed(3).padStart(10)}${peak.d.toFixed(4).padStart(8)}${final_i_calc.toFixed(1).padStart(10)}${peak.i_exp.toFixed(1).padStart(10)}`; addText(line, 8, false, 'Courier'); }); 
                doc.save(`${baseFilename}.pdf`); 
            } catch (error) { 
                console.error("Failed to generate report:", error); 
                alert(`An error occurred while generating the report: ${error.message}`); 
            } finally { 
                controls.reportButton.textContent = 'Generate PDF'; 
                controls.reportButton.disabled = false; 
            } 
        });
        // Initial UI setup on page load
        updateUIForSystemChange();
    });

</script>


</body>
</html>