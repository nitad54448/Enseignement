<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Le Bail Fit (GSAS Profile 4)</title>
    <link href="./dist/output.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        /* Custom Slider Style with Inline Value */
        .slider-group {
            margin-bottom: 1.25rem;
        }
        .slider-value-track {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
            align-items: center;
        }
        .slider-value-track > * {
            grid-column: 1;
            grid-row: 1;
        }
        .slider-value-display {
            text-align: center;
            color: #d1d5db;
            font-weight: 500;
            font-size: 0.875rem;
            pointer-events: none; /* Allows clicking through the text to the slider */
        }
        input[type="range"].custom-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 36px; /* Make track taller to contain the text */
            background: #374151;
            border-radius: 8px;
            outline: none;
            padding: 0;
            margin: 0;
        }
        input[type="range"].custom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #3b82f6; /* Blue handle */
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid #111827;
            box-sizing: border-box;
        }
        input[type="range"].custom-slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #3b82f6; /* Blue handle */
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid #111827;
            box-sizing: border-box
        }
        input[type="range"].custom-slider:disabled {
            background: #272f3d;
        }
        input[type="range"].custom-slider:disabled::-webkit-slider-thumb {
            background: #6b7280;
        }
        input[type="range"].custom-slider:disabled::-moz-range-thumb {
            background: #6b7280;
        }

        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f9fafb; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #app-container { display: flex; width: 100%; flex-grow: 1; min-height: 0; }
        #controls-panel { width: 450px; min-width: 350px; max-width: 600px; flex-shrink: 0; padding: 24px; background-color: #111827; border-right: 1px solid #374151; overflow-y: auto; color: #d1d5db; display: flex; flex-direction: column; }
        #drag-handle { width: 6px; cursor: col-resize; background-color: #374151; flex-shrink: 0; transition: background-color 0.2s; }
        #drag-handle:hover, #drag-handle:active { background-color: #3b82f6; }
        #results-area { flex-grow: 1; position: relative; background-color: #ffffff; min-width: 0; display: flex; flex-direction: column; padding: 1.5rem; color: #1f2937; }
        .control-group { margin-bottom: 1.5rem; padding-top: 1.5rem; border-top: 1px solid #374151;}
        .control-group:first-child { border-top: none; padding-top: 0; }
        .control-label { display: block; margin-bottom: 8px; font-weight: 500; color: #9ca3af; font-size: 0.875rem; }
        .control-input, .control-select { width: 100%; background-color: #374151; border: 1px solid #4b5563; color: #e5e7eb; border-radius: 0.375rem; padding: 0.5rem 0.75rem; transition: all 0.2s ease; }
        .control-input:focus, .control-select:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4); }
        .control-input:disabled { background-color: #272f3d; cursor: not-allowed; }
        .btn { padding: 0.5rem 1rem; border-radius: 0.375rem; font-weight: 600; transition: background-color 0.2s; cursor: pointer; border: none; }
        .btn-primary { background-color: #3b82f6; color: white; }
        .btn-primary:hover:not(:disabled) { background-color: #2563eb; }
        .btn-secondary { background-color: #4b5563; color: white; }
        .btn-secondary:hover:not(:disabled) { background-color: #6b7280; }
        .btn:disabled { background-color: #4b5563; cursor: not-allowed; opacity: 0.7; }
        .file-input-label { display: block; padding: 0.75rem 1rem; background-color: #4b5563; color: #d1d5db; border-radius: 0.375rem; text-align: center; cursor: pointer; transition: background-color 0.2s;}
        .file-input-label:hover { background-color: #6b7280; }
        .parameter-grid-3col { display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: 0.75rem; }
        .results-grid { display: grid; grid-template-columns: repeat(3, minmax(90px, 1fr)); gap: 0.75rem; }
        .result-card { background-color: #1f2937; padding: 0.5rem; border-radius: 0.5rem; text-align: center; transition: background 0.1s linear; }
        .result-card-label { font-size: 0.75rem; color: #9ca3af; }
        .result-card-value { font-size: 1.0rem; font-weight: 600; color: #e5e7eb; }
        .fit-checkbox { -webkit-appearance: none; appearance: none; background-color: #4b5563; width: 1.25rem; height: 1.25rem; border: 1px solid #6b7280; border-radius: 0.25rem; cursor: pointer; display: inline-block; position: relative; }
        .fit-checkbox:checked { background-color: #3b82f6; border-color: #3b82f6; }
        .fit-checkbox:checked::after { content: '✓'; color: white; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-size: 0.9rem; }
        .tab-nav { display: flex; border-bottom: 1px solid #374151; margin-bottom: 1.5rem; }
        .tab-button { padding: 0.75rem 1.25rem; cursor: pointer; border: none; background: none; color: #9ca3af; font-weight: 500; border-bottom: 2px solid transparent; transition: all 0.2s; }
        .tab-button.active { color: #e5e7eb; border-bottom-color: #3b82f6; }
        .tab-panel { display: none; }
        .tab-panel.active { display: block; }
        .profile-section-header { color: #9ca3af; font-weight: 600; margin-top: 1rem; margin-bottom: 0.5rem; grid-column: 1 / -1; }
        .chart-container { flex-grow: 1; position: relative; }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">
            <h1 class="text-2xl font-bold text-white mb-2">Le Bail Fitting</h1>
            <p class="text-sm text-gray-400 mb-6">Refine lattice parameters using global or local optimization.<br>Click and drag the plot, use the wheel to zoom (the zoom is axis-sensitive) or right-click to reset.
            </p>
            
            <div class="control-group">
                <h2 class="text-lg font-semibold text-white mb-3">Load Data</h2>
                <label for="file-input" class="file-input-label">
                    <span id="file-name">Select .xy, .csv or .xrdml File</span>
                </label>
                <input type="file" id="file-input" class="hidden" accept=".xy,.csv,.txt,.xrdml">
            </div>

            <div class="tab-nav">
                <button class="tab-button active" data-tab="sample">Sample & Instrument</button>
                <button class="tab-button" data-tab="background">Background</button>
                <button class="tab-button" data-tab="profile">Profile</button>
            </div>

            <div id="tab-content" class="flex-grow">
                <div id="tab-panel-sample" class="tab-panel active">
                    <div class="control-group">
                        <h2 class="text-lg font-semibold text-white mb-3">Structural Parameters</h2>
                        <div class="parameter-grid-3col">
                            <label for="bravais-lattice" class="control-label">System</label>
                            <select id="bravais-lattice" class="control-select col-span-2">
                                <option value="cubic_F" selected>Cubic (F)</option>
                                <option value="cubic_I">Cubic (I)</option>
                                <option value="cubic_P">Cubic (P)</option>
                                <option value="hexagonal_P">Hexagonal (P)</option>
                                <option value="hexagonal_R">Trigonal (R, Hex. axes)</option>
                                <option value="rhombohedral_P">Rhombohedral (Rhom. axes)</option>
                                <option value="tetragonal_I">Tetragonal (I)</option>
                                <option value="tetragonal_P">Tetragonal (P)</option>
                                <option value="orthorhombic_F">Orthorhombic (F)</option>
                                <option value="orthorhombic_I">Orthorhombic (I)</option>
                                <option value="orthorhombic_C">Orthorhombic (C)</option>
                                <option value="orthorhombic_P">Orthorhombic (P)</option>
                                <option value="monoclinic_C">Monoclinic (C)</option>
                                <option value="monoclinic_P">Monoclinic (P)</option>
                            </select>
                        </div>
                        <div id="lattice-parameters-container" class="parameter-grid-3col mt-4">
                        </div>
                    </div>
                    <div class="control-group">
                        <h2 class="text-lg font-semibold text-white mb-3">Instrumental Parameters</h2>
                        <div class="parameter-grid-3col">
                            <label for="zero-shift" class="control-label">Zero (°)</label>
                            <input type="number" id="zero-shift" value="0.0" step="0.001" class="control-input">
                            <input type="checkbox" id="fit-zero-shift" class="fit-checkbox" title="Fit this parameter" checked>
                        </div>
                         <label for="wavelength" class="control-label mt-4">Wavelength (Å)</label>
                        <div class="flex items-center space-x-2">
                            <input type="number" id="wavelength" value="1.54056" step="0.0001" class="control-input" min="0.01">
                            <select id="wavelength-preset" class="control-select w-auto pr-8">
                                <option value="1.54056">Cu Kα1</option>
                                <option value="1.5418">Cu Kα (avg)</option>
                                <option value="0.70930">Mo Kα1</option>
                                <option value="1.78897">Co Kα1</option>
                                <option value="custom" style="display: none;">User</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="tab-panel-background" class="tab-panel">
                    <div class="control-group">
                        <h2 class="text-lg font-semibold text-white mb-3">Background Parameters</h2>
                        <p class="text-xs text-gray-400 mb-4">Hybrid background: Chebyshev polynomial + inverse term for low-angle rise.</p>
                        <p class="text-xs text-yellow-400 bg-yellow-900/50 p-2 rounded-md mb-4">For complex backgrounds, enable the B-1 term and/or higher-order Chebyshev terms (B3, B4, etc.).</p>
                        <div id="background-controls-container" class="parameter-grid-3col">
                        </div>
                    </div>

<div class="control-group">
    <h2 class="text-lg font-semibold text-white mb-3">Background Weighting</h2>
    <p class="text-xs text-gray-400 mb-4">Increase the weight of data points far from reflections. A weight factor of 1 applies no extra weighting.</p>
    <div class="slider-group">
        <label class="control-label">Weight Factor</label>
        <div class="slider-value-track">
           <input type="range" id="bg-weight-factor-slider" min="1" max="20" value="1" step="1" class="custom-slider">
           <span id="bg-weight-factor-value" class="slider-value-display">1</span>
        </div>
    </div>
    <div class="slider-group">
        <label class="control-label">FWHM Widths</label>
        <div class="slider-value-track">
           <input type="range" id="fwhm-widths-slider" min="1.0" max="20.0" value="5.0" step="0.1" class="custom-slider">
           <span id="fwhm-widths-value" class="slider-value-display">5.0</span>
        </div>
    </div>
</div>

                </div>


                <div id="tab-panel-profile" class="tab-panel">
                     <div class="control-group">
                        <h2 class="text-lg font-semibold text-white mb-3">Peak Profile (GSAS Type 4)</h2>
                        <div id="profile-controls-container" class="parameter-grid-3col">
                            <h3 class="profile-section-header">Gaussian Broadening</h3>
                            <label class="control-label">GU</label>
                            <input type="number" id="param-gu" value="10" step="1" class="control-input" min="0">
                            <input type="checkbox" id="fit-gu" class="fit-checkbox" checked>
                            <label class="control-label">GV</label>
                            <input type="number" id="param-gv" value="-5" step="1" class="control-input">
                            <input type="checkbox" id="fit-gv" class="fit-checkbox" checked>
                            <label class="control-label">GW</label>
                            <input type="number" id="param-gw" value="5" step="1" class="control-input" min="0">
                            <input type="checkbox" id="fit-gw" class="fit-checkbox" checked>
                             <label class="control-label">GP</label>
                            <input type="number" id="param-gp" value="0" step="0.1" class="control-input">
                            <input type="checkbox" id="fit-gp" class="fit-checkbox">

                            <h3 class="profile-section-header">Lorentzian Broadening</h3>
                            <label class="control-label">LX</label>
                            <input type="number" id="param-lx" value="1" step="0.1" class="control-input" min="0">
                            <input type="checkbox" id="fit-lx" class="fit-checkbox" checked>

                             <h3 class="profile-section-header">Peak Shape & Position</h3>
                             <label class="control-label">eta (Mixing)</label>
                            <input type="number" id="param-eta" value="0.5" step="0.01" min="0" max="1" class="control-input">
                            <input type="checkbox" id="fit-eta" class="fit-checkbox">
                             <label class="control-label">shft (Displ.)</label>
                            <input type="number" id="param-shft" value="0" step="0.01" class="control-input">
                            <input type="checkbox" id="fit-shft" class="fit-checkbox" checked>
                             <label class="control-label">trns (Transp.)</label>
                            <input type="number" id="param-trns" value="0" step="0.01" class="control-input">
                            <input type="checkbox" id="fit-trns" class="fit-checkbox">


                        </div>
                    </div>
                </div>
            </div>

            <div class="mt-auto pt-4"> 
                 <div class="control-group">
                     <h2 class="text-lg font-semibold text-white mb-3">Refinement</h2>
                     
                     <label for="algorithm-select" class="control-label">Algorithm</label>
                     <select id="algorithm-select" class="control-select mb-4">
                        <option value="lm">Levenberg-Marquardt</option>
                        <option value="sa" selected>Simulated Annealing</option>
                     </select>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Min</label>
                         <div class="slider-value-track">
                            <input type="range" id="tth-min-slider" class="custom-slider" disabled>
                            <span id="tth-min-value" class="slider-value-display">10.0</span>
                         </div>
                     </div>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Max</label>
                         <div class="slider-value-track">
                             <input type="range" id="tth-max-slider" class="custom-slider" disabled>
                             <span id="tth-max-value" class="slider-value-display">80.0</span>
                         </div>
                     </div>

                     <div class="slider-group">
                         <label class="control-label">Max Iterations</label>
                         <div class="slider-value-track">
                            <input type="range" id="iterations-slider" min="2" max="200" value="120" step="1" class="custom-slider">
                            <span id="iterations-value" class="slider-value-display">120</span>
                         </div>
                     </div>

                     <div id="progress-bar-container" class="w-full bg-gray-700 rounded-full h-2.5 mt-4 hidden">
                        <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                     </div>
                     <div class="results-grid mt-4">
                        <div class="result-card">
                            <div class="result-card-label">Rp (%)</div>
                            <div id="rp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">Rwp (%)</div>
                            <div id="rwp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">χ² (GOF)</div>
                            <div id="chi2-result" class="result-card-value">-</div>
                        </div>
                     </div>
                </div>
                <div class="flex flex-col space-y-2">
                    <button id="fit-button" class="btn btn-primary w-full text-lg" disabled>Load Data to Start Fit</button>
                    <div class="flex space-x-2">
                        <button id="save-data-button" class="btn btn-secondary w-full text-lg" disabled>Save Data</button>
                        <button id="report-button" class="btn btn-secondary w-full text-lg" disabled>Report</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="results-area">
             <div id="placeholder" class="w-full h-full flex flex-col items-center justify-center text-center text-gray-500">
                <svg xmlns="http://www.w3.org/2000/svg" class="w-16 h-16 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                <h2 class="text-2xl font-semibold">Awaiting Data</h2>
                <p>Load a data file to begin.</p>
            </div>

            <div id="results-container" class="w-full h-full flex-col hidden relative">
                <div id="main-chart-container" class="chart-container">
                    <canvas id="main-chart"></canvas>
                </div>
            </div>

            <div class="absolute bottom-2 right-4 text-xs text-gray-400">
                NitaD, Univ Paris-Saclay, 14 Sept 2025
            </div>
        </div>
    </div>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- UI Elements ---
        const controls = {
            fileInput: document.getElementById('file-input'),
            fileName: document.getElementById('file-name'),
            bravaisLattice: document.getElementById('bravais-lattice'),
            latticeParamsContainer: document.getElementById('lattice-parameters-container'),
            wavelength: document.getElementById('wavelength'),
            wavelengthPreset: document.getElementById('wavelength-preset'),
            zeroShift: document.getElementById('zero-shift'),
            fitZeroShift: document.getElementById('fit-zero-shift'),
            paramGU: document.getElementById('param-gu'), fitGU: document.getElementById('fit-gu'),
            paramGV: document.getElementById('param-gv'), fitGV: document.getElementById('fit-gv'),
            paramGW: document.getElementById('param-gw'), fitGW: document.getElementById('fit-gw'),
            paramGP: document.getElementById('param-gp'), fitGP: document.getElementById('fit-gp'),
            paramLX: document.getElementById('param-lx'), fitLX: document.getElementById('fit-lx'),
            paramEta: document.getElementById('param-eta'), fitEta: document.getElementById('fit-eta'),
            paramShft: document.getElementById('param-shft'), fitShft: document.getElementById('fit-shft'),
            paramTrns: document.getElementById('param-trns'), fitTrns: document.getElementById('fit-trns'),
            algorithmSelect: document.getElementById('algorithm-select'),
            iterationsSlider: document.getElementById('iterations-slider'),
            iterationsValue: document.getElementById('iterations-value'),
            tthMinSlider: document.getElementById('tth-min-slider'),
            tthMinValue: document.getElementById('tth-min-value'),
            tthMaxSlider: document.getElementById('tth-max-slider'),
            tthMaxValue: document.getElementById('tth-max-value'),
            fitButton: document.getElementById('fit-button'),
            reportButton: document.getElementById('report-button'),
            saveDataButton: document.getElementById('save-data-button'),
            progressBar: document.getElementById('progress-bar'),
            progressBarContainer: document.getElementById('progress-bar-container'),
            rpResult: document.getElementById('rp-result'),
            rwpResult: document.getElementById('rwp-result'),
            chi2Result: document.getElementById('chi2-result'),
            mainChartCanvas: document.getElementById('main-chart'),
            placeholder: document.getElementById('placeholder'),
            resultsContainer: document.getElementById('results-container'),
            backgroundContainer: document.getElementById('background-controls-container'),
            fwhmWidthsSlider: document.getElementById('fwhm-widths-slider'),
            fwhmWidthsValue: document.getElementById('fwhm-widths-value'),
            bgWeightFactorSlider: document.getElementById('bg-weight-factor-slider'),
            bgWeightFactorValue: document.getElementById('bg-weight-factor-value'),
        };

        // --- Global State ---
        const NUM_BG_ANCHOR_POINTS = 5; // number of points for background anchor
        let fullExperimentalData = { tth: [], intensity: [] };
        let fitResults = null;
        let mainChart;
        let isFitting = false;
        let lastGeneratedHklList = []; 
        let lastRawDifference = [];
        const NUM_BG_TERMS = 10;
        
 
        // --- plugin .. ligne verticlae
        const verticalCursorLine = {
            id: 'verticalCursorLine',
            afterDraw: chart => {
                // draw the line when the tooltip is active
                if (chart.tooltip?._active?.length) {
                    let x = chart.tooltip._active[0].element.x;
                    let yAxis = chart.scales.y;
                    let ctx = chart.ctx;
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(x, yAxis.top);
                    ctx.lineTo(x, yAxis.bottom);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)'; // trop gris ? 
                    ctx.setLineDash([4, 4]); // dashed
                    ctx.stroke();
                    ctx.restore();
                }
            }
        };
        Chart.register(verticalCursorLine);
        // --- 


        // --- TOOLTIP indications de position

        Chart.Tooltip.positioners.experimentalAnchor = function(items) {
            // "items" is an array of all data points at the cursor's x-position
            if (!items.length) {
                return false;
            }
            
            // Find the item corresponding to the 'Experimental' dataset (which is the first one, datasetIndex: 0)
            const experimentalItem = items.find(item => item.datasetIndex === 0);

            // If we found it, use its coordinates. Otherwise, fall back to the first available item.
            const anchorPoint = experimentalItem || items[0];

            return {
                x: anchorPoint.element.x,
                y: anchorPoint.element.y
            };
        };
        // --- 

        function getSystemAndCentering() {
            const value = controls.bravaisLattice.value; // e.g., "cubic_P"
            const [system, centering] = value.split('_');
            return { system, centering };
        }

        function updateLatticeParamUI() {
            const { system } = getSystemAndCentering();
            const container = controls.latticeParamsContainer;
            container.innerHTML = '';

            const createInput = (name, label, value, step, isAngle = false) => {
                const id_base = `lattice-param-${name}`;
                const unit = isAngle ? '°' : 'Å';
                const minAttribute = isAngle ? '' : 'min="0.001"';
                container.innerHTML += `
                    <label for="${id_base}" class="control-label">${label} (${unit})</label>
                    <input type="number" id="${id_base}" value="${value}" step="${step}" class="control-input" ${minAttribute}>
                    <input type="checkbox" id="fit-lattice-${name}" class="fit-checkbox" title="Fit this parameter" checked>
                `;
            };

            const params = {
                cubic: [{ name: 'a', label: 'a', value: 4.08, step: 0.001 }],
                tetragonal: [
                    { name: 'a', label: 'a', value: 4.0, step: 0.001 },
                    { name: 'c', label: 'c', value: 5.0, step: 0.001 }
                ],
                orthorhombic: [
                    { name: 'a', label: 'a', value: 4.0, step: 0.001 },
                    { name: 'b', label: 'b', value: 5.0, step: 0.001 },
                    { name: 'c', label: 'c', value: 6.0, step: 0.001 }
                ],
                hexagonal: [
                    { name: 'a', label: 'a', value: 4.0, step: 0.001 },
                    { name: 'c', label: 'c', value: 6.0, step: 0.001 }
                ],
                rhombohedral: [
                    { name: 'a', label: 'a', value: 5.0, step: 0.001 },
                    { name: 'alpha', label: 'α', value: 60.0, step: 0.01, isAngle: true }
                ],
                monoclinic: [
                    { name: 'a', label: 'a', value: 4.0, step: 0.001 },
                    { name: 'b', label: 'b', value: 5.0, step: 0.001 },
                    { name: 'c', label: 'c', value: 6.0, step: 0.001 },
                    { name: 'beta', label: 'β', value: 105.0, step: 0.01, isAngle: true }
                ]
            };
            
            if(params[system]) {
                params[system].forEach(p => createInput(p.name, p.label, p.value, p.step, p.isAngle));
            }
        }

        function parseDataFile(text) {
            const lines = text.trim().split(/\r?\n/);
            const tth = [], intensity = [];
            for (let line of lines) {
                if (line.startsWith('#') || line.startsWith('//') || isNaN(parseFloat(line.trim().split(/[\s,;]+/)[0]))) continue;
                const parts = line.trim().split(/[\s,;]+/);
                if (parts.length >= 2) {
                    const x = parseFloat(parts[0]);
                    const y = parseFloat(parts[1]);
                    if (!isNaN(x) && !isNaN(y)) {
                        tth.push(x);
                        intensity.push(y);
                    }
                }
            }
            return { tth, intensity };
        }

        function parseXrdmlFile(xmlString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");

            const parserError = xmlDoc.querySelector("parsererror");
            if (parserError) {
                console.error("Error parsing XRDML file:", parserError.textContent);
                return null;
            }

            let wavelength = 1.5406;
            const kAlpha1Node = xmlDoc.querySelector("kAlpha1");
            if (kAlpha1Node && kAlpha1Node.textContent) {
                const parsedWavelength = parseFloat(kAlpha1Node.textContent);
                if (!isNaN(parsedWavelength)) wavelength = parsedWavelength;
            }

            let intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts");
            if (!intensityNode) {
                console.error("Could not find <intensities> or <counts> tag in XRDML file.");
                return null;
            }
            const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number);
            const numPoints = intensity.length;
            if (numPoints === 0) {
                console.error("No intensity data points found.");
                return null;
            }

            let tth = [];
            const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]');
            if (!positionsNode) {
                console.error("Could not find <positions axis=\"2Theta\"> tag in XRDML file.");
                return null;
            }

            const startPosNode = positionsNode.querySelector("startPosition");
            const endPosNode = positionsNode.querySelector("endPosition");

            if (startPosNode && endPosNode) {
                const startPos = parseFloat(startPosNode.textContent);
                const endPos = parseFloat(endPosNode.textContent);
                if (!isNaN(startPos) && !isNaN(endPos) && numPoints > 1) {
                    const step = (endPos - startPos) / (numPoints - 1);
                    tth = Array.from({ length: numPoints }, (_, i) => startPos + i * step);
                } else if (numPoints === 1 && !isNaN(startPos)) {
                    tth = [startPos];
                } else {
                    console.error("Invalid start/end positions for 2-theta axis.");
                    return null;
                }
            } else {
                const listPositions = positionsNode.textContent.trim().split(/\s+/).map(Number).filter(n => !isNaN(n));
                if (listPositions.length === numPoints) {
                    tth = listPositions;
                } else {
                    console.error("Mismatch between number of intensity points and explicit 2-theta positions.");
                    return null;
                }
            }
            
            if (tth.length !== intensity.length) {
                console.error("Final mismatch between 2-theta and intensity data points.");
                return null;
            }

            return { tth, intensity, wavelength };
        }

        function getWorkingData() {
            if (fullExperimentalData.tth.length === 0) return { tth: [], intensity: [] };
            const minTth = parseFloat(controls.tthMinSlider.value);
            const maxTth = parseFloat(controls.tthMaxSlider.value);
            const startIndex = fullExperimentalData.tth.findIndex(t => t >= minTth);
            let endIndex = fullExperimentalData.tth.findIndex(t => t > maxTth);
            if (endIndex === -1) endIndex = fullExperimentalData.tth.length;
            return {
                tth: fullExperimentalData.tth.slice(startIndex, endIndex),
                intensity: fullExperimentalData.intensity.slice(startIndex, endIndex)
            };
        }
        

/**
         * Finds the 2-theta value of the maximum experimental intensity within a search window.
         * @param {number} targetTth - The theoretical 2-theta position to search around.
         * @param {object} experimentalData - The object containing the full {tth, intensity} arrays.
         * @param {number} wavelength - The wavelength in Angstroms.
         * @param {number} searchWindow - The +/- 2-theta range to search within.
         * @returns {object} - An object with {tth_exp, d_exp} or {tth_exp: null, d_exp: null} if not found.
         */
        function findExperimentalPeakDetails(targetTth, experimentalData, wavelength, searchWindow = 0.5) {
            if (!experimentalData || experimentalData.tth.length === 0) {
                return { tth_exp: null, d_exp: null };
            }

            const minTth = targetTth - searchWindow;
            const maxTth = targetTth + searchWindow;
            
            let maxIntensity = -Infinity;
            let tth_exp = null;

            for (let i = 0; i < experimentalData.tth.length; i++) {
                const tth = experimentalData.tth[i];
                if (tth >= minTth && tth <= maxTth) {
                    if (experimentalData.intensity[i] > maxIntensity) {
                        maxIntensity = experimentalData.intensity[i];
                        tth_exp = tth;
                    }
                }
            }

            if (tth_exp !== null) {
                // Convert degrees to radians for Math.sin()
                const theta_rad = tth_exp * (Math.PI / 180) / 2;
                const d_exp = wavelength / (2 * Math.sin(theta_rad));
                return { tth_exp: tth_exp, d_exp: d_exp };
            }

            return { tth_exp: null, d_exp: null };
        }



/**
         * The crystallographic "ledger" .
         * Takes h, k, l indices and the crystal system, and returns the
         * canonical (conventional) representation and the correct multiplicity.
         */
        function getMultiplicityAndCanonicalHKL(h, k, l, system) {
            let H = Math.abs(h);
            let K = Math.abs(k);
            let L = Math.abs(l);

            let canonical_hkl = `(${H},${K},${L})`;
            let multiplicity = 1;

            switch (system) {
                
                case 'cubic':
                    // Sort into conventional order: h >= k >= l >= 0
                    [H, K, L] = [H, K, L].sort((a, b) => b - a);
                    canonical_hkl = `(${H},${K},${L})`;

                    if (H > K && K > L && L > 0)      multiplicity = 48; // hkl (general)
                    else if (H === K && K > L && L > 0) multiplicity = 24; // hhl
                    else if (H > K && K === L && L > 0) multiplicity = 24; // hkk
                    else if (H > K && K > 0 && L === 0) multiplicity = 24; // hk0
                    else if (H === K && K > 0 && L === 0) multiplicity = 12; // hh0
                    else if (H === K && K === L && L > 0) multiplicity = 8;  // hhh
                    else if (H > 0 && K === 0 && L === 0) multiplicity = 6;  // h00
                    break;

                case 'hexagonal':
                case 'rhombohedral': // Using Hexagonal axes (Laue class 6/mmm or -3m)
                    canonical_hkl = `(${H},${K},${L})`;
                    // Conditions based on hk.l notation
                    if (H > 0 && K > 0 && L > 0 && H !== K) multiplicity = 24; // hkl
                    else if (H > 0 && K > 0 && L > 0)      multiplicity = 12; // hhl, hkh, etc.
                    else if (H > 0 && K > 0 && L === 0 && H !== K) multiplicity = 12; // hk0
                    else if (H > 0 && K === 0 && L > 0)      multiplicity = 12; // h0l
                    else if (H > 0 && K === H && L === 0)      multiplicity = 6;  // hh0
                    else if (H > 0 && K === 0 && L === 0)      multiplicity = 6;  // h00 (equivalent to hh0)
                    else if (H === 0 && K === 0 && L > 0)      multiplicity = 2;  // 00l
                    break;
                
                case 'tetragonal':
                    // Conventional order: h >= k >= 0, l >= 0
                    if (K > H) [H, K] = [K, H];
                    canonical_hkl = `(${H},${K},${L})`;
                    
                    if (H > K && K > 0 && L > 0)      multiplicity = 16; // hkl
                    else if (H === K && K > 0 && L > 0) multiplicity = 8;  // hhl
                    else if (H > 0 && K === 0 && L > 0) multiplicity = 8;  // h0l
                    else if (H > K && K > 0 && L === 0) multiplicity = 8;  // hk0
                    else if (H === K && K > 0 && L === 0) multiplicity = 4;  // hh0
                    else if (H > 0 && K === 0 && L === 0) multiplicity = 4;  // h00
                    else if (H === 0 && K === 0 && L > 0) multiplicity = 2;  // 00l
                    break;
                
                case 'orthorhombic':
                    canonical_hkl = `(${H},${K},${L})`;
                    
                    if (H > 0 && K > 0 && L > 0)      multiplicity = 8; // hkl
                    else if (H > 0 && K > 0 && L === 0) multiplicity = 4; // hk0
                    else if (H > 0 && K === 0 && L > 0) multiplicity = 4; // h0l
                    else if (H === 0 && K > 0 && L > 0) multiplicity = 4; // 0kl
                    else if (H > 0 && K === 0 && L === 0) multiplicity = 2; // h00
                    else if (H === 0 && K > 0 && L === 0) multiplicity = 2; // 0k0
                    else if (H === 0 && K === 0 && L > 0) multiplicity = 2; // 00l
                    break;
                
                case 'monoclinic':
                    // Assumes b-axis is unique (Laue class 2/m)
                    canonical_hkl = `(${H},${K},${L})`;
                    
                    if (H > 0 && L > 0 && K > 0)      multiplicity = 4; // hkl (general)
                    else if (H > 0 && L > 0 && K === 0) multiplicity = 2; // h0l
                    else if (H === 0 && K > 0 && L === 0) multiplicity = 2; // 0k0
                    else { // All other cases (hk0, 0kl, h00, 00l) are general in projection
                        multiplicity = 4;
                        // But if one index is zero it's a special reflection
                        if (H===0 || K===0 || L===0) multiplicity = 2;
                        // Override for general case
                        if(H>0 && K>0 && L>0) multiplicity = 4;
                    }

                    // A simpler way for monoclinic.. à vérifier
                    if (H > 0 && L > 0) { // hkl and h0l
                        multiplicity = (K > 0) ? 4 : 2;
                    } else if (H > 0 || L > 0) { // hk0 and 0kl, or h00 and 00l
                        multiplicity = (K > 0) ? 4 : 2;
                    } else if (K > 0) { // 0k0
                        multiplicity = 2;
                    }
                    break;
            }

            return { canonical_hkl, multiplicity };
        }


            /**
         * Génère le contenu complet du rapport texte ASCII.
         * @param {object} fitResults - L'objet contenant les résultats de l'ajustement.
         * @param {object} controls - L'objet contenant les éléments de l'interface utilisateur.
         * @returns {string} - Le rapport complet sous forme de chaîne de caractères.
         */
        
        function generateTextReportContent(fitResults, controls) {
            const reportLines = [];
            const now = new Date();
            const { params: finalParams, fitFlags, algorithm, stats } = fitResults;

            const formatParamLine = (name, value, isFitted) => {
                let valStr;
                if (typeof value === 'number') {
                    valStr = value.toExponential(6).padStart(15);
                } else if (typeof value === 'string') {
                    valStr = value.padStart(15);
                } else {
                    valStr = 'N/A'.padStart(15);
                }
                const fitStr = (isFitted === undefined) ? '' : (isFitted ? 'Yes' : 'No');
                return `${name.padEnd(20)}${valStr}    ${fitStr}`;
            };
            
            // --- Section En-tête ---
            reportLines.push('==============================================================');
            reportLines.push('            Le Bail Refinement Report');
            reportLines.push('==============================================================');
            reportLines.push(`Report Generated: ${now.toLocaleString()}`);
            reportLines.push(`Program used: LeBail.html, version 14 Sept 2025, nitad54448.github.io`);
            reportLines.push(`Data File: ${controls.fileName.textContent}`);
            reportLines.push('');

            // --- Section Statistiques ---
            reportLines.push('--- Refinement Statistics ---');
            reportLines.push(`Rp (%):      ${stats.r_p.toFixed(4)}`);
            reportLines.push(`Rwp (%):     ${stats.rwp.toFixed(4)}`);
            reportLines.push(`χ² (GOF):    ${stats.chi2.toFixed(4)}`);
            reportLines.push(`Algorithm:   ${algorithm === 'lm' ? 'Levenberg-Marquardt' : 'Simulated Annealing'}`);
            reportLines.push('');


            // --- Section Paramètres ---
            reportLines.push('--- Structural & Instrumental Parameters ---');
            reportLines.push('Parameter'.padEnd(20) + 'Value'.padStart(15) + '    Fitted');
            reportLines.push('-'.repeat(50));
            const selectedOption = controls.bravaisLattice.options[controls.bravaisLattice.selectedIndex];
            reportLines.push(formatParamLine('System:', selectedOption.text));
            if(finalParams.a) reportLines.push(formatParamLine('a (Å)', finalParams.a, fitFlags.a));
            if(finalParams.b) reportLines.push(formatParamLine('b (Å)', finalParams.b, fitFlags.b));
            if(finalParams.c) reportLines.push(formatParamLine('c (Å)', finalParams.c, fitFlags.c));
            if(finalParams.alpha) reportLines.push(formatParamLine('alpha (°)', finalParams.alpha, fitFlags.alpha));
            if(finalParams.beta) reportLines.push(formatParamLine('beta (°)', finalParams.beta, fitFlags.beta));
            if(finalParams.gamma) reportLines.push(formatParamLine('gamma (°)', finalParams.gamma, fitFlags.gamma));
            reportLines.push(formatParamLine('Wavelength (Å)', finalParams.lambda));
            reportLines.push(formatParamLine('Zero Shift (°)', finalParams.zeroShift, fitFlags.zeroShift));
            reportLines.push('');

            reportLines.push('--- Profile Parameters ---');
            reportLines.push(formatParamLine('GU', finalParams.GU, fitFlags.GU));
            reportLines.push(formatParamLine('GV', finalParams.GV, fitFlags.GV));
            reportLines.push(formatParamLine('GW', finalParams.GW, fitFlags.GW));
            reportLines.push(formatParamLine('GP', finalParams.GP, fitFlags.GP));
            reportLines.push(formatParamLine('LX', finalParams.LX, fitFlags.LX));
            reportLines.push(formatParamLine('eta', finalParams.eta, fitFlags.eta));
            reportLines.push(formatParamLine('shft', finalParams.shft, fitFlags.shft));
            reportLines.push(formatParamLine('trns', finalParams.trns, fitFlags.trns));
            reportLines.push('');

            reportLines.push('--- Background Parameters ---');
            reportLines.push(formatParamLine('B-1', finalParams.bg_inv, fitFlags.bg_inv));
            finalParams.bg.forEach((val, i) => {
                if (Math.abs(val) > 1e-9 || fitFlags.background[i]) {
                    reportLines.push(formatParamLine(`B${i}`, val, fitFlags.background[i]));
                }
            });
            reportLines.push('');

            if (fitResults.weightingParams && fitResults.weightingParams.weightFactor > 1) {
    reportLines.push('--- Background Weighting Parameters ---');
    reportLines.push(formatParamLine('FWHM Widths', fitResults.weightingParams.fwhmWidths));
    reportLines.push(formatParamLine('Weight Factor', fitResults.weightingParams.weightFactor));
    reportLines.push('');
}

            // --- Section Réflexions 
            const { system, centering } = getSystemAndCentering();
            const hklListForReport = generateHKL(Math.max(...fullExperimentalData.tth), finalParams, system, centering);

            reportLines.push('--- Calculated vs. Experimental Reflections ---');
            reportLines.push(['h,k,l'.padEnd(10), 'd_calc (Å)'.padStart(12), 'd_exp (Å)'.padStart(12), '2th_corr (°)' .padStart(15), '2th_exp (°)' .padStart(15)].join('  '));
            reportLines.push('-'.repeat(80));

            hklListForReport.forEach(hkl => {
                const peakShift = calculatePeakShift(hkl.tth, finalParams);
                const tthCorr = hkl.tth + finalParams.zeroShift + peakShift;
                
                // Find corresponding experimental peak details
                const { tth_exp, d_exp } = findExperimentalPeakDetails(tthCorr, fullExperimentalData, finalParams.lambda);
                
                const d_calc_str = hkl.d.toFixed(5).padStart(12);
                const d_exp_str = d_exp ? d_exp.toFixed(5).padStart(12) : 'N/A'.padStart(12);
                const tth_corr_str = tthCorr.toFixed(4).padStart(15);
                const tth_exp_str = tth_exp ? tth_exp.toFixed(4).padStart(15) : 'N/A'.padStart(15);

                const line = [
                    hkl.hkl_list[0].padEnd(10),
                    d_calc_str,
                    d_exp_str,
                    tth_corr_str,
                    tth_exp_str
                ].join('  ');
                reportLines.push(line);
            });
            reportLines.push('');
            
            // --- Section Données ---
            const { pattern: finalCalcPattern } = calculatePattern(fullExperimentalData.tth, hklListForReport, finalParams, getWorkingData().tth);
            reportLines.push('');
            reportLines.push('--- Intensity Data ---');
            reportLines.push(['2theta', 'I_obs', 'I_calc', 'Difference'].join('\t'));
            for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                const tth = fullExperimentalData.tth[i];
                const i_obs = fullExperimentalData.intensity[i];
                const i_calc = finalCalcPattern[i];
                const diff = i_obs - i_calc;
                reportLines.push([tth.toFixed(4), i_obs.toFixed(2), i_calc.toFixed(2), diff.toFixed(2)].join('\t'));
            }

            return reportLines.join('\n');
        }
         /**
         * Déclenche le téléchargement d'un fichier texte dans le navigateur... un warning peut apparaître, chiant mais pas grave
         * @param {string} content - Le contenu du fichier.
         * @param {string} filename - Le nom du fichier à télécharger.
         */
        function downloadTextFile(content, filename) {
            const element = document.createElement('a');
            const file = new Blob([content], {type: 'text/plain;charset=utf-8'});
            element.href = URL.createObjectURL(file);
            element.download = filename;
            document.body.appendChild(element); // Requis pour Firefox ou autres nonChromium
            element.click();
            document.body.removeChild(element);
        }

       

        function generateHKL(maxTth, params, system, centering) {
            const { a, b, c, alpha, beta, gamma, lambda } = params;
            if (!a || !lambda || a <= 0) return [];

            const reflections = new Map();
            const maxIndex = Math.ceil(2 * Math.max(a || 0, b || 0, c || 0) / lambda * Math.sin(maxTth / 2 * Math.PI / 180)) + 2;

            const deg2rad = Math.PI / 180;
            const cos_a = Math.cos((alpha || 90) * deg2rad);
            const sin_b = Math.sin((beta || 90) * deg2rad);
            const cos_b = Math.cos((beta || 90) * deg2rad);
            
            for (let h = -maxIndex; h <= maxIndex; h++) {
                for (let k = -maxIndex; k <= maxIndex; k++) {
                    for (let l = 0; l <= maxIndex; l++) {
                        if (h === 0 && k === 0 && l === 0) continue;

                        let allowed = false;
                        switch(centering) {
                            case 'P': allowed = true; break;
                            case 'I': allowed = (h + k + l) % 2 === 0; break;
                            case 'F': allowed = (h % 2 === k % 2) && (k % 2 === l % 2); break;
                            case 'C': allowed = (h + k) % 2 === 0; break;
                            case 'R':
                                // This condition is for hexagonal axes description of a rhombohedral lattice
                                if (system === 'hexagonal') allowed = (-h + k + l) % 3 === 0;
                                else allowed = true; // Rhombohedral axes is primitive by definition
                                break;
                            default: allowed = true;
                        }
                        if (!allowed) continue;

                        let inv_d_sq = 0;
                        switch(system) {
                            case 'cubic':
                                inv_d_sq = (h*h + k*k + l*l) / (a*a);
                                break;
                            case 'tetragonal':
                                inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c);
                                break;
                            case 'orthorhombic':
                                inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c);
                                break;
                            case 'hexagonal':
                                inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c);
                                break;
                            case 'monoclinic':
                                inv_d_sq = (1/(sin_b*sin_b)) * ( (h*h)/(a*a) + (k*k*sin_b*sin_b)/(b*b) + (l*l)/(c*c) - (2*h*l*cos_b)/(a*c) );
                                break;
                            case 'rhombohedral':
                                const term1 = (h*h + k*k + l*l) * Math.sin(alpha*deg2rad)**2;
                                const term2 = 2 * (h*k + k*l + l*h) * (Math.cos(alpha*deg2rad)**2 - Math.cos(alpha*deg2rad));
                                const denominator = a*a * (1 - 3*Math.cos(alpha*deg2rad)**2 + 2*Math.cos(alpha*deg2rad)**3);
                                if(Math.abs(denominator) < 1e-9) continue;
                                inv_d_sq = (term1 + term2) / denominator;
                                break;
                        }
                        if (inv_d_sq <= 0) continue;
                        
                        const sinThetaSq = (lambda*lambda / 4) * inv_d_sq;
                        if (sinThetaSq <= 1) {
                            const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                            if (tth > maxTth * 1.05) continue;
                            const d = 1 / Math.sqrt(inv_d_sq);
                            const key = Math.round(tth * 1000);
                            if (!reflections.has(key)) {
                                // Call the ledger to get the canonical HKL and correct multiplicity.
                                const { canonical_hkl, multiplicity } = getMultiplicityAndCanonicalHKL(h, k, l, system);
                                reflections.set(key, { tth: tth, d: d, hkl_list: [canonical_hkl], multiplicity: multiplicity, intensity: 0 });
                            }
                            // If key already exists, do nothing. 

                        }
                    }
                }
            }
            return Array.from(reflections.values()).sort((a, b) => a.tth - b.tth);
        }

        function calculatePeakShift(tth, params) {
            const thetaRad = tth * (Math.PI / 180) / 2;
            const cosTheta = Math.cos(thetaRad);
            const sin2Theta = Math.sin(2 * thetaRad);
            const displacementShift = -(params.shft / 1000) * cosTheta * (180 / Math.PI);
            const transparencyShift = params.trns * sin2Theta;
            return displacementShift + transparencyShift;
        }

        function calculateProfileWidths(tth, params) {
            const thetaRad = Math.min(tth * (Math.PI / 180) / 2, 89.999 * Math.PI / 180);
            const tanTheta = Math.tan(thetaRad);
            const cosTheta = Math.cos(thetaRad);
            const gamma_G_sq = (params.GU / 100) * tanTheta * tanTheta + (params.GV / 100) * tanTheta + (params.GW / 100) + (params.GP / 100) / (cosTheta * cosTheta);
            const gamma_G = Math.sqrt(Math.max(1e-6, gamma_G_sq));
            const gamma_L = (params.LX / 100) / cosTheta;
            return { gamma_G, gamma_L };
        }

        function pseudoVoigt(x, x0, gamma_G, gamma_L, eta) {
            if (gamma_G <= 1e-6 && gamma_L <= 1e-6) return 0.0;
            const fwhm_g_to_sigma = 1 / (2 * Math.sqrt(2 * Math.log(2)));
            const sigma = gamma_G * fwhm_g_to_sigma;
            const normalizedGaussian = Math.exp(-0.5 * ((x - x0) ** 2) / (sigma * sigma));
            const hwhm_l = gamma_L / 2.0;
            const normalizedLorentzian = (hwhm_l * hwhm_l) / ((x - x0) ** 2 + (hwhm_l * hwhm_l));
            if (gamma_L < 1e-6) return normalizedGaussian;
            if (gamma_G < 1e-6) return normalizedLorentzian;
            return eta * normalizedLorentzian + (1 - eta) * normalizedGaussian;
        }
        
        function calculateBackground(tthAxis, chebyshevCoeffs, invCoeff, fitTthRange = null) {
            if (!tthAxis || tthAxis.length === 0) return new Array(tthAxis.length).fill(0);
            
            const normRange = fitTthRange || tthAxis;
            const minTth = normRange[0];
            const maxTth = normRange[normRange.length - 1];
            
            const range = maxTth - minTth;
            const cheby_bg = tthAxis.map(tth => {
                if (range < 1e-6) return chebyshevCoeffs[0] || 0;
                const x = (2 * (tth - minTth) / range) - 1;
                let T_prev = 1, T_curr = x;
                let background = (chebyshevCoeffs[0] || 0) * T_prev;
                if (chebyshevCoeffs.length > 1) background += (chebyshevCoeffs[1] || 0) * T_curr;
                for (let n = 2; n < chebyshevCoeffs.length; n++) {
                    const T_next = 2 * x * T_curr - T_prev;
                    background += (chebyshevCoeffs[n] || 0) * T_next;
                    T_prev = T_curr;
                    T_curr = T_next;
                }
                return background;
            });
            return cheby_bg.map((val, i) => {
                const tth = tthAxis[i];
                return tth > 1e-6 ? val + invCoeff / tth : val;
            });
        }

        function calculatePattern(tthAxis, hklList, params, fitTthRange = null) {
            const pattern = new Float32Array(tthAxis.length).fill(0);
            hklList.forEach(peak => {
                const basePos = peak.tth + params.zeroShift;
                const shift = calculatePeakShift(basePos, params);
                const peakPos = basePos + shift;
                const { gamma_G, gamma_L } = calculateProfileWidths(basePos, params);
                for (let i = 0; i < tthAxis.length; i++) {
                    const window = 5 * (gamma_G + gamma_L);
                    if (Math.abs(tthAxis[i] - peakPos) < window) {
                       pattern[i] += peak.intensity * pseudoVoigt(tthAxis[i], peakPos, gamma_G, gamma_L, params.eta);
                    }
                }
            });
            const background = calculateBackground(tthAxis, params.bg, params.bg_inv, fitTthRange);
            for(let i=0; i<pattern.length; i++) pattern[i] += background[i];
            return { pattern, background };
        }

        function leBailIntensityExtraction(exp, hklList, params) {
            hklList.forEach(p => p.intensity = 0);
            
            const background = calculateBackground(exp.tth, params.bg, params.bg_inv, exp.tth);

            for(let i = 0; i < exp.tth.length; i++) {
                let totalProfileAtPoint = 0;
                const contributingPeaks = [];
                hklList.forEach((peak, peakIdx) => {
                    const basePos = peak.tth + params.zeroShift;
                    const shift = calculatePeakShift(basePos, params);
                    const peakPos = basePos + shift;
                    const { gamma_G, gamma_L } = calculateProfileWidths(basePos, params);
                    const window = 5 * (gamma_G + gamma_L);
                    if(Math.abs(exp.tth[i] - peakPos) < window) {
                        const profileVal = pseudoVoigt(exp.tth[i], peakPos, gamma_G, gamma_L, params.eta);
                        totalProfileAtPoint += profileVal;
                        contributingPeaks.push({idx: peakIdx, val: profileVal});
                    }
                });
                if(totalProfileAtPoint > 1e-9) {
                    const obsIntensityNet = Math.max(0, exp.intensity[i] - background[i]);
                    contributingPeaks.forEach(p => {
                        hklList[p.idx].intensity += obsIntensityNet * (p.val / totalProfileAtPoint);
                    });
                }
            }
            const maxIntensity = Math.max(...hklList.map(p => p.intensity));
            if (maxIntensity > 0) {
                hklList.forEach(p => p.intensity = p.intensity / maxIntensity * 1000);
            }
        }

        /**
         * Calculates the weights for the refinement.
         * If background weighting is enabled, points far from peaks get a higher weight.
         * @param {object} workingData - The experimental data {tth, intensity} to be fitted.
         * @param {Array} hklList - The list of calculated reflection positions.
         * @param {object} params - The current set of refinement parameters.
         * @returns {Array<number>} An array of weights for each data point.
         */

         function calculateFitWeights(workingData, hklList, params) {
    const defaultWeights = workingData.intensity.map(y => 1 / Math.max(y, 1));
    const weightFactor = parseInt(controls.bgWeightFactorSlider.value);

    // If weight factor is 1, no special weighting is needed.
    if (weightFactor <= 1 || hklList.length === 0) {
        return defaultWeights;
    }

    const fwhmMultiplier = parseFloat(controls.fwhmWidthsSlider.value);
    
    const peakInfo = hklList.map(peak => {
        const pos = peak.tth + params.zeroShift + calculatePeakShift(peak.tth, params);
        const { gamma_G, gamma_L } = calculateProfileWidths(peak.tth, params);
        const fwhm = gamma_G + gamma_L;
        return { pos, fwhm };
    });

    const finalWeights = defaultWeights.map((weight, i) => {
        const currentTth = workingData.tth[i];
        let isNearPeak = false;
        for (const peak of peakInfo) {
            const threshold = fwhmMultiplier * peak.fwhm;
            if (Math.abs(currentTth - peak.pos) <= threshold) {
                isNearPeak = true;
                break;
            }
        }
        return isNearPeak ? weight : weight * weightFactor;
    });

    return finalWeights;
}

        function calculateRwp(exp_intensity, calc_intensity, weights) {
            let ss_res = 0, ss_tot = 0;
            if (weights.length !== exp_intensity.length) {
                console.error("Mismatch in lengths for Rwp calculation.");
                return 0;
            }
            for(let i=0; i<exp_intensity.length; i++) {
                const weight = weights[i];
                ss_res += weight * (exp_intensity[i] - calc_intensity[i])**2;
                ss_tot += weight * (exp_intensity[i])**2;
            }
            return ss_tot > 0 ? 100 * Math.sqrt(ss_res / ss_tot) : 0;
        }

        function calculateStatistics(workingData, finalWorkingPattern, finalParams, fitFlags) {
            const y_obs = workingData.intensity;
            const y_calc = finalWorkingPattern;

            const N = y_obs.length;
            const P = getParameterMapping(fitFlags).paramMapping.length;
            const { system, centering } = getSystemAndCentering();
            const hklList = generateHKL(Math.max(...workingData.tth), finalParams, system, centering);
            const weights = calculateFitWeights(workingData, hklList, finalParams);

            let sum_w_res_sq = 0;
            let sum_w_obs_sq = 0;
            let sum_abs_res = 0;
            let sum_abs_obs = 0;

            for (let i = 0; i < N; i++) {
                const res = y_obs[i] - y_calc[i];
                const w = weights[i];

                sum_w_res_sq += w * res * res;
                sum_w_obs_sq += w * y_obs[i] * y_obs[i];

                sum_abs_res += Math.abs(res);
                sum_abs_obs += Math.abs(y_obs[i]);
            }

            const r_p = sum_abs_obs > 0 ? 100 * (sum_abs_res / sum_abs_obs) : 0;
            const rwp = sum_w_obs_sq > 0 ? 100 * Math.sqrt(sum_w_res_sq / sum_w_obs_sq) : 0;
            
            const degreesOfFreedom = N - P;
            const chi2 = degreesOfFreedom > 0 ? sum_w_res_sq / degreesOfFreedom : Infinity;

            return { r_p, rwp, chi2 };
        }
        
        function getAllParams() {
             const bg = [];
             for(let i = 0; i < NUM_BG_TERMS; i++) {
                 bg.push(parseFloat(document.getElementById(`bg-param-${i}`).value));
             }
            return {
                a: parseFloat(document.getElementById('lattice-param-a')?.value),
                b: parseFloat(document.getElementById('lattice-param-b')?.value),
                c: parseFloat(document.getElementById('lattice-param-c')?.value),
                alpha: parseFloat(document.getElementById('lattice-param-alpha')?.value),
                beta: parseFloat(document.getElementById('lattice-param-beta')?.value),
                gamma: parseFloat(document.getElementById('lattice-param-gamma')?.value),
                lambda: parseFloat(controls.wavelength.value),
                zeroShift: parseFloat(controls.zeroShift.value),
                GU: parseFloat(controls.paramGU.value),
                GV: parseFloat(controls.paramGV.value),
                GW: parseFloat(controls.paramGW.value),
                GP: parseFloat(controls.paramGP.value),
                LX: parseFloat(controls.paramLX.value),
                eta: parseFloat(controls.paramEta.value),
                shft: parseFloat(controls.paramShft.value),
                trns: parseFloat(controls.paramTrns.value),
                bg: bg,
                bg_inv: parseFloat(document.getElementById('bg-param-neg1').value),
            };
        }
        
        function getFitFlags() {
             const bgFlags = [];
             for(let i = 0; i < NUM_BG_TERMS; i++) {
                 bgFlags.push(document.getElementById(`fit-bg-${i}`).checked);
             }
             return {
                a: document.getElementById('fit-lattice-a')?.checked,
                b: document.getElementById('fit-lattice-b')?.checked,
                c: document.getElementById('fit-lattice-c')?.checked,
                alpha: document.getElementById('fit-lattice-alpha')?.checked,
                beta: document.getElementById('fit-lattice-beta')?.checked,
                gamma: document.getElementById('fit-lattice-gamma')?.checked,
                zeroShift: controls.fitZeroShift.checked,
                GU: controls.fitGU.checked, GV: controls.fitGV.checked, GW: controls.fitGW.checked,
                GP: controls.fitGP.checked, LX: controls.fitLX.checked,
                eta: controls.fitEta.checked, shft: controls.fitShft.checked, trns: controls.fitTrns.checked,
                background: bgFlags,
                bg_inv: document.getElementById('fit-bg-neg1').checked,
            };
        }

        async function runLeBailFit() {
    if (isFitting) return;
    isFitting = true;
    fitResults = null; // Clear previous results
    setUIState(true);

    if (mainChart) {
        const manualSimDataset = mainChart.data.datasets.find(d => d.label === 'Simulation (Manual)');
        if (manualSimDataset) manualSimDataset.data = [];
    }
    
    await new Promise(resolve => setTimeout(resolve, 10));

    if (mainChart) {
        ['Calculated', 'Background', 'Difference', 'Difference Zero', 'HKL Markers'].forEach(label => {
            const dataset = mainChart.data.datasets.find(d => d.label === label);
            if (dataset) dataset.data = [];
        });
        mainChart.update('none');
    }

    let params = getAllParams();
    const fitFlags = getFitFlags();
    const workingData = getWorkingData();
    
    if (fitFlags.background[0] && workingData.intensity.length > 0) {
        const n_points = Math.min(NUM_BG_ANCHOR_POINTS, Math.floor(workingData.intensity.length / 2));
        if (n_points > 0) {
            let initialBg = 0;
            for (let i = 0; i < n_points; i++) {
                initialBg += workingData.intensity[i];
                initialBg += workingData.intensity[workingData.intensity.length - 1 - i];
            }
            initialBg /= (2 * n_points);
            params.bg[0] = isNaN(initialBg) ? 100 : initialBg;
            document.getElementById('bg-param-0').value = params.bg[0].toExponential(4);
        }
    }

    const { system, centering } = getSystemAndCentering();
    const maxIterations = parseInt(controls.iterationsSlider.value);
    const algorithm = controls.algorithmSelect.value;
    
    // This is now a local variable, not a global assignment from within the function
    let results; 

    const progressCallback = (progress, currentParams, rwp) => {
         controls.progressBar.style.width = `${progress * 100}%`;
         const rwpCard = controls.rwpResult.parentElement;
         rwpCard.style.background = `linear-gradient(to right, #3b82f6 ${progress * 100}%, #1f2937 ${progress * 100}%)`;
         
         const hklList = generateHKL(Math.max(...fullExperimentalData.tth), currentParams, system, centering);
         leBailIntensityExtraction(workingData, hklList, currentParams);
         const { pattern, background } = calculatePattern(fullExperimentalData.tth, hklList, currentParams, workingData.tth);

         updateUI(currentParams, { rwp: rwp }, pattern, background);
    };

    if (algorithm === 'lm') {
         results = await refineParametersLM(params, fitFlags, maxIterations, system, centering, progressCallback);
    } else if (algorithm === 'sa') {
         results = await refineParametersSA(params, fitFlags, maxIterations, system, centering, progressCallback);
    }
    
    // Now we assign the returned object to the global fitResults
    fitResults = results;
    const finalParams = fitResults.params;
    
    const finalWorkingData = getWorkingData();
    const hklList = generateHKL(Math.max(...fullExperimentalData.tth), finalParams, system, centering);
    lastGeneratedHklList = hklList;
    leBailIntensityExtraction(finalWorkingData, hklList, finalParams);
    
    const { pattern, background } = calculatePattern(fullExperimentalData.tth, hklList, finalParams, finalWorkingData.tth);
    const { pattern: finalWorkingPattern } = calculatePattern(finalWorkingData.tth, hklList, finalParams, finalWorkingData.tth);
    
    const finalStats = calculateStatistics(finalWorkingData, finalWorkingPattern, finalParams, fitFlags);
    fitResults.stats = finalStats;
    fitResults.weightingParams = {
        fwhmWidths: parseFloat(controls.fwhmWidthsSlider.value),
        weightFactor: parseInt(controls.bgWeightFactorSlider.value)
    };
    
    updateUI(finalParams, finalStats, pattern, background);

    isFitting = false;
    setUIState(false);
}
     
        function dot(v1, v2) { let s = 0; for(let i=0; i<v1.length; i++) s += v1[i] * v2[i]; return s; }
        function add(v1, v2) { return v1.map((x, i) => x + v2[i]); }
        function subtract(v1, v2) { return v1.map((x, i) => x - v2[i]); }
        function scale(v, s) { return v.map(x => x * s); }
        function transpose(m) {
            if (!m || m.length === 0 || !Array.isArray(m[0])) return m.map(x => [x]);
            return m[0].map((_, colIndex) => m.map(row => row[colIndex]));
        }
        function multiply(A, B) {
            if (!Array.isArray(B[0])) return A.map(row => dot(row, B));
            const Bt = transpose(B);
            return A.map(rowA => Bt.map(colB => dot(rowA, colB)));
        }
        
        function solve(A, b) {
            const n = A.length;
            const Ab = A.map((row, i) => [...row, b[i]]);
            for (let i = 0; i < n; i++) {
                let max = i;
                for (let k = i + 1; k < n; k++) { if (Math.abs(Ab[k][i]) > Math.abs(Ab[max][i])) max = k; }
                [Ab[i], Ab[max]] = [Ab[max], Ab[i]];
                if (Math.abs(Ab[i][i]) < 1e-12) continue;
                for (let k = i + 1; k < n; k++) {
                    const factor = Ab[k][i] / Ab[i][i];
                    if (!isFinite(factor)) continue;
                    for (let j = i; j < n + 1; j++) Ab[k][j] -= factor * Ab[i][j];
                }
            }
            const x = new Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                let sum = 0; for (let j = i + 1; j < n; j++) sum += Ab[i][j] * x[j];
                if (Math.abs(Ab[i][i]) > 1e-12) x[i] = (Ab[i][n] - sum) / Ab[i][i];
            }
            return x;
        }

        function matrixInverse(A) {
            const n = A.length;
            if (n === 0) return [];
            const I = Array.from({ length: n }, (_, i) => Array.from({ length: n }, (_, j) => (i === j ? 1 : 0)));
            const C = A.map((row, i) => [...row, ...I[i]]);
            for (let i = 0; i < n; i++) {
                let pivot = i;
                for (let j = i + 1; j < n; j++) { if (Math.abs(C[j][i]) > Math.abs(C[pivot][i])) pivot = j; }
                [C[i], C[pivot]] = [C[pivot], C[i]];
                const div = C[i][i];
                if (Math.abs(div) < 1e-12) return null;
                for (let j = i; j < 2 * n; j++) C[i][j] /= div;
                for (let j = 0; j < n; j++) {
                    if (i !== j) {
                        const mult = C[j][i];
                        for (let k = i; k < 2 * n; k++) C[j][k] -= mult * C[i][k];
                    }
                }
            }
            return C.map(row => row.slice(n));
        }

        function getParameterMapping(fitFlags) {
            const paramMapping = [];
            const paramDefs = [
                { flag: fitFlags.a, name: 'a', get: p => p.a, set: (p, v) => p.a = v, step: 1e-2 },
                { flag: fitFlags.b, name: 'b', get: p => p.b, set: (p, v) => p.b = v, step: 1e-2 },
                { flag: fitFlags.c, name: 'c', get: p => p.c, set: (p, v) => p.c = v, step: 1e-2 },
                { flag: fitFlags.alpha, name: 'alpha', get: p => p.alpha, set: (p, v) => p.alpha = v, step: 1e-1 },
                { flag: fitFlags.beta, name: 'beta', get: p => p.beta, set: (p, v) => p.beta = v, step: 1e-1 },
                { flag: fitFlags.gamma, name: 'gamma', get: p => p.gamma, set: (p, v) => p.gamma = v, step: 1e-1 },
                { flag: fitFlags.zeroShift, name: 'zeroShift', get: p => p.zeroShift, set: (p, v) => p.zeroShift = v, step: 1e-2 },
                { flag: fitFlags.GU, name: 'GU', get: p => p.GU, set: (p, v) => p.GU = v, step: 1. },
                { flag: fitFlags.GV, name: 'GV', get: p => p.GV, set: (p, v) => p.GV = v, step: 1. },
                { flag: fitFlags.GW, name: 'GW', get: p => p.GW, set: (p, v) => p.GW = Math.max(0, v), step: 1.0 },
                { flag: fitFlags.GP, name: 'GP', get: p => p.GP, set: (p, v) => p.GP = v, step: 0.5 },
                { flag: fitFlags.LX, name: 'LX', get: p => p.LX, set: (p, v) => p.LX = Math.max(0, v), step: 0.2 },
                { flag: fitFlags.eta, name: 'eta', get: p => p.eta, set: (p, v) => p.eta = Math.max(0, Math.min(1, v)), step: 0.05 },
                { flag: fitFlags.shft, name: 'shft', get: p => p.shft, set: (p, v) => p.shft = v, step: 0.1 },
                { flag: fitFlags.trns, name: 'trns', get: p => p.trns, set: (p, v) => p.trns = v, step: 0.05 },
                { flag: fitFlags.bg_inv, name: 'B-1', get: p => p.bg_inv, set: (p, v) => p.bg_inv = v, step: 10.0 },
            ];
            paramDefs.forEach(def => { if (def.flag) paramMapping.push(def); });
            
            fitFlags.background.forEach((fit, i) => {
                if (fit) { 
                    const step = 50.0;
                    paramMapping.push({ name: `B${i}`, get: p => p.bg[i], set: (p, v) => p.bg[i] = v, step: step }); 
                }
            });
            return { paramMapping };
        }

        async function refineParametersSA(initialParams, fitFlags, maxIter, system, centering, progressCallback) {
    const { paramMapping } = getParameterMapping(fitFlags);
    if (paramMapping.length === 0) {
        return { params: initialParams, algorithm: 'sa', paramMapping, fitFlags };
    }

    const workingData = getWorkingData();
    let p_initial_vec = paramMapping.map(m => m.get(initialParams));
    
    let referenceHklList = generateHKL(Math.max(...workingData.tth), initialParams, system, centering);
    leBailIntensityExtraction(workingData, referenceHklList, initialParams);
    const referenceIntensities = referenceHklList.map(hkl => ({ ...hkl }));

    const objective = (p_vec) => {
        let tempParams = JSON.parse(JSON.stringify(initialParams));
        paramMapping.forEach((m, i) => m.set(tempParams, p_vec[i]));
        if (tempParams.a <= 0) return 1e12;
        
        let hklList = generateHKL(Math.max(...workingData.tth), tempParams, system, centering);
        
        const maxRefIntensity = Math.max(...referenceIntensities.map(h => h.intensity));
        hklList.forEach(hkl => {
            const matchingRef = referenceIntensities.find(ref => 
                Math.abs(ref.d - hkl.d) < 0.01 * ref.d
            );
            hkl.intensity = matchingRef ? matchingRef.intensity : maxRefIntensity * 0.1;
        });

        const { pattern } = calculatePattern(workingData.tth, hklList, tempParams, workingData.tth);
        const diff = subtract(workingData.intensity, pattern);
        
        const weights = calculateFitWeights(workingData, hklList, tempParams);
        let weighted_ss = 0;
        for (let i = 0; i < diff.length; i++) {
            weighted_ss += weights[i] * diff[i] * diff[i];
        }
        return weighted_ss;
    };

    let T = 1000.0;
    const coolingRate = 0.999;
    const maxSteps = maxIter * 50;
    
    let current_x = [...p_initial_vec];
    let current_cost = objective(current_x);
    let best_x = [...current_x];
    let best_cost = current_cost;

    for (let i = 0; i < maxSteps; i++) {
        let neighbor_x = current_x.map((val, idx) => {
            const baseStep = paramMapping[idx].step;
            const tempFactor = Math.max(0.1, T / 1000.0);
            const stepSize = baseStep * tempFactor * 5.0;
            let newVal = val + (Math.random() - 0.5) * stepSize;
            if (paramMapping[idx].name === 'eta') newVal = Math.max(0, Math.min(1, newVal));
            else if (['a', 'b', 'c'].includes(paramMapping[idx].name)) newVal = Math.max(0.1, newVal);
            return newVal;
        });
        
        let neighbor_cost = objective(neighbor_x);
        let cost_diff = neighbor_cost - current_cost;

        if (cost_diff < 0 || Math.exp(-cost_diff / T) > Math.random()) {
            current_x = [...neighbor_x];
            current_cost = neighbor_cost;
        }

        if (current_cost < best_cost) {
            best_x = [...current_x];
            best_cost = current_cost;
        }

        T *= coolingRate;

        if (i % 100 === 0) {
            let tempParams = JSON.parse(JSON.stringify(initialParams));
            paramMapping.forEach((m, j) => m.set(tempParams, best_x[j]));
            
            const hklList = generateHKL(Math.max(...workingData.tth), tempParams, system, centering);
            leBailIntensityExtraction(workingData, hklList, tempParams);
            
            const { pattern: workingPattern } = calculatePattern(workingData.tth, hklList, tempParams, workingData.tth);
            const progressWeights = calculateFitWeights(workingData, hklList, tempParams);
            const rwp = calculateRwp(workingData.intensity, workingPattern, progressWeights);
            
            if (progressCallback) {
                await progressCallback(i / maxSteps, tempParams, rwp);
            }
        }
    }

    let finalParams = JSON.parse(JSON.stringify(initialParams));
    paramMapping.forEach((m, i) => m.set(finalParams, best_x[i]));
    
    // Return the entire results object
    return { params: finalParams, algorithm: 'sa', paramMapping, fitFlags };
}

        async function refineParametersLM(initialParams, fitFlags, maxIter, system, centering, progressCallback) {
    const { paramMapping } = getParameterMapping(fitFlags);
    if (paramMapping.length === 0) {
        return { params: initialParams, algorithm: 'lm', paramMapping, fitFlags };
    }

    let params = JSON.parse(JSON.stringify(initialParams));
    let lambda = 0.001;
    const workingData = getWorkingData();

    const objective = (p_vec, current_params, hklList) => {
        let tempParams = JSON.parse(JSON.stringify(current_params));
        paramMapping.forEach((m, i) => m.set(tempParams, p_vec[i]));
        
        const { pattern } = calculatePattern(workingData.tth, hklList, tempParams, workingData.tth);
        const weights = calculateFitWeights(workingData, hklList, tempParams);
        return { 
            residuals: workingData.intensity.map((y, i) => (y - pattern[i])),
            weights: weights
        };
    };

    let last_cost = Infinity, JtJ, finalResiduals;

    for (let iter = 0; iter < maxIter; iter++) {
        let hklList = generateHKL(Math.max(...workingData.tth), params, system, centering);
        leBailIntensityExtraction(workingData, hklList, params);

        let p_current_vec = paramMapping.map(m => m.get(params));
        const { residuals, weights } = objective(p_current_vec, params, hklList);
        const weightedResiduals = residuals.map((r, i) => r * Math.sqrt(weights[i]));

        finalResiduals = residuals;
        const cost = dot(weightedResiduals, weightedResiduals);

        if (Math.abs(last_cost - cost) < 1e-9 * last_cost && iter > 0) { last_cost = cost; break; }
        last_cost = cost;

        const jacobian = [];
        for (let i = 0; i < p_current_vec.length; i++) {
            const p_plus = [...p_current_vec];
            p_plus[i] += paramMapping[i].step;
            let tempParamsForDerivative = JSON.parse(JSON.stringify(params));
            paramMapping.forEach((m, j) => m.set(tempParamsForDerivative, p_current_vec[j]));
            paramMapping[i].set(tempParamsForDerivative, p_plus[i]);

            let hklList_plus = generateHKL(Math.max(...workingData.tth), tempParamsForDerivative, system, centering);
            leBailIntensityExtraction(workingData, hklList_plus, tempParamsForDerivative);
            
            // un truc étrange, erreur ? à voir, faut passer 'tempParamsForDerivative'
            const { residuals: res_plus, weights: weights_plus } = objective(p_plus, tempParamsForDerivative, hklList_plus);
            const weighted_res_plus = res_plus.map((r, j) => r * Math.sqrt(weights_plus[j]));
            
            const deriv = scale(subtract(weighted_res_plus, weightedResiduals), 1 / paramMapping[i].step);
            jacobian.push(deriv);
        }
        for(let i = 0; i < jacobian.length; i++) { 
            for(let j = 0; j < jacobian[i].length; j++) { 
                if (!isFinite(jacobian[i][j])) { jacobian[i][j] = 0; } 
            } 
        }
        
        const J = transpose(jacobian);
        JtJ = multiply(transpose(J), J);
        const Jtr = multiply(transpose(J), weightedResiduals);
        const A_lm = JSON.parse(JSON.stringify(JtJ));
        for (let i = 0; i < A_lm.length; i++) { A_lm[i][i] += lambda * (A_lm[i][i] || 1.0); }
        const p_step = solve(A_lm, scale(Jtr, -1));

        if (p_step.some(isNaN)) { console.error("Stopping LM: NaN detected in parameter step."); break; }

        const p_new_vec = add(p_current_vec, p_step);
        let tempParamsNew = JSON.parse(JSON.stringify(params));
        paramMapping.forEach((m, i) => m.set(tempParamsNew, p_new_vec[i]));
        let hklListNew = generateHKL(Math.max(...workingData.tth), tempParamsNew, system, centering);
        leBailIntensityExtraction(workingData, hklListNew, tempParamsNew);
        
        const { residuals: new_residuals, weights: new_weights } = objective(p_new_vec, params, hklListNew);
        const weighted_new_residuals = new_residuals.map((r, i) => r * Math.sqrt(new_weights[i]));
        const new_cost = dot(weighted_new_residuals, weighted_new_residuals);
        
        if (new_cost < cost && isFinite(new_cost)) {
            params = tempParamsNew;
            lambda = Math.max(lambda / 2, 1e-9);
        } else {
            lambda = Math.min(lambda * 2, 1e9);
        }
        
        const { pattern: workingPattern } = calculatePattern(workingData.tth, hklList, params, workingData.tth);
        const rwp = calculateRwp(workingData.intensity, workingPattern, weights);

        if (progressCallback) await progressCallback((iter + 1) / maxIter, params, rwp);
    }
    
    // Return the entire results object instead of just params
    return { params, JtJ, finalResiduals, paramMapping, ss_res: last_cost, algorithm: 'lm', fitFlags };
}

        function updatePreviewPattern() {
            if (!mainChart || fullExperimentalData.tth.length === 0 || isFitting) return;

            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);

            const calculatedDataset = findDataset('Calculated');
            const differenceDataset = findDataset('Difference');
            if (calculatedDataset) calculatedDataset.data = [];
            if (differenceDataset) differenceDataset.data = [];

            const { system, centering } = getSystemAndCentering();
            const params = getAllParams();
            
            const requiredParams = {
                cubic: ['a'], tetragonal: ['a', 'c'], orthorhombic: ['a', 'b', 'c'],
                hexagonal: ['a', 'c'], rhombohedral: ['a', 'alpha'], monoclinic: ['a', 'b', 'c', 'beta']
            };
            const coreParams = ['lambda', 'zeroShift', 'GU', 'GV', 'GW', 'GP', 'LX', 'eta', 'shft', 'trns'];
            for (const p of coreParams) if (isNaN(params[p])) return;
            if (isNaN(params.lambda) || params.lambda <= 0) return;
            if (requiredParams[system]) {
                for (const p of requiredParams[system]) {
                    if (isNaN(params[p]) || (!['alpha', 'beta', 'gamma'].includes(p) && params[p] <= 0)) return; 
                }
            }

            let hklList = generateHKL(Math.max(...fullExperimentalData.tth), params, system, centering);
            lastGeneratedHklList = hklList;
            
            const arbitraryIntensity = Math.max(...fullExperimentalData.intensity) * 0.5;
            hklList.forEach(p => p.intensity = arbitraryIntensity);

            const workingData = getWorkingData();
            const { pattern, background } = calculatePattern(fullExperimentalData.tth, hklList, params, workingData.tth.length > 0 ? workingData.tth : null);
            
            findDataset('Simulation (Manual)').data = fullExperimentalData.tth.map((t, i) => ({x: t, y: pattern[i]}));
            findDataset('Background').data = fullExperimentalData.tth.map((t, i) => ({x: t, y: background[i]}));
            
            const yMax = mainChart.options.scales.y.max / 1.1;
            const markerHeight = -yMax * 0.05;

            findDataset('HKL Markers').data = hklList.map(hkl => ({ 
                x: hkl.tth + params.zeroShift, 
                y: markerHeight,
                hkl: `${hkl.hkl_list[0]} [m=${hkl.multiplicity}]`
            }));
            
            mainChart.update('none');
        }

        function setUIState(fitting) {
            isFitting = fitting;
            controls.fitButton.disabled = fitting;
            controls.reportButton.disabled = fitting;
            controls.saveDataButton.disabled = fitting;
            controls.fitButton.textContent = fitting ? 'Refining...' : 'Run Refinement';
            controls.progressBarContainer.classList.toggle('hidden', !fitting);
            document.body.style.cursor = fitting ? 'wait' : 'default';

            const rwpCard = controls.rwpResult.parentElement.parentElement;
            if (fitting) {
                controls.rpResult.textContent = '...'; 
                controls.rwpResult.textContent = '...'; 
                controls.chi2Result.textContent = '...';
            }

            if (!fitting) {
                controls.progressBar.style.width = '0%';
                if(fitResults) {
                    controls.reportButton.disabled = false;
                    controls.saveDataButton.disabled = false;
                }
                rwpCard.querySelectorAll('.result-card').forEach(c => c.style.background = '');
            }
        }
        
        function updateUI(params, stats, calcPattern, background) {
            if (stats.r_p !== undefined) controls.rpResult.textContent = stats.r_p.toFixed(4);
            if (stats.rwp !== undefined) controls.rwpResult.textContent = stats.rwp.toFixed(4);
            if (stats.chi2 !== undefined) controls.chi2Result.textContent = stats.chi2.toFixed(4);
            
            if (params.a && document.getElementById('lattice-param-a')) document.getElementById('lattice-param-a').value = params.a.toFixed(5);
            if (params.b && document.getElementById('lattice-param-b')) document.getElementById('lattice-param-b').value = params.b.toFixed(5);
            if (params.c && document.getElementById('lattice-param-c')) document.getElementById('lattice-param-c').value = params.c.toFixed(5);
            if (params.alpha && document.getElementById('lattice-param-alpha')) document.getElementById('lattice-param-alpha').value = params.alpha.toFixed(4);
            if (params.beta && document.getElementById('lattice-param-beta')) document.getElementById('lattice-param-beta').value = params.beta.toFixed(4);
            if (params.gamma && document.getElementById('lattice-param-gamma')) document.getElementById('lattice-param-gamma').value = params.gamma.toFixed(4);

            controls.zeroShift.value = params.zeroShift.toFixed(4);
            controls.paramGU.value = params.GU.toFixed(4);
            controls.paramGV.value = params.GV.toFixed(4);
            controls.paramGW.value = params.GW.toFixed(4);
            controls.paramGP.value = params.GP.toFixed(4);
            controls.paramLX.value = params.LX.toFixed(4);
            controls.paramEta.value = params.eta.toFixed(4);
            controls.paramShft.value = params.shft.toFixed(4);
            controls.paramTrns.value = params.trns.toFixed(4);
            document.getElementById('bg-param-neg1').value = params.bg_inv.toExponential(4);
            params.bg.forEach((val, i) => {
                document.getElementById(`bg-param-${i}`).value = val.toExponential(4);
            });
            if (calcPattern && background) {
                const { system, centering } = getSystemAndCentering();
                const hklList = generateHKL(Math.max(...fullExperimentalData.tth), params, system, centering);
                lastGeneratedHklList = hklList;
                updateChart(calcPattern, background, hklList, params);
            }
        }



        function initializeChart() {
            if (mainChart) mainChart.destroy();

            const experimentalPoints = fullExperimentalData.tth.map((t, i) => ({x: t, y: fullExperimentalData.intensity[i]}));
            const yMax = Math.max(...fullExperimentalData.intensity) || 1000;

            mainChart = new Chart(controls.mainChartCanvas, {
                type: 'line', 
                data: { 
                    datasets: [
                        { label: 'Experimental', data: experimentalPoints, borderColor: 'rgba(107, 114, 128, 0.7)', borderWidth: 1.5, pointRadius: 0, order: 1 },
                        { label: 'Simulation (Manual)', data: [], borderColor: 'rgba(249, 115, 22, 0.8)', borderWidth: 2, pointRadius: 0, borderDash: [8, 4], order: 2 },
                        { label: 'Calculated', data: [], borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 2, pointRadius: 0, order: 3 },
                        { label: 'Background', data: [], borderColor: 'rgba(217, 119, 6, 0.8)', borderWidth: 1.5, pointRadius: 0, borderDash: [5, 5], order: 4 },
                        { label: 'Difference', data: [], borderColor: 'rgba(239, 68, 68, 0.8)', borderWidth: 1.5, pointRadius: 0, order: 5 },
                        { label: 'Difference Zero', data: [], borderColor: 'rgba(156, 163, 175, 0.8)', borderWidth: 1, pointRadius: 0, borderDash: [2, 2], order: 6 },
                        { type: 'bar', label: 'HKL Markers', data: [], backgroundColor: 'rgba(22, 163, 74, 0.9)', barThickness: 2, categoryPercentage: 1.0, barPercentage: 1.0, order: 0 },
                    ]
                },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    animation: false, 
                    scales: { 
                        x: { 
                            type: 'linear',
                            title: { display: true, text: '2θ (degrees)', font: { size: 14 }},
                        },
// digits
y: {
    type: 'linear',
    position: 'left',
    title: { display: true, text: 'Intensity (a.u.)', font: { size: 14 }},
    min: -yMax * 0.3, 
    max: Math.ceil(yMax * 1.1),
    ticks: {
        callback: function(value, index, ticks) {
            if (value >= 0) {
                
                return value.toFixed(1);
            }
            // This preserves the logic to hide negative ticks
            return null; 
        }
    }
}

                    }, 
plugins: {
  zoom: {
    pan: {
      enabled: true,
      mode: 'xy',
      threshold: 5,
    },
    zoom: {
      // ---Disable the plugin's default wheel handler ---
      wheel: {
        enabled: false,
      },
      pinch: {
        enabled: true,
      },
      drag: {
          enabled: false,
      }
    }
  },

  legend: { 
    labels: {
      filter: item => item.text !== 'Difference Zero' && item.text !== 'Simulation (Manual)'
    }
  },

                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            position: 'experimentalAnchor',
                            callbacks: {
                                /**
                                 * Creates the tooltip title. It now uses a dynamic tolerance based on the
                                 * FWHM of the nearest peak to decide when to show the HKL indices. 
                                 * Trop de boulot pour pas grand chose
                                 */
                                title: function(tooltipItems) {
                                    if (!tooltipItems.length) {
                                        return '';
                                    }
                                    const firstItem = tooltipItems[0];
                                    const tth = firstItem.parsed.x;
                                    let title = `2θ: ${tth.toFixed(2)}`;

                                    if (lastGeneratedHklList && lastGeneratedHklList.length > 0) {
                                        let closestPeak = null;
                                        let minDiff = Infinity;
                                        
                                        const currentParams = getAllParams();
                                        const zeroShift = currentParams.zeroShift || 0;

                                        // First, find the single closest peak to the cursor
                                        for (const hkl of lastGeneratedHklList) {
                                            const peakPos = hkl.tth + zeroShift;
                                            const diff = Math.abs(tth - peakPos);
                                            if (diff < minDiff) {
                                                minDiff = diff;
                                                closestPeak = hkl;
                                            }
                                        }

                                        
                                        // If a closest peak was found, calculate its FWHM
                                        if (closestPeak) {
                                            // Call the existing function to get width components
                                            const { gamma_G, gamma_L } = calculateProfileWidths(closestPeak.tth, currentParams);
                                            
                                            // A good approximation for pseudo-Voigt FWHM is the sum of its components
                                            const fwhm = gamma_G + gamma_L;
                                            
                                            // The tolerance is half of the peak's full width... ou  1 ?
                                            const dynamicTolerance = fwhm;

                                            // Check if the cursor is within this dynamic tolerance
                                            if (minDiff < dynamicTolerance) {
                                                title += `, HKL: ${closestPeak.hkl_list[0]} [m=${closestPeak.multiplicity}])`;
                                            }
                                        }
                                        // --- END NEW LOGIC ---
                                    }
                                    return title;
                                },
                                /**
                                 * This function formats each line inside the tooltip.
                                 **/
                                label: function(context) {
                                    const datasetLabel = context.dataset.label || '';

                                    if (datasetLabel === 'HKL Markers') {
                                        return null;
                                    }

                                    if (datasetLabel === 'Difference') {
                                        const yMax = mainChart.options.scales.y.max / 1.1;
                                        const dYmax = Math.max(1, ...lastRawDifference.map(Math.abs));
                                        const diffPlotHeightRatio = 0.33;
                                        const diffPlotOffset = -yMax * (diffPlotHeightRatio / 2);
                                        const availableAmplitude = yMax * (diffPlotHeightRatio / 2) * 0.9;
                                        const scalingFactor = availableAmplitude / dYmax;
                                        const realValue = (context.parsed.y - diffPlotOffset) / scalingFactor;
                                        return `${datasetLabel}: ${Math.round(realValue)}`;
                                    }

                                    if (datasetLabel === 'Difference Zero' || datasetLabel === 'Simulation (Manual)') {
                                        return null;
                                    }
                                    
                                    let label = datasetLabel ? `${datasetLabel}: ` : '';
                                    if (context.parsed.y !== null) {
                                        label += Math.round(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }

                    } 
                }
            });
        }

        function updatePlotRange() {
            if(!mainChart || !fullExperimentalData || fullExperimentalData.tth.length === 0) return;
            const min = parseFloat(controls.tthMinSlider.value);
            const max = parseFloat(controls.tthMaxSlider.value);

            mainChart.options.scales.x.min = min;
            mainChart.options.scales.x.max = max;

            let yMaxInRange = 1; 
            for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                if (fullExperimentalData.tth[i] >= min && fullExperimentalData.tth[i] <= max) {
                    if (fullExperimentalData.intensity[i] > yMaxInRange) {
                        yMaxInRange = fullExperimentalData.intensity[i];
                    }
                }
            }
            
            const diffPlotHeightRatio = 0.33;
            mainChart.options.scales.y.max = Math.ceil(yMaxInRange * 1.1);
            mainChart.options.scales.y.min = -yMaxInRange * diffPlotHeightRatio;

            const hklDataset = mainChart.data.datasets.find(d => d.label === 'HKL Markers');
            if (hklDataset && hklDataset.data.length > 0) {
                const new_marker_y = -yMaxInRange * 0.05;
                hklDataset.data.forEach(point => point.y = new_marker_y);
            }
        }
        
        function updateChart(calcPattern, background, hklList, params) {
            if (!mainChart) return;
            
            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            
            findDataset('Simulation (Manual)').data = []; 
            
            findDataset('Calculated').data = fullExperimentalData.tth.map((t, i) => ({x: t, y: calcPattern[i]})); 
            findDataset('Background').data = fullExperimentalData.tth.map((t, i) => ({x: t, y: background[i]})); 
            
            lastRawDifference = fullExperimentalData.intensity.map((y, i) => y - calcPattern[i]);

            updatePlotRange(); 

            const yMax = mainChart.options.scales.y.max / 1.1;
            const diffPlotHeightRatio = 0.33;
            
            let dYmax = 1;
            const min = parseFloat(controls.tthMinSlider.value);
            const max = parseFloat(controls.tthMaxSlider.value);
            if (lastRawDifference.length > 0) {
                 for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                    if (fullExperimentalData.tth[i] >= min && fullExperimentalData.tth[i] <= max) {
                        dYmax = Math.max(dYmax, Math.abs(lastRawDifference[i]));
                    }
                }
            }

            const diffPlotOffset = -yMax * (diffPlotHeightRatio / 2);
            const availableAmplitude = yMax * (diffPlotHeightRatio / 2) * 0.9;
            const scalingFactor = availableAmplitude / dYmax;

            findDataset('Difference').data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: (lastRawDifference[i] * scalingFactor) + diffPlotOffset }));
            
            findDataset('Difference Zero').data = [
                {x: fullExperimentalData.tth[0], y: diffPlotOffset},
                {x: fullExperimentalData.tth[fullExperimentalData.tth.length-1], y: diffPlotOffset}
            ];

            const markerHeight = -yMax * 0.05;

            findDataset('HKL Markers').data = hklList.map(hkl => ({ 
                x: hkl.tth + params.zeroShift, 
                y: markerHeight,
            hkl: `${hkl.hkl_list[0]} [m=${hkl.multiplicity}]`
            }));
            
            mainChart.update('none');
        }

        function rescalePlot() {
            if (!mainChart || !fullExperimentalData.tth.length) return;

            updatePlotRange();

            if (lastRawDifference && lastRawDifference.length > 0) {
                const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
                
                const yMaxInRange = mainChart.options.scales.y.max / 1.1;
                const diffPlotHeightRatio = 0.33;

                let dYmax = 1;
                const min = parseFloat(controls.tthMinSlider.value);
                const max = parseFloat(controls.tthMaxSlider.value);
                for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                    if (fullExperimentalData.tth[i] >= min && fullExperimentalData.tth[i] <= max) {
                        dYmax = Math.max(dYmax, Math.abs(lastRawDifference[i]));
                    }
                }

                const diffPlotOffset = -yMaxInRange * (diffPlotHeightRatio / 2);
                const availableAmplitude = yMaxInRange * (diffPlotHeightRatio / 2) * 0.9;
                const scalingFactor = availableAmplitude / dYmax;

                findDataset('Difference').data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: (lastRawDifference[i] * scalingFactor) + diffPlotOffset }));
                findDataset('Difference Zero').data = [
                    {x: fullExperimentalData.tth[0], y: diffPlotOffset},
                    {x: fullExperimentalData.tth[fullExperimentalData.tth.length-1], y: diffPlotOffset}
                ];
            }
            mainChart.update('none');
        }

        controls.fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                let parsedData = null;
                const fileNameLower = file.name.toLowerCase();

                if (fileNameLower.endsWith('.xrdml')) {
                    parsedData = parseXrdmlFile(evt.target.result);
                    if (parsedData && parsedData.wavelength) {
                        controls.wavelength.value = parsedData.wavelength.toFixed(5);
                        const presetOption = Array.from(controls.wavelengthPreset.options).find(opt => Math.abs(parseFloat(opt.value) - parsedData.wavelength) < 0.001);
                        const customOption = document.querySelector('#wavelength-preset option[value="custom"]');
                        
                        if (presetOption) {
                            controls.wavelengthPreset.value = presetOption.value;
                            customOption.style.display = 'none';
                        } else {
                            customOption.style.display = '';
                            customOption.textContent = `XRDML (${parsedData.wavelength.toFixed(4)} Å)`;
                            controls.wavelengthPreset.value = 'custom';
                        }
                    }
                } else {
                    const data = parseDataFile(evt.target.result);
                    if (data.tth.length > 0) {
                        parsedData = { tth: data.tth, intensity: data.intensity };
                    }
                }

                if (!parsedData || parsedData.tth.length === 0) {
                    alert('No valid data could be parsed from the file.');
                    return;
                }

                fullExperimentalData = { tth: parsedData.tth, intensity: parsedData.intensity };
                lastRawDifference = []; 

                const maxExpIntensity = Math.max(...fullExperimentalData.intensity);
                if (maxExpIntensity > 0) {
                    fullExperimentalData.intensity = fullExperimentalData.intensity.map(y => (y / maxExpIntensity) * 1000);
                }

                controls.fileName.textContent = file.name;
                controls.placeholder.classList.add('hidden');
                controls.resultsContainer.classList.add('flex');
                controls.resultsContainer.classList.remove('hidden');
                controls.fitButton.disabled = false;
                controls.fitButton.textContent = 'Run Refinement';

                

                initializeChart();
                
                const min = fullExperimentalData.tth[0];
                const max = fullExperimentalData.tth[fullExperimentalData.tth.length - 1];
                const step = (max - min) / 2000;
                [controls.tthMinSlider, controls.tthMaxSlider].forEach(slider => {
                    slider.min = min; slider.max = max; slider.step = step; slider.disabled = false;
                });
                const initialMin = Math.floor(min);
                const initialMax = Math.ceil(max);
                controls.tthMinSlider.value = initialMin;
                controls.tthMaxSlider.value = initialMax;
                controls.tthMinValue.textContent = initialMin.toFixed(1); 
                controls.tthMaxValue.textContent = initialMax.toFixed(1);

                updatePreviewPattern();
                rescalePlot();
            };
            reader.readAsText(file);
        });

        controls.wavelengthPreset.addEventListener('change', () => {
            if (controls.wavelengthPreset.value !== 'custom') {
                controls.wavelength.value = controls.wavelengthPreset.value;
                updatePreviewPattern(); 
            }
        });

        controls.wavelength.addEventListener('input', () => {
            const customWavelength = controls.wavelength.value;
            let isPreset = false;
            for (const option of controls.wavelengthPreset.options) {
                if (option.value !== 'custom' && Math.abs(parseFloat(option.value) - parseFloat(customWavelength)) < 0.00001) {
                    controls.wavelengthPreset.value = option.value;
                    isPreset = true;
                    break;
                }
            }
            
            if (!isPreset) {
                const customOption = controls.wavelengthPreset.querySelector('option[value="custom"]');
                customOption.style.display = '';
                customOption.textContent = `Custom (${parseFloat(customWavelength).toFixed(4)} Å)`;
                controls.wavelengthPreset.value = 'custom';
            }
        });
        
        controls.latticeParamsContainer.addEventListener('input', updatePreviewPattern);

        const previewInputs = Object.values(controls).filter(el => el && (el.tagName === 'INPUT' || el.tagName === 'SELECT'));
            previewInputs.forEach(input => {
                // Exclude the 2-theta range sliders from triggering the preview update.
                if (input.id !== 'file-input' && input.id !== 'tth-min-slider' && input.id !== 'tth-max-slider' && input.id !== 'bravais-lattice') {
                    input.addEventListener('input', updatePreviewPattern);
                }
            });

        controls.fitButton.addEventListener('click', runLeBailFit);

        const tabNav = document.querySelector('.tab-nav');
        tabNav.addEventListener('click', (e) => {
            if (e.target.classList.contains('tab-button')) {
                tabNav.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
                document.getElementById(`tab-panel-${e.target.dataset.tab}`).classList.add('active');
            }
        });
        
        function createBackgroundControls() {
            let html = `<label class="control-label">B-1 (1/2θ)</label><input type="number" id="bg-param-neg1" value="0.0" step="0.1" class="control-input"><input type="checkbox" id="fit-bg-neg1" class="fit-checkbox" title="Fit this parameter" checked>`;
            
            for (let i = 0; i < NUM_BG_TERMS; i++) {
                html += `<label class="control-label">B${i}</label><input type="number" id="bg-param-${i}" value="0.0" step="0.1" class="control-input"><input type="checkbox" id="fit-bg-${i}" class="fit-checkbox" title="Fit this parameter" ${i < 3 ? 'checked' : ''}>`;
            }
            controls.backgroundContainer.innerHTML = html;
             document.getElementById(`bg-param-neg1`).addEventListener('input', updatePreviewPattern);
             for (let i = 0; i < NUM_BG_TERMS; i++) { document.getElementById(`bg-param-${i}`).addEventListener('input', updatePreviewPattern); }
        }
        
        const resizer = document.getElementById('drag-handle');
        const leftPanel = document.getElementById('controls-panel');
        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault(); document.body.style.cursor = 'col-resize';
            const moveHandler = (moveEvent) => { if (moveEvent.clientX > 350 && moveEvent.clientX < window.innerWidth - 350) { leftPanel.style.width = `${moveEvent.clientX}px`; } };
            const upHandler = () => { document.body.style.cursor = 'default'; window.removeEventListener('mousemove', moveHandler); window.removeEventListener('mouseup', upHandler); };
            window.addEventListener('mousemove', moveHandler);
            window.addEventListener('mouseup', upHandler);
        });


        controls.reportButton.addEventListener('click', async () => {
            if (!fitResults) {
                alert("Please run a refinement before generating a report.");
                return;
            }

            const originalText = controls.reportButton.textContent;
            controls.reportButton.textContent = 'Generating...';
            controls.reportButton.disabled = true;

            try {
                const now = new Date();
                const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}`;
                const baseFilename = `LeBail-Report-${timestamp}`;
                
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                const margin = 15;
                const pdfWidth = doc.internal.pageSize.getWidth();
                const contentWidth = pdfWidth - 2 * margin;

                doc.setFontSize(18);
                doc.text('Le Bail Refinement Report', 105, 15, { align: 'center' });
                doc.setFontSize(10);
                doc.text(`Report Generated: ${now.toLocaleString()}`, margin, 25);
                doc.text(`Program used: LeBail.html, version 14 Sept 2025, nitad54448.github.io`,margin, 30);
                doc.text(`Data File: ${controls.fileName.textContent}`, margin, 35);
                const chartCanvas = await html2canvas(controls.mainChartCanvas, { backgroundColor: '#ffffff' });
                const mainImgData = chartCanvas.toDataURL('image/png');
                const mainImgProps = doc.getImageProperties(mainImgData);
                const mainImgHeight = (mainImgProps.height * contentWidth) / mainImgProps.width;
                
                doc.addImage(mainImgData, 'PNG', margin, 40, contentWidth, mainImgHeight);

                doc.addPage();
                let yPos = 20;
                doc.setFont('Helvetica', 'bold');
                doc.setFontSize(16);
                doc.text('Refinement Parameters & Statistics', margin, yPos);
                yPos += 10;
                
                const { system, centering } = getSystemAndCentering();
                const finalParams = fitResults.params;
                const fitFlags = fitResults.fitFlags;

                let esds = {};
                let esdWarning = null;

                if (fitResults.algorithm === 'lm' && fitResults.JtJ) {
                    const N = fitResults.finalResiduals.length;
                    const P = fitResults.paramMapping.length;
                    if (N > P && fitResults.ss_res !== undefined) {
                        const reduced_chi_sq = fitResults.ss_res / (N - P);
                        const cov_matrix = matrixInverse(fitResults.JtJ);
                        if (cov_matrix) {
                            fitResults.paramMapping.forEach((p, i) => {
                                if (cov_matrix[i] && cov_matrix[i][i] !== undefined) {
                                    esds[p.name] = Math.sqrt(Math.abs(reduced_chi_sq * cov_matrix[i][i]));
                                }
                            });
                        } else {
                            esdWarning = 'ESD calculation failed (unstable refinement or correlated parameters).';
                        }
                    }
                }
                
                const lineSpacing = 5;
                const addLine = (text) => { doc.text(text, margin, yPos); yPos += lineSpacing; };
                const addHeader = (text) => { yPos += 4; doc.setFont('Helvetica', 'bold'); doc.text(text, margin, yPos); yPos += (lineSpacing + 1); doc.setFont('Courier', 'normal'); };
                
                doc.setFontSize(9);
                doc.setFont('Courier', 'normal');
                
                addLine(`Rp (%):      ${fitResults.stats.r_p.toFixed(2)}`);
                addLine(`Rwp (%):     ${fitResults.stats.rwp.toFixed(2)}`);
                addLine(`Chi2 (GOF):    ${fitResults.stats.chi2.toFixed(4)}`);
                addLine(`Algorithm:   ${fitResults.algorithm === 'lm' ? 'Levenberg-Marquardt' : 'Simulated Annealing'}`);
                yPos += lineSpacing;
                
                addHeader('Structural Parameters');
                
                const paramTableLine = (name, value, flag, esd) => {
                    const valStr = (value !== undefined && value !== null) ? value.toExponential(6) : 'N/A';
                    const fitStr = flag ? 'Yes' : 'No';
                    const esdStr = (flag && esd !== undefined) ? `(${esd.toExponential(2)})` : '-';
                    return `${name.padEnd(14)}${valStr.padStart(14)} ${fitStr.padStart(8)}   ${esdStr.padStart(15)}`;
                };
                
                const allParams = [
                    { name: 'a (Å)', value: finalParams.a, flag: fitFlags.a, esd_name: 'a' },
                    { name: 'b (Å)', value: finalParams.b, flag: fitFlags.b, esd_name: 'b' },
                    { name: 'c (Å)', value: finalParams.c, flag: fitFlags.c, esd_name: 'c' },
                    { name: 'alpha (°)', value: finalParams.alpha, flag: fitFlags.alpha, esd_name: 'alpha' },
                    { name: 'beta (°)', value: finalParams.beta, flag: fitFlags.beta, esd_name: 'beta' },
                    { name: 'gamma (°)', value: finalParams.gamma, flag: fitFlags.gamma, esd_name: 'gamma' }
                ];
                
                const selectedOption = controls.bravaisLattice.options[controls.bravaisLattice.selectedIndex];
                addLine(`System: ${selectedOption.text}`);
                addLine('--------------------------------------------------------------');
                addLine('Parameter      Value           Fitted          ESD');
                addLine('--------------------------------------------------------------');
                allParams.forEach(p => { if (p.value) addLine(paramTableLine(p.name, p.value, p.flag, esds[p.esd_name])); });
                
                if (esdWarning) {
                    yPos += 2;
                    doc.setFont('Helvetica', 'italic');
                    doc.setTextColor(255, 0, 0);
                    doc.text(esdWarning, margin, yPos);
                    doc.setTextColor(0, 0, 0);
                    doc.setFont('Courier', 'normal');
                    yPos += lineSpacing;
                }

                addHeader('Instrument & Profile Parameters');
                addLine('--------------------------------------------------------------');
                addLine('Parameter      Value           Fitted          ESD');
                addLine('--------------------------------------------------------------');
                addLine(paramTableLine('Wavelength (Å)', finalParams.lambda, false, null));
                addLine(paramTableLine('Zero Shift (°)', finalParams.zeroShift, fitFlags.zeroShift, esds['zeroShift']));
                addLine(paramTableLine('GU', finalParams.GU, fitFlags.GU, esds['GU']));
                addLine(paramTableLine('GV', finalParams.GV, fitFlags.GV, esds['GV']));
                addLine(paramTableLine('GW', finalParams.GW, fitFlags.GW, esds['GW']));
                addLine(paramTableLine('GP', finalParams.GP, fitFlags.GP, esds['GP']));
                addLine(paramTableLine('LX', finalParams.LX, fitFlags.LX, esds['LX']));
                addLine(paramTableLine('eta', finalParams.eta, fitFlags.eta, esds['eta']));
                addLine(paramTableLine('shft', finalParams.shft, fitFlags.shft, esds['shft']));
                addLine(paramTableLine('trns', finalParams.trns, fitFlags.trns, esds['trns']));

                addHeader('Background Parameters');
                addLine('--------------------------------------------------------------');
                addLine('Parameter      Value           Fitted          ESD');
                addLine('--------------------------------------------------------------');
                addLine(paramTableLine('B-1', finalParams.bg_inv, fitFlags.bg_inv, esds['B-1']));
                finalParams.bg.forEach((val, i) => {
                    if (Math.abs(val) > 1e-9 || fitFlags.background[i]) {
                        addLine(paramTableLine(`B${i}`, val, fitFlags.background[i], esds[`B${i}`]));
                    }
                });

                if (fitResults.weightingParams && fitResults.weightingParams.weightFactor > 1) {
    addHeader('Background Weighting Parameters');
    addLine('--------------------------------------------------------------');
    addLine(`FWHM Widths:      ${fitResults.weightingParams.fwhmWidths.toFixed(2)}`);
    addLine(`Weight Factor:    ${fitResults.weightingParams.weightFactor}`);
}

                doc.addPage();
                yPos = 20;
                doc.setFont('Helvetica', 'bold');
                doc.setFontSize(12);
                doc.text('Calculated vs. Experimental Reflections', margin, yPos);
                yPos += 8;
                doc.setFontSize(9);
                doc.setFont('Courier', 'normal');

                const hklList = generateHKL(Math.max(...fullExperimentalData.tth), finalParams, system, centering);

                const hklHeader = ['h,k,l', 'd_calc (Å)', 'd_exp (Å)', '2th_corr (°)', '2th_exp (°)'];
                const hklAlign = ['left', 'right', 'right', 'right', 'right'];
                const colX = {
                    hkl: margin,
                    d_calc: margin + 35,
                    d_exp: margin + 70,
                    tth_corr: margin + 105,
                    tth_exp: margin + 140
                };
                const hklSeparator = '-'.repeat(120);

                const printHklHeader = () => {
                    doc.text(hklHeader[0], colX.hkl, yPos, { align: hklAlign[0] });
                    doc.text(hklHeader[1], colX.d_calc, yPos, { align: hklAlign[1] });
                    doc.text(hklHeader[2], colX.d_exp, yPos, { align: hklAlign[2] });
                    doc.text(hklHeader[3], colX.tth_corr, yPos, { align: hklAlign[3] });
                    doc.text(hklHeader[4], colX.tth_exp, yPos, { align: hklAlign[4] });
                    yPos += lineSpacing;
                    doc.text(hklSeparator, margin, yPos);
                    yPos += lineSpacing;
                }

                printHklHeader();

                hklList.forEach(hkl => {
                    if (yPos > 280) {
                        doc.addPage();
                        yPos = 20;
                        doc.setFont('Courier', 'normal');
                        doc.setFontSize(9);
                        printHklHeader();
                    }
                    const peakShift = calculatePeakShift(hkl.tth, finalParams);
                    const tthCorr = hkl.tth + finalParams.zeroShift + peakShift;
                    
                    // Find corresponding experimental peak details
                    const { tth_exp, d_exp } = findExperimentalPeakDetails(tthCorr, fullExperimentalData, finalParams.lambda);

                    const d_calc_str = hkl.d.toFixed(5);
                    const d_exp_str = d_exp ? d_exp.toFixed(5) : 'N/A';
                    const tth_corr_str = tthCorr.toFixed(4);
                    const tth_exp_str = tth_exp ? tth_exp.toFixed(4) : 'N/A';

                    doc.text(hkl.hkl_list[0], colX.hkl, yPos, { align: hklAlign[0] });
                    doc.text(d_calc_str, colX.d_calc, yPos, { align: hklAlign[1] });
                    doc.text(d_exp_str, colX.d_exp, yPos, { align: hklAlign[2] });
                    doc.text(tth_corr_str, colX.tth_corr, yPos, { align: hklAlign[3] });
                    doc.text(tth_exp_str, colX.tth_exp, yPos, { align: hklAlign[4] });
                    yPos += lineSpacing;
                });
                
                doc.save(`${baseFilename}.pdf`);

            } catch (error) {
                console.error("Failed to generate report:", error);
                alert("An error occurred while generating the report.");
            } finally {
                controls.reportButton.textContent = originalText;
                controls.reportButton.disabled = false;
            }
        });

        controls.saveDataButton.addEventListener('click', () => {
            if (!fitResults) {
                alert("Please run a refinement before saving data.");
                return;
            }

            const originalText = controls.saveDataButton.textContent;
            controls.saveDataButton.textContent = 'Saving...';
            controls.saveDataButton.disabled = true;
            
            try {
                const now = new Date();
                const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}`;
                const baseFilename = `LeBail-Data-${timestamp}`;
                
                const textContent = generateTextReportContent(fitResults, controls);
                downloadTextFile(textContent, `${baseFilename}.txt`);

            } catch (error) {
                console.error("Failed to save data:", error);
                alert("An error occurred while saving the data file.");
            } finally {
                controls.saveDataButton.textContent = originalText;
                controls.saveDataButton.disabled = false;
            }
        });

        controls.bravaisLattice.addEventListener('change', () => {
            updateLatticeParamUI();
            if (fullExperimentalData.tth.length > 0) {
                updatePreviewPattern();
            }
        });

        // --- Event Listeners for new sliders ---
        controls.iterationsSlider.addEventListener('input', () => {
            controls.iterationsValue.textContent = controls.iterationsSlider.value;
        });

        controls.tthMinSlider.addEventListener('input', () => {
            let minVal = parseFloat(controls.tthMinSlider.value);
            let maxVal = parseFloat(controls.tthMaxSlider.value);
            if (minVal >= maxVal) {
                minVal = maxVal - parseFloat(controls.tthMinSlider.step);
                controls.tthMinSlider.value = minVal;
            }
            controls.tthMinValue.textContent = minVal.toFixed(1);
            rescalePlot();
        });

        controls.tthMaxSlider.addEventListener('input', () => {
            let minVal = parseFloat(controls.tthMinSlider.value);
            let maxVal = parseFloat(controls.tthMaxSlider.value);
            if (maxVal <= minVal) {
                maxVal = minVal + parseFloat(controls.tthMaxSlider.step);
                controls.tthMaxSlider.value = maxVal;
            }
            controls.tthMaxValue.textContent = maxVal.toFixed(1);
            rescalePlot();
        });
        
 // --- Wheel Zoom with Differential Axis Control ---
controls.mainChartCanvas.addEventListener('wheel', e => {
    e.preventDefault();

    const chart = mainChart;
    if (!chart || !chart.chartArea) return;

    const { left, right, top, bottom } = chart.chartArea;
    const x = e.offsetX;
    const y = e.offsetY;

    const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;

    if (y > bottom) {
        // Cursor is below the plot area → zoom X only
        chart.zoom({ x: zoomFactor }, { x, y });
           } else if (x < left) {
        // Cursor is left of the plot area → zoom Y only
        chart.zoom({ y: zoomFactor }, { x, y });
           } else if (x >= left && x <= right && y >= top && y <= bottom) {
        // Cursor is inside the plot area → zoom both
        chart.zoom({ x: zoomFactor, y: zoomFactor }, { x, y });
    }
});

// --- Right-Click Reset Zoom ---
controls.mainChartCanvas.addEventListener('contextmenu', e => {
    e.preventDefault(); // prevent browser menu... on ne peut pas sauvegarder l'image directement...
    if (mainChart) {
        mainChart.resetZoom();
    }
});



        controls.bgWeightFactorSlider.addEventListener('input', () => {
    controls.bgWeightFactorValue.textContent = controls.bgWeightFactorSlider.value;
});

controls.fwhmWidthsSlider.addEventListener('input', () => {
    controls.fwhmWidthsValue.textContent = parseFloat(controls.fwhmWidthsSlider.value).toFixed(1);
});
        

        // Set initial state of checkboxes on load
        ['fitGU', 'fitGV', 'fitGW', 'fitLX', 'fitZeroShift', 'fitShft'].forEach(key => {
            if (controls[key]) controls[key].checked = false;
        });

        updateLatticeParamUI();
        createBackgroundControls();
    });
</script>
</body>
</html>