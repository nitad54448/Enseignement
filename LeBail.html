<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Le Bail Fit (GSAS Profile 4)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        :root {
            --system-blue: #007AFF;
            --system-gray-1: #8E8E93;
            --system-gray-2: #AEAEB2;
            --system-gray-3: #C7C7CC;
            --system-gray-4: #D1D1D6;
            --system-gray-5: #E5E5EA;
            --system-gray-6: #F2F2F7;
            --system-background: #FFFFFF;
            --system-grouped-background: #F2F2F7;
            --system-material-thin: rgba(255, 255, 255, 0.7);
            --system-material-regular: rgba(255, 255, 255, 0.8);
            --system-label: #000000;
            --system-secondary-label: rgba(60, 60, 67, 0.6);
            --system-tertiary-label: rgba(60, 60, 67, 0.3);
            --system-separator: rgba(60, 60, 67, 0.29);
            --system-fill: rgba(120, 120, 128, 0.2);
            --system-secondary-fill: rgba(120, 120, 128, 0.16);
            --system-shadow: rgba(0, 0, 0, 0.1);
        }

        #fit-button { width: 100%; }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif; 
            margin: 0; 
            background-color: var(--system-grouped-background); 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            overflow: hidden; 
            color: var(--system-label);
        }
        #app-container { 
            display: flex; 
            width: 100%; 
            flex-grow: 1; 
            min-height: 0; 
            background-color: var(--system-grouped-background);
        }
        
        #controls-panel { 
            width: 380px; 
            min-width: 320px; 
            max-width: 500px; 
            flex-shrink: 0; 
            padding: 16px; 
            background-color: var(--system-background); 
            border-right: 1px solid var(--system-separator); 
            display: flex; 
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            z-index: 20;
            box-shadow: 0 0 20px rgba(0,0,0,0.05);
            border-radius: 0 12px 12px 0;
        }
        
        #drag-handle { 
            width: 6px; 
            cursor: col-resize; 
            background-color: var(--system-gray-5); 
            flex-shrink: 0; 
            transition: background-color 0.2s; 
        }
        #drag-handle:hover, #drag-handle:active { 
            background-color: var(--system-blue); 
        }
        
        #results-area { 
            flex-grow: 1; 
            position: relative; 
            background-color: var(--system-background); 
            min-width: 0; 
            display: flex; 
            flex-direction: column; 
            padding: 20px; 
            z-index: 10;
            border-radius: 12px 0 0 12px;
            margin: 8px 8px 8px 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
        }
        
        .control-group { 
            padding: 16px; 
            margin-bottom: 16px;
            background-color: var(--system-background);
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .control-group:first-child { 
            padding-top: 0; 
            margin-top: 0;
        }
        .control-label { 
            display: block; 
            font-weight: 500; 
            color: var(--system-secondary-label); 
            font-size: 13px; 
            margin-bottom: 6px;
        }
        
        .control-input, .control-select { 
            width: 100%; 
            background-color: var(--system-gray-6); 
            border: 1px solid var(--system-gray-4); 
            color: var(--system-label); 
            border-radius: 8px; 
            padding: 10px 14px; 
            transition: all 0.2s ease; 
            box-sizing: border-box;
            font-size: 15px;
            height: 40px;
        }
        .control-input:focus, .control-select:focus { 
            outline: none; 
            border-color: var(--system-blue); 
            box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2); 
        }
        .control-input:disabled { 
            background-color: var(--system-gray-6);
            color: var(--system-tertiary-label);
            cursor: not-allowed; 
        }
        
        .btn { 
            padding: 12px 20px; 
            border-radius: 10px; 
            font-weight: 600; 
            transition: all 0.2s; 
            cursor: pointer; 
            border: none; 
            text-align: center; 
            font-size: 15px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-primary { 
            background-color: var(--system-blue); 
            color: white; 
            box-shadow: 0 1px 3px rgba(0, 122, 255, 0.3);
        }
        .btn-primary:hover:not(:disabled) { 
            background-color: #006ee6; 
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 122, 255, 0.3);
        }
        .btn-primary:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 122, 255, 0.3);
        }
        .btn-secondary { 
            background-color: var(--system-gray-6); 
            color: var(--system-label); 
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .btn-secondary:hover:not(:disabled) { 
            background-color: var(--system-gray-5); 
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .btn:disabled { 
            background-color: var(--system-gray-6); 
            color: var(--system-tertiary-label);
            cursor: not-allowed; 
            opacity: 0.7; 
            box-shadow: none;
        }
        
        .file-input-label { 
            display: block; 
            padding: 12px 16px; 
            background-color: var(--system-gray-6); 
            color: var(--system-label); 
            border-radius: 10px; 
            text-align: center; 
            cursor: pointer; 
            transition: all 0.2s;
            font-weight: 500;
            border: 1px dashed var(--system-gray-4);
        }
        .file-input-label:hover { 
            background-color: var(--system-gray-5); 
            border-color: var(--system-blue);
        }
        
        .results-grid { 
            display: grid; 
            grid-template-columns: repeat(3, minmax(80px, 1fr)); 
            gap: 12px; 
        }
        .result-card { 
            background-color: var(--system-gray-6); 
            padding: 12px; 
            border-radius: 10px; 
            text-align: center; 
            transition: all 0.2s; 
        }
        .result-card-label { 
            font-size: 12px; 
            color: var(--system-secondary-label); 
            margin-bottom: 4px;
        }
        .result-card-value { 
            font-size: 18px; 
            font-weight: 700; 
            color: var(--system-label); 
        }
        
        .fit-checkbox { 
            -webkit-appearance: none; 
            appearance: none; 
            background-color: var(--system-gray-6); 
            width: 22px; 
            height: 22px; 
            border: 1px solid var(--system-gray-4); 
            border-radius: 6px; 
            cursor: pointer; 
            display: inline-block; 
            position: relative; 
            transition: all 0.2s;
        }
        .fit-checkbox:checked { 
            background-color: var(--system-blue); 
            border-color: var(--system-blue); 
        }
        .fit-checkbox:checked::after { 
            content: '✓'; 
            color: white; 
            position: absolute; 
            left: 50%; 
            top: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 14px; 
            font-weight: bold;
        }
        
        .tab-buttons { 
            display: flex; 
            background-color: var(--system-gray-6);
            border-radius: 10px;
            padding: 4px;
            margin-bottom: 16px;
        }
        .tab-btn { 
            flex: 1; 
            padding: 8px 12px; 
            background: none; 
            border: none; 
            color: var(--system-secondary-label); 
            font-weight: 500; 
            cursor: pointer; 
            border-radius: 8px;
            transition: all 0.2s; 
            font-size: 14px; 
        }
        .tab-btn:hover { 
            color: var(--system-label); 
            background-color: rgba(255,255,255,0.5);
        }
        .tab-btn.active { 
            color: var(--system-blue); 
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .tab-content-panels { 
            position: relative; 
            padding-top: 0; 
        }
        .tab-content-panel { 
            display: none; 
            flex-direction: column; 
        }
        .tab-content-panel.active { 
            display: flex; 
        }

        .tab-content-panel > .control-group {
            border-top: none;
        }

        #lattice-parameters-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .bottom-actions { 
            margin-top: auto; 
            padding-top: 16px;
        }

        .slider-value-track { 
            display: grid; 
            grid-template-columns: 1fr; 
            grid-template-rows: 1fr; 
            align-items: center; 
        }
        .slider-value-track > * { 
            grid-column: 1; 
            grid-row: 1; 
        }
        .slider-value-display { 
            text-align: center; 
            color: var(--system-secondary-label); 
            font-weight: 500; 
            font-size: 13px; 
            pointer-events: none; 
        }
        input[type="range"].custom-slider { 
            -webkit-appearance: none; 
            appearance: none; 
            width: 100%; 
            height: 36px; 
            background: var(--system-gray-6); 
            border-radius: 6px; 
            outline: none; 
            padding: 0; 
            margin: 0; 
        }
        input[type="range"].custom-slider::-webkit-slider-thumb { 
            -webkit-appearance: none; 
            appearance: none; 
            width: 22px; 
            height: 22px; 
            background: var(--system-blue); 
            border-radius: 50%; 
            cursor: pointer; 
            border: 3px solid white; 
            box-sizing: border-box; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        input[type="range"].custom-slider::-moz-range-thumb { 
            width: 22px; 
            height: 22px; 
            background: var(--system-blue); 
            border-radius: 50%; 
            cursor: pointer; 
            border: 3px solid white; 
            box-sizing: border-box; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        input[type="range"].custom-slider:disabled { 
            background: var(--system-gray-6); 
        }
        input[type="range"].custom-slider:disabled::-webkit-slider-thumb { 
            background: var(--system-gray-3); 
        }
        input[type="range"].custom-slider:disabled::-moz-range-thumb { 
            background: var(--system-gray-3); 
        }

        /* --- UNIFIED UI & SPACING STYLES --- */
        #tab-panel-sample > .control-group, #tab-panel-background > .control-group {
            display: flex; 
            flex-direction: column; 
            gap: 16px; 
        }
        
        .control-group h2, .profile-section-header {
            margin: 0 0 16px 0; 
            padding-bottom: 12px; 
            border-bottom: 1px solid var(--system-separator);
            color: var(--system-label); 
            font-size: 17px; 
            font-weight: 600;
        }

        .parameter-grid-3col, .parameter-grid-2col, .slider-group, .form-row {
            display: grid; 
            gap: 12px; 
            align-items: center;
        }
        .parameter-grid-3col { 
            grid-template-columns: minmax(100px, auto) 1fr auto; 
        }
        .parameter-grid-2col, .slider-group, .form-row { 
            grid-template-columns: minmax(100px, auto) 1fr; 
        }
        
        .parameter-grid-3col > .control-label, .parameter-grid-2col > .control-label,
        .slider-group > .control-label, .form-row > .control-label {
            grid-column: 1; 
            margin-bottom: 0;
        }
        
        .parameter-grid-2col > *:not(label), .slider-group > .slider-value-track,
        .form-row > *:not(label) { 
            grid-column: 2; 
        }
        .parameter-grid-3col > .control-input { 
            grid-column: 2; 
        }
        .parameter-grid-3col > .fit-checkbox { 
            grid-column: 3; 
            justify-self: center; 
        }

        #profile-controls-container {
            display: grid; 
            grid-template-columns: minmax(100px, auto) 1fr auto;
            gap: 16px 12px; 
            align-items: center;
        }
        #profile-controls-container > .control-label { 
            grid-column: 1; 
            text-align: left; 
            margin-bottom: 0; 
        }
        #profile-controls-container > input[type="number"] { 
            grid-column: 2; 
        }
        #profile-controls-container > input[type="checkbox"] { 
            grid-column: 3; 
            justify-self: center; 
        }
        #profile-controls-container > .profile-section-header { 
            grid-column: 1 / -1; 
        }
        
        #tab-panel-sample > .control-group:nth-of-type(2) {
            display: grid; 
            grid-template-columns: minmax(100px, auto) 1fr;
            gap: 16px; 
            align-items: center;
        }
        #tab-panel-sample > .control-group:nth-of-type(2) > h2,
        #tab-panel-sample > .control-group:nth-of-type(2) > .parameter-grid-3col {
            grid-column: 1 / -1;
        }
        #tab-panel-sample > .control-group:nth-of-type(2) > label[for="wavelength"] {
            grid-column: 1; 
            margin-bottom: 0;
        }
        #tab-panel-sample > .control-group:nth-of-type(2) > .flex {
            grid-column: 2; 
            display: flex;
        }
        
        .bottom-actions > .control-group {
            display: grid; 
            grid-template-columns: minmax(100px, auto) 1fr;
            gap: 16px; 
            align-items: center; 
            border: none; 
            padding: 0;
        }
        .bottom-actions > .control-group > h2,
        .bottom-actions > .control-group > .slider-group,
        .bottom-actions > .control-group > #progress-bar-container,
        .bottom-actions > .control-group > .results-grid {
            grid-column: 1 / -1;
        }
        .bottom-actions > .control-group > label[for="algorithm-select"] {
            grid-column: 1; 
            margin-bottom: 0;
        }
        .bottom-actions > .control-group > #algorithm-select {
            grid-column: 2; 
            margin-bottom: 0;
        }
        
        /* --- FINAL TOOLTIP AND SCROLLBAR FIX --- */
        .help-tooltip-container { 
            position: relative; 
            display: inline-block; 
        }
.help-icon { 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    width: 24px; 
    height: 24px; 
    background-color: #4a5568; /* Darker background for icon */
    color: white; /* White question mark */
    border-radius: 50%; 
    font-weight: 500; 
    font-size: 14px; 
    cursor: help; 
    transition: all 0.2s; 
}
.help-icon:hover { 
    background-color: #2d3748; /* Even darker on hover */
    color: white;
}
        
.tooltip-content {
    visibility: hidden; 
    opacity: 0; 
    width: 280px;
    background-color: #2d3748; /* Darker background for better contrast */
    color: #f7fafc; /* Light text color */
    text-align: left;
    border-radius: 10px; 
    padding: 16px;
    position: absolute; 
    z-index: 1001;
    top: -15px;
    right: 115%;
    margin-right: 10px;
    transition: opacity 0.3s; 
    font-size: 13px; 
    border: 1px solid #4a5568; /* Darker border */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); /* Stronger shadow */
}
.tooltip-content::after {
    content: ""; 
    position: absolute;
    top: 20px;
    left: 100%;
    margin-top: -5px; 
    border-width: 5px; 
    border-style: solid;
    border-color: transparent transparent transparent #2d3748; /* Match tooltip background */
}
        .help-tooltip-container:hover .tooltip-content { 
            visibility: visible; 
            opacity: 1; 
        }
.tooltip-content h4 { 
    color: #fff; /* White for headings */
    font-size: 15px; 
    margin-top: 0; 
    margin-bottom: 8px; 
    font-weight: 600; 
}
.tooltip-content p { 
    margin-top: 0; 
    margin-bottom: 12px; 
    line-height: 1.4; 
    color: #e2e8f0; /* Lighter gray for paragraph text */
}
.tooltip-content hr { 
    border: none; 
    border-top: 1px solid #4a5568; /* Darker separator */
    margin: 12px 0; 
}
        .hidden { 
            display: none !important; 
        }

        #controls-panel::-webkit-scrollbar { 
            width: 5px; 
        }
        #controls-panel::-webkit-scrollbar-track { 
            background: transparent; 
        }
        #controls-panel::-webkit-scrollbar-thumb { 
            background: var(--system-gray-4); 
            border-radius: 3px; 
        }
        #controls-panel::-webkit-scrollbar-thumb:hover { 
            background: var(--system-gray-3); 
        }

        /* Apple-style progress bar */
        #progress-bar-container {
            height: 5px;
            background-color: var(--system-gray-5);
            border-radius: 3px;
            overflow: hidden;
        }
        #progress-bar {
            height: 100%;
            background-color: var(--system-blue);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        /* Apple-style placeholder */
        #placeholder {
            background-color: var(--system-background);
            border-radius: 12px;
            padding: 40px;
        }
        #placeholder svg {
            color: var(--system-gray-3);
        }

        /* Subtle animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .control-group {
            animation: fadeIn 0.3s ease;
        }

        /* Improved focus states for accessibility */
        .btn:focus-visible,
        .control-input:focus-visible,
        .control-select:focus-visible,
        .fit-checkbox:focus-visible {
            outline: 2px solid var(--system-blue);
            outline-offset: 2px;
        }

    </style>
</head>

<body>

    <div id="app-container">
        <div id="controls-panel">
            
            <div class="control-group" style="padding-top: 16px;">
                 <div style="display: flex; align-items: center; gap: 10px;">
                     <label for="file-input" class="file-input-label" style="flex-grow: 1;">
                        <span id="file-name">Select Data File</span>
                    </label>
                     <div class="help-tooltip-container">
                        <span class="help-icon">?</span>
                        <div class="tooltip-content">
                            <h4>Le Bail Fitting</h4>
                            <p>Refine lattice parameters and profile shape from powder diffraction data. The profile used here is the one defined in GSAS as Profile 4. This method extracts integrated intensities from the raw data based on the calculated peak positions, then refines parameters to minimize the difference between observed and calculated profiles.</p>
                             <p>Based on A. Le Bail et al., J. Appl. Cryst. 21, 249-254 (1988).</p>
                            <hr>
                             <p>Click and drag the plot, use the mouse wheel to zoom (zoom is axis-sensitive), or right-click to reset view.</p>
                        </div>
                    </div>
                </div>
                <input type="file" id="file-input" class="hidden" accept=".xy,.csv,.txt,.xrdml,.brml,.ras,.esd,.std,.udf">
            </div>

            <div class="tab-buttons">
                <button class="tab-btn active" data-tab="sample">Sample</button>
                <button class="tab-btn" data-tab="background">Background</button>
                <button class="tab-btn" data-tab="profile">Profile</button>
            </div>

            <div class="tab-content-panels">
                <div id="tab-panel-sample" class="tab-content-panel active">
                    <div class="control-group">
                        <h2>Structural Parameters</h2>
                        <div class="parameter-grid-2col">
                            <label for="bravais-lattice" class="control-label">System</label>
                            <select id="bravais-lattice" class="control-select">
                                <option value="cubic_F" selected>Cubic (F)</option>
                                <option value="cubic_I">Cubic (I)</option>
                                <option value="cubic_P">Cubic (P)</option>
                                <option value="hexagonal_P">Hexagonal (P)</option>
                                <option value="hexagonal_R">Trigonal (R, Hex. axes)</option>
                                <option value="rhombohedral_P">Rhombohedral (Rhom. axes)</option>
                                <option value="tetragonal_I">Tetragonal (I)</option>
                                <option value="tetragonal_P">Tetragonal (P)</option>
                                <option value="orthorhombic_F">Orthorhombic (F)</option>
                                <option value="orthorhombic_I">Orthorhombic (I)</option>
                                <option value="orthorhombic_C">Orthorhombic (C)</option>
                                <option value="orthorhombic_P">Orthorhombic (P)</option>
                                <option value="monoclinic_C">Monoclinic (C)</option>
                                <option value="monoclinic_P">Monoclinic (P)</option>
                            </select>
                        </div>
                        <div id="lattice-parameters-container">
                        </div>
                    </div>
                    <div class="control-group">
                        <h2>Instrumental Parameters</h2>
                        <label for="wavelength" class="control-label">Radiation (Å)</label>
                        <input type="number" id="wavelength" value="1.54056" step="0.0001" class="control-input" min="0.01">



                        <div class="parameter-grid-3col">
                            <label for="zero-shift" class="control-label">Zero (°)</label>
                            <input type="number" id="zero-shift" value="0.0" step="0.001" class="control-input">
                            <input type="checkbox" id="fit-zero-shift" class="fit-checkbox" title="Fit this parameter" checked>
                        </div>

                    </div>
                </div>

                <div id="tab-panel-background" class="tab-content-panel">
                    <div class="control-group">
                        <h2>Background (Rolling Ball)</h2>
                        
                        <div class="slider-group">
                             <label class="control-label">Ball Radius (pts)</label>
                             <div class="slider-value-track">
                                <input type="range" id="ball-radius-slider" class="custom-slider" min="1" max="150" value="30" step="1">
                                <span id="ball-radius-value" class="slider-value-display">30</span>
                             </div>
                        </div>

                         <div class="slider-group">
                             <label class="control-label">Smoothing (pts)</label>
                             <div class="slider-value-track">
                                <input type="range" id="smoothing-width-slider" class="custom-slider" min="1" max="50" value="5" step="1">
                                <span id="smoothing-width-value" class="slider-value-display">5</span>
                             </div>
                        </div>
                    </div>
                </div>

                <div id="tab-panel-profile" class="tab-content-panel">
                     <div class="control-group">

                        <div id="profile-controls-container">
                            <h3 class="profile-section-header">Gaussian Broadening</h3>
                            <label class="control-label">GU</label>
                            <input type="number" id="param-gu" value="2.0" step="0.1" class="control-input" min="0">
                            <input type="checkbox" id="fit-gu" class="fit-checkbox">
                            <label class="control-label">GV</label>
                            <input type="number" id="param-gv" value="-1.0" step="0.1" class="control-input">
                            <input type="checkbox" id="fit-gv" class="fit-checkbox" >
                            <label class="control-label">GW</label>
                            <input type="number" id="param-gw" value="1.0" step="0.1" class="control-input" min="0">
                            <input type="checkbox" id="fit-gw" class="fit-checkbox" >
                             <label class="control-label">GP</label>
                            <input type="number" id="param-gp" value="0.0" step="0.1" class="control-input">
                            <input type="checkbox" id="fit-gp" class="fit-checkbox">

                            <h3 class="profile-section-header">Lorentzian Broadening</h3>
                            <label class="control-label">LX</label>
                            <input type="number" id="param-lx" value="12.8" step="0.1" class="control-input" min="0">
                            <input type="checkbox" id="fit-lx" class="fit-checkbox" >

                             <h3 class="profile-section-header">Peak Shape & Position</h3>
                             <label class="control-label">eta (Mixing)</label>
                            <input type="number" id="param-eta" value="0.74" step="0.01" min="0" max="1" class="control-input">
                            <input type="checkbox" id="fit-eta" class="fit-checkbox">
                             <label class="control-label">shft (Displ.)</label>
                            <input type="number" id="param-shft" value="0" step="0.01" class="control-input">
                            <input type="checkbox" id="fit-shft" class="fit-checkbox" >
                             <label class="control-label">trns (Transp.)</label>
                            <input type="number" id="param-trns" value="0" step="0.01" class="control-input">
                            <input type="checkbox" id="fit-trns" class="fit-checkbox">
                        </div>
                    </div>
                </div>
            </div>

            <div class="bottom-actions"> 
                 <div class="control-group" style="border-top: none; padding-top: 0;">
                     <h2>Refinement</h2>
                     <label for="algorithm-select" class="control-label">Method</label>
                     <select id="algorithm-select" class="control-select">
                        <option value="lm">Levenberg-Marquardt</option>
                        <option value="sa" selected>Simulated Annealing</option>
                     </select>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Min</label>
                         <div class="slider-value-track">
                            <input type="range" id="tth-min-slider" class="custom-slider" disabled>
                            <span id="tth-min-value" class="slider-value-display">10.0</span>
                         </div>
                     </div>
                     
                     <div class="slider-group">
                         <label class="control-label">2θ Max</label>
                         <div class="slider-value-track">
                             <input type="range" id="tth-max-slider" class="custom-slider" disabled>
                             <span id="tth-max-value" class="slider-value-display">80.0</span>
                         </div>
                     </div>

                     <div class="slider-group">
                         <label class="control-label">Max Iterations</label>
                         <div class="slider-value-track">
                            <input type="range" id="iterations-slider" min="2" max="200" value="120" step="1" class="custom-slider">
                            <span id="iterations-value" class="slider-value-display">120</span>
                         </div>
                     </div>

                     <div id="progress-bar-container" class="hidden" style="width: 100%; border-radius: 3px; height: 5px;">
                        <div id="progress-bar" style="height: 100%; width: 0%; border-radius: 3px;"></div>
                     </div>
                     <div class="results-grid">
                        <div class="result-card">
                            <div class="result-card-label">Rp (%)</div>
                            <div id="rp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">Rwp (%)</div>
                            <div id="rwp-result" class="result-card-value">-</div>
                        </div>
                        <div class="result-card">
                            <div class="result-card-label">χ² (GOF)</div>
                            <div id="chi2-result" class="result-card-value">-</div>
                        </div>
                     </div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 16px; margin-top: 16px;">

                    <button id="fit-button" class="btn btn-primary" disabled>Load Data to Start Fit</button>

                    <div style="display: flex; gap: 10px;">
                        <button id="save-data-button" class="btn btn-secondary" style="flex: 1;" disabled>Save Report</button>
                        <button id="report-button" class="btn btn-secondary" style="flex: 1;" disabled>Generate PDF</button>
                    </div>
                </div>
            </div>
        </div>


        <div id="drag-handle"></div>

<div id="results-area" style="position: relative; flex-grow: 1; min-height: 0;">
    <div id="placeholder" style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: var(--system-secondary-label);">
        <svg xmlns="http://www.w3.org/2000/svg" style="width: 64px; height: 64px; margin-bottom: 16px;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
        <h2 style="font-size: 22px; font-weight: 600; margin-bottom: 8px;">Awaiting Data</h2>
        <p style="font-size: 16px; color: var(--system-secondary-label);">Load a data file to begin.</p>
    </div>

    <div id="results-container" style="width: 100%; height: 100%; display: none; flex-direction: column; position: relative;">
        <canvas id="main-chart"></canvas>
    </div>

    <div style="position: absolute; bottom: 6px; right: 12px; font-size: 12px; color: var(--system-secondary-label);">
        NitaD, Univ Paris-Saclay, 19 Sept 2025
    </div>
</div>


<script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- UI Elements ---
        const controls = {
            fileInput: document.getElementById('file-input'),
            fileName: document.getElementById('file-name'),
            bravaisLattice: document.getElementById('bravais-lattice'),
            latticeParamsContainer: document.getElementById('lattice-parameters-container'),
            wavelength: document.getElementById('wavelength'),

            zeroShift: document.getElementById('zero-shift'),
            fitZeroShift: document.getElementById('fit-zero-shift'),
            paramGU: document.getElementById('param-gu'), fitGU: document.getElementById('fit-gu'),
            paramGV: document.getElementById('param-gv'), fitGV: document.getElementById('fit-gv'),
            paramGW: document.getElementById('param-gw'), fitGW: document.getElementById('fit-gw'),
            paramGP: document.getElementById('param-gp'), fitGP: document.getElementById('fit-gp'),
            paramLX: document.getElementById('param-lx'), fitLX: document.getElementById('fit-lx'),
            paramEta: document.getElementById('param-eta'), fitEta: document.getElementById('fit-eta'),
            paramShft: document.getElementById('param-shft'), fitShft: document.getElementById('fit-shft'),
            paramTrns: document.getElementById('param-trns'), fitTrns: document.getElementById('fit-trns'),
            algorithmSelect: document.getElementById('algorithm-select'),
            iterationsSlider: document.getElementById('iterations-slider'),
            iterationsValue: document.getElementById('iterations-value'),
            tthMinSlider: document.getElementById('tth-min-slider'),
            tthMinValue: document.getElementById('tth-min-value'),
            tthMaxSlider: document.getElementById('tth-max-slider'),
            tthMaxValue: document.getElementById('tth-max-value'),
            fitButton: document.getElementById('fit-button'),
            reportButton: document.getElementById('report-button'),
            saveDataButton: document.getElementById('save-data-button'),
            progressBar: document.getElementById('progress-bar'),
            progressBarContainer: document.getElementById('progress-bar-container'),
            rpResult: document.getElementById('rp-result'),
            rwpResult: document.getElementById('rwp-result'),
            chi2Result: document.getElementById('chi2-result'),
            mainChartCanvas: document.getElementById('main-chart'),
            placeholder: document.getElementById('placeholder'),
            resultsContainer: document.getElementById('results-container'),
            ballRadiusSlider: document.getElementById('ball-radius-slider'),
            ballRadiusValue: document.getElementById('ball-radius-value'),
            smoothingWidthSlider: document.getElementById('smoothing-width-slider'),
            smoothingWidthValue: document.getElementById('smoothing-width-value'),
        };

        // --- Global State ---
        let fullExperimentalData = { tth: [], intensity: [] };
        let fitResults = null;
        let mainChart;
        let isFitting = false;
        let lastGeneratedHklList = []; 
        let lastRawDifference = [];
        let calculatedBackground = []; 
        
 
        // --- ChartJS Plugin for Vertical Cursor Line ---
        const verticalCursorLine = {
            id: 'verticalCursorLine',
            afterDraw: chart => {
                if (chart.tooltip?._active?.length) {
                    let x = chart.tooltip._active[0].element.x;
                    let yAxis = chart.scales.y;
                    let ctx = chart.ctx;
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(x, yAxis.top);
                    ctx.lineTo(x, yAxis.bottom);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(156, 163, 175, 0.7)';
                    ctx.setLineDash([4, 4]); // dashed
                    ctx.stroke();
                    ctx.restore();
                }
            }
        };
        Chart.register(verticalCursorLine);

        // --- ChartJS Plugin for Tooltip Positioning ---
        Chart.Tooltip.positioners.experimentalAnchor = function(items) {
            if (!items.length) {
                return false;
            }
            const experimentalItem = items.find(item => item.datasetIndex === 0);
            const anchorPoint = experimentalItem || items[0];
            return {
                x: anchorPoint.element.x,
                y: anchorPoint.element.y
            };
        };
        
        // --- Core Application Logic ---
        function getSystemAndCentering() {
            const value = controls.bravaisLattice.value;
            const [system, centering] = value.split('_');
            return { system, centering };
        }

        function updateLatticeParamUI() {
            const { system } = getSystemAndCentering();
            const container = controls.latticeParamsContainer;
            container.innerHTML = '';

            const createInput = (name, label, value, step, isAngle = false) => {
                const id_base = `lattice-param-${name}`;
                const unit = isAngle ? '°' : 'Å';
                const minAttribute = isAngle ? '' : 'min="0.001"';
                
                const row = document.createElement('div');
                row.className = 'parameter-grid-3col';
                row.innerHTML = `
                    <label for="${id_base}" class="control-label">${label} (${unit})</label>
                    <input type="number" id="${id_base}" value="${value}" step="${step}" class="control-input" ${minAttribute}>
                    <input type="checkbox" id="fit-lattice-${name}" class="fit-checkbox" title="Fit this parameter" checked>
                `;
                container.appendChild(row);
            };

            const params = {
                cubic: [{ name: 'a', label: 'a', value: 4.08, step: 0.001 }],
                tetragonal: [
                    { name: 'a', label: 'a', value: 4.0, step: 0.001 },
                    { name: 'c', label: 'c', value: 5.0, step: 0.001 }
                ],
                orthorhombic: [
                    { name: 'a', label: 'a', value: 4.0, step: 0.001 },
                    { name: 'b', label: 'b', value: 5.0, step: 0.001 },
                    { name: 'c', label: 'c', value: 6.0, step: 0.001 }
                ],
                hexagonal: [
                    { name: 'a', label: 'a', value: 4.0, step: 0.001 },
                    { name: 'c', label: 'c', value: 6.0, step: 0.001 }
                ],
                rhombohedral: [
                    { name: 'a', label: 'a', value: 5.0, step: 0.001 },
                    { name: 'alpha', label: 'α', value: 60.0, step: 0.01, isAngle: true }
                ],
                monoclinic: [
                    { name: 'a', label: 'a', value: 4.0, step: 0.001 },
                    { name: 'b', label: 'b', value: 5.0, step: 0.001 },
                    { name: 'c', label: 'c', value: 6.0, step: 0.001 },
                    { name: 'beta', label: 'β', value: 105.0, step: 0.01, isAngle: true }
                ]
            };
            
            if(params[system]) {
                params[system].forEach(p => createInput(p.name, p.label, p.value, p.step, p.isAngle));
            }
        }

        // --- Data Parsers ---
        function parseDataFile(text) {
            const lines = text.trim().split(/\r?\n/);
            const tth = [], intensity = [];
            for (let line of lines) {
                if (line.startsWith('#') || line.startsWith('//') || isNaN(parseFloat(line.trim().split(/[\s,;]+/)[0]))) continue;
                const parts = line.trim().split(/[\s,;]+/);
                if (parts.length >= 2) {
                    const x = parseFloat(parts[0]);
                    const y = parseFloat(parts[1]);
                    if (!isNaN(x) && !isNaN(y)) {
                        tth.push(x);
                        intensity.push(y);
                    }
                }
            }
            return { tth, intensity };
        }

        function parseXrdmlFile(xmlString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");

            const parserError = xmlDoc.querySelector("parsererror");
            if (parserError) {
                console.error("Error parsing XRDML file:", parserError.textContent);
                return null;
            }

            let wavelength = 1.5406;
            const kAlpha1Node = xmlDoc.querySelector("kAlpha1");
            if (kAlpha1Node && kAlpha1Node.textContent) {
                const parsedWavelength = parseFloat(kAlpha1Node.textContent);
                if (!isNaN(parsedWavelength)) wavelength = parsedWavelength;
            }

            let intensityNode = xmlDoc.querySelector("intensities") || xmlDoc.querySelector("counts");
            if (!intensityNode) {
                console.error("Could not find <intensities> or <counts> tag in XRDML file.");
                return null;
            }
            const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number);
            const numPoints = intensity.length;
            if (numPoints === 0) {
                console.error("No intensity data points found.");
                return null;
            }

            let tth = [];
            const positionsNode = xmlDoc.querySelector('positions[axis="2Theta"]');
            if (!positionsNode) {
                console.error("Could not find <positions axis=\"2Theta\"> tag in XRDML file.");
                return null;
            }

            const startPosNode = positionsNode.querySelector("startPosition");
            const endPosNode = positionsNode.querySelector("endPosition");

            if (startPosNode && endPosNode) {
                const startPos = parseFloat(startPosNode.textContent);
                const endPos = parseFloat(endPosNode.textContent);
                if (!isNaN(startPos) && !isNaN(endPos) && numPoints > 1) {
                    const step = (endPos - startPos) / (numPoints - 1);
                    tth = Array.from({ length: numPoints }, (_, i) => startPos + i * step);
                } else if (numPoints === 1 && !isNaN(startPos)) {
                    tth = [startPos];
                } else {
                    console.error("Invalid start/end positions for 2-theta axis.");
                    return null;
                }
            } else {
                const listPositions = positionsNode.textContent.trim().split(/\s+/).map(Number).filter(n => !isNaN(n));
                if (listPositions.length === numPoints) {
                    tth = listPositions;
                } else {
                    console.error("Mismatch between number of intensity points and explicit 2-theta positions.");
                    return null;
                }
            }
            
            if (tth.length !== intensity.length) {
                console.error("Final mismatch between 2-theta and intensity data points.");
                return null;
            }

            return { tth, intensity, wavelength };
        }

        const parseBrukerBrmlFile = (xmlString) => {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");
            if (xmlDoc.querySelector("parsererror")) { throw new Error("Error parsing BRML file."); }

            let wavelength = null;
            const wlNode = xmlDoc.querySelector('usedWavelength');
            if (wlNode) {
                const kAlpha1 = wlNode.getAttribute('kAlpha1');
                if (kAlpha1) wavelength = parseFloat(kAlpha1);
            }
            
            const intensityNode = xmlDoc.querySelector("dataPoints > counts");
            if (!intensityNode) throw new Error("No <counts> data found in BRML file.");
            const intensity = intensityNode.textContent.trim().split(/\s+/).map(Number);

            const startPosNode = xmlDoc.querySelector('startPosition[axis="TwoTheta"]');
            const stepSizeNode = xmlDoc.querySelector('increment[axis="TwoTheta"]');
            if (!startPosNode || !stepSizeNode) throw new Error("Could not find scan parameters in BRML file.");

            const startPos = parseFloat(startPosNode.textContent);
            const stepSize = parseFloat(stepSizeNode.textContent);
            
            const tth = Array.from({ length: intensity.length }, (_, i) => startPos + i * stepSize);

            return { tth, intensity, wavelength };
        };

        const parseRigakuRasFile = (text) => {
            const lines = text.trim().split(/\r?\n/);
            const tth = [], intensity = [];
            let inDataSection = false;
            let wavelength = null;

            for (const line of lines) {
                const upperLine = line.toUpperCase();
                if (upperLine.startsWith('*WAVE_LENGTH') || upperLine.startsWith('*MEAS_COND_XG_WAVE_LENGTH')) {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length > 1) {
                        const wl = parseFloat(parts[1]);
                        if (!isNaN(wl)) wavelength = wl;
                    }
                }
                if (upperLine.startsWith('*RAS_INT_START')) {
                    inDataSection = true;
                    continue;
                }
                if (upperLine.startsWith('*RAS_INT_END')) {
                    break;
                }
                if (inDataSection) {
                    const parts = line.trim().split(/[\s,]+/);
                    if (parts.length >= 2) {
                        const x = parseFloat(parts[0]);
                        const y = parseFloat(parts[1]);
                        if (!isNaN(x) && !isNaN(y)) {
                            tth.push(x);
                            intensity.push(y);
                        }
                    }
                }
            }
            if (tth.length === 0) throw new Error("No data found in RAS file data section.");
            return { tth, intensity, wavelength };
        };

        const parseGsasEsdFile = (text) => {
            const lines = text.trim().split(/\r?\n/);
            const tth = [], intensity = [];
            let inDataSection = false;
            
            for (const line of lines) {
                if (!inDataSection && /^\s*\d/.test(line)) {
                    inDataSection = true;
                }

                if (inDataSection) {
                     if (line.trim().length < 30) continue;
                    try {
                        const tth_val = parseFloat(line.substring(0, 10)) / 100;
                        const int_val = parseFloat(line.substring(20, 30)); // raw intensity
                        if (!isNaN(tth_val) && !isNaN(int_val)) {
                            tth.push(tth_val);
                            intensity.push(int_val);
                        }
                    } catch (e) { 
                        console.warn("Skipping malformed data line in GSAS file:", line);
                    }
                }
            }
            if (tth.length === 0) throw new Error("Could not parse data from GSAS ESD file.");
            return { tth, intensity };
        };

        const parsePhilipsUdfFile = (text) => {
            const lines = text.trim().split(/\r?\n/);
            const tth = [], intensity = [];
            let inDataSection = false;
            let wavelength = null;

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine.toUpperCase().startsWith('LAMBDA')) {
                    const parts = trimmedLine.split('=');
                    if (parts.length > 1) wavelength = parseFloat(parts[1]);
                }
                if (trimmedLine.toUpperCase() === '[DATA]') {
                    inDataSection = true;
                    continue;
                }
                if (trimmedLine.startsWith('[') && trimmedLine.toUpperCase() !== '[DATA]') {
                    inDataSection = false;
                }
                if (inDataSection) {
                    const parts = trimmedLine.split(/,/).map(p => p.trim());
                    if(parts.length >= 2) {
                        const x = parseFloat(parts[0]);
                        const y = parseFloat(parts[1]);
                        if (!isNaN(x) && !isNaN(y)) {
                            tth.push(x);
                            intensity.push(y);
                        }
                    }
                }
            }
            if (tth.length === 0) throw new Error("No [Data] section found in UDF file.");
            return { tth, intensity, wavelength };
        };
        // --- End Data Parsers ---

        function getWorkingData(subtractBackground = false) {
            if (fullExperimentalData.tth.length === 0) return { tth: [], intensity: [] };
            const minTth = parseFloat(controls.tthMinSlider.value);
            const maxTth = parseFloat(controls.tthMaxSlider.value);
            const startIndex = fullExperimentalData.tth.findIndex(t => t >= minTth);
            let endIndex = fullExperimentalData.tth.findIndex(t => t > maxTth);
            if (endIndex === -1) endIndex = fullExperimentalData.tth.length;

            const tth = fullExperimentalData.tth.slice(startIndex, endIndex);
            let intensity = fullExperimentalData.intensity.slice(startIndex, endIndex);

            if (subtractBackground && calculatedBackground.length === fullExperimentalData.intensity.length) {
                const backgroundSlice = calculatedBackground.slice(startIndex, endIndex);
                intensity = intensity.map((y, i) => Math.max(0, y - backgroundSlice[i]));
            }

            return { tth, intensity };
        }


        function rollingBallBackground(y, radius, smoothingWidth) {
            const n = y.length;
            if (n === 0 || radius <= 0) return new Array(n).fill(0);

            let smoothed_y = y;
            if (smoothingWidth > 1) {
                smoothed_y = new Array(n);
                const halfWidth = Math.floor(smoothingWidth / 2);
                for (let i = 0; i < n; i++) {
                    const start = Math.max(0, i - halfWidth);
                    const end = Math.min(n, i + halfWidth + 1);
                    let sum = 0;
                    for (let j = start; j < end; j++) {
                        sum += y[j];
                    }
                    smoothed_y[i] = sum / (end - start);
                }
            }

            const eroded = new Array(n);
            for (let i = 0; i < n; i++) {
                const start = Math.max(0, i - radius);
                const end = Math.min(n, i + radius + 1);
                let min = Infinity;
                for (let j = start; j < end; j++) {
                    if (smoothed_y[j] < min) {
                        min = smoothed_y[j];
                    }
                }
                eroded[i] = min;
            }

            const background = new Array(n);
            for (let i = 0; i < n; i++) {
                const start = Math.max(0, i - radius);
                const end = Math.min(n, i + radius + 1);
                let max = -Infinity;
                for (let j = start; j < end; j++) {
                    if (eroded[j] > max) {
                        max = eroded[j];
                    }
                }
                background[i] = max;
            }
            
            return background;
        }

        function updateAndApplyBackground() {
            if (fullExperimentalData.intensity.length === 0) return;
            const radius = parseInt(controls.ballRadiusSlider.value, 10);
            const smoothing = parseInt(controls.smoothingWidthSlider.value, 10);
            
            calculatedBackground = rollingBallBackground(fullExperimentalData.intensity, radius, smoothing);

            if (mainChart) {
                const backgroundDataset = mainChart.data.datasets.find(d => d.label === 'Background');
                if (backgroundDataset) {
                    backgroundDataset.data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: calculatedBackground[i] }));
                }
                updatePreviewPattern();
            }
        }

        function findExperimentalPeakDetails(targetTth, experimentalData, wavelength, searchWindow = 0.5) {
            if (!experimentalData || experimentalData.tth.length === 0) {
                return { tth_exp: null, d_exp: null };
            }

            const minTth = targetTth - searchWindow;
            const maxTth = targetTth + searchWindow;
            
            let maxIntensity = -Infinity;
            let tth_exp = null;

            for (let i = 0; i < experimentalData.tth.length; i++) {
                const tth = experimentalData.tth[i];
                if (tth >= minTth && tth <= maxTth) {
                    if (experimentalData.intensity[i] > maxIntensity) {
                        maxIntensity = experimentalData.intensity[i];
                        tth_exp = tth;
                    }
                }
            }

            if (tth_exp !== null) {
                const theta_rad = tth_exp * (Math.PI / 180) / 2;
                const d_exp = wavelength / (2 * Math.sin(theta_rad));
                return { tth_exp: tth_exp, d_exp: d_exp };
            }

            return { tth_exp: null, d_exp: null };
        }

        function getMultiplicityAndCanonicalHKL(h, k, l, system) {
            let H = Math.abs(h);
            let K = Math.abs(k);
            let L = Math.abs(l);

            let canonical_hkl = `(${H},${K},${L})`;
            let multiplicity = 1;

            switch (system) {
                case 'cubic':
                    [H, K, L] = [H, K, L].sort((a, b) => b - a);
                    canonical_hkl = `(${H},${K},${L})`;
                    if (H > K && K > L && L > 0)      multiplicity = 48;
                    else if (H === K && K > L && L > 0) multiplicity = 24;
                    else if (H > K && K === L && L > 0) multiplicity = 24;
                    else if (H > K && K > 0 && L === 0) multiplicity = 24;
                    else if (H === K && K > 0 && L === 0) multiplicity = 12;
                    else if (H === K && K === L && L > 0) multiplicity = 8;
                    else if (H > 0 && K === 0 && L === 0) multiplicity = 6;
                    break;
                case 'hexagonal':
                case 'rhombohedral':
                    canonical_hkl = `(${H},${K},${L})`;
                    if (H > 0 && K > 0 && L > 0 && H !== K) multiplicity = 24;
                    else if (H > 0 && K > 0 && L > 0)      multiplicity = 12;
                    else if (H > 0 && K > 0 && L === 0 && H !== K) multiplicity = 12;
                    else if (H > 0 && K === 0 && L > 0)      multiplicity = 12;
                    else if (H > 0 && K === H && L === 0)      multiplicity = 6;
                    else if (H > 0 && K === 0 && L === 0)      multiplicity = 6;
                    else if (H === 0 && K === 0 && L > 0)      multiplicity = 2;
                    break;
                case 'tetragonal':
                    if (K > H) [H, K] = [K, H];
                    canonical_hkl = `(${H},${K},${L})`;
                    if (H > K && K > 0 && L > 0)      multiplicity = 16;
                    else if (H === K && K > 0 && L > 0) multiplicity = 8;
                    else if (H > 0 && K === 0 && L > 0) multiplicity = 8;
                    else if (H > K && K > 0 && L === 0) multiplicity = 8;
                    else if (H === K && K > 0 && L === 0) multiplicity = 4;
                    else if (H > 0 && K === 0 && L === 0) multiplicity = 4;
                    else if (H === 0 && K === 0 && L > 0) multiplicity = 2;
                    break;
                case 'orthorhombic':
                    canonical_hkl = `(${H},${K},${L})`;
                    if (H > 0 && K > 0 && L > 0)      multiplicity = 8;
                    else if (H > 0 && K > 0 && L === 0) multiplicity = 4;
                    else if (H > 0 && K === 0 && L > 0) multiplicity = 4;
                    else if (H === 0 && K > 0 && L > 0) multiplicity = 4;
                    else if (H > 0 && K === 0 && L === 0) multiplicity = 2;
                    else if (H === 0 && K > 0 && L === 0) multiplicity = 2;
                    else if (H === 0 && K === 0 && L > 0) multiplicity = 2;
                    break;
                case 'monoclinic':
                    canonical_hkl = `(${H},${K},${L})`;
                    if (H > 0 && L > 0) {
                        multiplicity = (K > 0) ? 4 : 2;
                    } else if (H > 0 || L > 0) {
                        multiplicity = (K > 0) ? 4 : 2;
                    } else if (K > 0) {
                        multiplicity = 2;
                    }
                    break;
            }
            return { canonical_hkl, multiplicity };
        }
        
        function generateTextReportContent(fitResults, controls) {
            const reportLines = [];
            const now = new Date();
            const { params: finalParams, fitFlags, algorithm, stats } = fitResults;

            const formatParamLine = (name, value, isFitted) => {
                let valStr;
                if (typeof value === 'number') {
                    valStr = value.toExponential(6).padStart(15);
                } else if (typeof value === 'string') {
                    valStr = value.padStart(15);
                } else {
                    valStr = 'N/A'.padStart(15);
                }
                const fitStr = (isFitted === undefined) ? '' : (isFitted ? 'Yes' : 'No');
                return `${name.padEnd(20)}${valStr}    ${fitStr}`;
            };
            
            reportLines.push('==============================================================');
            reportLines.push('            Le Bail Refinement Report');
            reportLines.push('==============================================================');
            reportLines.push(`Report Generated: ${now.toLocaleString()}`);
            reportLines.push(`Program used: LeBail.html, version 19 Sept 2025, nitad54448.github.io`);
            reportLines.push(`Data File: ${controls.fileName.textContent}`);
            reportLines.push('');
            reportLines.push('--- Refinement Statistics ---');
            reportLines.push(`Rp (%):      ${stats.r_p.toFixed(2)}`);
            reportLines.push(`Rwp (%):     ${stats.rwp.toFixed(2)}`);
            reportLines.push(`χ² (GOF):    ${stats.chi2.toFixed(2)}`);
            reportLines.push(`Algorithm:   ${algorithm === 'lm' ? 'Levenberg-Marquardt' : 'Simulated Annealing'}`);
            reportLines.push('');
            reportLines.push('--- Structural & Instrumental Parameters ---');
            reportLines.push('Parameter'.padEnd(20) + 'Value'.padStart(15) + '    Fitted');
            reportLines.push('-'.repeat(50));
            const selectedOption = controls.bravaisLattice.options[controls.bravaisLattice.selectedIndex];
            reportLines.push(formatParamLine('System:', selectedOption.text));
            if(finalParams.a) reportLines.push(formatParamLine('a (Å)', finalParams.a, fitFlags.a));
            if(finalParams.b) reportLines.push(formatParamLine('b (Å)', finalParams.b, fitFlags.b));
            if(finalParams.c) reportLines.push(formatParamLine('c (Å)', finalParams.c, fitFlags.c));
            if(finalParams.alpha) reportLines.push(formatParamLine('alpha (°)', finalParams.alpha, fitFlags.alpha));
            if(finalParams.beta) reportLines.push(formatParamLine('beta (°)', finalParams.beta, fitFlags.beta));
            if(finalParams.gamma) reportLines.push(formatParamLine('gamma (°)', finalParams.gamma, fitFlags.gamma));
            reportLines.push(formatParamLine('Radiation (Å)', finalParams.lambda));
            reportLines.push(formatParamLine('Zero Shift (°)', finalParams.zeroShift, fitFlags.zeroShift));
            reportLines.push('');
            reportLines.push('--- Profile Parameters ---');
            reportLines.push(formatParamLine('GU', finalParams.GU, fitFlags.GU));
            reportLines.push(formatParamLine('GV', finalParams.GV, fitFlags.GV));
            reportLines.push(formatParamLine('GW', finalParams.GW, fitFlags.GW));
            reportLines.push(formatParamLine('GP', finalParams.GP, fitFlags.GP));
            reportLines.push(formatParamLine('LX', finalParams.LX, fitFlags.LX));
            reportLines.push(formatParamLine('eta', finalParams.eta, fitFlags.eta));
            reportLines.push(formatParamLine('shft', finalParams.shft, fitFlags.shft));
            reportLines.push(formatParamLine('trns', finalParams.trns, fitFlags.trns));
            reportLines.push('');
            reportLines.push('--- Background ---');
            reportLines.push('Method: Rolling Ball (fixed)');
            reportLines.push(`Ball Radius: ${controls.ballRadiusSlider.value} pts`);
            reportLines.push(`Smoothing: ${controls.smoothingWidthSlider.value} pts`);
            reportLines.push('');

            const { system, centering } = getSystemAndCentering();
            const hklListForReport = generateHKL(Math.max(...fullExperimentalData.tth), finalParams, system, centering);

            reportLines.push('--- Calculated vs. Experimental Reflections ---');
            reportLines.push(['h,k,l'.padEnd(10), 'd_calc (Å)'.padStart(12), 'd_exp (Å)'.padStart(12), '2th_corr (°)' .padStart(15), '2th_exp (°)' .padStart(15)].join('  '));
            reportLines.push('-'.repeat(80));

            hklListForReport.forEach(hkl => {
                const peakShift = calculatePeakShift(hkl.tth, finalParams);
                const tthCorr = hkl.tth + finalParams.zeroShift + peakShift;
                const { tth_exp, d_exp } = findExperimentalPeakDetails(tthCorr, fullExperimentalData, finalParams.lambda);
                const d_calc_str = hkl.d.toFixed(5).padStart(12);
                const d_exp_str = d_exp ? d_exp.toFixed(5).padStart(12) : 'N/A'.padStart(12);
                const tth_corr_str = tthCorr.toFixed(4).padStart(15);
                const tth_exp_str = tth_exp ? tth_exp.toFixed(4).padStart(15) : 'N/A'.padStart(15);
                const line = [hkl.hkl_list[0].padEnd(10), d_calc_str, d_exp_str, tth_corr_str, tth_exp_str].join('  ');
                reportLines.push(line);
            });
            reportLines.push('');
            
            const { pattern: finalCalcPattern } = calculatePattern(fullExperimentalData.tth, hklListForReport, finalParams);
            reportLines.push('');
            reportLines.push('--- Intensity Data ---');
            reportLines.push(['2theta', 'I_obs', 'I_calc', 'Difference'].join('\t'));
            for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                const tth = fullExperimentalData.tth[i];
                const i_obs = fullExperimentalData.intensity[i];
                const i_calc = finalCalcPattern[i] + calculatedBackground[i];
                const diff = i_obs - i_calc;
                reportLines.push([tth.toFixed(4), i_obs.toFixed(2), i_calc.toFixed(2), diff.toFixed(2)].join('\t'));
            }

            return reportLines.join('\n');
        }
        
        function downloadTextFile(content, filename) {
            const element = document.createElement('a');
            const file = new Blob([content], {type: 'text/plain;charset=utf-8'});
            element.href = URL.createObjectURL(file);
            element.download = filename;
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }

        // --- All calculations and logic functions (generateHKL, calculatePattern, runLeBailFit, etc.) go here ---
        // These functions are extensive and remain unchanged from the original provided code.
        function generateHKL(maxTth, params, system, centering) {
            const { a, b, c, alpha, beta, gamma, lambda } = params;
            if (!a || !lambda || a <= 0) return [];

            const reflections = new Map();
            const maxIndex = Math.ceil(2 * Math.max(a || 0, b || 0, c || 0) / lambda * Math.sin(maxTth / 2 * Math.PI / 180)) + 2;

            const deg2rad = Math.PI / 180;
            const sin_b = Math.sin((beta || 90) * deg2rad);
            const cos_b = Math.cos((beta || 90) * deg2rad);
            
            for (let h = -maxIndex; h <= maxIndex; h++) {
                for (let k = -maxIndex; k <= maxIndex; k++) {
                    for (let l = 0; l <= maxIndex; l++) {
                        if (h === 0 && k === 0 && l === 0) continue;

                        let allowed = false;
                        switch(centering) {
                            case 'P': allowed = true; break;
                            case 'I': allowed = (h + k + l) % 2 === 0; break;
                            case 'F': allowed = (h % 2 === k % 2) && (k % 2 === l % 2); break;
                            case 'C': allowed = (h + k) % 2 === 0; break;
                            case 'R':
                                if (system === 'hexagonal') allowed = (-h + k + l) % 3 === 0;
                                else allowed = true;
                                break;
                            default: allowed = true;
                        }
                        if (!allowed) continue;

                        let inv_d_sq = 0;
                        switch(system) {
                            case 'cubic':
                                inv_d_sq = (h*h + k*k + l*l) / (a*a);
                                break;
                            case 'tetragonal':
                                inv_d_sq = (h*h + k*k) / (a*a) + (l*l) / (c*c);
                                break;
                            case 'orthorhombic':
                                inv_d_sq = (h*h)/(a*a) + (k*k)/(b*b) + (l*l)/(c*c);
                                break;
                            case 'hexagonal':
                                inv_d_sq = (4/3) * (h*h + h*k + k*k) / (a*a) + (l*l) / (c*c);
                                break;
                            case 'monoclinic':
                                inv_d_sq = (1/(sin_b*sin_b)) * ( (h*h)/(a*a) + (k*k*sin_b*sin_b)/(b*b) + (l*l)/(c*c) - (2*h*l*cos_b)/(a*c) );
                                break;
                            case 'rhombohedral':
                                const term1 = (h*h + k*k + l*l) * Math.sin(alpha*deg2rad)**2;
                                const term2 = 2 * (h*k + k*l + l*h) * (Math.cos(alpha*deg2rad)**2 - Math.cos(alpha*deg2rad));
                                const denominator = a*a * (1 - 3*Math.cos(alpha*deg2rad)**2 + 2*Math.cos(alpha*deg2rad)**3);
                                if(Math.abs(denominator) < 1e-9) continue;
                                inv_d_sq = (term1 + term2) / denominator;
                                break;
                        }
                        if (inv_d_sq <= 0) continue;
                        
                        const sinThetaSq = (lambda*lambda / 4) * inv_d_sq;
                        if (sinThetaSq <= 1) {
                            const tth = 2 * Math.asin(Math.sqrt(sinThetaSq)) * (180 / Math.PI);
                            if (tth > maxTth * 1.05) continue;
                            const d = 1 / Math.sqrt(inv_d_sq);
                            const key = Math.round(tth * 1000);
                            if (!reflections.has(key)) {
                                const { canonical_hkl, multiplicity } = getMultiplicityAndCanonicalHKL(h, k, l, system);
                                reflections.set(key, { tth: tth, d: d, hkl_list: [canonical_hkl], multiplicity: multiplicity, intensity: 0 });
                            }
                        }
                    }
                }
            }
            return Array.from(reflections.values()).sort((a, b) => a.tth - b.tth);
        }

        function calculatePeakShift(tth, params) {
            const thetaRad = tth * (Math.PI / 180) / 2;
            const cosTheta = Math.cos(thetaRad);
            const sin2Theta = Math.sin(2 * thetaRad);
            const displacementShift = -(params.shft / 1000) * cosTheta * (180 / Math.PI);
            const transparencyShift = params.trns * sin2Theta;
            return displacementShift + transparencyShift;
        }

        function calculateProfileWidths(tth, params) {
            const thetaRad = Math.min(tth * (Math.PI / 180) / 2, 89.999 * Math.PI / 180);
            const tanTheta = Math.tan(thetaRad);
            const cosTheta = Math.cos(thetaRad);
            const gamma_G_sq = (params.GU / 100) * tanTheta * tanTheta + (params.GV / 100) * tanTheta + (params.GW / 100) + (params.GP / 100) / (cosTheta * cosTheta);
            const gamma_G = Math.sqrt(Math.max(1e-6, gamma_G_sq));
            const gamma_L = (params.LX / 100) / cosTheta;
            return { gamma_G, gamma_L };
        }

        function pseudoVoigt(x, x0, gamma_G, gamma_L, eta) {
            if (gamma_G <= 1e-6 && gamma_L <= 1e-6) return 0.0;
            const fwhm_g_to_sigma = 1 / (2 * Math.sqrt(2 * Math.log(2)));
            const sigma = gamma_G * fwhm_g_to_sigma;
            const normalizedGaussian = Math.exp(-0.5 * ((x - x0) ** 2) / (sigma * sigma));
            const hwhm_l = gamma_L / 2.0;
            const normalizedLorentzian = (hwhm_l * hwhm_l) / ((x - x0) ** 2 + (hwhm_l * hwhm_l));
            if (gamma_L < 1e-6) return normalizedGaussian;
            if (gamma_G < 1e-6) return normalizedLorentzian;
            return eta * normalizedLorentzian + (1 - eta) * normalizedGaussian;
        }
        
        function calculatePattern(tthAxis, hklList, params) {
            const pattern = new Float32Array(tthAxis.length).fill(0);
            hklList.forEach(peak => {
                const basePos = peak.tth + params.zeroShift;
                const shift = calculatePeakShift(basePos, params);
                const peakPos = basePos + shift;
                const { gamma_G, gamma_L } = calculateProfileWidths(basePos, params);
                for (let i = 0; i < tthAxis.length; i++) {
                    const window = 5 * (gamma_G + gamma_L);
                    if (Math.abs(tthAxis[i] - peakPos) < window) {
                       pattern[i] += peak.intensity * pseudoVoigt(tthAxis[i], peakPos, gamma_G, gamma_L, params.eta);
                    }
                }
            });
            const background = calculatedBackground.length === tthAxis.length ? calculatedBackground : new Array(tthAxis.length).fill(0);
            return { pattern, background };
        }


        function leBailIntensityExtraction(exp, hklList, params) {
            hklList.forEach(p => p.intensity = 0);
            
            for(let i = 0; i < exp.tth.length; i++) {
                let totalProfileAtPoint = 0;
                const contributingPeaks = [];
                hklList.forEach((peak, peakIdx) => {
                    const basePos = peak.tth + params.zeroShift;
                    const shift = calculatePeakShift(basePos, params);
                    const peakPos = basePos + shift;
                    const { gamma_G, gamma_L } = calculateProfileWidths(basePos, params);
                    const window = 5 * (gamma_G + gamma_L);
                    if(Math.abs(exp.tth[i] - peakPos) < window) {
                        const profileVal = pseudoVoigt(exp.tth[i], peakPos, gamma_G, gamma_L, params.eta);
                        totalProfileAtPoint += profileVal;
                        contributingPeaks.push({idx: peakIdx, val: profileVal});
                    }
                });
                if(totalProfileAtPoint > 1e-9) {
                    const obsIntensityNet = exp.intensity[i];
                    contributingPeaks.forEach(p => {
                        hklList[p.idx].intensity += obsIntensityNet * (p.val / totalProfileAtPoint);
                    });
                }
            }
            const maxIntensity = Math.max(...hklList.map(p => p.intensity));
            if (maxIntensity > 0) {
                hklList.forEach(p => p.intensity = p.intensity / maxIntensity * 1000);
            }
        }

        function calculateRwp(exp_intensity, calc_intensity) {
            let ss_res = 0, ss_tot = 0;
            let sum_obs_calc = 0, sum_calc_sq = 0;

            for(let i=0; i<exp_intensity.length; i++) {
                sum_obs_calc += exp_intensity[i] * calc_intensity[i];
                sum_calc_sq += calc_intensity[i] * calc_intensity[i];
            }
            const scaleFactor = sum_calc_sq > 0 ? sum_obs_calc / sum_calc_sq : 1.0;

            for(let i=0; i<exp_intensity.length; i++) {
                const weight = 1 / Math.max(exp_intensity[i], 1);
                ss_res += weight * (exp_intensity[i] - scaleFactor * calc_intensity[i])**2;
                ss_tot += weight * (exp_intensity[i])**2;
            }
            return ss_tot > 0 ? 100 * Math.sqrt(ss_res / ss_tot) : 0;
        }

        function calculateStatistics(totalWorkingData, netCalcPattern, backgroundSlice, fitFlags) {
    const y_obs_total = totalWorkingData.intensity;
    const y_calc_net = netCalcPattern;
    const y_bkg = backgroundSlice;
    const N = y_obs_total.length;
    const P = getParameterMapping(fitFlags).paramMapping.length;

    // Step 1: Determine the scale factor by comparing the net (background-subtracted) data.
    const y_obs_net = y_obs_total.map((y, i) => y - y_bkg[i]);
    let sum_obs_net_calc_net = 0;
    let sum_calc_net_sq = 0;
    for (let i = 0; i < N; i++) {
        sum_obs_net_calc_net += y_obs_net[i] * y_calc_net[i];
        sum_calc_net_sq += y_calc_net[i] * y_calc_net[i];
    }
    const scaleFactor = sum_calc_net_sq > 0 ? sum_obs_net_calc_net / sum_calc_net_sq : 1.0;

    // Step 2: Build the final total calculated pattern.
    const y_calc_total = y_calc_net.map((y, i) => (scaleFactor * y) + y_bkg[i]);

    // Step 3: Calculate final statistics by comparing the total patterns.
    const weights = y_obs_total.map(y => 1 / Math.max(y, 1));
    let sum_w_res_sq = 0;
    let sum_w_obs_sq = 0;
    let sum_abs_res = 0;
    let sum_abs_obs = 0;

    for (let i = 0; i < N; i++) {
        const res = y_obs_total[i] - y_calc_total[i];
        const w = weights[i];
        sum_w_res_sq += w * res * res;
        sum_w_obs_sq += w * y_obs_total[i] * y_obs_total[i];
        sum_abs_res += Math.abs(res);
        sum_abs_obs += Math.abs(y_obs_total[i]);
    }

    const r_p = sum_abs_obs > 0 ? 100 * (sum_abs_res / sum_abs_obs) : 0;
    const rwp = sum_w_obs_sq > 0 ? 100 * Math.sqrt(sum_w_res_sq / sum_w_obs_sq) : 0;
    const degreesOfFreedom = N - P;
    const chi2 = degreesOfFreedom > 0 ? sum_w_res_sq / degreesOfFreedom : Infinity;
    
    return { r_p, rwp, chi2 };
}


        function getAllParams() {
            return {
                a: parseFloat(document.getElementById('lattice-param-a')?.value),
                b: parseFloat(document.getElementById('lattice-param-b')?.value),
                c: parseFloat(document.getElementById('lattice-param-c')?.value),
                alpha: parseFloat(document.getElementById('lattice-param-alpha')?.value),
                beta: parseFloat(document.getElementById('lattice-param-beta')?.value),
                gamma: parseFloat(document.getElementById('lattice-param-gamma')?.value),
                lambda: parseFloat(controls.wavelength.value),
                zeroShift: parseFloat(controls.zeroShift.value),
                GU: parseFloat(controls.paramGU.value),
                GV: parseFloat(controls.paramGV.value),
                GW: parseFloat(controls.paramGW.value),
                GP: parseFloat(controls.paramGP.value),
                LX: parseFloat(controls.paramLX.value),
                eta: parseFloat(controls.paramEta.value),
                shft: parseFloat(controls.paramShft.value),
                trns: parseFloat(controls.paramTrns.value),
            };
        }
        
        function getFitFlags() {
             return {
                a: document.getElementById('fit-lattice-a')?.checked,
                b: document.getElementById('fit-lattice-b')?.checked,
                c: document.getElementById('fit-lattice-c')?.checked,
                alpha: document.getElementById('fit-lattice-alpha')?.checked,
                beta: document.getElementById('fit-lattice-beta')?.checked,
                gamma: document.getElementById('fit-lattice-gamma')?.checked,
                zeroShift: controls.fitZeroShift.checked,
                GU: controls.fitGU.checked, GV: controls.fitGV.checked, GW: controls.fitGW.checked,
                GP: controls.fitGP.checked, LX: controls.fitLX.checked,
                eta: controls.fitEta.checked, shft: controls.fitShft.checked, trns: controls.fitTrns.checked,
            };
        }

        async function runLeBailFit() {
    if (isFitting) return;
    isFitting = true;
    fitResults = null;
    setUIState(true);

    if (mainChart) {
        const manualSimDataset = mainChart.data.datasets.find(d => d.label === 'Simulation (Manual)');
        if (manualSimDataset) manualSimDataset.data = [];
    }
    
    await new Promise(resolve => setTimeout(resolve, 10));
    
    updateAndApplyBackground();
    
    const fitFlags = getFitFlags();
    let params = getAllParams();
    const { system, centering } = getSystemAndCentering();
    const maxIterations = parseInt(controls.iterationsSlider.value);
    const algorithm = controls.algorithmSelect.value;
    let results; 

    // Get the background-subtracted ("net") data for the refinement cost function
    const workingData_NET = getWorkingData(true);

    const progressCallback = async (progress, currentParams) => {
    // This now ONLY updates the single progress bar near the stats
    controls.progressBar.style.width = `${progress * 100}%`;
    await new Promise(resolve => setTimeout(resolve, 0));
};

    if (algorithm === 'lm') {
        results = await refineParametersLM(params, fitFlags, maxIterations, system, centering, progressCallback);
    } else if (algorithm === 'sa') {
        results = await refineParametersSA(params, fitFlags, maxIterations, system, centering, progressCallback);
    }
    
    fitResults = results;
    const finalParams = fitResults.params;
    
    // --- Final Calculations & UI Update ---

    // 1. Get NET data for final intensity extraction
    const finalWorkingData_NET = getWorkingData(true);
    const hklList = generateHKL(Math.max(...fullExperimentalData.tth), finalParams, system, centering);
    lastGeneratedHklList = hklList;
    leBailIntensityExtraction(finalWorkingData_NET, hklList, finalParams);
    
    // 2. Get NET calculated pattern over the fitting range
    const finalWorkingPattern_NET = calculatePattern(finalWorkingData_NET.tth, hklList, finalParams).pattern;

    // 3. Get TOTAL observed data and the BACKGROUND for the same range
    const finalWorkingData_TOTAL = getWorkingData(false);
    const startIndex = fullExperimentalData.tth.findIndex(t => t >= finalWorkingData_TOTAL.tth[0]);
    let endIndex = fullExperimentalData.tth.findIndex(t => t > finalWorkingData_TOTAL.tth[finalWorkingData_TOTAL.tth.length - 1]);
    if (endIndex === -1) endIndex = fullExperimentalData.tth.length;
    const background_slice = calculatedBackground.slice(startIndex, endIndex);

    // 4. Calculate final statistics with the correct TOTAL and NET data inputs
    const finalStats = calculateStatistics(finalWorkingData_TOTAL, finalWorkingPattern_NET, background_slice, fitFlags);
    fitResults.stats = finalStats;

    // 5. For display, get the full-range peak pattern and background and update the UI
    const { pattern: peakPattern, background } = calculatePattern(fullExperimentalData.tth, hklList, finalParams);
    updateUI(finalParams, finalStats, peakPattern, background);

    isFitting = false;
    setUIState(false);
}
        
        function dot(v1, v2) { let s = 0; for(let i=0; i<v1.length; i++) s += v1[i] * v2[i]; return s; }
        function add(v1, v2) { return v1.map((x, i) => x + v2[i]); }
        function subtract(v1, v2) { return v1.map((x, i) => x - v2[i]); }
        function scale(v, s) { return v.map(x => x * s); }
        function transpose(m) {
            if (!m || m.length === 0 || !Array.isArray(m[0])) return m.map(x => [x]);
            return m[0].map((_, colIndex) => m.map(row => row[colIndex]));
        }
        function multiply(A, B) {
            if (!Array.isArray(B[0])) return A.map(row => dot(row, B));
            const Bt = transpose(B);
            return A.map(rowA => Bt.map(colB => dot(rowA, colB)));
        }
        
        function solve(A, b) {
            const n = A.length;
            const Ab = A.map((row, i) => [...row, b[i]]);
            for (let i = 0; i < n; i++) {
                let max = i;
                for (let k = i + 1; k < n; k++) { if (Math.abs(Ab[k][i]) > Math.abs(Ab[max][i])) max = k; }
                [Ab[i], Ab[max]] = [Ab[max], Ab[i]];
                if (Math.abs(Ab[i][i]) < 1e-12) continue;
                for (let k = i + 1; k < n; k++) {
                    const factor = Ab[k][i] / Ab[i][i];
                    if (!isFinite(factor)) continue;
                    for (let j = i; j < n + 1; j++) Ab[k][j] -= factor * Ab[i][j];
                }
            }
            const x = new Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                let sum = 0; for (let j = i + 1; j < n; j++) sum += Ab[i][j] * x[j];
                if (Math.abs(Ab[i][i]) > 1e-12) x[i] = (Ab[i][n] - sum) / Ab[i][i];
            }
            return x;
        }

        function matrixInverse(A) {
            const n = A.length;
            if (n === 0) return [];
            const I = Array.from({ length: n }, (_, i) => Array.from({ length: n }, (_, j) => (i === j ? 1 : 0)));
            const C = A.map((row, i) => [...row, ...I[i]]);
            for (let i = 0; i < n; i++) {
                let pivot = i;
                for (let j = i + 1; j < n; j++) { if (Math.abs(C[j][i]) > Math.abs(C[pivot][i])) pivot = j; }
                [C[i], C[pivot]] = [C[pivot], C[i]];
                const div = C[i][i];
                if (Math.abs(div) < 1e-12) return null;
                for (let j = i; j < 2 * n; j++) C[i][j] /= div;
                for (let j = 0; j < n; j++) {
                    if (i !== j) {
                        const mult = C[j][i];
                        for (let k = i; k < 2 * n; k++) C[j][k] -= mult * C[i][k];
                    }
                }
            }
            return C.map(row => row.slice(n));
        }

        function getParameterMapping(fitFlags) {
            const paramMapping = [];
            const paramDefs = [
                { flag: fitFlags.a, name: 'a', get: p => p.a, set: (p, v) => p.a = v, step: 1e-3 },
                { flag: fitFlags.b, name: 'b', get: p => p.b, set: (p, v) => p.b = v, step: 1e-3 },
                { flag: fitFlags.c, name: 'c', get: p => p.c, set: (p, v) => p.c = v, step: 1e-3 },
                { flag: fitFlags.alpha, name: 'alpha', get: p => p.alpha, set: (p, v) => p.alpha = v, step: 1e-2 },
                { flag: fitFlags.beta, name: 'beta', get: p => p.beta, set: (p, v) => p.beta = v, step: 1e-2 },
                { flag: fitFlags.gamma, name: 'gamma', get: p => p.gamma, set: (p, v) => p.gamma = v, step: 1e-2 },
                { flag: fitFlags.zeroShift, name: 'zeroShift', get: p => p.zeroShift, set: (p, v) => p.zeroShift = v, step: 1e-3 },
                { flag: fitFlags.GU, name: 'GU', get: p => p.GU, set: (p, v) => p.GU = v, step: 0.1 },
                { flag: fitFlags.GV, name: 'GV', get: p => p.GV, set: (p, v) => p.GV = v, step: 0.1 },
                { flag: fitFlags.GW, name: 'GW', get: p => p.GW, set: (p, v) => p.GW = Math.max(0, v), step: 0.1 },
                { flag: fitFlags.GP, name: 'GP', get: p => p.GP, set: (p, v) => p.GP = v, step: 0.1 },
                { flag: fitFlags.LX, name: 'LX', get: p => p.LX, set: (p, v) => p.LX = Math.max(0, v), step: 0.2 },
                { flag: fitFlags.eta, name: 'eta', get: p => p.eta, set: (p, v) => p.eta = Math.max(0, Math.min(1, v)), step: 0.05 },
                { flag: fitFlags.shft, name: 'shft', get: p => p.shft, set: (p, v) => p.shft = v, step: 0.01 },
                { flag: fitFlags.trns, name: 'trns', get: p => p.trns, set: (p, v) => p.trns = v, step: 0.01 },
            ];
            paramDefs.forEach(def => { if (def.flag) paramMapping.push(def); });
            return { paramMapping };
        }

        async function refineParametersSA(initialParams, fitFlags, maxIter, system, centering, progressCallback) {
            const { paramMapping } = getParameterMapping(fitFlags);
            if (paramMapping.length === 0) {
                return { params: initialParams, algorithm: 'sa', paramMapping, fitFlags };
            }
            const workingData = getWorkingData(true);
            if (workingData.tth.length === 0) return { params: initialParams };

            const objective = (p_vec, params_template) => {
                let tempParams = JSON.parse(JSON.stringify(params_template));
                paramMapping.forEach((m, i) => m.set(tempParams, p_vec[i]));

                if (tempParams.a && tempParams.a <= 0) return 1e12; // Prevent invalid lattice param

                let hklList = generateHKL(Math.max(...workingData.tth), tempParams, system, centering);
                leBailIntensityExtraction(workingData, hklList, tempParams);
                const { pattern } = calculatePattern(workingData.tth, hklList, tempParams);
                
                const diff = subtract(workingData.intensity, pattern);
                return dot(diff, diff);
            };

            let T = 1.0, coolingRate = 0.99;
            const maxSteps = maxIter * 100;

            let current_x = paramMapping.map(m => m.get(initialParams));
            let current_cost = objective(current_x, initialParams);
            
            let best_x = [...current_x];
            let best_cost = current_cost;

            for (let i = 0; i < maxSteps; i++) {
                let neighbor_x = current_x.map((val, idx) => {
                    const stepSize = (paramMapping[idx].step || 0.1) * T;
                    let newVal = val + (Math.random() - 0.5) * 2 * stepSize;
                    if (paramMapping[idx].name === 'eta') newVal = Math.max(0, Math.min(1, newVal));
                    else if (['a', 'b', 'c', 'GW', 'LX'].includes(paramMapping[idx].name)) newVal = Math.max(0.001, newVal);
                    return newVal;
                });

                let neighbor_cost = objective(neighbor_x, initialParams);

                if (neighbor_cost < current_cost || Math.exp(-(neighbor_cost - current_cost) / T) > Math.random()) {
                    current_x = [...neighbor_x];
                    current_cost = neighbor_cost;
                }

                if (current_cost < best_cost) {
                    best_x = [...current_x];
                    best_cost = current_cost;
                }

                T *= coolingRate;

                if (i % 100 === 0 && progressCallback) {
                    let tempParams = JSON.parse(JSON.stringify(initialParams));
                    paramMapping.forEach((m, j) => m.set(tempParams, best_x[j]));
                    await progressCallback(i / maxSteps, tempParams);
                }
            }

            let finalParams = JSON.parse(JSON.stringify(initialParams));
            paramMapping.forEach((m, i) => m.set(finalParams, best_x[i]));
            
            return { params: finalParams, algorithm: 'sa', paramMapping, fitFlags };
        }

        async function refineParametersLM(initialParams, fitFlags, maxIter, system, centering, progressCallback) {
            const { paramMapping } = getParameterMapping(fitFlags);
            if (paramMapping.length === 0) {
                return { params: initialParams, algorithm: 'lm', paramMapping, fitFlags };
            }
            let params = JSON.parse(JSON.stringify(initialParams));
            let lambda = 0.001;
            const workingData = getWorkingData(true);
            
            const calculateResiduals = (p_vec, current_params) => {
                let tempParams = JSON.parse(JSON.stringify(current_params));
                paramMapping.forEach((m, i) => m.set(tempParams, p_vec[i]));

                let hklList = generateHKL(Math.max(...workingData.tth), tempParams, system, centering);
                leBailIntensityExtraction(workingData, hklList, tempParams);
                const { pattern } = calculatePattern(workingData.tth, hklList, tempParams);
                
                return subtract(workingData.intensity, pattern);
            };
            
            let last_cost = Infinity, JtJ, finalResiduals;

            for (let iter = 0; iter < maxIter; iter++) {
                let p_current_vec = paramMapping.map(m => m.get(params));
                const residuals = calculateResiduals(p_current_vec, params);
                const weights = workingData.intensity.map(y => 1 / Math.max(y, 1));
                const weightedResiduals = residuals.map((r, i) => r * Math.sqrt(weights[i]));
                finalResiduals = residuals;
                const cost = dot(weightedResiduals, weightedResiduals);

                if (Math.abs(last_cost - cost) < 1e-9 * cost && iter > 0) {
                     if (progressCallback) await progressCallback(1, params);
                     break;
                }
                last_cost = cost;

                const jacobian = [];
                for (let i = 0; i < p_current_vec.length; i++) {
                    const p_plus = [...p_current_vec];
                    const step = paramMapping[i].step || 1e-5;
                    p_plus[i] += step;
                    
                    const res_plus = calculateResiduals(p_plus, params);
                    const weighted_res_plus = res_plus.map((r, j) => r * Math.sqrt(weights[j]));
                    const deriv = scale(subtract(weighted_res_plus, weightedResiduals), -1 / step);
                    jacobian.push(deriv);
                }

                for(let i = 0; i < jacobian.length; i++) { 
                    for(let j = 0; j < jacobian[i].length; j++) { 
                        if (!isFinite(jacobian[i][j])) jacobian[i][j] = 0;
                    } 
                }

                const J = transpose(jacobian);
                JtJ = multiply(transpose(J), J);
                const Jtr = multiply(transpose(J), weightedResiduals);

                const A_lm = JSON.parse(JSON.stringify(JtJ));
                for (let i = 0; i < A_lm.length; i++) { A_lm[i][i] += lambda * (A_lm[i][i] || 1.0); }
                
                const p_step = solve(A_lm, Jtr);
                if (p_step.some(isNaN)) { console.error("Stopping LM: NaN detected."); break; }

                const p_new_vec = add(p_current_vec, p_step);
                const new_residuals = calculateResiduals(p_new_vec, params);
                const weighted_new_residuals = new_residuals.map((r, i) => r * Math.sqrt(weights[i]));
                const new_cost = dot(weighted_new_residuals, weighted_new_residuals);

                if (new_cost < cost && isFinite(new_cost)) {
                    paramMapping.forEach((m, i) => m.set(params, p_new_vec[i]));
                    lambda = Math.max(lambda / 2, 1e-9);
                } else {
                    lambda = Math.min(lambda * 2, 1e9);
                }
                if (progressCallback) await progressCallback((iter + 1) / maxIter, params);
            }
            return { params, JtJ, finalResiduals, paramMapping, ss_res: last_cost, algorithm: 'lm', fitFlags };
        }

        // --- UI Update and Charting Functions ---
        function updatePreviewPattern() {
            if (!mainChart || fullExperimentalData.tth.length === 0 || isFitting) return;
            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            const calculatedDataset = findDataset('Calculated');
            const differenceDataset = findDataset('Difference');
            if (calculatedDataset) calculatedDataset.data = [];
            if (differenceDataset) differenceDataset.data = [];

            const { system, centering } = getSystemAndCentering();
            const params = getAllParams();
            const requiredParams = {
                cubic: ['a'], tetragonal: ['a', 'c'], orthorhombic: ['a', 'b', 'c'],
                hexagonal: ['a', 'c'], rhombohedral: ['a', 'alpha'], monoclinic: ['a', 'b', 'c', 'beta']
            };
            const coreParams = ['lambda', 'zeroShift', 'GU', 'GV', 'GW', 'GP', 'LX', 'eta', 'shft', 'trns'];
            for (const p of coreParams) if (isNaN(params[p])) return;
            if (isNaN(params.lambda) || params.lambda <= 0) return;
            if (requiredParams[system]) {
                for (const p of requiredParams[system]) {
                    if (isNaN(params[p]) || (!['alpha', 'beta', 'gamma'].includes(p) && params[p] <= 0)) return; 
                }
            }

            let hklList = generateHKL(Math.max(...fullExperimentalData.tth), params, system, centering);
            lastGeneratedHklList = hklList;
            
            const arbitraryIntensity = Math.max(...fullExperimentalData.intensity) * 0.5;
            hklList.forEach(p => p.intensity = arbitraryIntensity);

            const { pattern, background } = calculatePattern(fullExperimentalData.tth, hklList, params);
            
            const totalSimPattern = pattern.map((y, i) => y + background[i]);
            findDataset('Simulation (Manual)').data = fullExperimentalData.tth.map((t, i) => ({x: t, y: totalSimPattern[i]}));
            findDataset('Background').data = fullExperimentalData.tth.map((t, i) => ({x: t, y: background[i]}));
            
            const yMinLive = mainChart.scales.y.min;
            const negSpaceHeight = Math.abs(yMinLive);
            const markerBottom = -(negSpaceHeight * 0.05);
            const markerTop = -(negSpaceHeight * 0.20);

            findDataset('HKL Markers').data = hklList.map(hkl => ({ 
                x: hkl.tth + params.zeroShift, 
                y: [markerTop, markerBottom],
                hkl: `${hkl.hkl_list[0]} [m=${hkl.multiplicity}]`
            }));
            mainChart.update('none');
        }

        function setUIState(fitting) {
    isFitting = fitting;
    controls.fitButton.disabled = fitting;
    controls.reportButton.disabled = fitting;
    controls.saveDataButton.disabled = fitting;
    // This now correctly targets the button's text content
    controls.fitButton.textContent = fitting ? 'Refining...' : 'Run Refinement';
    controls.progressBarContainer.classList.toggle('hidden', !fitting);
    document.body.style.cursor = fitting ? 'wait' : 'default';
    if (fitting) {
        controls.rpResult.textContent = '...'; 
        controls.rwpResult.textContent = '...'; 
        controls.chi2Result.textContent = '...';
    }
    if (!fitting) {
        controls.progressBar.style.width = '0%';
        if(fitResults) {
            controls.reportButton.disabled = false;
            controls.saveDataButton.disabled = false;
        }
        controls.rwpResult.parentElement.parentElement.querySelectorAll('.result-card').forEach(c => c.style.background = '');
    }
}
        
        function updateUI(params, stats, peakPattern, background) {
            if (stats.r_p !== undefined) controls.rpResult.textContent = stats.r_p.toFixed(2);
            if (stats.rwp !== undefined) controls.rwpResult.textContent = stats.rwp.toFixed(2);
            if (stats.chi2 !== undefined) controls.chi2Result.textContent = stats.chi2.toFixed(3);
            if (params.a && document.getElementById('lattice-param-a')) document.getElementById('lattice-param-a').value = params.a.toFixed(4);
            if (params.b && document.getElementById('lattice-param-b')) document.getElementById('lattice-param-b').value = params.b.toFixed(4);
            if (params.c && document.getElementById('lattice-param-c')) document.getElementById('lattice-param-c').value = params.c.toFixed(4);
            if (params.alpha && document.getElementById('lattice-param-alpha')) document.getElementById('lattice-param-alpha').value = params.alpha.toFixed(3);
            if (params.beta && document.getElementById('lattice-param-beta')) document.getElementById('lattice-param-beta').value = params.beta.toFixed(3);
            if (params.gamma && document.getElementById('lattice-param-gamma')) document.getElementById('lattice-param-gamma').value = params.gamma.toFixed(3);
            controls.zeroShift.value = params.zeroShift.toFixed(4);
            controls.paramGU.value = params.GU.toFixed(4);
            controls.paramGV.value = params.GV.toFixed(4);
            controls.paramGW.value = params.GW.toFixed(4);
            controls.paramGP.value = params.GP.toFixed(4);
            controls.paramLX.value = params.LX.toFixed(4);
            controls.paramEta.value = params.eta.toFixed(4);
            controls.paramShft.value = params.shft.toFixed(4);
            controls.paramTrns.value = params.trns.toFixed(4);
            if (peakPattern && background) {
                const { system, centering } = getSystemAndCentering();
                const hklList = generateHKL(Math.max(...fullExperimentalData.tth), params, system, centering);
                lastGeneratedHklList = hklList;
                updateChart(peakPattern, background, hklList, params);
            }
        }

        function initializeChart() {
            if (mainChart) mainChart.destroy();
            const experimentalPoints = fullExperimentalData.tth.map((t, i) => ({x: t, y: fullExperimentalData.intensity[i]}));
            const yMax = Math.max(...fullExperimentalData.intensity) || 1000;
            mainChart = new Chart(controls.mainChartCanvas, {
                type: 'line', 
                data: { datasets: [
                    { label: 'Experimental', data: experimentalPoints, borderColor: 'rgba(107, 114, 128, 0.7)', borderWidth: 1.5, pointRadius: 0, order: 1 },
                    { label: 'Simulation (Manual)', data: [], borderColor: 'rgba(249, 115, 22, 0.8)', borderWidth: 2, pointRadius: 0, borderDash: [8, 4], order: 2 },
                    { label: 'Calculated', data: [], borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 2, pointRadius: 0, order: 3 },
                    { label: 'Background', data: [], borderColor: 'rgba(217, 119, 6, 0.8)', borderWidth: 1.5, pointRadius: 0, borderDash: [5, 5], order: 4 },
                    { label: 'Difference', data: [], borderColor: 'rgba(239, 68, 68, 0.8)', borderWidth: 1.5, pointRadius: 0, order: 5 },
                    { label: 'Difference Zero', data: [], borderColor: 'rgba(156, 163, 175, 0.8)', borderWidth: 1, pointRadius: 0, borderDash: [2, 2], order: 6 },
                    { type: 'bar', label: 'HKL Markers', data: [], backgroundColor: 'rgba(22, 163, 74, 0.9)', barThickness: 2, categoryPercentage: 1.0, barPercentage: 1.0, order: 0 },
                ]},
                options: { 
                    responsive: true, maintainAspectRatio: false, animation: false, 
                    scales: { 
                        x: { type: 'linear', title: { display: true, text: '2θ (degrees)', font: { size: 14 }}},
                        y: { type: 'linear', position: 'left', title: { display: true, text: 'Intensity (a.u.)', font: { size: 14 }},
                            min: -yMax * 0.3, max: Math.ceil(yMax * 1.1),
                            ticks: { callback: function(value, index, ticks) { return value >= 0 ? value.toFixed(1) : null; }}
                        }
                    }, 
                    plugins: {
                        zoom: { 
                            pan: { 
                                enabled: true, 
                                mode: 'xy', 
                                threshold: 5,
                                onPanComplete: () => rescalePlot(false)
                            }, 
                            zoom: { 
                                wheel: { enabled: false }, 
                                pinch: { enabled: true }, 
                                drag: { enabled: false },
                                onZoomComplete: () => rescalePlot(false)
                            }
                        },
                        legend: { labels: { filter: item => item.text !== 'Difference Zero' && item.text !== 'Simulation (Manual)'}},
                        tooltip: { enabled: true, mode: 'index', intersect: false, position: 'experimentalAnchor', callbacks: {
                            title: function(tooltipItems) {
                                if (!tooltipItems.length) return '';
                                const tth = tooltipItems[0].parsed.x;
                                let title = `2θ: ${tth.toFixed(2)}`;
                                if (lastGeneratedHklList && lastGeneratedHklList.length > 0) {
                                    let closestPeak = null, minDiff = Infinity;
                                    const currentParams = getAllParams();
                                    const zeroShift = currentParams.zeroShift || 0;
                                    for (const hkl of lastGeneratedHklList) {
                                        const peakPos = hkl.tth + zeroShift;
                                        const diff = Math.abs(tth - peakPos);
                                        if (diff < minDiff) { minDiff = diff; closestPeak = hkl; }
                                    }
                                    if (closestPeak) {
                                        const { gamma_G, gamma_L } = calculateProfileWidths(closestPeak.tth, currentParams);
                                        const fwhm = gamma_G + gamma_L;
                                        if (minDiff < fwhm) title += `, HKL: ${closestPeak.hkl_list[0]} [m=${closestPeak.multiplicity}])`;
                                    }
                                }
                                return title;
                            },
                            label: function(context) {
                                const datasetLabel = context.dataset.label || '';
                                if (datasetLabel === 'HKL Markers' || datasetLabel === 'Difference Zero' || datasetLabel === 'Simulation (Manual)') return null;
                                if (datasetLabel === 'Difference') {
                                    const yMinLive = mainChart.scales.y.min;
                                    const negSpaceHeight = Math.abs(yMinLive);
                                    const diffPlotSpaceTop = -(negSpaceHeight * 0.25);
                                    const diffPlotZeroLine = (yMinLive + diffPlotSpaceTop) / 2;
                                    const diffPlotAmplitude = Math.abs(yMinLive - diffPlotSpaceTop) / 2 * 0.95;
                                    let dYmax = 1;
                                    const minX = mainChart.scales.x.min;
                                    const maxX = mainChart.scales.x.max;
                                    for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                                        if (fullExperimentalData.tth[i] >= minX && fullExperimentalData.tth[i] <= maxX) {
                                            dYmax = Math.max(dYmax, Math.abs(lastRawDifference[i]));
                                        }
                                    }
                                    const scalingFactor = diffPlotAmplitude / dYmax;

                                    const realValue = (context.parsed.y - diffPlotZeroLine) / scalingFactor;
                                    return `${datasetLabel}: ${Math.round(realValue)}`;
                                }
                                let label = datasetLabel ? `${datasetLabel}: ` : '';
                                if (context.parsed.y !== null) label += Math.round(context.parsed.y);
                                return label;
                            }
                        }}
                    } 
                }
            });
        }
        
        // --- MODIFIED: This function only changes X-axis unless updateY is true ---
        function updatePlotRange(updateY = false) {
            if(!mainChart || !fullExperimentalData || fullExperimentalData.tth.length === 0) return;
            const min = parseFloat(controls.tthMinSlider.value);
            const max = parseFloat(controls.tthMaxSlider.value);
            mainChart.options.scales.x.min = min;
            mainChart.options.scales.x.max = max;
            
            if (updateY) {
                let yMaxInRange = 1; 
                for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                    if (fullExperimentalData.tth[i] >= min && fullExperimentalData.tth[i] <= max) {
                        if (fullExperimentalData.intensity[i] > yMaxInRange) yMaxInRange = fullExperimentalData.intensity[i];
                    }
                }
                const diffPlotHeightRatio = 0.33;
                mainChart.options.scales.y.max = Math.ceil(yMaxInRange * 1.1);
                mainChart.options.scales.y.min = -yMaxInRange * diffPlotHeightRatio;
            }
        }
        
        // --- MODIFIED: This function now handles dynamic plots and calls updatePlotRange with a flag ---
        function rescalePlot(updateY = false) {
            if (!mainChart || !fullExperimentalData.tth.length) return;
            
            updatePlotRange(updateY); 
            mainChart.update('none'); 

            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            
            const yMinLive = mainChart.scales.y.min;
            const negSpaceHeight = Math.abs(yMinLive);

            // Update HKL Markers (if they exist)
            const hklDataset = findDataset('HKL Markers');
            if (hklDataset && hklDataset.data.length > 0) {
                const markerBottom = -(negSpaceHeight * 0.05);
                const markerTop = -(negSpaceHeight * 0.20);
                hklDataset.data.forEach(point => point.y = [markerTop, markerBottom]);
            }
            
            // Update Difference Plot (if it exists)
            if (lastRawDifference && lastRawDifference.length > 0) {
                const diffPlotSpaceTop = -(negSpaceHeight * 0.25);
                const diffPlotZeroLine = (yMinLive + diffPlotSpaceTop) / 2;
                const diffPlotAmplitude = Math.abs(yMinLive - diffPlotSpaceTop) / 2 * 0.95;

                let dYmax = 1;
                const minX = mainChart.scales.x.min;
                const maxX = mainChart.scales.x.max;
                for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                    if (fullExperimentalData.tth[i] >= minX && fullExperimentalData.tth[i] <= maxX) {
                        dYmax = Math.max(dYmax, Math.abs(lastRawDifference[i]));
                    }
                }
                
                const scalingFactor = diffPlotAmplitude / dYmax;
                findDataset('Difference').data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: (lastRawDifference[i] * scalingFactor) + diffPlotZeroLine }));
                findDataset('Difference Zero').data = [
                    {x: fullExperimentalData.tth[0], y: diffPlotZeroLine},
                    {x: fullExperimentalData.tth[fullExperimentalData.tth.length-1], y: diffPlotZeroLine}
                ];
            }
            
            mainChart.update('none');
        }

        // --- MODIFIED: This function now uses dynamic positioning for markers and difference plot ---
        function updateChart(peakPattern, background, hklList, params) {
            if (!mainChart) return;
            const findDataset = (label) => mainChart.data.datasets.find(d => d.label === label);
            findDataset('Simulation (Manual)').data = []; 
            
            const totalCalcPattern = peakPattern.map((y, i) => y + background[i]);
            findDataset('Calculated').data = fullExperimentalData.tth.map((t, i) => ({x: t, y: totalCalcPattern[i]})); 
            findDataset('Background').data = fullExperimentalData.tth.map((t, i) => ({x: t, y: background[i]})); 

            lastRawDifference = fullExperimentalData.intensity.map((y, i) => y - totalCalcPattern[i]);
            
            updatePlotRange(true); // Always update Y-scale after a fit
            mainChart.update('none'); // Apply scale change

            // Now draw markers and diff plot dynamically
            const yMinLive = mainChart.scales.y.min;
            const negSpaceHeight = Math.abs(yMinLive);

            // HKL Markers
            const markerBottom = -(negSpaceHeight * 0.05);
            const markerTop = -(negSpaceHeight * 0.20);
            findDataset('HKL Markers').data = hklList.map(hkl => ({ 
                x: hkl.tth + params.zeroShift, 
                y: [markerTop, markerBottom], // Use floating bar y-data
                hkl: `${hkl.hkl_list[0]} [m=${hkl.multiplicity}]`
            }));
            
            // Difference Plot
            const diffPlotSpaceTop = -(negSpaceHeight * 0.25);
            const diffPlotZeroLine = (yMinLive + diffPlotSpaceTop) / 2;
            const diffPlotAmplitude = Math.abs(yMinLive - diffPlotSpaceTop) / 2 * 0.95;

            let dYmax = 1;
            const minX = mainChart.scales.x.min;
            const maxX = mainChart.scales.x.max;
            if (lastRawDifference.length > 0) {
                 for (let i = 0; i < fullExperimentalData.tth.length; i++) {
                    if (fullExperimentalData.tth[i] >= minX && fullExperimentalData.tth[i] <= maxX) {
                        dYmax = Math.max(dYmax, Math.abs(lastRawDifference[i]));
                    }
                }
            }
            
            const scalingFactor = diffPlotAmplitude / dYmax;
            findDataset('Difference').data = fullExperimentalData.tth.map((t, i) => ({ x: t, y: (lastRawDifference[i] * scalingFactor) + diffPlotZeroLine }));
            findDataset('Difference Zero').data = [
                {x: fullExperimentalData.tth[0], y: diffPlotZeroLine},
                {x: fullExperimentalData.tth[fullExperimentalData.tth.length-1], y: diffPlotZeroLine}
            ];
            
            mainChart.update('none');
        }

        // --- Event Listeners ---
        controls.fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                try {
                    let parsedData;
                    const fileContent = evt.target.result;
                    const fileName = file.name.toLowerCase();
                    const fileStart = (fileContent && typeof fileContent === 'string') ? fileContent.substring(0, 200).toUpperCase() : '';

                    if (fileName.endsWith('.xrdml')) parsedData = parseXrdmlFile(fileContent);
                    else if (fileName.endsWith('.brml')) parsedData = parseBrukerBrmlFile(fileContent);
                    else if (fileName.endsWith('.ras')) parsedData = parseRigakuRasFile(fileContent);
                    else if (fileName.endsWith('.esd') || fileName.endsWith('.std')) parsedData = parseGsasEsdFile(fileContent);
                    else if (fileName.endsWith('.udf')) parsedData = parsePhilipsUdfFile(fileContent);
                    else if (fileStart.includes('<?XML')) {
                        if (fileStart.includes('<XRDMEASUREMENT')) parsedData = parseXrdmlFile(fileContent);
                        else if (fileStart.includes('<RAWDATAFILE')) parsedData = parseBrukerBrmlFile(fileContent);
                        else throw new Error("Unsupported XML file format. Trying generic parser.");
                    } else if (fileStart.includes('*RAS_HEADER_START')) {
                        parsedData = parseRigakuRasFile(fileContent);
                    } else {
                        const data = parseDataFile(fileContent);
                        if (data.tth.length > 0) parsedData = { tth: data.tth, intensity: data.intensity };
                    }
                    if (!parsedData || parsedData.tth.length === 0) throw new Error("No valid data points could be parsed from the file.");

                    if (parsedData.wavelength) {
                    controls.wavelength.value = parsedData.wavelength.toFixed(5);
                    }

                    fullExperimentalData = { tth: parsedData.tth, intensity: parsedData.intensity };
                    lastRawDifference = [];
                    calculatedBackground = new Array(fullExperimentalData.tth.length).fill(0);
                    const maxExpIntensity = Math.max(...fullExperimentalData.intensity);
                    if (maxExpIntensity > 0) {
                        fullExperimentalData.intensity = fullExperimentalData.intensity.map(y => (y / maxExpIntensity) * 1000);
                    }
                    controls.fileName.textContent = file.name;
                    controls.placeholder.style.display = 'none';
                    controls.resultsContainer.style.display = 'flex';
                    controls.fitButton.disabled = false;

                    controls.fitButton.textContent = 'Run Refinement';
                    
                    initializeChart();
                    const min = fullExperimentalData.tth[0];
                    const max = fullExperimentalData.tth[fullExperimentalData.tth.length - 1];
                    const step = (max - min) / 2000;
                    [controls.tthMinSlider, controls.tthMaxSlider].forEach(slider => {
                        slider.min = min; slider.max = max; slider.step = step; slider.disabled = false;
                    });
                    const initialMin = Math.floor(min);
            const initialMax = Math.ceil(max);
            controls.tthMinSlider.value = initialMin;
            controls.tthMaxSlider.value = initialMax;
            controls.tthMinValue.textContent = initialMin.toFixed(2); 
            controls.tthMaxValue.textContent = initialMax.toFixed(2);
            updateAndApplyBackground(); 
            rescalePlot(true); // MODIFIED: Update Y-axis on new file
        } catch (error) {
            alert(`Error reading file: ${error.message}`);
            console.error(error);
        }
    };
    reader.onerror = () => { alert('Error: Could not read the selected file.'); };
    reader.readAsText(file);
});

 
        
        document.getElementById('lattice-parameters-container').addEventListener('input', updatePreviewPattern);

        const previewInputs = Object.values(controls).filter(el => el && (el.tagName === 'INPUT' || el.tagName === 'SELECT'));
        previewInputs.forEach(input => {
            if (!['file-input', 'tth-min-slider', 'tth-max-slider', 'bravais-lattice', 'ball-radius-slider', 'smoothing-width-slider'].includes(input.id)) {
                input.addEventListener('input', updatePreviewPattern);
            }
        });

        controls.fitButton.addEventListener('click', runLeBailFit);

        const tabNav = document.querySelector('.tab-buttons');
        tabNav.addEventListener('click', (e) => {
            const clickedTab = e.target.closest('.tab-btn');
            if (clickedTab && !clickedTab.disabled) {
                tabNav.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                clickedTab.classList.add('active');
                document.querySelectorAll('.tab-content-panel').forEach(panel => panel.classList.remove('active'));
                document.getElementById(`tab-panel-${clickedTab.dataset.tab}`).classList.add('active');
            }
        });
        
        const resizer = document.getElementById('drag-handle');
        const leftPanel = document.getElementById('controls-panel');
        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault(); document.body.style.cursor = 'col-resize';
            const moveHandler = (moveEvent) => { if (moveEvent.clientX > 350 && moveEvent.clientX < window.innerWidth - 350) { leftPanel.style.width = `${moveEvent.clientX}px`; } };
            const upHandler = () => { document.body.style.cursor = 'default'; window.removeEventListener('mousemove', moveHandler); window.removeEventListener('mouseup', upHandler); };
            window.addEventListener('mousemove', moveHandler);
            window.addEventListener('mouseup', upHandler);
        });

        controls.reportButton.addEventListener('click', async () => {
            if (!fitResults) {
                alert("Please run a refinement before generating a report.");
                return;
            }
            const originalText = controls.reportButton.textContent;
            controls.reportButton.textContent = 'Generating...';
            controls.reportButton.disabled = true;

            try {
                const now = new Date();
                const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}`;
                const baseFilename = `LeBail-Report-${timestamp}`;
                
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                const margin = 15;
                const pdfWidth = doc.internal.pageSize.getWidth();
                const contentWidth = pdfWidth - 2 * margin;

                doc.setFontSize(18);
                doc.text('Le Bail Refinement Report', 105, 15, { align: 'center' });
                doc.setFontSize(10);
                doc.text(`Report Generated: ${now.toLocaleString()}`, margin, 25);
                doc.text(`Program used: LeBail.html, version 19 Sept 2025, nitad54448.github.io`,margin, 30);
                doc.text(`Data File: ${controls.fileName.textContent}`, margin, 35);
                const chartCanvas = await html2canvas(controls.mainChartCanvas, { backgroundColor: '#ffffff' });
                const mainImgData = chartCanvas.toDataURL('image/png');
                const mainImgProps = doc.getImageProperties(mainImgData);
                const mainImgHeight = (mainImgProps.height * contentWidth) / mainImgProps.width;
                doc.addImage(mainImgData, 'PNG', margin, 40, contentWidth, mainImgHeight);
                doc.addPage();
                let yPos = 20;
                doc.setFont('Helvetica', 'bold');
                doc.setFontSize(16);
                doc.text('Refinement Parameters & Statistics', margin, yPos);
                yPos += 10;
                const { system, centering } = getSystemAndCentering();
                const finalParams = fitResults.params;
                const fitFlags = fitResults.fitFlags;
                let esds = {}, esdWarning = null;

                if (fitResults.algorithm === 'lm' && fitResults.JtJ) {
                    const workingDataForStats = getWorkingData(true);
                    const N = workingDataForStats.intensity.length;
                    const P = fitResults.paramMapping.length;
                    if (N > P && fitResults.ss_res !== undefined) {
                        const reduced_chi_sq = fitResults.ss_res / (N - P);
                        const cov_matrix = matrixInverse(fitResults.JtJ);
                        if (cov_matrix) {
                            fitResults.paramMapping.forEach((p, i) => {
                                if (cov_matrix[i] && cov_matrix[i][i] !== undefined) {
                                    esds[p.name] = Math.sqrt(Math.abs(reduced_chi_sq * cov_matrix[i][i]));
                                }
                            });
                        } else { esdWarning = 'ESD calculation failed (unstable refinement or correlated parameters).'; }
                    }
                }
                const lineSpacing = 5;
                const addLine = (text) => { doc.text(text, margin, yPos); yPos += lineSpacing; };
                const addHeader = (text) => { yPos += 4; doc.setFont('Helvetica', 'bold'); doc.text(text, margin, yPos); yPos += (lineSpacing + 1); doc.setFont('Courier', 'normal'); };
                doc.setFontSize(9);
                doc.setFont('Courier', 'normal');
                addLine(`Rp (%):      ${fitResults.stats.r_p.toFixed(2)}`);
                addLine(`Rwp (%):     ${fitResults.stats.rwp.toFixed(2)}`);
                addLine(`Chi2 (GOF):    ${fitResults.stats.chi2.toFixed(3)}`);
                addLine(`Algorithm:   ${fitResults.algorithm === 'lm' ? 'Levenberg-Marquardt' : 'Simulated Annealing'}`);
                yPos += lineSpacing;
                addHeader('Structural Parameters');
                const paramTableLine = (name, value, flag, esd) => {
                    const valStr = (value !== undefined && value !== null) ? value.toExponential(6) : 'N/A';
                    const fitStr = flag ? 'Yes' : 'No';
                    const esdStr = (flag && esd !== undefined) ? `(${esd.toExponential(2)})` : '-';
                    return `${name.padEnd(14)}${valStr.padStart(14)} ${fitStr.padStart(8)}   ${esdStr.padStart(15)}`;
                };
                const allParams = [
                    { name: 'a (Å)', value: finalParams.a, flag: fitFlags.a, esd_name: 'a' },
                    { name: 'b (Å)', value: finalParams.b, flag: fitFlags.b, esd_name: 'b' },
                    { name: 'c (Å)', value: finalParams.c, flag: fitFlags.c, esd_name: 'c' },
                    { name: 'alpha (°)', value: finalParams.alpha, flag: fitFlags.alpha, esd_name: 'alpha' },
                    { name: 'beta (°)', value: finalParams.beta, flag: fitFlags.beta, esd_name: 'beta' },
                    { name: 'gamma (°)', value: finalParams.gamma, flag: fitFlags.gamma, esd_name: 'gamma' }
                ];
                const selectedOption = controls.bravaisLattice.options[controls.bravaisLattice.selectedIndex];
                addLine(`System: ${selectedOption.text}`);
                addLine('--------------------------------------------------------------');
                addLine('Parameter      Value           Fitted          ESD');
                addLine('--------------------------------------------------------------');
                allParams.forEach(p => { if (p.value) addLine(paramTableLine(p.name, p.value, p.flag, esds[p.esd_name])); });
                if (esdWarning) {
                    yPos += 2;
                    doc.setFont('Helvetica', 'italic');
                    doc.setTextColor(255, 0, 0);
                    doc.text(esdWarning, margin, yPos);
                    doc.setTextColor(0, 0, 0);
                    doc.setFont('Courier', 'normal');
                    yPos += lineSpacing;
                }
                addHeader('Instrument & Profile Parameters');
                addLine('--------------------------------------------------------------');
                addLine('Parameter      Value           Fitted          ESD');
                addLine('--------------------------------------------------------------');
                addLine(paramTableLine('Radiation (Å)', finalParams.lambda, false, null));
                addLine(paramTableLine('Zero Shift (°)', finalParams.zeroShift, fitFlags.zeroShift, esds['zeroShift']));
                addLine(paramTableLine('GU', finalParams.GU, fitFlags.GU, esds['GU']));
                addLine(paramTableLine('GV', finalParams.GV, fitFlags.GV, esds['GV']));
                addLine(paramTableLine('GW', finalParams.GW, fitFlags.GW, esds['GW']));
                addLine(paramTableLine('GP', finalParams.GP, fitFlags.GP, esds['GP']));
                addLine(paramTableLine('LX', finalParams.LX, fitFlags.LX, esds['LX']));
                addLine(paramTableLine('eta', finalParams.eta, fitFlags.eta, esds['eta']));
                addLine(paramTableLine('shft', finalParams.shft, fitFlags.shft, esds['shft']));
                addLine(paramTableLine('trns', finalParams.trns, fitFlags.trns, esds['trns']));
                addHeader('Background');
                addLine(`Method: Rolling Ball (fixed)`);
                addLine(`Ball Radius: ${controls.ballRadiusSlider.value} pts`);
                addLine(`Smoothing: ${controls.smoothingWidthSlider.value} pts`);


                doc.addPage();
                yPos = 20;
                doc.setFont('Helvetica', 'bold');
                doc.setFontSize(12);
                doc.text('Calculated vs. Experimental Reflections', margin, yPos);
                yPos += 8;
                doc.setFontSize(9);
                doc.setFont('Courier', 'normal');
                const hklList = generateHKL(Math.max(...fullExperimentalData.tth), finalParams, system, centering);
                const hklHeader = ['h,k,l', 'd_calc (Å)', 'd_exp (Å)', '2th_corr (°)', '2th_exp (°)'];
                const hklAlign = ['left', 'right', 'right', 'right', 'right'];
                const colX = { hkl: margin, d_calc: margin + 35, d_exp: margin + 70, tth_corr: margin + 105, tth_exp: margin + 140 };
                const hklSeparator = '-'.repeat(120);
                const printHklHeader = () => {
                    doc.text(hklHeader[0], colX.hkl, yPos, { align: hklAlign[0] });
                    doc.text(hklHeader[1], colX.d_calc, yPos, { align: hklAlign[1] });
                    doc.text(hklHeader[2], colX.d_exp, yPos, { align: hklAlign[2] });
                    doc.text(hklHeader[3], colX.tth_corr, yPos, { align: hklAlign[3] });
                    doc.text(hklHeader[4], colX.tth_exp, yPos, { align: hklAlign[4] });
                    yPos += lineSpacing;
                    doc.text(hklSeparator, margin, yPos);
                    yPos += lineSpacing;
                }
                printHklHeader();
                hklList.forEach(hkl => {
                    if (yPos > 280) {
                        doc.addPage();
                        yPos = 20;
                        doc.setFont('Courier', 'normal');
                        doc.setFontSize(9);
                        printHklHeader();
                    }
                    const peakShift = calculatePeakShift(hkl.tth, finalParams);
                    const tthCorr = hkl.tth + finalParams.zeroShift + peakShift;
                    const { tth_exp, d_exp } = findExperimentalPeakDetails(tthCorr, fullExperimentalData, finalParams.lambda);
                    const d_calc_str = hkl.d.toFixed(5), d_exp_str = d_exp ? d_exp.toFixed(5) : 'N/A';
                    const tth_corr_str = tthCorr.toFixed(4), tth_exp_str = tth_exp ? tth_exp.toFixed(4) : 'N/A';
                    doc.text(hkl.hkl_list[0], colX.hkl, yPos, { align: hklAlign[0] });
                    doc.text(d_calc_str, colX.d_calc, yPos, { align: hklAlign[1] });
                    doc.text(d_exp_str, colX.d_exp, yPos, { align: hklAlign[2] });
                    doc.text(tth_corr_str, colX.tth_corr, yPos, { align: hklAlign[3] });
                    doc.text(tth_exp_str, colX.tth_exp, yPos, { align: hklAlign[4] });
                    yPos += lineSpacing;
                });
                doc.save(`${baseFilename}.pdf`);
            } catch (error) {
                console.error("Failed to generate report:", error);
                alert("An error occurred while generating the report.");
            } finally {
                controls.reportButton.textContent = 'Generate PDF';
                controls.reportButton.disabled = false;
            }
        });

        controls.saveDataButton.addEventListener('click', () => {
            if (!fitResults) {
                alert("Please run a refinement before saving data.");
                return;
            }
            const originalText = controls.saveDataButton.textContent;
            controls.saveDataButton.textContent = 'Saving...';
            controls.saveDataButton.disabled = true;
            try {
                const now = new Date();
                const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}`;
                const baseFilename = `LeBail-Data-${timestamp}`;
                const textContent = generateTextReportContent(fitResults, controls);
                downloadTextFile(textContent, `${baseFilename}.txt`);
            } catch (error) {
                console.error("Failed to save data:", error);
                alert("An error occurred while saving the data file.");
            } finally {
                controls.saveDataButton.textContent = 'Save Report';
                controls.saveDataButton.disabled = false;
            }
        });

        controls.bravaisLattice.addEventListener('change', () => {
            updateLatticeParamUI();
            if (fullExperimentalData.tth.length > 0) {
                updatePreviewPattern();
            }
        });

        controls.iterationsSlider.addEventListener('input', () => {
            controls.iterationsValue.textContent = controls.iterationsSlider.value;
        });

        // --- MODIFIED: Listeners call rescalePlot with false to prevent Y-axis scaling ---
        controls.tthMinSlider.addEventListener('input', () => {
            let minVal = parseFloat(controls.tthMinSlider.value);
            let maxVal = parseFloat(controls.tthMaxSlider.value);
            if (minVal >= maxVal) {
                minVal = maxVal - parseFloat(controls.tthMinSlider.step);
                controls.tthMinSlider.value = minVal;
            }
            controls.tthMinValue.textContent = minVal.toFixed(2);
            rescalePlot(false);
        });

        controls.tthMaxSlider.addEventListener('input', () => {
            let minVal = parseFloat(controls.tthMinSlider.value);
            let maxVal = parseFloat(controls.tthMaxSlider.value);
            if (maxVal <= minVal) {
                maxVal = minVal + parseFloat(controls.tthMaxSlider.step);
                controls.tthMaxSlider.value = maxVal;
            }
            controls.tthMaxValue.textContent = maxVal.toFixed(2);
            rescalePlot(false);
        });
        
        controls.mainChartCanvas.addEventListener('wheel', e => {
            e.preventDefault();
            const chart = mainChart;
            if (!chart || !chart.chartArea) return;
            const { left, right, top, bottom } = chart.chartArea;
            const x = e.offsetX, y = e.offsetY;
            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
            
            // The onZoomComplete callback in the plugin options will handle redrawing the markers
            if (y > bottom) { 
                chart.zoom({ x: zoomFactor }, {x, y});
            } else if (x < left) { 
                chart.zoom({ y: zoomFactor }, {x, y});
            } else if (x >= left && x <= right && y >= top && y <= bottom) { 
                chart.zoom({ x: zoomFactor, y: zoomFactor }, {x, y});
            }
        });

        controls.mainChartCanvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            if (mainChart) {
                mainChart.resetZoom();
                rescalePlot(true); // Rescale fully on reset
            }
        });

        controls.ballRadiusSlider.addEventListener('input', () => {
            controls.ballRadiusValue.textContent = controls.ballRadiusSlider.value;
            updateAndApplyBackground();
        });
        controls.smoothingWidthSlider.addEventListener('input', () => {
            controls.smoothingWidthValue.textContent = controls.smoothingWidthSlider.value;
            updateAndApplyBackground();
        });

        // Initialize UI
        updateLatticeParamUI();
    });
</script>


</body>
</html>


