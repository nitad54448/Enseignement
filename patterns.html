<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Pattern Generator</title>
    <link href="./dist/output.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: #f0f0f0;
            color: #e5e7eb; /* Default light text for dark theme */
            display: flex;
            flex-direction: column; /* Allow footer to sit below */
            height: 100vh;
            overflow: hidden;
        }
        .main-container {
            display: flex;
            width: 100%;
            flex-grow: 1; /* Take up available space */
            overflow: hidden;
        }
        #controls-panel {
            flex: 0 0 400px; /* Initial width */
            min-width: 320px;
            max-width: 600px;
            padding: 24px;
            background-color: #111827; /* Dark blue-gray */
            border-right: 1px solid #374151;
            overflow-y: auto;
            color: #d1d5db;
        }
        #drag-handle {
            width: 8px;
            cursor: col-resize;
            background-color: #374151;
            flex-shrink: 0;
            transition: background-color 0.2s;
        }
        #drag-handle:hover {
            background-color: #3b82f6;
        }
        #visualization-area {
            flex-grow: 1;
            background-color: #ffffff;
            min-width: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 1rem;
            color: #1f2937; /* Dark text for light theme */
        }
        .canvas-wrapper {
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            width: 100%;
            max-width: 1000px;
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        /* Dark Theme Controls Styling */
        #controls-panel h1 { font-size: 1.8em; margin-bottom: 8px; font-weight: 700; color: #ffffff; }
        #controls-panel p { font-size: 0.9em; margin-bottom: 24px; color: #9ca3af; }
        #controls-panel h2 { font-size: 1.25em; font-weight: 600; margin-bottom: 16px; border-bottom: 1px solid #374151; padding-bottom: 8px; color: #ffffff;}
        #controls-panel label { display: block; margin-bottom: 8px; font-weight: 500; color: #9ca3af; }
        #controls-panel select {
            background-color: #374151;
            border: 1px solid #4b5563;
            color: #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.5rem;
            width: 100%;
        }
        .control-group {
            margin-bottom: 1.5rem;
            padding: 1rem;
            border: 1px solid #374151;
            border-radius: 0.5rem;
            background-color: rgba(255, 255, 255, 0.05);
        }

        /* Range Slider */
        input[type=range] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 6px; background: #4b5563;
            border-radius: 3px; outline: none; opacity: 0.8; transition: opacity .2s;
        }
        input[type=range]:hover { opacity: 1; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 18px; height: 18px; background: #3b82f6;
            cursor: pointer; border-radius: 50%;
        }
        input[type=range]::-moz-range-thumb {
            width: 18px; height: 18px; background: #3b82f6;
            cursor: pointer; border-radius: 50%;
        }

        /* Color Picker */
        input[type="color"] {
            -webkit-appearance: none;
            width: 48px;
            height: 48px;
            border: 1px solid #4b5563;
            cursor: pointer;
            padding: 0;
            border-radius: 0.375rem;
            overflow: hidden;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 0.375rem; }

        footer {
            flex-shrink: 0; /* Prevent footer from shrinking */
        }

    </style>
</head>
<body class="bg-gray-100 flex flex-col h-screen">

    <div class="main-container">
        <div id="controls-panel">
            <h1>Pattern Generator</h1>
            <p>Create tilings using the 17 wallpaper groups. Start by uploading a motif.</p>

            <div class="space-y-6">
                <div class="control-group">
                    <h2 class="text-lg font-semibold mb-2">Motif Source</h2>
                    <div class="flex items-center gap-3 mb-3">
                        <button id="use-upload-btn" class="flex-1 bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 focus:outline-none ring-blue-500 ring-offset-2 transition-all duration-200">Upload</button>
                        <button id="use-webcam-btn" class="flex-1 bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600 focus:outline-none ring-green-500 ring-offset-2 transition-all duration-200">Webcam</button>
                        <input type="file" id="image-upload" class="hidden" accept="image/png, image/jpeg">
                    </div>
                    <div class="flex items-center gap-4">
                         <div class="w-20 h-20 bg-gray-700 rounded-md overflow-hidden border border-gray-600">
                            <img id="source-preview-img" class="w-full h-full object-cover hidden">
                            <video id="source-preview-video" class="w-full h-full object-cover hidden" autoplay playsinline muted></video>
                         </div>
                         <div id="status" class="text-sm text-gray-400 font-medium flex-1">Select a source to begin.</div>
                    </div>
                </div>

                <div class="control-group">
                    <div class="flex items-center justify-between">
                        <label for="space-group-select" class="text-lg font-semibold mb-0">Space Group</label>
                        <select id="space-group-select" class="w-1/2">
                            <option value="p1">p1</option>
                            <option value="p2">p2</option>
                            <option value="pm">pm</option>
                            <option value="pg">pg</option>
                            <option value="cm">cm</option>
                            <option value="p2mm">p2mm</option>
                            <option value="p2mg">p2mg</option>
                            <option value="p2gg">p2gg</option>
                            <option value="c2mm">c2mm</option>
                            <option value="p4">p4</option>
                            <option value="p4mm">p4mm</option>
                            <option value="p4gm">p4gm</option>
                            <option value="p3">p3</option>
                            <option value="p3m1">p3m1</option>
                            <option value="p31m">p31m</option>
                            <option value="p6">p6</option>
                            <option value="p6mm">p6mm</option>
                        </select>
                    </div>
                </div>

                <div class="control-group">
                    <h2 class="text-lg font-semibold mb-3">Motif Parameters</h2>
                    <div class="space-y-4">
                        <div class="flex items-center gap-4">
                            <label for="motif-x-slider" class="w-24 text-sm font-medium">X: <span id="motif-x-value" class="font-mono bg-gray-700 px-2 py-1 rounded">0.25</span></label>
                            <input type="range" id="motif-x-slider" min="0" max="1" step="0.01" value="0.25">
                        </div>
                         <div class="flex items-center gap-4">
                            <label for="motif-y-slider" class="w-24 text-sm font-medium">Y: <span id="motif-y-value" class="font-mono bg-gray-700 px-2 py-1 rounded">0.25</span></label>
                            <input type="range" id="motif-y-slider" min="0" max="1" step="0.01" value="0.25">
                        </div>
                         <div class="flex items-center gap-4">
                            <label for="motif-size-slider" class="w-24 text-sm font-medium">Size: <span id="motif-size-value" class="font-mono bg-gray-700 px-2 py-1 rounded">50</span></label>
                            <input type="range" id="motif-size-slider" min="10" max="150" step="1" value="50">
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <h2 class="text-lg font-semibold mb-3">Cell Parameters</h2>
                    <div class="space-y-4">
                        <div class="flex items-center gap-4">
                            <label for="cell-a-slider" class="w-24 text-sm font-medium">a: <span id="cell-a-value" class="font-mono bg-gray-700 px-2 py-1 rounded">100</span></label>
                            <input type="range" id="cell-a-slider" min="50" max="250" step="1" value="100">
                        </div>
                         <div class="flex items-center gap-4">
                            <label for="cell-b-slider" class="w-24 text-sm font-medium">b: <span id="cell-b-value" class="font-mono bg-gray-700 px-2 py-1 rounded">100</span></label>
                            <input type="range" id="cell-b-slider" min="50" max="250" step="1" value="100">
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <h2 class="text-lg font-semibold mb-2">Background</h2>
                    <div class="flex items-center justify-between gap-3">
                        <input type="color" id="bg-color-picker" value="#FFFFFF">
                        <button id="bg-upload-btn" class="flex-1 bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-all duration-200 text-sm">Upload Image</button>
                        <input type="file" id="bg-upload-input" class="hidden" accept="image/png, image/jpeg">
                        <button id="bg-clear-btn" class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-all duration-200 text-sm">Clear</button>
                    </div>
                </div>

                <div class="control-group">
                    <h2 class="text-lg font-semibold mb-2">Export</h2>
                    <button id="save-image-btn" class="w-full bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200">
                        Save as PNG
                    </button>
                </div>

            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="visualization-area">
            <div class="canvas-wrapper">
                <canvas id="pattern-canvas"></canvas>
            </div>
        </div>
    </div>

    <footer class="w-full bg-white p-2 border-t flex justify-between items-center text-xs text-gray-600 shadow-inner">
        <span class="px-4">2D space groups tilings</span>
        <span class="px-4">NitaD, Univ Paris-Saclay, 02 Aug 2025</span>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const patternCanvas = document.getElementById('pattern-canvas');
            const patternCtx = patternCanvas.getContext('2d');
            
            const sourcePreviewImg = document.getElementById('source-preview-img');
            const sourcePreviewVideo = document.getElementById('source-preview-video');
            const useUploadBtn = document.getElementById('use-upload-btn');
            const useWebcamBtn = document.getElementById('use-webcam-btn');
            const imageUpload = document.getElementById('image-upload');
            const statusEl = document.getElementById('status');
            const saveImageBtn = document.getElementById('save-image-btn');

            const spaceGroupSelect = document.getElementById('space-group-select');
            
            const motifXSlider = document.getElementById('motif-x-slider');
            const motifYSlider = document.getElementById('motif-y-slider');
            const motifSizeSlider = document.getElementById('motif-size-slider');
            const motifXValue = document.getElementById('motif-x-value');
            const motifYValue = document.getElementById('motif-y-value');
            const motifSizeValue = document.getElementById('motif-size-value');

            const cellASlider = document.getElementById('cell-a-slider');
            const cellBSlider = document.getElementById('cell-b-slider');
            const cellAValue = document.getElementById('cell-a-value');
            const cellBValue = document.getElementById('cell-b-value');

            const bgColorPicker = document.getElementById('bg-color-picker');
            const bgUploadBtn = document.getElementById('bg-upload-btn');
            const bgUploadInput = document.getElementById('bg-upload-input');
            const bgClearBtn = document.getElementById('bg-clear-btn');

            const resizer = document.getElementById('drag-handle');
            const leftPanel = document.getElementById('controls-panel');

            // --- State ---
            let state = {
                spaceGroup: 'p1',
                motifX: 0.25,
                motifY: 0.25,
                motifSize: 50,
                a: 100,
                b: 100,
                backgroundColor: '#FFFFFF',
                backgroundImage: null,
                source: null,
                currentMode: null,
                webcamStream: null,
                animationFrameId: null,
            };
            
            let backgroundImage = new Image();

            // --- Crystallographic Data ---
            const spaceGroupInfo = {
                p1: { system: 'oblique', gamma: 110 }, p2: { system: 'oblique', gamma: 110 },
                pm: { system: 'rectangular', gamma: 90 }, pg: { system: 'rectangular', gamma: 90 },
                cm: { system: 'rectangular', gamma: 90 }, p2mm: { system: 'rectangular', gamma: 90 },
                p2mg: { system: 'rectangular', gamma: 90 }, p2gg: { system: 'rectangular', gamma: 90 },
                c2mm: { system: 'rectangular', gamma: 90 }, p4: { system: 'square', gamma: 90 },
                p4mm: { system: 'square', gamma: 90 }, p4gm: { system: 'square', gamma: 90 },
                p3: { system: 'hexagonal', gamma: 120 }, p3m1: { system: 'hexagonal', gamma: 120 },
                p31m: { system: 'hexagonal', gamma: 120 }, p6: { system: 'hexagonal', gamma: 120 },
                p6mm: { system: 'hexagonal', gamma: 120 }
            };
            
            // --- Core Logic Functions ---
            function getSymmetryOperations(spaceGroup) {
                const ops = {
                    p1: (x, y) => [{x, y}], p2: (x, y) => [{x, y}, {x: -x, y: -y, a: 180}],
                    pm: (x, y) => [{x, y}, {x: -x, y, m: 'y'}], pg: (x, y) => [{x, y}, {x: -x, y: y + 0.5, m: 'y'}],
                    cm: (x, y) => [{x, y}, {x: -x, y, m: 'y'}, {x: x + 0.5, y: y + 0.5}, {x: -x + 0.5, y: y + 0.5, m: 'y'}],
                    p2mm: (x, y) => [{x, y}, {x: -x, y, m: 'y'}, {x, y: -y, m: 'x'}, {x: -x, y: -y, a: 180}],
                    p2mg: (x, y) => [{x, y}, {x: -x, y: -y, a: 180}, {x: -x + 0.5, y, m: 'y'}, {x: x + 0.5, y: -y, m: 'x'}],
                    p2gg: (x, y) => [{x, y}, {x: -x, y: -y, a: 180}, {x: -x + 0.5, y: y + 0.5, m: 'y'}, {x: x + 0.5, y: -y + 0.5, m: 'x'}],
                    c2mm: (x, y) => [{x:x, y:y}, {x:-x,y,m:'y'}, {x,y:-y,m:'x'}, {x:-x,y:-y, a: 180}, {x:x+0.5,y:y+0.5}, {x:-x+0.5,y:y+0.5,m:'y'}, {x:x+0.5,y:-y+0.5,m:'x'}, {x:-x+0.5,y:-y+0.5, a: 180}],
                    p4: (x, y) => [{x, y}, {x: -y, y: x, a: 90}, {x: -x, y: -y, a: 180}, {x: y, y: -x, a: 270}],
                    p4mm: (x, y) => [{x, y}, {x: -y, y: x, a: 90}, {x: -x, y: -y, a: 180}, {x: y, y: -x, a: 270}, {x: -x, y, m: 'y'}, {x: y, y: x, m: 'xy'}, {x, y: -y, m: 'x'}, {x: -y, y: -x, m: 'x-y'}],
                    p4gm: (x, y) => [{x:x, y:y}, {x:-x, y:-y, a:180}, {x:-y, y:x, a:90}, {x:y, y:-x, a:270}, {x:-x+0.5, y:y+0.5, m:'y'}, {x:x+0.5, y:-y+0.5, m:'x'}, {x:y+0.5, y:x+0.5, m:'xy'}, {x:-y+0.5, y:-x+0.5, m:'x-y'}],
                    p3: (x, y) => [{x,y}, {x: -y, y: x-y, a:120}, {x: y-x, y: -x, a:240}],
                    p3m1: (x, y) => [{x:x, y:y}, {x:-y, y:x-y, a:120}, {x:y-x, y:-x, a:240}, {x:x-y, y:-y, m:'x'}, {x:-x, y:y-x, m:'y'}, {x:y, y:x, m:'xy'}],
                    p31m: (x, y) => [{x:x, y:y}, {x:-y, y:x-y, a:120}, {x:y-x, y:-x, a:240}, {x:y, y:x, m:'xy'}, {x:x-y, y:-y, m:'x'}, {x:-x, y:y-x, m:'y'}],
                    p6: (x, y) => [{x:x, y:y}, {x:-y, y:x-y, a:120}, {x:y-x, y:-x, a:240}, {x:-x, y:-y, a:180}, {x:y, y:y-x, a:60}, {x:x-y, y:x, a:300}],
                    p6mm: (x, y) => [{x:x, y:y}, {x:-y, y:x-y, a:120}, {x:y-x, y:-x, a:240}, {x:-x, y:-y, a:180}, {x:y, y:y-x, a:60}, {x:x-y, y:x, a:300}, {x:y, y:x, m:'xy'}, {x:x-y, y:-y, m:'x'}, {x:-x, y:y-x, m:'y'}, {x:-y, y:-x, m:'x-y'}]
                };
                return ops[spaceGroup];
            }

            function createDefaultMotif() {
                const motifCanvas = document.createElement('canvas');
                motifCanvas.width = 100;
                motifCanvas.height = 100;
                const ctx = motifCanvas.getContext('2d');
                ctx.beginPath();
                ctx.arc(50, 50, 45, 0, 2 * Math.PI); // x, y, radius, startAngle, endAngle
                ctx.fillStyle = 'rgba(40, 40, 80, 0.7)';
                ctx.fill();
                return motifCanvas;
            }
            
            // --- Drawing Functions ---
            function drawPattern(forExport = false) {
                const dpr = window.devicePixelRatio || 1;
                const canvasEl = patternCanvas;
                const ctx = patternCtx;
                
                const size = canvasEl.width / dpr;
                ctx.save();
                ctx.resetTransform();
                ctx.scale(dpr, dpr);

                if (state.backgroundImage && state.backgroundImage.width > 0) {
                    const pattern = ctx.createPattern(state.backgroundImage, 'repeat');
                    ctx.fillStyle = pattern;
                    ctx.fillRect(0, 0, size, size);
                } else {
                    ctx.fillStyle = state.backgroundColor;
                    ctx.fillRect(0, 0, size, size);
                }

                if (!state.source || !(state.source.width || state.source.videoWidth)) {
                    ctx.restore();
                    return;
                }

                const info = spaceGroupInfo[state.spaceGroup];
                const gammaRad = info.gamma * Math.PI / 180;
                const opFunc = getSymmetryOperations(state.spaceGroup);
                if (!opFunc) {
                    ctx.restore();
                    return;
                }
                
                const operations = opFunc(state.motifX, state.motifY);
                
                const { a, b } = state;
                const v1 = { x: a, y: 0 };
                const v2 = { x: b * Math.cos(gammaRad), y: b * Math.sin(gammaRad) };

                ctx.save();
                ctx.translate(size / 2, size / 2);

                const sinG = Math.sin(gammaRad);
                if (Math.abs(sinG) < 1e-6) { ctx.restore(); return; }
                const inv_a = 1 / a;
                const inv_b_sin_g = 1 / (b * sinG);
                const cos_g = Math.cos(gammaRad);

                const corners = [
                    { x: -size / 2, y: -size / 2 }, { x:  size / 2, y: -size / 2 },
                    { x:  size / 2, y:  size / 2 }, { x: -size / 2, y:  size / 2 },
                ];

                let min_n1 = Infinity, max_n1 = -Infinity, min_n2 = Infinity, max_n2 = -Infinity;
                corners.forEach(p => {
                    const n2 = p.y * inv_b_sin_g;
                    const n1 = (p.x - n2 * b * cos_g) * inv_a;
                    min_n1 = Math.min(min_n1, n1); max_n1 = Math.max(max_n1, n1);
                    min_n2 = Math.min(min_n2, n2); max_n2 = Math.max(max_n2, n2);
                });

                for (let n1 = Math.floor(min_n1) - 1; n1 <= Math.ceil(max_n1) + 1; n1++) {
                    for (let n2 = Math.floor(min_n2) - 1; n2 <= Math.ceil(max_n2) + 1; n2++) {
                        
                        ctx.save();
                        
                        const cellOriginX = n1 * v1.x + n2 * v2.x;
                        const cellOriginY = n1 * v1.y + n2 * v2.y;
                        ctx.translate(cellOriginX, cellOriginY);

                        operations.forEach(op => {
                            const motifImage = state.source;
                            const w = state.motifSize; const h = state.motifSize;
                            
                            ctx.save();
                            
                            const posX = op.x * a + op.y * b * cos_g;
                            const posY = op.y * b * sinG;
                            ctx.translate(posX, posY);

                            if (op.a) ctx.rotate(op.a * Math.PI / 180);
                            if (op.m === 'x') ctx.scale(1, -1);
                            else if (op.m === 'y') ctx.scale(-1, 1);
                            else if (op.m === 'xy') ctx.transform(0, 1, 1, 0, 0, 0);
                            else if (op.m === 'x-y') ctx.transform(0, -1, -1, 0, 0, 0);
                            
                            if (motifImage.width > 0 || motifImage.videoWidth > 0) {
                                ctx.drawImage(motifImage, -w / 2, -h / 2, w, h);
                            }
                            ctx.restore();
                        });

                        if (!forExport) {
                            ctx.strokeStyle = 'rgba(55, 65, 81, 0.2)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(0, 0); ctx.lineTo(v1.x, v1.y);
                            ctx.lineTo(v1.x + v2.x, v1.y + v2.y);
                            ctx.lineTo(v2.x, v2.y);
                            ctx.closePath();
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                    }
                }
                ctx.restore();
                ctx.restore();
            }

            // --- UI and Event Handlers ---
            function updateStateFromUI() {
                state.spaceGroup = spaceGroupSelect.value;
                state.motifX = parseFloat(motifXSlider.value);
                state.motifY = parseFloat(motifYSlider.value);
                state.motifSize = parseFloat(motifSizeSlider.value);
                state.a = parseFloat(cellASlider.value);
                
                const info = spaceGroupInfo[state.spaceGroup];
                const system = info.system;

                if (system === 'square' || system === 'hexagonal') {
                    state.b = state.a;
                    cellBSlider.value = cellASlider.value;
                    cellBSlider.disabled = true;
                } else {
                    state.b = parseFloat(cellBSlider.value);
                    cellBSlider.disabled = false;
                }

                motifXValue.textContent = state.motifX.toFixed(2);
                motifYValue.textContent = state.motifY.toFixed(2);
                motifSizeValue.textContent = state.motifSize.toFixed(0);
                cellAValue.textContent = state.a.toFixed(0);
                cellBValue.textContent = state.b.toFixed(0);

                drawPattern();
            }

            function setupMode(mode) {
                state.currentMode = mode;
                stopAnimationLoop();
                [useUploadBtn, useWebcamBtn].forEach(btn => btn.classList.remove('ring-2'));
                
                if (mode === 'upload') {
                    stopWebcam();
                    sourcePreviewVideo.classList.add('hidden');
                    sourcePreviewImg.classList.remove('hidden');
                    useUploadBtn.classList.add('ring-2');
                    statusEl.textContent = 'Select an image file.';
                } else if (mode === 'webcam') {
                    stopWebcam();
                    sourcePreviewImg.classList.add('hidden');
                    sourcePreviewVideo.classList.remove('hidden');
                    useWebcamBtn.classList.add('ring-2');
                    startWebcam();
                }
            }

            function handleImageUpload(event, isBackground) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        if (isBackground) {
                            backgroundImage = img;
                            state.backgroundImage = backgroundImage;
                        } else {
                            state.source = img;
                            sourcePreviewImg.src = img.src;
                            setupMode('upload');
                        }
                        updateStateFromUI();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            async function startWebcam() { 
                try { 
                    if (state.webcamStream) return; 
                    statusEl.textContent = 'Requesting webcam...'; 
                    state.webcamStream = await navigator.mediaDevices.getUserMedia({ video: true }); 
                    sourcePreviewVideo.srcObject = state.webcamStream; 
                    statusEl.textContent = 'Webcam active.'; 
                    state.source = sourcePreviewVideo;
                    animationLoop(); 
                } catch (err) { 
                    statusEl.textContent = 'Could not access webcam.'; 
                } 
            }

            function stopWebcam() { 
                if (state.webcamStream) { 
                    state.webcamStream.getTracks().forEach(track => track.stop()); 
                    state.webcamStream = null; 
                } 
            }

            function animationLoop() { 
                if (state.currentMode !== 'webcam') return; 
                drawPattern();
                state.animationFrameId = requestAnimationFrame(animationLoop); 
            }

            function stopAnimationLoop() { 
                if (state.animationFrameId) { 
                    cancelAnimationFrame(state.animationFrameId); 
                    state.animationFrameId = null; 
                } 
            }
            
            function handleSaveImage() {
                drawPattern(true);
                const link = document.createElement('a');
                link.download = `pattern-${state.spaceGroup}.png`;
                link.href = patternCanvas.toDataURL('image/png');
                link.click();
                drawPattern(false);
            }
            
            function resizeCanvas() {
                const wrapper = patternCanvas.parentElement;
                let size = wrapper.clientWidth;
                const dpr = window.devicePixelRatio || 1;
                size = Math.min(size, 1200);
                patternCanvas.style.width = `${size}px`;
                patternCanvas.style.height = `${size}px`;
                patternCanvas.width = size * dpr;
                patternCanvas.height = size * dpr;
                drawPattern();
            }

            function setupEventListeners() {
                // Main controls
                spaceGroupSelect.addEventListener('change', updateStateFromUI);
                motifXSlider.addEventListener('input', updateStateFromUI);
                motifYSlider.addEventListener('input', updateStateFromUI);
                motifSizeSlider.addEventListener('input', updateStateFromUI);
                cellASlider.addEventListener('input', updateStateFromUI);
                cellBSlider.addEventListener('input', updateStateFromUI);
                
                // Source controls
                useUploadBtn.addEventListener('click', () => imageUpload.click());
                useWebcamBtn.addEventListener('click', () => setupMode('webcam'));
                imageUpload.addEventListener('change', (e) => handleImageUpload(e, false));
                
                // Background controls
                bgColorPicker.addEventListener('input', (e) => {
                    state.backgroundColor = e.target.value;
                    state.backgroundImage = null; // Color overrides image
                    drawPattern();
                });
                bgUploadBtn.addEventListener('click', () => bgUploadInput.click());
                bgUploadInput.addEventListener('change', (e) => handleImageUpload(e, true));
                bgClearBtn.addEventListener('click', () => {
                    state.backgroundColor = '#FFFFFF';
                    state.backgroundImage = null;
                    bgColorPicker.value = '#FFFFFF';
                    drawPattern();
                });

                // Export
                saveImageBtn.addEventListener('click', handleSaveImage);
                
                // Resizer
                resizer.addEventListener('mousedown', function (e) {
                    e.preventDefault(); 
                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';
                    document.addEventListener('mousemove', resize);
                    document.addEventListener('mouseup', stopResize);
                });

                function resize(e) {
                    const newLeftWidth = e.clientX;
                    const minWidth = parseInt(leftPanel.style.minWidth, 10) || 320;
                    const maxWidth = parseInt(leftPanel.style.maxWidth, 10) || 600;
                    if (newLeftWidth > minWidth && newLeftWidth < maxWidth) {
                       leftPanel.style.flexBasis = newLeftWidth + 'px';
                       resizeCanvas();
                    }
                }

                function stopResize() {
                    document.body.style.cursor = 'default';
                    document.body.style.userSelect = 'auto';
                    document.removeEventListener('mousemove', resize);
                    document.removeEventListener('mouseup', stopResize);
                }

                window.addEventListener('resize', resizeCanvas);
            }
            
            // --- Initialization ---
            function initialize() {
                const ro = new ResizeObserver(resizeCanvas);
                ro.observe(document.getElementById('visualization-area'));
                setupEventListeners();
                
                // Use the programmatically generated circle as the default motif
                const defaultMotif = createDefaultMotif();
                state.source = defaultMotif;
                
                // Update the preview image
                sourcePreviewImg.src = defaultMotif.toDataURL();
                sourcePreviewImg.classList.remove('hidden');
                statusEl.textContent = 'Default motif loaded.';
                
                updateStateFromUI();
            }

            initialize();
        });
    </script>
</body>
</html>