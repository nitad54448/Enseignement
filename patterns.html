<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Pattern Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent body scroll */
        }
        .main-container {
            display: flex;
            flex: 1 1 auto; /* Allow container to grow and shrink */
            overflow: hidden; /* Prevent this container from scrolling */
        }
        #left-panel {
            flex: 0 0 400px; /* Initial width */
            min-width: 320px;
            max-width: 600px;
            padding: 1rem;
            background-color: #f9fafb; /* gray-50 */
            overflow-y: auto; /* Allow only this panel to scroll */
            border-right: 1px solid #d1d5db; /* gray-300 */
        }
        #resizer {
            flex: 0 0 8px;
            background: #e5e7eb; /* gray-200 */
            cursor: col-resize;
            position: relative;
        }
        #resizer:hover::before {
             content: '';
             position: absolute;
             left: -2px;
             right: -2px;
             top: 0;
             bottom: 0;
             background-color: #9ca3af; /* gray-400 */
        }
        #right-panel {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            background-color: #f3f4f6; /* gray-100 */
        }
        .canvas-wrapper {
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            width: 100%;
            max-width: 1000px; /* Allow larger canvas */
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #d1d5db;
            border-radius: 5px;
        }
        input[type=range]::-webkit-slider-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -6px;
        }
        input[type="color"] {
            -webkit-appearance: none;
            width: 40px;
            height: 40px;
            border: none;
            cursor: pointer;
            padding: 0;
            border-radius: 0.375rem;
            overflow: hidden;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 0.375rem;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col h-screen">

    <div class="main-container">
        <div id="left-panel">
            <h1 class="text-2xl font-bold text-gray-800 mb-4">Controls</h1>

            <div class="space-y-6">
                <!-- Motif Source Section -->
                <div class="p-4 bg-white rounded-lg border">
                    <h2 class="text-lg font-semibold mb-2">1. Motif Source</h2>
                    <div class="flex items-center gap-3 mb-3">
                        <button id="use-upload-btn" class="flex-1 bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 focus:outline-none ring-blue-500 ring-offset-2 transition-all duration-200">Upload</button>
                        <button id="use-webcam-btn" class="flex-1 bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600 focus:outline-none ring-green-500 ring-offset-2 transition-all duration-200">Webcam</button>
                        <input type="file" id="image-upload" class="hidden" accept="image/png, image/jpeg">
                    </div>
                    <div class="flex items-center gap-4">
                         <div class="w-20 h-20 bg-gray-200 rounded-md overflow-hidden border">
                            <img id="source-preview-img" class="w-full h-full object-cover hidden">
                            <video id="source-preview-video" class="w-full h-full object-cover hidden" autoplay playsinline muted></video>
                         </div>
                         <div id="status" class="text-sm text-gray-600 font-medium flex-1">Select a source to begin.</div>
                    </div>
                </div>

                <!-- Space Group Section -->
                 <div class="p-4 bg-white rounded-lg border">
                    <div class="flex items-center justify-between">
                        <label for="space-group-select" class="text-lg font-semibold">2. Space Group</label>
                        <select id="space-group-select" class="p-2 border border-gray-300 rounded-md w-1/2">
                            <option value="p1">p1</option>
                            <option value="p2">p2</option>
                            <option value="pm">pm</option>
                            <option value="pg">pg</option>
                            <option value="cm">cm</option>
                            <option value="p2mm">p2mm</option>
                            <option value="p2mg">p2mg</option>
                            <option value="p2gg">p2gg</option>
                            <option value="c2mm">c2mm</option>
                            <option value="p4">p4</option>
                            <option value="p4mm">p4mm</option>
                            <option value="p4gm">p4gm</option>
                            <option value="p3">p3</option>
                            <option value="p3m1">p3m1</option>
                            <option value="p31m">p31m</option>
                            <option value="p6">p6</option>
                            <option value="p6mm">p6mm</option>
                        </select>
                    </div>
                </div>

                <!-- Motif Parameters Section -->
                <div class="p-4 bg-white rounded-lg border">
                    <h2 class="text-lg font-semibold mb-3">3. Motif Parameters</h2>
                    <div class="space-y-3">
                        <div class="flex items-center gap-4">
                            <label for="motif-x-slider" class="w-20 text-sm font-medium text-gray-700">X: <span id="motif-x-value" class="font-mono">0.25</span></label>
                            <input type="range" id="motif-x-slider" min="0" max="1" step="0.01" value="0.25">
                        </div>
                         <div class="flex items-center gap-4">
                            <label for="motif-y-slider" class="w-20 text-sm font-medium text-gray-700">Y: <span id="motif-y-value" class="font-mono">0.25</span></label>
                            <input type="range" id="motif-y-slider" min="0" max="1" step="0.01" value="0.25">
                        </div>
                         <div class="flex items-center gap-4">
                            <label for="motif-size-slider" class="w-20 text-sm font-medium text-gray-700">Size: <span id="motif-size-value" class="font-mono">50</span></label>
                            <input type="range" id="motif-size-slider" min="10" max="150" step="1" value="50">
                        </div>
                    </div>
                </div>
                
                <!-- Cell Parameters Section -->
                <div class="p-4 bg-white rounded-lg border">
                    <h2 class="text-lg font-semibold mb-3">4. Cell Parameters</h2>
                    <div class="space-y-3">
                        <div class="flex items-center gap-4">
                            <label for="cell-a-slider" class="w-20 text-sm font-medium text-gray-700">a: <span id="cell-a-value" class="font-mono">100</span></label>
                            <input type="range" id="cell-a-slider" min="50" max="250" step="1" value="100">
                        </div>
                         <div class="flex items-center gap-4">
                            <label for="cell-b-slider" class="w-20 text-sm font-medium text-gray-700">b: <span id="cell-b-value" class="font-mono">100</span></label>
                            <input type="range" id="cell-b-slider" min="50" max="250" step="1" value="100">
                        </div>
                    </div>
                </div>

                <!-- Background Section -->
                <div class="p-4 bg-white rounded-lg border">
                    <h2 class="text-lg font-semibold mb-2">5. Background</h2>
                    <div class="flex items-center justify-between gap-2">
                        <input type="color" id="bg-color-picker" value="#FFFFFF">
                        <button id="bg-upload-btn" class="flex-1 bg-gray-200 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-300 transition-all duration-200 text-sm">Upload Image</button>
                        <input type="file" id="bg-upload-input" class="hidden" accept="image/png, image/jpeg">
                        <button id="bg-clear-btn" class="bg-gray-200 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-300 transition-all duration-200 text-sm">Clear</button>
                    </div>
                </div>

                <!-- Export Section -->
                <div class="p-4 bg-white rounded-lg border">
                    <h2 class="text-lg font-semibold mb-2">6. Export</h2>
                    <button id="save-image-btn" class="w-full bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-all duration-200">
                        Save as PNG
                    </button>
                </div>

            </div>
        </div>

        <div id="resizer"></div>

        <div id="right-panel">
             <h1 class="text-2xl font-bold text-gray-800 mb-4">Generated Pattern</h1>
            <div class="canvas-wrapper">
                <canvas id="pattern-canvas"></canvas>
            </div>
        </div>
    </div>

    <footer class="w-full bg-white p-2 border-t flex justify-between items-center text-xs text-gray-600 shadow-inner">
        <span class="px-4">2D space groups tilings</span>
        <span class="px-4">NitaD, Univ Paris-Saclay, Aug 2025</span>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const patternCanvas = document.getElementById('pattern-canvas');
            const patternCtx = patternCanvas.getContext('2d');
            
            const sourcePreviewImg = document.getElementById('source-preview-img');
            const sourcePreviewVideo = document.getElementById('source-preview-video');
            const useUploadBtn = document.getElementById('use-upload-btn');
            const useWebcamBtn = document.getElementById('use-webcam-btn');
            const imageUpload = document.getElementById('image-upload');
            const statusEl = document.getElementById('status');
            const saveImageBtn = document.getElementById('save-image-btn');

            const spaceGroupSelect = document.getElementById('space-group-select');
            
            const motifXSlider = document.getElementById('motif-x-slider');
            const motifYSlider = document.getElementById('motif-y-slider');
            const motifSizeSlider = document.getElementById('motif-size-slider');
            const motifXValue = document.getElementById('motif-x-value');
            const motifYValue = document.getElementById('motif-y-value');
            const motifSizeValue = document.getElementById('motif-size-value');

            const cellASlider = document.getElementById('cell-a-slider');
            const cellBSlider = document.getElementById('cell-b-slider');
            const cellAValue = document.getElementById('cell-a-value');
            const cellBValue = document.getElementById('cell-b-value');

            const bgColorPicker = document.getElementById('bg-color-picker');
            const bgUploadBtn = document.getElementById('bg-upload-btn');
            const bgUploadInput = document.getElementById('bg-upload-input');
            const bgClearBtn = document.getElementById('bg-clear-btn');

            const resizer = document.getElementById('resizer');
            const leftPanel = document.getElementById('left-panel');

            // --- State ---
            let state = {
                spaceGroup: 'p1',
                motifX: 0.25,
                motifY: 0.25,
                motifSize: 50,
                a: 100,
                b: 100,
                backgroundColor: '#FFFFFF',
                backgroundImage: null,
                source: null,
                currentMode: null,
                webcamStream: null,
                animationFrameId: null,
            };
            let sourceImage = new Image();
            sourceImage.crossOrigin = "Anonymous";
            let backgroundImage = new Image();
            backgroundImage.crossOrigin = "Anonymous";

            // --- Crystallographic Data ---
            const spaceGroupInfo = {
                p1: { system: 'oblique', gamma: 110 }, p2: { system: 'oblique', gamma: 110 },
                pm: { system: 'rectangular', gamma: 90 }, pg: { system: 'rectangular', gamma: 90 },
                cm: { system: 'rectangular', gamma: 90 }, p2mm: { system: 'rectangular', gamma: 90 },
                p2mg: { system: 'rectangular', gamma: 90 }, p2gg: { system: 'rectangular', gamma: 90 },
                c2mm: { system: 'rectangular', gamma: 90 }, p4: { system: 'square', gamma: 90 },
                p4mm: { system: 'square', gamma: 90 }, p4gm: { system: 'square', gamma: 90 },
                p3: { system: 'hexagonal', gamma: 120 }, p3m1: { system: 'hexagonal', gamma: 120 },
                p31m: { system: 'hexagonal', gamma: 120 }, p6: { system: 'hexagonal', gamma: 120 },
                p6mm: { system: 'hexagonal', gamma: 120 }
            };
            
            // --- Core Logic Functions ---
            function getSymmetryOperations(spaceGroup) {
                const ops = {
                    p1: (x, y) => [{x, y}], p2: (x, y) => [{x, y}, {x: -x, y: -y, a: 180}],
                    pm: (x, y) => [{x, y}, {x: -x, y, m: 'y'}], pg: (x, y) => [{x, y}, {x: -x, y: y + 0.5, m: 'y'}],
                    cm: (x, y) => [{x, y}, {x: -x, y, m: 'y'}, {x: x + 0.5, y: y + 0.5}, {x: -x + 0.5, y: y + 0.5, m: 'y'}],
                    p2mm: (x, y) => [{x, y}, {x: -x, y, m: 'y'}, {x, y: -y, m: 'x'}, {x: -x, y: -y, a: 180}],
                    p2mg: (x, y) => [{x, y}, {x: -x, y: -y, a: 180}, {x: -x + 0.5, y, m: 'y'}, {x: x + 0.5, y: -y, m: 'x'}],
                    p2gg: (x, y) => [{x, y}, {x: -x, y: -y, a: 180}, {x: -x + 0.5, y: y + 0.5, m: 'y'}, {x: x + 0.5, y: -y + 0.5, m: 'x'}],
                    c2mm: (x, y) => [{x,y}, {x:-x,y,m:'y'}, {x,y:-y,m:'x'}, {x:-x,y:-y, a: 180}, {x:x+0.5,y:y+0.5}, {x:-x+0.5,y:y+0.5,m:'y'}, {x:x+0.5,y:-y+0.5,m:'x'}, {x:-x+0.5,y:-y+0.5, a: 180}],
                    p4: (x, y) => [{x, y}, {x: -y, y: x, a: 90}, {x: -x, y: -y, a: 180}, {x: y, y: -x, a: 270}],
                    p4mm: (x, y) => [{x, y}, {x: -y, y: x, a: 90}, {x: -x, y: -y, a: 180}, {x: y, y: -x, a: 270}, {x: -x, y, m: 'y'}, {x: y, y: x, m: 'xy'}, {x, y: -y, m: 'x'}, {x: -y, y: -x, m: 'x-y'}],
                    p4gm: (x, y) => [{x:x, y:y}, {x:-x, y:-y, a:180}, {x:-y, y:x, a:90}, {x:y, y:-x, a:270}, {x:-x+0.5, y:y+0.5, m:'y'}, {x:x+0.5, y:-y+0.5, m:'x'}, {x:y+0.5, y:x+0.5, m:'xy'}, {x:-y+0.5, y:-x+0.5, m:'x-y'}],
                    p3: (x, y) => [{x,y}, {x: -y, y: x-y, a:120}, {x: y-x, y: -x, a:240}],
                    p3m1: (x, y) => [{x:x, y:y}, {x:-y, y:x-y, a:120}, {x:y-x, y:-x, a:240}, {x:x-y, y:-y, m:'x'}, {x:-x, y:y-x, m:'y'}, {x:y, y:x, m:'xy'}],
                    p31m: (x, y) => [{x:x, y:y}, {x:-y, y:x-y, a:120}, {x:y-x, y:-x, a:240}, {x:y, y:x, m:'xy'}, {x:x-y, y:-y, m:'x'}, {x:-x, y:y-x, m:'y'}],
                    p6: (x, y) => [{x:x, y:y}, {x:-y, y:x-y, a:120}, {x:y-x, y:-x, a:240}, {x:-x, y:-y, a:180}, {x:y, y:y-x, a:60}, {x:x-y, y:x, a:300}],
                    p6mm: (x, y) => [{x:x, y:y}, {x:-y, y:x-y, a:120}, {x:y-x, y:-x, a:240}, {x:-x, y:-y, a:180}, {x:y, y:y-x, a:60}, {x:x-y, y:x, a:300}, {x:y, y:x, m:'xy'}, {x:x-y, y:-y, m:'x'}, {x:-x, y:y-x, m:'y'}, {x:-y, y:-x, m:'x-y'}, {x:y-x, y:y, m:'?'}, {x:x, y:x-y, m:'?'}]
                };
                return ops[spaceGroup];
            }
            
            // --- Drawing Functions ---
            function drawPattern(forExport = false) {
                const dpr = window.devicePixelRatio || 1;
                const size = patternCanvas.width / dpr;
                
                // 1. Draw Background
                if (state.backgroundImage && state.backgroundImage.width > 0) {
                    const pattern = patternCtx.createPattern(state.backgroundImage, 'repeat');
                    patternCtx.fillStyle = pattern;
                    patternCtx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);
                } else {
                    patternCtx.fillStyle = state.backgroundColor;
                    patternCtx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);
                }

                if (!state.source || !(state.source.width || state.source.videoWidth)) return;

                const info = spaceGroupInfo[state.spaceGroup];
                const gammaRad = info.gamma * Math.PI / 180;
                const opFunc = getSymmetryOperations(state.spaceGroup);
                if (!opFunc) return;
                
                const operations = opFunc(state.motifX, state.motifY);
                
                const { a, b } = state;
                const v1 = { x: a, y: 0 };
                const v2 = { x: b * Math.cos(gammaRad), y: b * Math.sin(gammaRad) };

                patternCtx.save();
                patternCtx.translate(size / 2, size / 2);

                const sinG = Math.sin(gammaRad);
                if (Math.abs(sinG) < 1e-6) { patternCtx.restore(); return; }
                const inv_a = 1 / a;
                const inv_b_sin_g = 1 / (b * sinG);
                const cos_g = Math.cos(gammaRad);

                const corners = [
                    { x: -size / 2, y: -size / 2 }, { x:  size / 2, y: -size / 2 },
                    { x:  size / 2, y:  size / 2 }, { x: -size / 2, y:  size / 2 },
                ];

                let min_n1 = Infinity, max_n1 = -Infinity, min_n2 = Infinity, max_n2 = -Infinity;
                corners.forEach(p => {
                    const n2 = p.y * inv_b_sin_g;
                    const n1 = (p.x - n2 * b * cos_g) * inv_a;
                    min_n1 = Math.min(min_n1, n1); max_n1 = Math.max(max_n1, n1);
                    min_n2 = Math.min(min_n2, n2); max_n2 = Math.max(max_n2, n2);
                });

                for (let n1 = Math.floor(min_n1) - 1; n1 <= Math.ceil(max_n1) + 1; n1++) {
                    for (let n2 = Math.floor(min_n2) - 1; n2 <= Math.ceil(max_n2) + 1; n2++) {
                        
                        patternCtx.save();
                        
                        const cellOriginX = n1 * v1.x + n2 * v2.x;
                        const cellOriginY = n1 * v1.y + n2 * v2.y;
                        patternCtx.translate(cellOriginX, cellOriginY);

                        operations.forEach(op => {
                            const motifImage = state.source;
                            const w = state.motifSize; const h = state.motifSize;
                            
                            patternCtx.save();
                            
                            const posX = op.x * a + op.y * b * cos_g;
                            const posY = op.y * b * sinG;
                            patternCtx.translate(posX, posY);

                            if (op.a) patternCtx.rotate(op.a * Math.PI / 180);
                            if (op.m === 'x') patternCtx.scale(1, -1);
                            else if (op.m === 'y') patternCtx.scale(-1, 1);
                            else if (op.m === 'xy') patternCtx.transform(0, 1, 1, 0, 0, 0);
                            else if (op.m === 'x-y') patternCtx.transform(0, -1, -1, 0, 0, 0);
                            
                            if (motifImage.width > 0 || motifImage.videoWidth > 0) {
                                patternCtx.drawImage(motifImage, -w / 2, -h / 2, w, h);
                            }
                            patternCtx.restore();
                        });

                        if (!forExport) {
                            patternCtx.strokeStyle = 'rgba(55, 65, 81, 0.2)';
                            patternCtx.lineWidth = 1;
                            patternCtx.beginPath();
                            patternCtx.moveTo(0, 0); patternCtx.lineTo(v1.x, v1.y);
                            patternCtx.lineTo(v1.x + v2.x, v1.y + v2.y);
                            patternCtx.lineTo(v2.x, v2.y);
                            patternCtx.closePath();
                            patternCtx.stroke();
                        }
                        
                        patternCtx.restore();
                    }
                }

                patternCtx.restore();
            }

            // --- UI and Event Handlers ---
            function updateStateFromUI() {
                state.spaceGroup = spaceGroupSelect.value;
                state.motifX = parseFloat(motifXSlider.value);
                state.motifY = parseFloat(motifYSlider.value);
                state.motifSize = parseFloat(motifSizeSlider.value);
                state.a = parseFloat(cellASlider.value);
                
                const info = spaceGroupInfo[state.spaceGroup];
                const system = info.system;

                if (system === 'square' || system === 'hexagonal') {
                    state.b = state.a;
                    cellBSlider.value = cellASlider.value;
                    cellBSlider.disabled = true;
                } else {
                    state.b = parseFloat(cellBSlider.value);
                    cellBSlider.disabled = false;
                }

                motifXValue.textContent = state.motifX.toFixed(2);
                motifYValue.textContent = state.motifY.toFixed(2);
                motifSizeValue.textContent = state.motifSize.toFixed(0);
                cellAValue.textContent = state.a.toFixed(0);
                cellBValue.textContent = state.b.toFixed(0);

                drawPattern();
            }

            function setupMode(mode) {
                state.currentMode = mode;
                stopAnimationLoop();
                [useUploadBtn, useWebcamBtn].forEach(btn => btn.classList.remove('bg-indigo-600'));
                
                if (mode === 'upload') {
                    stopWebcam();
                    sourcePreviewVideo.classList.add('hidden');
                    sourcePreviewImg.classList.remove('hidden');
                    useUploadBtn.classList.add('bg-indigo-600');
                    statusEl.textContent = 'Select an image file.';
                } else if (mode === 'webcam') {
                    stopWebcam();
                    sourcePreviewImg.classList.add('hidden');
                    sourcePreviewVideo.classList.remove('hidden');
                    useWebcamBtn.classList.add('bg-indigo-600');
                    startWebcam();
                }
            }

            function handleImageUpload(event, isBackground) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    if (isBackground) {
                        backgroundImage.src = e.target.result;
                        backgroundImage.onload = () => {
                            state.backgroundImage = backgroundImage;
                            drawPattern();
                        }
                    } else {
                        sourceImage.src = e.target.result;
                        sourceImage.onload = () => {
                            state.source = sourceImage;
                            sourcePreviewImg.src = e.target.result;
                            setupMode('upload');
                            updateStateFromUI();
                        };
                    }
                };
                reader.readAsDataURL(file);
            }

            async function startWebcam() { 
                try { 
                    if (state.webcamStream) return; 
                    statusEl.textContent = 'Requesting webcam...'; 
                    state.webcamStream = await navigator.mediaDevices.getUserMedia({ video: true }); 
                    sourcePreviewVideo.srcObject = state.webcamStream; 
                    statusEl.textContent = 'Webcam active.'; 
                    state.source = sourcePreviewVideo;
                    animationLoop(); 
                } catch (err) { 
                    statusEl.textContent = 'Could not access webcam.'; 
                } 
            }

            function stopWebcam() { 
                if (state.webcamStream) { 
                    state.webcamStream.getTracks().forEach(track => track.stop()); 
                    state.webcamStream = null; 
                } 
            }

            function animationLoop() { 
                if (state.currentMode !== 'webcam') return; 
                drawPattern();
                state.animationFrameId = requestAnimationFrame(animationLoop); 
            }

            function stopAnimationLoop() { 
                if (state.animationFrameId) { 
                    cancelAnimationFrame(state.animationFrameId); 
                    state.animationFrameId = null; 
                } 
            }
            
            function handleSaveImage() {
                drawPattern(true);
                const link = document.createElement('a');
                link.download = `pattern-${state.spaceGroup}.png`;
                link.href = patternCanvas.toDataURL('image/png');
                link.click();
                drawPattern(false);
            }

            function setupEventListeners() {
                // Main controls
                spaceGroupSelect.addEventListener('change', updateStateFromUI);
                motifXSlider.addEventListener('input', updateStateFromUI);
                motifYSlider.addEventListener('input', updateStateFromUI);
                motifSizeSlider.addEventListener('input', updateStateFromUI);
                cellASlider.addEventListener('input', updateStateFromUI);
                cellBSlider.addEventListener('input', updateStateFromUI);
                
                // Source controls
                useUploadBtn.addEventListener('click', () => imageUpload.click());
                useWebcamBtn.addEventListener('click', () => setupMode('webcam'));
                imageUpload.addEventListener('change', (e) => handleImageUpload(e, false));
                
                // Background controls
                bgColorPicker.addEventListener('input', (e) => {
                    state.backgroundColor = e.target.value;
                    state.backgroundImage = null; // Color overrides image
                    drawPattern();
                });
                bgUploadBtn.addEventListener('click', () => bgUploadInput.click());
                bgUploadInput.addEventListener('change', (e) => handleImageUpload(e, true));
                bgClearBtn.addEventListener('click', () => {
                    state.backgroundColor = '#FFFFFF';
                    state.backgroundImage = null;
                    bgColorPicker.value = '#FFFFFF';
                    drawPattern();
                });

                // Export
                saveImageBtn.addEventListener('click', handleSaveImage);
                
                // Resizer
                resizer.addEventListener('mousedown', function (e) {
                    e.preventDefault(); document.body.style.cursor = 'col-resize';
                    document.addEventListener('mousemove', resize);
                    document.addEventListener('mouseup', stopResize);
                });

                function resize(e) {
                    const newLeftWidth = e.clientX;
                    if (newLeftWidth > 320 && newLeftWidth < 600) {
                       leftPanel.style.flexBasis = newLeftWidth + 'px';
                    }
                }

                function stopResize() {
                    document.body.style.cursor = 'default';
                    document.removeEventListener('mousemove', resize);
                    document.removeEventListener('mouseup', stopResize);
                    resizeCanvas();
                    updateStateFromUI();
                }
            }
            
            function resizeCanvas() {
                const wrapper = patternCanvas.parentElement;
                let size = wrapper.clientWidth;
                const dpr = window.devicePixelRatio || 1;
                size = Math.min(size, 1200);
                patternCanvas.style.width = `${size}px`;
                patternCanvas.style.height = `${size}px`;
                patternCanvas.width = size * dpr;
                patternCanvas.height = size * dpr;
                patternCtx.scale(dpr, dpr);
            }

            // --- Initialization ---
            resizeCanvas();
            setupEventListeners();
            
            sourceImage.src = 'https://placehold.co/100x100/3b82f6/ffffff?text=Motif';
            sourceImage.onload = () => {
                state.source = sourceImage;
                sourcePreviewImg.src = sourceImage.src;
                sourcePreviewImg.classList.remove('hidden');
                statusEl.textContent = 'Default motif loaded.';
                updateStateFromUI();
            };
        });
    </script>
</body>
</html>
