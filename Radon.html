<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Radon Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        .canvas-wrapper {
            background-color: #e5e7eb; /* gray-200 */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: 512px;
            aspect-ratio: 1 / 1;
        }
        canvas, video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        .active-btn {
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
        }
         input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-runnable-track {
            background: #d1d5db; /* gray-300 */
            height: 0.5rem;
            border-radius: 0.25rem;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 1rem;
            width: 1rem;
            border-radius: 9999px;
            background: #3b82f6; /* blue-500 */
            cursor: pointer;
            margin-top: -0.25rem;
        }
    </style>
</head>
<body class="flex flex-col h-screen bg-gray-100 overflow-hidden">

    <header class="bg-white p-3 shadow-md w-full z-10">
        <div class="container mx-auto flex items-center justify-between flex-wrap gap-4">
            <div class="flex items-center gap-8">
                <h1 class="text-xl font-bold text-gray-800 hidden sm:block">2D Radon Explorer</h1>
                <div class="flex items-center gap-4 flex-wrap">
                    <button id="use-upload-btn" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 focus:outline-none ring-blue-500 ring-offset-2 transition-all duration-200">
                        Upload Image
                    </button>
                    <div class="flex items-center gap-2">
                        <label for="function-presets" class="text-sm font-medium text-gray-700">or select a Preset:</label>
                        <select id="function-presets" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2">
                            <option value="point" selected>Point (Interactive)</option>
                            <option value="two-points">Two Points (Interactive)</option>
                            <option value="text">Text</option>
                            <option value="circle">Circle</option>
                            <option value="square">Square</option>
                            <option value="concentric-circles">Concentric Circles</option>
                            <option value="embedded-squares">Embedded Squares</option>
                            <option value="shepp-logan">Shepp-Logan Phantom</option>
                        </select>
                    </div>


                    <div class="flex items-center gap-2">
    <input type="checkbox" id="filter-checkbox" class="h-4 w-4 rounded border-gray-300 text-blue-500 focus:ring-blue-500" checked>
    <label for="filter-checkbox" class="text-sm font-medium text-gray-700">Use Filtered Back-Projection</label>
</div>

<input type="file" id="image-upload" class="hidden" accept="image/png, image/jpeg">
                </div>
            </div>
            <div id="status" class="w-full sm:w-auto text-sm text-center text-gray-600 mt-2 sm:mt-0">Select a source to begin.</div>
        </div>
    </header>

    <main class="flex-grow p-8 md:p-12 grid grid-cols-1 md:grid-cols-3 gap-12 items-start justify-items-center overflow-auto">
        <div class="w-full flex flex-col items-center">
            <h3 class="text-lg font-semibold text-center mb-3 text-gray-700">Source</h3>
            <div class="relative w-full max-w-[512px]">
                <p class="absolute -left-4 top-1/2 -translate-y-1/2 -rotate-90 text-sm text-gray-600 bg-gray-100 px-2">y</p>
                <div id="source-wrapper" class="canvas-wrapper">
                    <canvas id="sourceCanvas"></canvas>
                    <canvas id="sourceOverlayCanvas" class="overlay-canvas"></canvas>
                </div>
                <p id="source-y-pos" class="absolute left-0 top-0 -translate-x-full pr-1 text-xs text-gray-500"></p>
                <p id="source-y-neg" class="absolute left-0 bottom-0 -translate-x-full pr-1 text-xs text-gray-500"></p>
                <p id="source-x-neg" class="absolute -bottom-5 left-0 text-xs text-gray-500"></p>
                <p id="source-x-pos" class="absolute -bottom-5 right-0 text-xs text-gray-500"></p>
            </div>
            <div class="w-full max-w-[512px]">
                <div id="sweep-container" class="w-full mt-4 hidden">
                    <input type="range" id="sweep-slider" min="0" value="0">
                    <label for="sweep-slider" class="block text-center text-sm font-medium text-gray-700 mt-1">Sweep Angle (θ): <span id="sweep-value" class="font-mono">0</span>°</label>
                </div>
            </div>
        </div>
        <div class="w-full flex flex-col items-center">
            <h3 class="text-lg font-semibold text-center mb-3 text-gray-700">Radon Transform (Sinogram)</h3>
            <div class="relative w-full max-w-[512px]">
                <p class="absolute -left-8 top-1/2 -translate-y-1/2 -rotate-90 text-sm text-gray-600 bg-gray-100 px-2">Position (ρ)</p>
                <div id="radon-wrapper" class="canvas-wrapper relative">
                    <canvas id="radonCanvas"></canvas>
                    <canvas id="radonOverlayCanvas" class="overlay-canvas"></canvas>
                </div>
                <p id="rho-max-label" class="absolute left-0 top-0 -translate-x-full pr-1 text-xs text-gray-500"></p>
                <p id="rho-min-label" class="absolute left-0 bottom-0 -translate-x-full pr-1 text-xs text-gray-500"></p>
                <p class="absolute -bottom-5 left-0 text-xs text-gray-500">0°</p>
                <p class="absolute -bottom-5 right-0 text-xs text-gray-500">180°</p>
            </div>
            <div class="w-full max-w-[512px]">
                 <p class="text-sm text-center text-gray-600 mt-2">Projection Angle (θ)</p>
            </div>
        </div>
        <div class="w-full flex flex-col items-center">
            <h3 class="text-lg font-semibold text-center mb-3 text-gray-700">Reconstruction</h3>
            <div class="relative w-full max-w-[512px]">
                <p class="absolute -left-4 top-1/2 -translate-y-1/2 -rotate-90 text-sm text-gray-600 bg-gray-100 px-2">y</p>
                <div id="recon-wrapper" class="canvas-wrapper">
                    <canvas id="reconstructionCanvas"></canvas>
                </div>
                <p id="recon-y-pos" class="absolute left-0 top-0 -translate-x-full pr-1 text-xs text-gray-500"></p>
                <p id="recon-y-neg" class="absolute left-0 bottom-0 -translate-x-full pr-1 text-xs text-gray-500"></p>
                <p id="recon-x-neg" class="absolute -bottom-5 left-0 text-xs text-gray-500"></p>
                <p id="recon-x-pos" class="absolute -bottom-5 right-0 text-xs text-gray-500"></p>
            </div>
            <div class="w-full max-w-[512px]">
                <p class="text-sm text-center text-gray-600 mt-2">x</p>
            </div>
        </div>
    </main>

    <footer class="w-full p-2 bg-gray-100">
        <p class="text-left text-xs text-gray-500">
            NitaD, Univ. Paris-Saclay, 2025
        </p>
    </footer>

    <script>
        // --- Elements ---
        const useUploadBtn = document.getElementById('use-upload-btn'),
            imageUpload = document.getElementById('image-upload'),
            statusEl = document.getElementById('status'),
            sourceCanvas = document.getElementById('sourceCanvas'),
            sourceCtx = sourceCanvas.getContext('2d', { willReadFrequently: true }),
            radonCanvas = document.getElementById('radonCanvas'),
            radonCtx = radonCanvas.getContext('2d'),
            reconstructionCanvas = document.getElementById('reconstructionCanvas'),
            reconstructionCtx = reconstructionCanvas.getContext('2d'),
            functionPresets = document.getElementById('function-presets'),
            filterCheckbox = document.getElementById('filter-checkbox'),
            rhoMaxLabel = document.getElementById('rho-max-label'),
            rhoMinLabel = document.getElementById('rho-min-label'),
            sourceWrapper = document.getElementById('source-wrapper'),
            sourceOverlayCanvas = document.getElementById('sourceOverlayCanvas'),
            sourceOverlayCtx = sourceOverlayCanvas.getContext('2d'),
            radonOverlayCanvas = document.getElementById('radonOverlayCanvas'),
            radonOverlayCtx = radonOverlayCanvas.getContext('2d'),
            sweepContainer = document.getElementById('sweep-container'),
            sweepSlider = document.getElementById('sweep-slider'),
            sweepValue = document.getElementById('sweep-value');

        // --- Constants & State ---
        const IMG_SIZE = 256;
        const INTERACTIVE_MODES = ['point', 'two-points'];

        let NUM_ANGLES, NUM_RHO, RHO_MAX;
        let currentMode = null, sourceImage = new Image();
        let randomPoints = [];
        let cosAngles, sinAngles; // Precomputed trig values
        
        // --- Initial Setup ---
        function initializeParameters() {
            RHO_MAX = Math.hypot(IMG_SIZE, IMG_SIZE) / 2;
            NUM_RHO = 2 * Math.ceil(RHO_MAX);
            NUM_ANGLES = Math.round(IMG_SIZE * 1.5);
            
            // Precompute trig values
            cosAngles = new Float32Array(NUM_ANGLES);
            sinAngles = new Float32Array(NUM_ANGLES);
            for (let i = 0; i < NUM_ANGLES; i++) {
                const angle = i * Math.PI / NUM_ANGLES;
                cosAngles[i] = Math.cos(angle);
                sinAngles[i] = Math.sin(angle);
            }

            [sourceCanvas, reconstructionCanvas, sourceOverlayCanvas].forEach(c => c.width = c.height = IMG_SIZE);
            sweepSlider.max = NUM_ANGLES - 1;

            const halfSize = IMG_SIZE / 2;
            const labels = {
                'source-y-pos': halfSize, 'source-y-neg': -halfSize,
                'source-x-neg': -halfSize, 'source-x-pos': halfSize,
                'recon-y-pos': halfSize, 'recon-y-neg': -halfSize,
                'recon-x-neg': -halfSize, 'recon-x-pos': halfSize,
                'rho-max-label': `+${Math.round(RHO_MAX)}`, 'rho-min-label': `-${Math.round(RHO_MAX)}`
            };
            for (const [id, value] of Object.entries(labels)) {
                document.getElementById(id).textContent = value;
            }
        }

        initializeParameters();

        useUploadBtn.addEventListener('click', () => { imageUpload.click(); });
        imageUpload.addEventListener('change', handleImageUpload);
        functionPresets.addEventListener('change', () => { setupMode('function'); performTransform(); });
        filterCheckbox.addEventListener('change', () => performTransform());
        sweepSlider.addEventListener('input', e => handleSweep(parseInt(e.target.value)));

        setupMode('function');
        performTransform();

        // --- Mode Setup ---
        function setupMode(mode) {
            currentMode = mode;
            useUploadBtn.classList.remove('active-btn');
            sourceWrapper.style.cursor = 'default';

            const isInteractive = mode === 'function' && INTERACTIVE_MODES.includes(functionPresets.value);
            sweepContainer.classList.toggle('hidden', !isInteractive);
            
            if (mode === 'upload') {
                useUploadBtn.classList.add('active-btn');
                statusEl.textContent = 'Select an image file to begin.';
            } else if (mode === 'function') {
                statusEl.textContent = 'Choose a preset to generate a pattern.';
            }
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                sourceImage.src = URL.createObjectURL(file);
                sourceImage.onload = () => {
                    setupMode('upload');
                    performTransform();
                };
            }
        }

        // --- Main Execution ---
        function performTransform() {
            const startTime = performance.now();
            statusEl.textContent = 'Processing...';

            generateSource();
            
            const imageData = sourceCtx.getImageData(0, 0, IMG_SIZE, IMG_SIZE);
            const sinogram = radonTransform(imageData);
            drawSinogram(sinogram);

            const useFilter = filterCheckbox.checked;
            const finalSinogram = useFilter ? filterSinogram(sinogram) : sinogram;
            const reconstructedData = inverseRadonTransform(finalSinogram, IMG_SIZE, IMG_SIZE);
            drawReconstruction(reconstructedData);

            if (currentMode === 'function' && INTERACTIVE_MODES.includes(functionPresets.value)) {
                sweepSlider.value = 0;
                handleSweep(0);
            } else {
                 sourceOverlayCtx.clearRect(0, 0, sourceOverlayCanvas.width, sourceOverlayCanvas.height);
                 radonOverlayCtx.clearRect(0, 0, radonOverlayCanvas.width, radonOverlayCanvas.height);
            }

            const endTime = performance.now();
            statusEl.textContent = `Transform complete (${Math.round(endTime-startTime)}ms).`;
        }

        // --- Data Generation & Separation ---
        function generateSource() {
            if (currentMode === 'function') {
                generateFromFunction();
            } else if (currentMode === 'upload' && sourceImage.src) {
                drawSourceToCanvas(sourceImage);
            }
        }

        // --- Optimized Core Logic ---
        function radonTransform(imageData) {
            const width = imageData.width, height = imageData.height, data = imageData.data;
            const centerX = width / 2, centerY = height / 2;
            const sinogram = Array.from({ length: NUM_ANGLES }, () => new Float32Array(NUM_RHO));
            
            // Precompute pixel intensities
            const intensities = new Uint8Array(width * height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    if (data[idx + 3] > 0) {
                        intensities[y * width + x] = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    }
                }
            }

            for (let i_theta = 0; i_theta < NUM_ANGLES; i_theta++) {
                const cosA = cosAngles[i_theta];
                const sinA = sinAngles[i_theta];
                const row = sinogram[i_theta];
                
                for (let y = 0; y < height; y++) {
                    const y_math = -(y - centerY);
                    const rowOffset = y * width;
                    
                    for (let x = 0; x < width; x++) {
                        const intensity = intensities[rowOffset + x];
                        if (intensity > 5) {
                            const rho = (x - centerX) * cosA + y_math * sinA;
                            const i_rho = Math.round(rho) + (NUM_RHO / 2);
                            if (i_rho >= 0 && i_rho < NUM_RHO) {
                                row[i_rho] += intensity;
                            }
                        }
                    }
                }
            }
            return sinogram;
        }

        function filterSinogram(sinogram) {
            const numAngles = sinogram.length;
            if (numAngles === 0) return sinogram;
            const numRho = sinogram[0].length;
            const filteredSinogram = Array.from({ length: numAngles }, () => new Float32Array(numRho));
            const filter = new Float32Array(numRho * 2 - 1);
            const center = numRho -1;
            filter[center] = 1;
            for(let i=1; i < numRho; i++) {
                const val = (i % 2 === 0) ? 0 : (-4 / (Math.PI**2)) / (i**2);
                filter[center + i] = val;
                filter[center - i] = val;
            }
            for (let i_theta = 0; i_theta < numAngles; i_theta++) {
                for (let i_rho = 0; i_rho < numRho; i_rho++) {
                    let sum = 0;
                    for(let k=0; k < filter.length; k++) {
                        const rho_k = i_rho - (k-center);
                        if(rho_k >= 0 && rho_k < numRho) {
                            sum += sinogram[i_theta][rho_k] * filter[k];
                        }
                    }
                    filteredSinogram[i_theta][i_rho] = sum;
                }
            }
            return filteredSinogram;
        }

        function inverseRadonTransform(sinogram, width, height) {
            const numAngles = sinogram.length;
            if (numAngles === 0) return new Float32Array(width * height);
            const numRho = sinogram[0].length;
            const reconstructedData = new Float32Array(width * height);
            const centerX = width / 2, centerY = height / 2;
            
            // Precompute trig values for reconstruction
            const cosAngles = new Float32Array(numAngles);
            const sinAngles = new Float32Array(numAngles);
            for (let i = 0; i < numAngles; i++) {
                const angle = i * Math.PI / numAngles;
                cosAngles[i] = Math.cos(angle);
                sinAngles[i] = Math.sin(angle);
            }

            for (let i_theta = 0; i_theta < numAngles; i_theta++) {
                const cosA = cosAngles[i_theta];
                const sinA = sinAngles[i_theta];
                const sinogramRow = sinogram[i_theta];
                
                for (let y = 0; y < height; y++) {
                    const y_math = -(y - centerY);
                    const rowOffset = y * width;
                    
                    for (let x = 0; x < width; x++) {
                        const rho = (x - centerX) * cosA + y_math * sinA;
                        const i_rho = Math.round(rho) + (NUM_RHO / 2);
                        if (i_rho >= 0 && i_rho < numRho) {
                           reconstructedData[rowOffset + x] += sinogramRow[i_rho];
                        }
                    }
                }
            }
             return reconstructedData;
        }

        // --- Visualization Functions ---
        function drawSinogram(sinogram) {
            const numAngles = sinogram.length;
            if (numAngles === 0) { 
                radonOverlayCanvas.width = 0; radonOverlayCanvas.height = 0;
                return;
            }
            const numRho = sinogram[0].length;
            radonCanvas.width = numAngles;
            radonCanvas.height = numRho;
            radonOverlayCanvas.width = numAngles;
            radonOverlayCanvas.height = numRho;

            radonCtx.fillStyle = 'black';
            radonCtx.fillRect(0, 0, numAngles, numRho);
            const outputImageData = radonCtx.createImageData(numAngles, numRho);
            
            // Find max value in a single pass
            let maxVal = 0;
            for (let i = 0; i < numAngles; i++) {
                const row = sinogram[i];
                for (let j = 0; j < numRho; j++) {
                    if (row[j] > maxVal) maxVal = row[j];
                }
            }
            
            if (maxVal === 0) {
                radonCtx.putImageData(outputImageData, 0, 0);
                return;
            };
            
            const scale = 255 / maxVal;
            for (let i_theta = 0; i_theta < numAngles; i_theta++) {
                const row = sinogram[i_theta];
                for (let i_rho = 0; i_rho < numRho; i_rho++) {
                    const val = row[i_rho] * scale;
                    const idx = ((numRho - 1 - i_rho) * numAngles + i_theta) * 4;
                    outputImageData.data[idx] = val;
                    outputImageData.data[idx + 1] = val;
                    outputImageData.data[idx + 2] = val;
                    outputImageData.data[idx + 3] = 255;
                }
            }
            radonCtx.putImageData(outputImageData, 0, 0);
        }

        function drawReconstruction(data) {
            reconstructionCtx.clearRect(0, 0, IMG_SIZE, IMG_SIZE);
            const outputImageData = reconstructionCtx.createImageData(IMG_SIZE, IMG_SIZE);
            
            // Find min/max in a single pass
            let maxVal = -Infinity, minVal = Infinity;
            for (let i = 0; i < data.length; i++) {
                const val = data[i];
                if (val > maxVal) maxVal = val;
                if (val < minVal) minVal = val;
            }
            
            const range = maxVal - minVal;
            if (range < 1e-9) return;
            
            const scale = 255 / range;
            for (let i = 0; i < data.length; i++) {
                const val = (data[i] - minVal) * scale;
                const idx = i * 4;
                outputImageData.data[idx] = val;
                outputImageData.data[idx + 1] = val;
                outputImageData.data[idx + 2] = val;
                outputImageData.data[idx + 3] = 255;
            }
            reconstructionCtx.putImageData(outputImageData, 0, 0);
        }

        // --- Preset Generation & Drawing ---
        function generateFromFunction() {
            const type = functionPresets.value;
            sourceCtx.fillStyle = 'black';
            sourceCtx.fillRect(0, 0, IMG_SIZE, IMG_SIZE);
            
            randomPoints = [];

            if (type === 'shepp-logan') {
                const phantomData = createSheppLoganData(IMG_SIZE);
                const imageData = sourceCtx.createImageData(IMG_SIZE, IMG_SIZE);
                 for(let i=0; i < imageData.data.length; i += 4) {
                    const val = phantomData[i/4];
                    imageData.data[i] = val;
                    imageData.data[i+1] = val;
                    imageData.data[i+2] = val;
                    imageData.data[i+3] = 255;
                }
                sourceCtx.putImageData(imageData, 0, 0);
            } else {
                sourceCtx.save();
                sourceCtx.translate(IMG_SIZE / 2, IMG_SIZE / 2);
                sourceCtx.fillStyle = 'white';
                if (type === 'circle') {
                    sourceCtx.beginPath(); sourceCtx.arc(0, 0, IMG_SIZE * 0.4, 0, 2 * Math.PI); sourceCtx.fill();
                } else if (type === 'square') {
                    sourceCtx.fillRect(-IMG_SIZE * 0.3, -IMG_SIZE * 0.3, IMG_SIZE * 0.6, IMG_SIZE * 0.6);
                } else if (type === 'embedded-squares') {
                    sourceCtx.fillRect(-IMG_SIZE * 0.4, -IMG_SIZE * 0.4, IMG_SIZE * 0.8, IMG_SIZE * 0.8);
                    sourceCtx.fillStyle = 'gray';
                    sourceCtx.fillRect(-IMG_SIZE * 0.2, -IMG_SIZE * 0.2, IMG_SIZE * 0.4, IMG_SIZE * 0.4);
                } else if (type === 'concentric-circles') {
                    sourceCtx.beginPath(); sourceCtx.arc(0, 0, IMG_SIZE * 0.45, 0, 2 * Math.PI); sourceCtx.fill();
                    sourceCtx.fillStyle = 'gray';
                    sourceCtx.beginPath(); sourceCtx.arc(0, 0, IMG_SIZE * 0.25, 0, 2 * Math.PI); sourceCtx.fill();
                } else if (type === 'point') {
                    const x = 60; const y = 40;
                    randomPoints.push({ x, y });
                    sourceCtx.fillRect(x - 2, -y - 2, 4, 4);
                } else if (type === 'two-points') {
                    const x1 = 60, y1 = 40;
                    randomPoints.push({ x: x1, y: y1 });
                    sourceCtx.fillRect(x1 - 2, -y1 - 2, 4, 4);
                    
                    const x2 = -30, y2 = -70;
                    randomPoints.push({ x: x2, y: y2 });
                    sourceCtx.fillStyle = 'gray';
                    sourceCtx.fillRect(x2 - 2, -y2 - 2, 4, 4);
                } else if (type === 'text') {
                    sourceCtx.font = '24px Inter';
                    sourceCtx.textAlign = 'center';
                    sourceCtx.textBaseline = 'middle';
                    sourceCtx.fillText('nitad54448.github.io', 0, -IMG_SIZE / 4);
                }
                sourceCtx.restore();
            }
        }
        
        function drawSourceToCanvas(source) {
            sourceCtx.fillStyle = 'black';
            sourceCtx.fillRect(0, 0, IMG_SIZE, IMG_SIZE);
            const sourceW = source.width;
            const sourceH = source.height;
            const ratio = Math.min(IMG_SIZE / sourceW, IMG_SIZE / sourceH);
            const centerShift_x = (IMG_SIZE - sourceW * ratio) / 2;
            const centerShift_y = (IMG_SIZE - sourceH * ratio) / 2;
            sourceCtx.drawImage(source, 0, 0, sourceW, sourceH, centerShift_x, centerShift_y, sourceW * ratio, sourceH * ratio);
        }

       function createSheppLoganData(size) {
            const data = new Float32Array(size * size).fill(0);
            const ellipses = [
                [0,    0,      .69,   .92,   90,  1],
                [0,   -0.0184, .6624, .874,  90, -0.8],
                [.22,  0,      .11,   .31,   72, -0.2],
                [-.22, 0,      .16,   .41,   108, -0.2],
                [0,    .35,    .21,   .25,   90,  0.1],
                [0,    .1,     .046,  .046,  0,   0.1],
                [0,   -0.1,    .046,  .046,  0,   0.1],
                [-.08, -.605,  .023,  .046,  0,   0.1],
                [0,    -.605,  .023,  .023,  0,   0.1],
                [.06,  -.605,  .023,  .046,  90,  0.1]
            ];
            
            const halfSize = size / 2;
            const ellipseParams = ellipses.map(ell => {
                const [x0, y0, a, b, angle, gray] = ell;
                const angRad = -angle * Math.PI / 180;
                const cosA = Math.cos(angRad);
                const sinA = Math.sin(angRad);
                return { x0, y0, a, b, cosA, sinA, gray };
            });
            
            for (let j = 0; j < size; j++) {
                const y = (j - halfSize) / halfSize;
                const rowOffset = j * size;
                
                for (let i = 0; i < size; i++) {
                    const x = (i - halfSize) / halfSize;
                    let intensitySum = 0;
                    
                    for (const ell of ellipseParams) {
                        const { x0, y0, a, b, cosA, sinA, gray } = ell;
                        const dx = x - x0;
                        const dy = y - y0;
                        const term1 = ((dx * cosA + dy * sinA) / a) ** 2;
                        const term2 = ((dx * sinA - dy * cosA) / b) ** 2;
                        
                        if (term1 + term2 <= 1) {
                            intensitySum += gray;
                        }
                    }
                    data[rowOffset + i] = Math.max(0, Math.min(255, intensitySum * 255));
                }
            }
            return data;
        }

        // --- Interactive Guides ---
        function handleSweep(i_theta) {
            sweepValue.textContent = Math.round((i_theta / (NUM_ANGLES - 1)) * 180);
            if (randomPoints.length === 0) {
                sourceOverlayCtx.clearRect(0, 0, sourceOverlayCanvas.width, sourceOverlayCanvas.height);
                radonOverlayCtx.clearRect(0, 0, radonOverlayCanvas.width, radonOverlayCanvas.height);
                return;
            }

            sourceOverlayCtx.clearRect(0, 0, sourceOverlayCanvas.width, sourceOverlayCanvas.height);
            radonOverlayCtx.clearRect(0, 0, radonOverlayCanvas.width, radonOverlayCanvas.height);
            
            const centerX = sourceOverlayCanvas.width / 2;
            const centerY = sourceOverlayCanvas.height / 2;
            const theta = (i_theta / (NUM_ANGLES - 1)) * Math.PI;

            const lineLength = Math.max(sourceOverlayCanvas.width, sourceOverlayCanvas.height);
            const cos_t = Math.cos(theta);
            const sin_t = Math.sin(theta);
            
            sourceOverlayCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            sourceOverlayCtx.lineWidth = 1.5;
            sourceOverlayCtx.setLineDash([]);
            sourceOverlayCtx.beginPath();
            sourceOverlayCtx.moveTo(centerX, centerY);
            sourceOverlayCtx.lineTo(centerX + lineLength * cos_t, centerY - lineLength * sin_t);
            sourceOverlayCtx.stroke();
            sourceOverlayCtx.setLineDash([5, 10]);
            sourceOverlayCtx.beginPath();
            sourceOverlayCtx.moveTo(centerX, centerY);
            sourceOverlayCtx.lineTo(centerX - lineLength * cos_t, centerY + lineLength * sin_t);
            sourceOverlayCtx.stroke();
            
            sourceOverlayCtx.strokeStyle = 'rgba(255, 165, 0, 0.9)';
            sourceOverlayCtx.lineWidth = 2.;
            sourceOverlayCtx.setLineDash([]);
            sourceOverlayCtx.beginPath();
            sourceOverlayCtx.arc(centerX, centerY, 25, 0, -theta, true);
            sourceOverlayCtx.stroke();
            
            const x_pos = (theta / Math.PI) * radonOverlayCanvas.width;
            
            radonOverlayCtx.strokeStyle = 'rgba(255, 165, 0, 0.9)';
            radonOverlayCtx.lineWidth = 2;
            radonOverlayCtx.beginPath();
            radonOverlayCtx.moveTo(x_pos, 0);
            radonOverlayCtx.lineTo(x_pos, radonOverlayCanvas.height);
            radonOverlayCtx.stroke();
            
            const rhoDotColors = ['rgba(0, 255, 0, 0.9)', 'rgba(20, 150, 255, 0.9)'];
            const rhoLineColors = ['rgba(0, 255, 0, 0.9)', 'rgba(20, 150, 255, 0.9)'];
            
            randomPoints.forEach((point, index) => {
                const dotColor = rhoDotColors[index % rhoDotColors.length];
                const lineColor = rhoLineColors[index % rhoLineColors.length];
                const rho = point.x * cos_t + point.y * sin_t;
                
                const point_x_abs = centerX + point.x;
                const point_y_abs = centerY - point.y;

                const proj_x_abs = centerX + rho * cos_t;
                const proj_y_abs = centerY - rho * sin_t;

                sourceOverlayCtx.strokeStyle = lineColor;
                sourceOverlayCtx.lineWidth = 1.5;
                sourceOverlayCtx.setLineDash([3, 5]);
                sourceOverlayCtx.beginPath();
                sourceOverlayCtx.moveTo(point_x_abs, point_y_abs);
                sourceOverlayCtx.lineTo(proj_x_abs, proj_y_abs);
                sourceOverlayCtx.stroke();
                
                sourceOverlayCtx.strokeStyle = dotColor;
                sourceOverlayCtx.lineWidth = 1.5;
                sourceOverlayCtx.setLineDash([]);
                sourceOverlayCtx.beginPath();
                sourceOverlayCtx.moveTo(centerX, centerY);
                sourceOverlayCtx.lineTo(proj_x_abs, proj_y_abs);
                sourceOverlayCtx.stroke();
                
                sourceOverlayCtx.fillStyle = dotColor;
                sourceOverlayCtx.beginPath();
                sourceOverlayCtx.arc(proj_x_abs, proj_y_abs, 3, 0, 2 * Math.PI);
                sourceOverlayCtx.fill();

                const y_rho_pos = (radonOverlayCanvas.height / 2) - (rho / RHO_MAX) * (radonOverlayCanvas.height / 2);
            
                radonOverlayCtx.strokeStyle = lineColor;
                radonOverlayCtx.lineWidth = 1.5;
                radonOverlayCtx.beginPath();
                radonOverlayCtx.moveTo(0, y_rho_pos);
                radonOverlayCtx.lineTo(radonOverlayCanvas.width, y_rho_pos);
                radonOverlayCtx.stroke();

                radonOverlayCtx.fillStyle = dotColor;
                radonOverlayCtx.beginPath();
                radonOverlayCtx.arc(x_pos, y_rho_pos, 4, 0, 2 * Math.PI);
                radonOverlayCtx.fill();
            });
        }
    </script>
</body>
</html>