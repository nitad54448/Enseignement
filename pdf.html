<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pair Distribution Function Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background-color: #f0f0f0;
            color: #e5e7eb; /* Default light text for dark theme */
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        #app-container {
            display: flex;
            width: 100%;
            flex-grow: 1;
            min-height: 0;
        }
        #controls-panel {
            width: 380px;
            min-width: 300px;
            max-width: 600px;
            flex-shrink: 0;
            padding: 24px;
            background-color: #111827; /* Dark blue-gray */
            border-right: 1px solid #374151;
            overflow-y: auto;
            color: #d1d5db;
        }
        #drag-handle {
            width: 6px;
            cursor: col-resize;
            background-color: #374151;
            flex-shrink: 0;
            transition: background-color 0.2s;
        }
        #drag-handle:hover {
            background-color: #3b82f6;
        }
        #visualization-area {
            flex-grow: 1;
            position: relative;
            background-color: #ffffff;
            min-width: 0;
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            color: #1f2937;
        }
        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 1.5rem;
            width: 100%;
            height: 100%;
            align-items: center;
            justify-items: center;
        }
        .canvas-container {
            width: 100%;
            max-width: 512px;
            aspect-ratio: 1 / 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .canvas-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .canvas-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        /* Dark Theme Controls Styling */
        #controls-panel h1 { font-size: 1.8em; margin-bottom: 8px; font-weight: 700; color: #ffffff; }
        #controls-panel > p { font-size: 0.9em; margin-bottom: 24px; color: #9ca3af; line-height: 1.5; }
        #controls-panel label { display: block; margin-bottom: 8px; font-weight: 500; color: #9ca3af; }
        #controls-panel input[type="number"] {
            width: 90px;
            background-color: #374151;
            border: 1px solid #4b5563;
            color: #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.5rem;
            text-align: right;
        }
        #controls-panel select {
            width: 100%;
            background-color: #374151;
            border: 1px solid #4b5563;
            color: #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.5rem;
        }
        #controls-panel button {
            background-color: #3b82f6;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            font-weight: 500;
            width: 100%;
        }
        #controls-panel button:hover { background-color: #2563EB; }
        .control-group { margin-bottom: 1.5rem; }
        .control-row { display: flex; align-items: center; gap: 1rem; }

        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 6px; background: #4b5563;
            border-radius: 3px; outline: none; opacity: 0.8; transition: opacity .2s;
            flex-grow: 1;
        }
        input[type="range"]:hover { opacity: 1; }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 18px; height: 18px; background: #3b82f6;
            cursor: pointer; border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px; height: 18px; background: #3b82f6;
            cursor: pointer; border-radius: 50%; border: 0;
        }
        footer {
            width: 100%;
            background-color: #ffffff;
            padding: 8px 24px;
            text-align: left;
            font-size: 0.8em;
            color: #4b5563;
            border-top: 1px solid #e5e7eb;
            flex-shrink: 0;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">
            <h1>Pair Distribution</h1>
            <p>Simulate the pair distribution function g(d) for various 2D particle arrangements, from crystalline to gas-like.</p>

            <div class="control-group">
                <label for="function-presets">Arrangement Preset</label>
                <select id="function-presets">
                    <option value="crystal">Crystal</option>
                    <option value="crystal-hex">Compact Crystal</option>
                    <option value="liquid" selected>Liquid-like</option>
                    <option value="gas">Random (Gas)</option>
                    <option value="liquid-crystal-smectic">Liquid Crystal (Smectic)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="particle-slider">Number of Particles</label>
                <div class="control-row">
                    <input type="range" id="particle-slider" min="20" max="1000" value="600" step="1">
                    <input type="number" id="particle-value" min="20" max="1000" value="600" step="1">
                </div>
            </div>
            
            <div class="control-group">
                <label for="temp-slider">Disorder</label>
                <div class="control-row">
                    <input type="range" id="temp-slider" min="0" max="20" value="8" step="1">
                    <input type="number" id="temp-value" min="0" max="20" value="8" step="1">
                </div>
            </div>

            <div class="control-group">
                <label for="sweep-slider">Highlight Distance (diameters)</label>
                <div class="control-row">
                    <input type="range" id="sweep-slider" min="0" max="10" value="0" step="0.1">
                    <input type="number" id="sweep-value" min="0" max="10" value="0" step="0.1">
                </div>
            </div>
            
            <div class="control-group">
                 <button id="reset-btn">Reset Simulation</button>
            </div>

            <p id="status" class="text-sm text-gray-400 mt-6"></p>

        </div>

        <div id="drag-handle"></div>

        <div id="visualization-area">
            <div class="visualization-grid">
                <div class="canvas-container">
                    <h3 class="text-lg font-semibold text-center mb-3 text-gray-700">Particle Distribution</h3>
                    <div class="canvas-wrapper cursor-crosshair">
                        <canvas id="sourceCanvas"></canvas>
                        <canvas id="sourceOverlayCanvas"></canvas>
                    </div>
                </div>
                <div class="canvas-container">
                    <h3 class="text-lg font-semibold text-center mb-3 text-gray-700">Pair Distribution Function, g(d)</h3>
                    <div class="canvas-wrapper">
                         <canvas id="pdfCanvas"></canvas>
                         <canvas id="pdfOverlayCanvas"></canvas>
                    </div>
                     <p class="text-sm text-center text-gray-600 mt-2">Distance, d (in particle diameters)</p>
                </div>
            </div>
        </div>
    </div>

    <footer class="text-gray-600">
        A simulation for educational purposes. NitaD, Univ Paris-Saclay, 2025.
    </footer>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Elements ---
        const statusEl = document.getElementById('status');
        const sourceCanvas = document.getElementById('sourceCanvas');
        const sourceCtx = sourceCanvas.getContext('2d');
        const sourceOverlayCanvas = document.getElementById('sourceOverlayCanvas');
        const sourceOverlayCtx = sourceOverlayCanvas.getContext('2d');
        const pdfCanvas = document.getElementById('pdfCanvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const pdfOverlayCanvas = document.getElementById('pdfOverlayCanvas');
        const pdfOverlayCtx = pdfOverlayCanvas.getContext('2d');

        const functionPresets = document.getElementById('function-presets');
        const resetBtn = document.getElementById('reset-btn');
        
        // --- Constants & State ---
        const RENDER_SIZE = 512; // Internal resolution
        const PARTICLE_RADIUS = 10;
        const PARTICLE_DIAMETER = PARTICLE_RADIUS * 2;
        const R_MAX_UNITS = 10; // Max distance in plot, in units of particle diameters
        let points = [];
        let pdfData = { g_r: [], radii: [] };
        let originalParticleCount = 600;

        // --- Initial Setup ---
        function initialize() {
            [sourceCanvas, sourceOverlayCanvas, pdfCanvas, pdfOverlayCanvas].forEach(c => {
                c.width = RENDER_SIZE;
                c.height = RENDER_SIZE;
            });
            
            setupControls();
            addEventListeners();
            updateVisualization();
            handleResize(); // Initial draw
        }

        function setupControls() {
            const controls = [
                { slider: 'particle-slider', value: 'particle-value', changeCallback: () => { points = []; updateVisualization(); } },
                { slider: 'temp-slider', value: 'temp-value', changeCallback: () => { points = []; updateVisualization(); } },
                { slider: 'sweep-slider', value: 'sweep-value', inputCallback: (val) => handleSliderChange(val) }
            ];

            controls.forEach(c => {
                const slider = document.getElementById(c.slider);
                const valueInput = document.getElementById(c.value);
                const step = parseFloat(slider.step);
                const precision = step < 1 ? (step.toString().split('.')[1] || '').length : 0;

                slider.addEventListener('input', () => {
                    const val = parseFloat(slider.value);
                    valueInput.value = val.toFixed(precision);
                    if (c.inputCallback) c.inputCallback(val);
                });
                
                slider.addEventListener('change', () => {
                     if (c.changeCallback) c.changeCallback();
                });

                valueInput.addEventListener('change', () => {
                    const min = parseFloat(valueInput.min);
                    const max = parseFloat(valueInput.max);
                    let val = parseFloat(valueInput.value);
                    if (isNaN(val)) val = min;
                    val = Math.max(min, Math.min(max, val));
                    valueInput.value = val.toFixed(precision);
                    slider.value = val;
                    if (c.inputCallback) c.inputCallback(val);
                    if (c.changeCallback) c.changeCallback();
                });
            });
        }


        function addEventListeners() {
            functionPresets.addEventListener('change', () => {
                points = []; 
                const isGas = functionPresets.value === 'gas';
                const particleSlider = document.getElementById('particle-slider');
                const particleValue = document.getElementById('particle-value');
                
                particleSlider.disabled = isGas;
                if (isGas) {
                    originalParticleCount = particleSlider.value;
                    particleSlider.value = 30;
                } else {
                    particleSlider.value = originalParticleCount;
                }
                particleValue.value = particleSlider.value;
                updateVisualization();
            });
            
            resetBtn.addEventListener('click', () => {
                points = [];
                updateVisualization();
            });
            sourceCanvas.addEventListener('click', handleCanvasClick);
        }

        // --- Main Execution ---
        function updateVisualization() {
            statusEl.textContent = 'Generating points...';
            generatePoints();
            drawPoints();
            
            statusEl.textContent = 'Calculating g(d)...';
            pdfData = calculatePDF(points, RENDER_SIZE, R_MAX_UNITS, 0.05);
            drawPDF(pdfData);
            
            handleSliderChange(parseFloat(document.getElementById('sweep-slider').value));
            statusEl.textContent = `Ready. ${points.length} particles.`;
        }
        
        function generatePoints() {
            const mode = functionPresets.value;
            const numPoints = parseInt(document.getElementById('particle-slider').value);
            const temperature = parseInt(document.getElementById('temp-slider').value);
            
            if (points.length > 0) return;

            const tryPlaceParticle = (newPoint, minDistance) => {
                for (const p of points) {
                    if (Math.hypot(p.x - newPoint.x, p.y - newPoint.y) < minDistance) return false;
                }
                points.push(newPoint);
                return true;
            };

            if (mode === 'crystal') {
                const spacing = PARTICLE_DIAMETER * 1.1;
                const numPerSide = Math.ceil(Math.sqrt(numPoints));
                const totalWidth = (numPerSide - 1) * spacing;
                const offset = (RENDER_SIZE - totalWidth) / 2;
                for (let i = 0; i < numPerSide && points.length < numPoints; i++) {
                    for (let j = 0; j < numPerSide && points.length < numPoints; j++) {
                        points.push({ x: offset + i * spacing, y: offset + j * spacing });
                    }
                }
            } else if (mode === 'crystal-hex') {
                const spacing = PARTICLE_DIAMETER * 1.15;
                const rowHeight = spacing * Math.sqrt(3) / 2;
                const numCols = Math.floor(RENDER_SIZE / spacing) + 1;
                const numRows = Math.floor(RENDER_SIZE / rowHeight) + 1;
                const xOffset = (RENDER_SIZE - (numCols - 1) * spacing) / 2;
                const yOffset = (RENDER_SIZE - (numRows - 1) * rowHeight) / 2;

                for (let j = 0; j < numRows && points.length < numPoints; j++) {
                    const horizontalShift = (j % 2 === 0) ? 0 : spacing / 2;
                    for (let i = 0; i < numCols && points.length < numPoints; i++) {
                        const x = xOffset + i * spacing + horizontalShift;
                        const y = yOffset + j * rowHeight;
                        if (x < RENDER_SIZE + PARTICLE_RADIUS && y < RENDER_SIZE + PARTICLE_RADIUS) {
                             points.push({ x, y });
                        }
                    }
                }
            } else { // random modes
                const minDistance = (mode === 'gas') ? 0 : PARTICLE_DIAMETER;
                for (let i = 0; i < numPoints; i++) {
                    let attempts = 0;
                    while (attempts < 200) {
                        let newPoint;
                        if (mode === 'liquid-crystal-smectic') {
                            const layerSpacing = PARTICLE_DIAMETER * 2.5;
                            const numLayers = Math.floor(RENDER_SIZE / layerSpacing);
                            const layerIndex = Math.floor(Math.random() * numLayers);
                            newPoint = { x: Math.random() * RENDER_SIZE, y: (layerIndex + 0.5) * layerSpacing + (Math.random() - 0.5) * PARTICLE_DIAMETER };
                        } else {
                           newPoint = { x: Math.random() * RENDER_SIZE, y: Math.random() * RENDER_SIZE };
                        }
                        if (tryPlaceParticle(newPoint, minDistance)) break;
                        attempts++;
                    }
                }
            }
            
            if (temperature > 0) {
                const idealPoints = [...points];
                points = [];
                for (const p of idealPoints) {
                    let attempts = 0;
                    while(attempts < 50) {
                        const newPos = {
                            x: (p.x + (Math.random() - 0.5) * temperature + RENDER_SIZE) % RENDER_SIZE,
                            y: (p.y + (Math.random() - 0.5) * temperature + RENDER_SIZE) % RENDER_SIZE
                        };
                        if (tryPlaceParticle(newPos, (mode === 'gas') ? 0 : PARTICLE_DIAMETER)) break;
                        attempts++;
                    }
                }
            }
        }

        function handleCanvasClick(event) {
            const rect = sourceCanvas.getBoundingClientRect();
            const x = (event.clientX - rect.left) * (RENDER_SIZE / rect.width);
            const y = (event.clientY - rect.top) * (RENDER_SIZE / rect.height);
            
            let canPlace = true;
            for (const p of points) {
                if (Math.hypot(p.x - x, p.y - y) < PARTICLE_DIAMETER) {
                    canPlace = false;
                    break;
                }
            }

            if (canPlace) {
                points.push({x,y});
                const pSlider = document.getElementById('particle-slider');
                const pValue = document.getElementById('particle-value');
                pSlider.value = points.length;
                pValue.value = points.length;
                updateVisualization();
            } else {
                statusEl.textContent = "Cannot place particle: Too close to another.";
                setTimeout(() => { statusEl.textContent = `Ready. ${points.length} particles.`}, 2000);
            }
        }

        function calculatePDF(points, boxSize, rMaxUnits, drUnits) {
            const N = points.length;
            if (N < 2) return { g_r: [], radii: [] };

            const rho = N / (boxSize * boxSize);
            const nBins = Math.ceil(rMaxUnits / drUnits);
            const histogram = new Float32Array(nBins).fill(0);

            for (let i = 0; i < N; i++) {
                for (let j = i + 1; j < N; j++) {
                    const rPixels = Math.hypot(points[j].x - points[i].x, points[j].y - points[i].y);
                    const rUnits = rPixels / PARTICLE_DIAMETER;
                    if (rUnits < rMaxUnits) {
                        const binIndex = Math.floor(rUnits / drUnits);
                        if(binIndex < nBins) histogram[binIndex] += 2;
                    }
                }
            }

            const g_r = new Float32Array(nBins);
            const radii = new Float32Array(nBins);
            for (let i = 0; i < nBins; i++) {
                const rLowerUnits = i * drUnits;
                const rUpperUnits = (i + 1) * drUnits;
                radii[i] = (rLowerUnits + rUpperUnits) / 2;
                
                const shellAreaPixels = Math.PI * ( (rUpperUnits * PARTICLE_DIAMETER)**2 - (rLowerUnits * PARTICLE_DIAMETER)**2 );
                const idealCountInShell = rho * shellAreaPixels;
                
                g_r[i] = (idealCountInShell > 1e-9) ? (histogram[i] / N) / idealCountInShell : 0;
            }
            return { g_r, radii };
        }

        function getColorForDistance(distanceUnits, maxDistanceUnits) {
            const hue = (1 - Math.min(distanceUnits / maxDistanceUnits, 1)) * 240; // 240=blue, 0=red
            return `hsl(${hue}, 90%, 60%)`;
        }

        function drawPoints() {
            sourceCtx.fillStyle = '#ffffff';
            sourceCtx.fillRect(0, 0, RENDER_SIZE, RENDER_SIZE);
            if (points.length === 0) return;

            const center = { x: RENDER_SIZE / 2, y: RENDER_SIZE / 2 };
            let centralParticle = points[0];
            let minD = Infinity;
            points.forEach(p => {
                const d = Math.hypot(p.x - center.x, p.y - center.y);
                if (d < minD) { minD = d; centralParticle = p; }
            });
            
            points.forEach(p => {
                if (p === centralParticle) return;
                const distUnits = Math.hypot(p.x - centralParticle.x, p.y - centralParticle.y) / PARTICLE_DIAMETER;
                sourceCtx.fillStyle = getColorForDistance(distUnits, R_MAX_UNITS);
                sourceCtx.beginPath();
                sourceCtx.arc(p.x, p.y, PARTICLE_RADIUS, 0, 2 * Math.PI);
                sourceCtx.fill();
            });
            sourceCtx.fillStyle = 'black';
            sourceCtx.beginPath();
            sourceCtx.arc(centralParticle.x, centralParticle.y, PARTICLE_RADIUS, 0, 2 * Math.PI);
            sourceCtx.fill();
        }

        function drawPDF({ g_r, radii }) {
            pdfCtx.fillStyle = '#ffffff';
            pdfCtx.fillRect(0, 0, RENDER_SIZE, RENDER_SIZE);
            if (g_r.length === 0) return;

            const yAxisMax = Math.max(2.5, Math.ceil(Math.max(...g_r) * 1.1));
            const scaleX = RENDER_SIZE / R_MAX_UNITS;
            const scaleY = RENDER_SIZE / yAxisMax;
            
            pdfCtx.save();
            pdfCtx.strokeStyle = '#d1d5db';
            pdfCtx.fillStyle = '#6b7280';
            pdfCtx.font = '14px Inter';
            pdfCtx.lineWidth = 1;

            for (let i = 0; i <= yAxisMax; i++) {
                const y = RENDER_SIZE - i * scaleY;
                pdfCtx.beginPath();
                pdfCtx.moveTo(0, y);
                pdfCtx.lineTo(RENDER_SIZE, y);
                pdfCtx.stroke();
                if(i > 0) pdfCtx.fillText(i, 5, y - 5);
            }
            for (let i = 0; i <= R_MAX_UNITS; i++) {
                const x = i * scaleX;
                pdfCtx.beginPath();
                pdfCtx.moveTo(x, 0);
                pdfCtx.lineTo(x, RENDER_SIZE);
                pdfCtx.stroke();
                if(i > 0) pdfCtx.fillText(i, x + 5, RENDER_SIZE - 10);
            }
            pdfCtx.restore();

            const gradient = pdfCtx.createLinearGradient(0, 0, RENDER_SIZE, 0);
            for(let i=0; i<1; i+=0.05) {
                gradient.addColorStop(i, getColorForDistance(i * R_MAX_UNITS, R_MAX_UNITS));
            }
            pdfCtx.strokeStyle = gradient;
            pdfCtx.lineWidth = 3;
            pdfCtx.beginPath();
            pdfCtx.moveTo(0, RENDER_SIZE - g_r[0] * scaleY);
            for (let i = 0; i < g_r.length; i++) {
                pdfCtx.lineTo(radii[i] * scaleX, RENDER_SIZE - g_r[i] * scaleY);
            }
            pdfCtx.stroke();
        }

        function handleSliderChange(rUnits) {
            sourceOverlayCtx.clearRect(0, 0, RENDER_SIZE, RENDER_SIZE);
            pdfOverlayCtx.clearRect(0, 0, RENDER_SIZE, RENDER_SIZE);
            
            if (rUnits > 0) {
                const center = { x: RENDER_SIZE / 2, y: RENDER_SIZE / 2 };
                let centralParticle = points.length > 0 ? points[0] : null;
                if(centralParticle) {
                    let minD = Infinity;
                    points.forEach(p => {
                        const d = Math.hypot(p.x - center.x, p.y - center.y);
                        if (d < minD) { minD = d; centralParticle = p; }
                    });
                    sourceOverlayCtx.strokeStyle = 'rgba(239, 68, 68, 0.7)';
                    sourceOverlayCtx.lineWidth = 2;
                    sourceOverlayCtx.beginPath();
                    sourceOverlayCtx.arc(centralParticle.x, centralParticle.y, rUnits * PARTICLE_DIAMETER, 0, 2 * Math.PI);
                    sourceOverlayCtx.stroke();
                }

                const x_pos = (rUnits / R_MAX_UNITS) * RENDER_SIZE;
                pdfOverlayCtx.strokeStyle = 'rgba(239, 68, 68, 0.9)';
                pdfOverlayCtx.lineWidth = 2;
                pdfOverlayCtx.beginPath();
                pdfOverlayCtx.moveTo(x_pos, 0);
                pdfOverlayCtx.lineTo(x_pos, RENDER_SIZE);
                pdfOverlayCtx.stroke();
            }
        }
        
        // --- Resizer Logic ---
        const resizer = document.getElementById('drag-handle');
        const leftPanel = document.getElementById('controls-panel');
        let isResizing = false;

        resizer.addEventListener('mousedown', e => {
            e.preventDefault();
            isResizing = true;
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', stopResize);
        });

        function handleMouseMove(e) {
            if (!isResizing) return;
            const container = resizer.parentElement;
            const newLeftWidth = e.clientX - container.getBoundingClientRect().left;
            if (newLeftWidth > 300 && newLeftWidth < container.clientWidth - 400) {
                leftPanel.style.width = `${newLeftWidth}px`;
                handleResize();
            }
        }

        function stopResize() {
            isResizing = false;
            document.body.style.cursor = 'default';
            document.body.style.userSelect = 'auto';
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', stopResize);
            handleResize();
        }
        
        function handleResize() {
            // This function can be used to make canvases responsive if needed.
            // For now, they are fixed resolution but scale with CSS.
        }

        const ro = new ResizeObserver(handleResize);
        ro.observe(document.getElementById('visualization-area'));

        initialize();
    });
    </script>
</body>
</html>