<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WaveXplorer - v2.1</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        :root {
            --accent-color: #0056b3; /* Primary color for title and interactive elements */
            --border-color: #e0e0e0; /* Consistent color for borders and inactive tracks */
        }

        body {
            font-family: system-ui, sans-serif; margin: 0; background-color: #f0f0f0; color: #333; display: flex; height: 100vh; overflow: hidden;
        }
        #app-container {
            display: flex; background-color: #ffffff; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); border-radius: 12px;
            overflow: hidden; width: 98%; max-width: 1800px; height: 90vh; margin: auto;
        }
        #controls-panel {
            width: 200px; min-width: 140px; max-width: 400px; flex-shrink: 0; padding: 10px;
            background-color: #ffffff; /* Cleaner background */
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
        }
        #drag-handle {
            width: 5px; cursor: col-resize; background-color: var(--border-color);
            flex-shrink: 0; transition: background-color 0.2s;
        }
        #drag-handle:hover {
            background-color: var(--accent-color);
        }
        #visualization-area {
            flex-grow: 1; position: relative; background-color: #111827; min-width: 0;
        }
        #controls-panel h1 {
            font-size: 1.5em; margin-top: 0; margin-bottom: 20px; color: var(--accent-color);
        }
        #webgl-canvas {
            display: block; width: 100%; height: 100%;
        }
        .control-group { margin-bottom: 22px; }
        .control-group label { display: block; margin-bottom: 8px; font-weight: 600; }
        .control-group select,
        .control-group input[type="number"].value-input {
            width: 100%; padding: 10px; border-radius: 5px;
            border: 1px solid var(--border-color); /* Consistent border */
            box-sizing: border-box;
        }
        .control-group input[type="number"].value-input { text-align: right; }
        .slider-group { display: flex; align-items: center; gap: 10px; }
        .slider-group input[type="range"] {
            flex-grow: 1; -webkit-appearance: none; appearance: none;
            height: 8px; background: var(--border-color); /* Consistent track color */
            border-radius: 5px; outline: none; opacity: 0.8; transition: opacity .2s;
        }
        .slider-group input[type="range"]:hover { opacity: 1; }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px;
            background: var(--accent-color); /* Use accent color */
            cursor: pointer; border-radius: 50%;
        }
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px; height: 20px;
            background: var(--accent-color); /* Use accent color */
            cursor: pointer; border-radius: 50%;
        }
        .radio-group label { font-weight: normal; margin-right: 15px; }
        .radio-options-container div { margin-bottom: 8px; }
        /* Style for radio buttons */
        .radio-options-container input[type="radio"] {
            accent-color: var(--accent-color);
        }
        .param-info {
            padding: 10px; border-radius: 5px; border: 1px solid var(--border-color);
            background-color: #f0f0f0; font-size: 0.9em; margin-top: 4px;
            color: #555; text-align: center;
        }
        footer {
            position: fixed; bottom: 10px; left: 20px;
            font-size: 0.8em; color: #888; z-index: 100;
        }
        #scale-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; font-family: Arial, sans-serif;
            font-size: 12px; color: #b0b0b0;
        }
        .scale-label {
            position: absolute; background-color: rgba(17, 24, 39, 0.7);
            padding: 2px 4px; border-radius: 3px;
            pointer-events: auto; white-space: nowrap;
            user-select: none; -webkit-user-select: none; -ms-user-select: none;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="controls-panel">
            <h1>WaveXplorer</h1>
             <div class="control-group">
                <label for="concept-selector">Concept:</label>
                <select id="concept-selector">
                    <option value="wavelength_amplitude">Wavelength & Amplitude</option>
                    <option value="phase">Phase (Phase Shift)</option>
                    <option value="polarization">Polarization</option>
                    <option value="poynting_vector">Poynting Vector</option>
                    <option value="phase_group_velocity">Phase/Group Velocity</option>
                    <option value="wave_type_comparison">Wave Type (Comparison)</option>
                    <option value="wavefront">Wavefront</option>
                </select>
            </div>
            <div id="parameter-controls">
                </div>
        </div>
        <div id="drag-handle"></div>
        <div id="visualization-area">
            <canvas id="webgl-canvas"></canvas>
            <div id="scale-container"></div>
        </div>
    </div>

    <footer>
        NitaD, Univ Paris-Saclay, version 04 juin 2025. UI adapted July 2025.
    </footer>
    
    <script>
        // --- All original simulation JavaScript is preserved here ---
        let scene, camera, renderer;
        let axesHelper;
        let controls; 
        let scaleContainerElement;
        let parameterControlsContainer; 
        let waveLine1, waveLine2; 
        let animatedEVector, eVectorTracePath; 
        let spatialPolarizationEVectors = []; 
        let poyntingArrowViz;
        let phaseMarkerViz, groupMarkerViz; 
        let groupWaveComp1, groupWaveComp2, groupWaveSuperposition, groupWaveEnvelopeUpper, groupWaveEnvelopeLower; 
        let particleSystemViz = []; 
        let wavefrontObjects = []; 
        let animationTime = 0;
        const omegaAnimation = Math.PI / 1.5; 
        let currentConcept = 'wavelength_amplitude'; 
        const waveParams = { 
            wavelength: 2.0, 
            amplitude: 1.0, 
            points: 500,
            extent: 10,  
            phaseShift: 0,
            polarizationType: 'linear_vertical', 
            polarizationViewMode: 'temporal', 
            Ey_amplitude: 1.0, 
            Ez_amplitude: 0.5, 
            packet_delta_k_factor: 0.15, 
            dispersionFactor: 0.1, 
            poyntingShow: true, 
            velocityDisplayType: 'phase', 
            waveComparisonType: 'transverse', 
            wavefrontType: 'plane', 
            particleCount: 30 
        };
        let conceptSelector;

        function connectSliderAndNumberInput(sliderId, numberId, paramName, isFloat, updateFn) {
            const slider = document.getElementById(sliderId);
            const numberInput = document.getElementById(numberId);
            if (!slider || !numberInput) return;

            const updateValue = (newValue) => {
                const value = isFloat ? parseFloat(newValue) : parseInt(newValue, 10);
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                
                if (isNaN(value)) return;

                let clampedValue = Math.max(min, Math.min(max, value));
                
                waveParams[paramName] = clampedValue;
                
                if(document.activeElement !== slider) slider.value = clampedValue;
                if(document.activeElement !== numberInput) numberInput.value = isFloat ? clampedValue.toFixed(2) : clampedValue;

                if (paramName === 'phaseShift') {
                    const phaseDeg = (clampedValue * 180 / Math.PI).toFixed(0);
                     if(document.getElementById('phase-deg-value')) document.getElementById('phase-deg-value').textContent = ` (${phaseDeg}°)`;
                }

                if (updateFn) updateFn(currentConcept);
            };

            slider.addEventListener('input', e => updateValue(e.target.value));
            numberInput.addEventListener('change', e => updateValue(e.target.value));
        }

        function setupConceptUI(concept) {
            parameterControlsContainer.innerHTML = ''; 
            let preservedAmplitude = waveParams.amplitude; let preservedWavelength = waveParams.wavelength;
            if (waveParams.Ey_amplitude === undefined) waveParams.Ey_amplitude = 1.0; if (waveParams.Ez_amplitude === undefined) waveParams.Ez_amplitude = 0.5;

            if (concept === 'wavelength_amplitude') {
                const wlMin = 0.2, wlMax = 3.0, wlStep = 0.01;
                const ampMin = 0.1, ampMax = 3.0, ampStep = 0.05;
                parameterControlsContainer.innerHTML = `
                    <div class="control-group">
                        <label for="wavelength-slider">Wavelength (λ)</label>
                        <div class="slider-group">
                            <input type="range" id="wavelength-slider" min="${wlMin}" max="${wlMax}" step="${wlStep}" value="${waveParams.wavelength}">
                        </div>
                         <input type="number" class="value-input" id="wavelength-value" min="${wlMin}" max="${wlMax}" step="${wlStep}" value="${waveParams.wavelength.toFixed(2)}" style="margin-top: 8px;">
                    </div>
                    <div class="control-group">
                        <label for="amplitude-slider">Amplitude (A)</label>
                        <div class="slider-group">
                             <input type="range" id="amplitude-slider" min="${ampMin}" max="${ampMax}" step="${ampStep}" value="${waveParams.amplitude}">
                        </div>
                        <input type="number" class="value-input" id="amplitude-value" min="${ampMin}" max="${ampMax}" step="${ampStep}" value="${waveParams.amplitude.toFixed(2)}" style="margin-top: 8px;">
                    </div>`;
                connectSliderAndNumberInput('wavelength-slider', 'wavelength-value', 'wavelength', true, updateConceptVisualization);
                connectSliderAndNumberInput('amplitude-slider', 'amplitude-value', 'amplitude', true, updateConceptVisualization);
            } else if (concept === 'phase') {
                const phaseMin = 0, phaseMax = 2 * Math.PI, phaseStep = 0.01;
                waveParams.amplitude = 1.0; waveParams.wavelength = 2.0;
                parameterControlsContainer.innerHTML = `
                     <div class="control-group">
                        <label for="phase-slider">Phase Shift (ϕ)<span id="phase-deg-value"> (${(waveParams.phaseShift * 180 / Math.PI).toFixed(0)}°)</span></label>
                        <div class="slider-group">
                            <input type="range" id="phase-slider" min="${phaseMin}" max="${phaseMax.toFixed(4)}" step="${phaseStep}" value="${waveParams.phaseShift.toFixed(4)}">
                        </div>
                        <input type="number" class="value-input" id="phase-value" min="${phaseMin}" max="${phaseMax.toFixed(4)}" step="${phaseStep}" value="${waveParams.phaseShift.toFixed(2)}" style="margin-top: 8px;">
                    </div>
                    <div class="param-info">Amplitude (A): ${waveParams.amplitude.toFixed(1)} (Fixed)</div>
                    <div class="param-info" style="margin-top: 8px;">Wavelength (λ): ${waveParams.wavelength.toFixed(1)} (Fixed)</div>`;
                connectSliderAndNumberInput('phase-slider', 'phase-value', 'phaseShift', true, updateConceptVisualization);
            } else if (concept === 'polarization') {
                waveParams.amplitude = 1.0; waveParams.wavelength = 4.0;
                parameterControlsContainer.innerHTML = `
                    <div class="control-group radio-group">
                        <label>Polarization Type:</label>
                        <div class="radio-options-container">
                            <div><label><input type="radio" name="p_type" value="linear_vertical" ${waveParams.polarizationType === 'linear_vertical' ? 'checked' : ''}> Linear Vertical</label></div>
                            <div><label><input type="radio" name="p_type" value="linear_horizontal" ${waveParams.polarizationType === 'linear_horizontal' ? 'checked' : ''}> Linear Horizontal</label></div>
                            <div><label><input type="radio" name="p_type" value="circular_right_expected" ${waveParams.polarizationType === 'circular_right_expected' ? 'checked' : ''}> Circular Right</label></div>
                            <div><label><input type="radio" name="p_type" value="circular_left_expected" ${waveParams.polarizationType === 'circular_left_expected' ? 'checked' : ''}> Circular Left</label></div>
                            <div><label><input type="radio" name="p_type" value="elliptical" ${waveParams.polarizationType === 'elliptical' ? 'checked' : ''}> Elliptical</label></div>
                            <div><label><input type="radio" name="p_type" value="unpolarized" ${waveParams.polarizationType === 'unpolarized' ? 'checked' : ''}> Unpolarized</label></div>
                        </div>
                    </div>
                    <div id="polarization_dynamic_controls"></div>
                    <div class="control-group radio-group" style="margin-top:1.5rem; border-top: 1px solid var(--border-color); padding-top: 1.5rem;">
                        <label>Visualization Mode:</label>
                        <div class="radio-options-container">
                            <div><label><input type="radio" name="p_view_mode" value="temporal" ${waveParams.polarizationViewMode === 'temporal' ? 'checked' : ''}> Temporal (at x=0)</label></div>
                            <div><label><input type="radio" name="p_view_mode" value="spatial" ${waveParams.polarizationViewMode === 'spatial' ? 'checked' : ''}> Spatial (snapshot)</label></div>
                        </div>
                    </div>`;
                
                const updateDynamicControls = () => {
                    const dynContainer = document.getElementById('polarization_dynamic_controls');
                    if (waveParams.polarizationType === 'elliptical') {
                        dynContainer.innerHTML = `
                            <div class="control-group">
                                <label for="Ey_amplitude_slider">Amplitude Ey</label>
                                <div class="slider-group">
                                    <input type="range" id="Ey_amplitude_slider" min="0.0" max="1.5" step="0.05" value="${waveParams.Ey_amplitude}">
                                </div>
                                <input type="number" class="value-input" id="Ey_amplitude_value" min="0.0" max="1.5" step="0.05" value="${waveParams.Ey_amplitude.toFixed(2)}" style="margin-top: 8px;">
                            </div>
                            <div class="control-group">
                                <label for="Ez_amplitude_slider">Amplitude Ez</label>
                                <div class="slider-group">
                                    <input type="range" id="Ez_amplitude_slider" min="0.0" max="1.5" step="0.05" value="${waveParams.Ez_amplitude}">
                                </div>
                                <input type="number" class="value-input" id="Ez_amplitude_value" min="0.0" max="1.5" step="0.05" value="${waveParams.Ez_amplitude.toFixed(2)}" style="margin-top: 8px;">
                            </div>`;
                        const spatialUpdateFn = () => { if(waveParams.polarizationViewMode === 'spatial') {clearConceptVisualization(); setupConceptVisualization(currentConcept); updateConceptVisualization(currentConcept);} };
                        connectSliderAndNumberInput('Ey_amplitude_slider', 'Ey_amplitude_value', 'Ey_amplitude', true, spatialUpdateFn);
                        connectSliderAndNumberInput('Ez_amplitude_slider', 'Ez_amplitude_value', 'Ez_amplitude', true, spatialUpdateFn);
                    } else {
                        dynContainer.innerHTML = '';
                    }
                };
                
                updateDynamicControls();
                document.getElementsByName('p_type').forEach(r => r.addEventListener('change', e => { waveParams.polarizationType = e.target.value; updateDynamicControls(); clearConceptVisualization(); setupConceptVisualization(currentConcept); updateConceptVisualization(currentConcept); }));
                document.getElementsByName('p_view_mode').forEach(r => r.addEventListener('change', e => { waveParams.polarizationViewMode = e.target.value; clearConceptVisualization(); setupConceptVisualization(currentConcept); updateConceptVisualization(currentConcept); }));
            } else if (concept === 'poynting_vector') {
                 if (typeof waveParams.amplitude !== 'number' || isNaN(waveParams.amplitude) || waveParams.amplitude < 0.1 || waveParams.amplitude > 2.5) { waveParams.amplitude = 1.0; }
                 waveParams.wavelength = 3.0;
                 parameterControlsContainer.innerHTML = `
                    <div class="control-group">
                        <label for="poynting_E_slider">Amplitude E₀</label>
                        <div class="slider-group">
                           <input type="range" id="poynting_E_slider" min="0.1" max="2.5" step="0.1" value="${waveParams.amplitude}">
                        </div>
                        <input type="number" class="value-input" id="poynting_E_value" min="0.1" max="2.5" step="0.1" value="${waveParams.amplitude.toFixed(2)}" style="margin-top: 8px;">
                    </div>
                    <div class="param-info">Poynting Vector (red) ∝ E₀²</div>
                    <div class="param-info" style="margin-top: 8px;">Guide wave (blueish) shows E₀. λ=${waveParams.wavelength.toFixed(1)} (Fixed)</div> `;
                 connectSliderAndNumberInput('poynting_E_slider', 'poynting_E_value', 'amplitude', true, updateConceptVisualization);
            } else if (concept === 'phase_group_velocity') {
                waveParams.amplitude = 1.0; waveParams.wavelength = 2.0; waveParams.packet_delta_k_factor = 0.15; waveParams.dispersionFactor = 0.1;
                parameterControlsContainer.innerHTML = `
                    <div class="control-group radio-group">
                        <label>Visualization:</label>
                        <div class="radio-options-container">
                            <div><label><input type="radio" name="vel_type" value="phase" ${waveParams.velocityDisplayType === 'phase' ? 'checked' : ''}> Phase Velocity (Single Wave)</label></div>
                            <div><label><input type="radio" name="vel_type" value="group" ${waveParams.velocityDisplayType === 'group' ? 'checked' : ''}> Group & Phase Velocity (Packet)</label></div>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="dispersion_slider">Dispersion (D)</label>
                        <div class="slider-group">
                            <input type="range" id="dispersion_slider" min="0" max="0.5" step="0.01" value="${waveParams.dispersionFactor}">
                        </div>
                        <input type="number" class="value-input" id="dispersion_value" min="0" max="0.5" step="0.01" value="${waveParams.dispersionFactor.toFixed(2)}" style="margin-top: 8px;">
                    </div>
                    <div class="param-info">A=${waveParams.amplitude.toFixed(1)}, λ₀=${waveParams.wavelength.toFixed(1)} (Carrier)</div>
                `;
                document.getElementsByName('vel_type').forEach(r => r.addEventListener('change', e => { waveParams.velocityDisplayType = e.target.value; animationTime = 0; clearConceptVisualization(); setupConceptVisualization(currentConcept); }));
                connectSliderAndNumberInput('dispersion_slider', 'dispersion_value', 'dispersionFactor', true, () => { if(waveParams.velocityDisplayType === 'group'){ animationTime = 0; } });
            } else if (concept === 'wave_type_comparison' || concept === 'wavefront') {
                 waveParams.amplitude = 0.5; waveParams.wavelength = 3.0;
                 const typeContent = `
                    <div class="control-group radio-group">
                        <label>Wave Type:</label>
                        <div class="radio-options-container">
                            <div><label><input type="radio" name="comp_type" value="transverse" ${waveParams.waveComparisonType === 'transverse' ? 'checked' : ''}> Transverse</label></div>
                            <div><label><input type="radio" name="comp_type" value="longitudinal" ${waveParams.waveComparisonType === 'longitudinal' ? 'checked' : ''}> Longitudinal</label></div>
                        </div>
                    </div>
                    <div class="param-info">A=${waveParams.amplitude.toFixed(1)}, λ=${waveParams.wavelength.toFixed(1)} (Fixed)</div>`;
                 const frontContent = `
                    <div class="control-group radio-group">
                        <label>Wavefront Type:</label>
                        <div class="radio-options-container">
                            <div><label><input type="radio" name="wf_type" value="plane" ${waveParams.wavefrontType === 'plane' ? 'checked' : ''}> Plane</label></div>
                            <div><label><input type="radio" name="wf_type" value="spherical" ${waveParams.wavefrontType === 'spherical' ? 'checked' : ''}> Spherical</label></div>
                        </div>
                    </div>`;
                 
                 parameterControlsContainer.innerHTML = concept === 'wave_type_comparison' ? typeContent : frontContent;

                 if (concept === 'wave_type_comparison') {
                     document.getElementsByName('comp_type').forEach(r => r.addEventListener('change', e => { waveParams.waveComparisonType = e.target.value; animationTime = 0; }));
                 } else {
                     document.getElementsByName('wf_type').forEach(r => r.addEventListener('change', e => { waveParams.wavefrontType = e.target.value; animationTime = 0; clearConceptVisualization(); setupConceptVisualization(currentConcept); }));
                 }
            } else {
                parameterControlsContainer.innerHTML = '<p style="text-align:center; padding:10px;">Concept not implemented.</p>';
            }
            updateScales();
        }
        // --- The rest of the JavaScript remains unchanged. ---
        function createSingleWaveObject(color, opacity = 1) { const material = new THREE.LineBasicMaterial({ color: color, transparent: opacity < 1, opacity: opacity }); const geometry = new THREE.BufferGeometry(); const positions = new Float32Array(waveParams.points * 3); geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); return new THREE.Line(geometry, material); }
        function updateWaveGeometry(lineObject, wavelength, amplitude, phase, isEnvelopeModulation = false) { if (!lineObject) { return; } const positions = lineObject.geometry.attributes.position.array; if (wavelength <= 0.001) wavelength = 0.001; const k = (2 * Math.PI) / wavelength; for (let i = 0; i < waveParams.points; i++) { const x = (i / (waveParams.points - 1)) * waveParams.extent - (waveParams.extent / 2); let y; if (isEnvelopeModulation) { y = amplitude * Math.cos(k * x + phase); } else { y = amplitude * Math.sin(k * x + phase); } const z = 0; positions[i * 3] = x; positions[i * 3 + 1] = y; positions[i * 3 + 2] = z; } lineObject.geometry.attributes.position.needsUpdate = true; }
        function calculateWavePoint(x, k_val, omega_val, amplitude_val, time_val, initial_phase = 0) { return amplitude_val * Math.sin(k_val * x - omega_val * time_val + initial_phase); }
        function aspectVerticalFix(cam) { if (!cam || cam.top === cam.bottom || cam.right === cam.left) return 1; return (cam.right - cam.left) / (cam.top - cam.bottom); }
        function init() {
            scaleContainerElement = document.getElementById('scale-container');
            parameterControlsContainer = document.getElementById('parameter-controls'); 
            if (!scaleContainerElement || !parameterControlsContainer) { console.error("UI containers missing!"); return; }
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x111827); // Color updated to match panel
            axesHelper = new THREE.AxesHelper(waveParams.extent / 2); scene.add(axesHelper);
            const canvasElement = document.getElementById('webgl-canvas');
            const vizArea = document.getElementById('visualization-area');
            if (!canvasElement || !vizArea) { console.error("Canvas or vizArea missing."); return; }
            const initialWidth = vizArea.clientWidth; const initialHeight = vizArea.clientHeight;
            camera = new THREE.OrthographicCamera( waveParams.extent / -2, waveParams.extent / 2, (waveParams.extent * initialHeight / initialWidth) / 2, (waveParams.extent * initialHeight / initialWidth) / -2, 0.1, 1000 );
            camera.position.set(0, 0, 10); 
            renderer = new THREE.WebGLRenderer({ canvas: canvasElement, antialias: true }); renderer.setSize(initialWidth, initialHeight);
            if (typeof THREE.OrbitControls !== 'undefined') {
                controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.screenSpacePanning = true; 
                controls.target.set(0, 0, 0); controls.minZoom = 0.2; controls.maxZoom = 5; controls.update();
            } else { console.error("THREE.OrbitControls is not loaded."); }
            conceptSelector = document.getElementById('concept-selector');
            if (conceptSelector) { conceptSelector.disabled = false; conceptSelector.value = currentConcept; conceptSelector.addEventListener('change', handleConceptChange); }
            else { console.error("Concept selector not found!");}
            
            setupConceptUI(currentConcept); 
            setupConceptVisualization(currentConcept); 
            
            window.addEventListener('resize', onWindowResize, false); 
            setupResizer();
            animate();
        }
        function handleConceptChange(event) { const newConcept = event.target.value; if (newConcept === currentConcept) return; animationTime = 0; clearConceptVisualization(); currentConcept = newConcept; setupConceptUI(currentConcept); setupConceptVisualization(currentConcept); }
        function setupConceptVisualization(concept) { if (concept === 'wavelength_amplitude') { waveLine1 = createSingleWaveObject(0x2ecc71); scene.add(waveLine1); updateWaveGeometry(waveLine1, waveParams.wavelength, waveParams.amplitude, 0); } else if (concept === 'phase') { waveLine1 = createSingleWaveObject(0x3498db, 0.6); scene.add(waveLine1); updateWaveGeometry(waveLine1, waveParams.wavelength, waveParams.amplitude, 0); waveLine2 = createSingleWaveObject(0xe67e22); scene.add(waveLine2); updateWaveGeometry(waveLine2, waveParams.wavelength, waveParams.amplitude, waveParams.phaseShift); } else if (concept === 'polarization') { animationTime = 0; if (waveParams.polarizationViewMode === 'temporal') { waveLine1 = createSingleWaveObject(0xaaaaaa, 0.4); scene.add(waveLine1); const E_amp_temp = waveParams.amplitude; animatedEVector = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), E_amp_temp, 0xffff00, 0.25 * E_amp_temp, 0.15 * E_amp_temp); scene.add(animatedEVector); const traceMaterial = new THREE.LineBasicMaterial({color: 0xffffff, transparent: true, opacity:0.7}); const tracePointsCount = 100; const tracePositions = new Float32Array(tracePointsCount * 3); let initialEy, initialEz; const temp_A_trace = (waveParams.polarizationType === 'elliptical' && waveParams.Ey_amplitude !== undefined) ? waveParams.Ey_amplitude : E_amp_temp; const temp_B_trace = (waveParams.polarizationType === 'elliptical' && waveParams.Ez_amplitude !== undefined) ? waveParams.Ez_amplitude : E_amp_temp; switch (waveParams.polarizationType) { case 'linear_vertical': initialEy = temp_A_trace * Math.cos(0); initialEz = 0; break; case 'linear_horizontal': initialEy = 0; initialEz = temp_A_trace * Math.cos(0); break; case 'circular_right_expected': initialEy = temp_A_trace * Math.cos(0); initialEz = -temp_A_trace * Math.sin(0); break; case 'circular_left_expected':  initialEy = temp_A_trace * Math.cos(0); initialEz =  temp_A_trace * Math.sin(0); break; case 'elliptical': initialEy = temp_A_trace * Math.cos(0); initialEz = temp_B_trace * Math.sin(0); break; case 'unpolarized': initialEy = temp_A_trace; initialEz = 0; break; default: initialEy = temp_A_trace; initialEz = 0; } for(let i=0; i < tracePointsCount; ++i) { tracePositions[i*3] = initialEy; tracePositions[i*3+1] = initialEz; tracePositions[i*3+2] = 0;} const traceGeometry = new THREE.BufferGeometry(); traceGeometry.setAttribute('position', new THREE.BufferAttribute(tracePositions, 3)); traceGeometry.setDrawRange(0, 1); eVectorTracePath = new THREE.Line(traceGeometry, traceMaterial); eVectorTracePath.userData = { pathLength: tracePointsCount,  drawnPoints: 1}; scene.add(eVectorTracePath); } else { const arrowColor = 0xffff00; const numberOfArrows = 25; const arrowSpacing = waveParams.extent / (numberOfArrows > 1 ? (numberOfArrows - 1) : 1) ; for (let i = 0; i < numberOfArrows; i++) { const xPos = -waveParams.extent / 2 + i * arrowSpacing; const origin = new THREE.Vector3(xPos, 0, 0); const arrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), origin, 1, arrowColor, 0.3, 0.2); if (waveParams.polarizationType === 'unpolarized') arrow.userData.randomAngleSpatial = Math.random() * 2 * Math.PI; spatialPolarizationEVectors.push(arrow); scene.add(arrow); } } updateConceptVisualization(currentConcept); } else if (concept === 'poynting_vector') { waveLine1 = createSingleWaveObject(0x3498db, 0.8); scene.add(waveLine1); updateWaveGeometry(waveLine1, waveParams.wavelength, waveParams.amplitude, 0); poyntingArrowViz = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0, 0, 0), 1.5, 0xffff00, 0.3, 0.15); scene.add(poyntingArrowViz); updateConceptVisualization(currentConcept); } else if (concept === 'phase_group_velocity') { const baseAmp = waveParams.amplitude; const baseLambda = waveParams.wavelength; if(waveParams.velocityDisplayType === 'phase') { waveLine1 = createSingleWaveObject(0x1abc9c); scene.add(waveLine1); updateWaveGeometry(waveLine1, baseLambda, baseAmp, 0); const markerGeom = new THREE.SphereGeometry(0.15, 12, 8); const markerMat = new THREE.MeshBasicMaterial({color: 0xf1c40f}); phaseMarkerViz = new THREE.Mesh(markerGeom, markerMat); scene.add(phaseMarkerViz); } else { groupWaveComp1 = createSingleWaveObject(0x3498db, 0.5); scene.add(groupWaveComp1); groupWaveComp2 = createSingleWaveObject(0x9b59b6, 0.5); scene.add(groupWaveComp2); groupWaveSuperposition = createSingleWaveObject(0xffffff, 0.9); scene.add(groupWaveSuperposition); groupWaveEnvelopeUpper = createSingleWaveObject(0xe74c3c, 0.8); scene.add(groupWaveEnvelopeUpper); groupWaveEnvelopeLower = createSingleWaveObject(0xe74c3c, 0.8); scene.add(groupWaveEnvelopeLower); const markerGeomPhase = new THREE.SphereGeometry(0.1, 10, 6); const markerMatPhase = new THREE.MeshBasicMaterial({color: 0xf1c40f}); phaseMarkerViz = new THREE.Mesh(markerGeomPhase, markerMatPhase); scene.add(phaseMarkerViz); const markerGeomGroup = new THREE.SphereGeometry(0.12, 10, 6); const markerMatGroup = new THREE.MeshBasicMaterial({color: 'cyan'}); groupMarkerViz = new THREE.Mesh(markerGeomGroup, markerMatGroup); scene.add(groupMarkerViz); } animationTime = 0; updateConceptVisualization(currentConcept); } else if (concept === 'wave_type_comparison') { const particleMat = new THREE.MeshBasicMaterial({color: 0xffffff}); const particleGeom = new THREE.SphereGeometry(0.08, 16, 12); for(let i=0; i < waveParams.particleCount; i++) { const xPos = -waveParams.extent/2 + i * (waveParams.extent / (waveParams.particleCount > 1 ? (waveParams.particleCount -1) : 1) ); const particle = new THREE.Mesh(particleGeom.clone(), particleMat.clone()); particle.userData.initialX = xPos; particle.position.set(xPos, 0, 0); particleSystemViz.push(particle); scene.add(particle); } animationTime = 0; } else if (concept === 'wavefront') { const wfMat = new THREE.MeshBasicMaterial({color:0x1abc9c, transparent: true, opacity: 0.4, side: THREE.DoubleSide}); const numFronts = 7; const planeSize = waveParams.extent / aspectVerticalFix(camera) * 0.8; if(waveParams.wavefrontType === 'plane') { const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize); for(let i=0; i < numFronts; i++) { const plane = new THREE.Mesh(planeGeom, wfMat.clone()); plane.rotation.y = Math.PI/2; plane.userData.initialX = -waveParams.extent/2 - i * 1.5; plane.position.x = plane.userData.initialX; wavefrontObjects.push(plane); scene.add(plane); } } else { const sphereGeom = new THREE.SphereGeometry(1, 32, 16); for(let i=0; i < numFronts -2 ; i++) { const sphere = new THREE.Mesh(sphereGeom, wfMat.clone()); sphere.material.wireframe = false; sphere.userData.currentRadius = 0.1 + i * 1.2; sphere.scale.setScalar(sphere.userData.currentRadius); wavefrontObjects.push(sphere); scene.add(sphere); } } animationTime = 0; if (controls) { camera.position.set(4, 3, 8); controls.target.set(-2, 0, 0); controls.update(); } } }
        function updateConceptVisualization(concept) { let A = waveParams.amplitude; let L = waveParams.wavelength; let k = (2 * Math.PI) / L; if (L <= 0.001) k = (2 * Math.PI) / 0.001; if (concept === 'wavelength_amplitude') { if (waveLine1) updateWaveGeometry(waveLine1, L, A, 0); } else if (concept === 'phase') { A = waveParams.amplitude; L = waveParams.wavelength; if (waveLine1) updateWaveGeometry(waveLine1, L, A, 0); if (waveLine2) updateWaveGeometry(waveLine2, L, A, waveParams.phaseShift); } else if (concept === 'polarization') { A = waveParams.amplitude; L = waveParams.wavelength; k = (2 * Math.PI) / L; if (waveParams.polarizationViewMode === 'temporal') { if (!animatedEVector || !eVectorTracePath || !waveLine1) return; const guideWavePhase = -omegaAnimation * animationTime * 0.5; updateWaveGeometry(waveLine1, L, A, guideWavePhase); let Ey, Ez; let Ay_t = (waveParams.polarizationType === 'elliptical' && waveParams.Ey_amplitude !== undefined) ? waveParams.Ey_amplitude : A; let Az_t = (waveParams.polarizationType === 'elliptical' && waveParams.Ez_amplitude !== undefined) ? waveParams.Ez_amplitude : A; if (waveParams.polarizationType === 'linear_horizontal') Ay_t = 0; if (waveParams.polarizationType === 'linear_vertical') Az_t = 0; switch (waveParams.polarizationType) { case 'linear_vertical': Ey = Ay_t * Math.cos(omegaAnimation * animationTime); Ez = 0; break; case 'linear_horizontal': Ey = 0; Ez = Az_t * Math.cos(omegaAnimation * animationTime); break; case 'circular_right_expected': Ey = Ay_t * Math.cos(omegaAnimation * animationTime); Ez = -Ay_t * Math.sin(omegaAnimation * animationTime); break; case 'circular_left_expected':  Ey = Ay_t * Math.cos(omegaAnimation * animationTime); Ez =  Ay_t * Math.sin(omegaAnimation * animationTime); break;  case 'elliptical': Ey = Ay_t * Math.cos(omegaAnimation * animationTime); Ez = Az_t * Math.sin(omegaAnimation * animationTime); break; case 'unpolarized': if (animatedEVector && (Math.floor(animationTime / 0.1) !== Math.floor((animationTime - 0.015) / 0.1) || animatedEVector.userData.randomAngle === undefined )) { animatedEVector.userData.randomAngle = Math.random() * 2 * Math.PI;} const unpolarizedMag = A * Math.cos(omegaAnimation * animationTime * 3); Ey = unpolarizedMag * Math.cos(animatedEVector ? animatedEVector.userData.randomAngle : 0); Ez = unpolarizedMag * Math.sin(animatedEVector ? animatedEVector.userData.randomAngle : 0); break; default: Ey = Ay_t; Ez = 0; } const direction = new THREE.Vector3(0, Ey, Ez); const currentLength = direction.length(); animatedEVector.position.set(0,0,0); if (currentLength < 0.001) { direction.set(0,1,0); animatedEVector.visible = false; } else { animatedEVector.visible = true; if(currentLength > 0.001) direction.normalize(); } animatedEVector.setDirection(direction); const headL = Math.max(0.05, 0.25 * currentLength); const headW = Math.max(0.025, 0.15 * currentLength); animatedEVector.setLength(currentLength, headL, headW); const tracePositions = eVectorTracePath.geometry.attributes.position.array; const pathLength = eVectorTracePath.userData.pathLength; for (let i = pathLength - 1; i > 0; i--) { tracePositions[i * 3] = tracePositions[(i - 1) * 3]; tracePositions[i * 3 + 1] = tracePositions[(i - 1) * 3 + 1]; tracePositions[i * 3 + 2] = tracePositions[(i - 1) * 3 + 2]; } tracePositions[0] = Ey; tracePositions[1] = Ez; tracePositions[2] = 0; if (eVectorTracePath.userData.drawnPoints < pathLength) eVectorTracePath.userData.drawnPoints++; eVectorTracePath.geometry.setDrawRange(0, eVectorTracePath.userData.drawnPoints); eVectorTracePath.geometry.attributes.position.needsUpdate = true; } else { if (spatialPolarizationEVectors.length === 0) return; const t_snapshot = 0; let Ay_s_val = (waveParams.polarizationType === 'elliptical' && waveParams.Ey_amplitude !==undefined) ? waveParams.Ey_amplitude : A; let Az_s_val = (waveParams.polarizationType === 'elliptical' && waveParams.Ez_amplitude !==undefined) ? waveParams.Ez_amplitude : A; if (waveParams.polarizationType === 'linear_horizontal') Ay_s_val = 0; if (waveParams.polarizationType === 'linear_vertical') Az_s_val = 0; spatialPolarizationEVectors.forEach(arrow => { const x_arrow = arrow.position.x; let Ey, Ez; switch (waveParams.polarizationType) { case 'linear_vertical': Ey = Ay_s_val * Math.cos(k * x_arrow - t_snapshot); Ez = 0; break; case 'linear_horizontal': Ey = 0; Ez = Az_s_val * Math.cos(k * x_arrow - t_snapshot); break; case 'circular_right_expected': Ey = Ay_s_val * Math.cos(k * x_arrow - t_snapshot); Ez = -Ay_s_val * Math.sin(k * x_arrow - t_snapshot); break; case 'circular_left_expected': Ey = Ay_s_val * Math.cos(k * x_arrow - t_snapshot); Ez =  Ay_s_val * Math.sin(k * x_arrow - t_snapshot); break;  case 'elliptical': Ey = Ay_s_val * Math.cos(k * x_arrow - t_snapshot); Ez = Az_s_val * Math.sin(k * x_arrow - t_snapshot); break; case 'unpolarized': if (arrow.userData.randomAngleSpatial === undefined) arrow.userData.randomAngleSpatial = Math.random() * 2 * Math.PI; const waveModulation = A * Math.cos(k * x_arrow - t_snapshot); Ey = waveModulation * Math.cos(arrow.userData.randomAngleSpatial); Ez = waveModulation * Math.sin(arrow.userData.randomAngleSpatial); break; default: Ey = Ay_s_val; Ez = 0; } const direction = new THREE.Vector3(0, Ey, Ez); let currentLength = direction.length(); if (currentLength < 0.001) { direction.set(0,1,0); arrow.visible = false; currentLength=0;} else { arrow.visible = true; direction.normalize(); } arrow.setDirection(direction); const headL = Math.max(0.05, 0.25 * currentLength); const headW = Math.max(0.025, 0.15 * currentLength); arrow.setLength(currentLength, headL, headW ); }); } } else if (concept === 'poynting_vector') { const E0 = waveParams.amplitude; if (waveLine1) updateWaveGeometry(waveLine1, waveParams.wavelength, E0, 0); if (poyntingArrowViz) { const poyntingMagnitude = 0.3 + Math.min(2.5, E0 * E0 * 0.4); const headLength = Math.max(0.1, 0.25 * poyntingMagnitude); const headWidth = Math.max(0.05, 0.12 * poyntingMagnitude); poyntingArrowViz.setLength(poyntingMagnitude, headLength, headWidth); } } else if (concept === 'phase_group_velocity') { const baseAmp = waveParams.amplitude; const baseLambda = waveParams.wavelength; const k0 = (2 * Math.PI) / baseLambda; const baseOmega = omegaAnimation * 1.2; if (waveParams.velocityDisplayType === 'phase') { if (waveLine1 && phaseMarkerViz) { const phaseOffset = -baseOmega * animationTime; updateWaveGeometry(waveLine1, baseLambda, baseAmp, phaseOffset); let markerX = (Math.PI/2 - phaseOffset) / k0; while(markerX > waveParams.extent/2 + baseLambda) markerX -= baseLambda; while(markerX < -waveParams.extent/2 - baseLambda) markerX += baseLambda; if (markerX > waveParams.extent / 2) markerX -= baseLambda; else if (markerX < -waveParams.extent /2) markerX += baseLambda; phaseMarkerViz.position.set(markerX, baseAmp * Math.sin(k0*markerX + phaseOffset) , 0.01); } } else { if (!groupWaveSuperposition || !groupWaveEnvelopeUpper || !groupWaveEnvelopeLower || !phaseMarkerViz || !groupMarkerViz) return; const A_comp = baseAmp * 0.5; const delta_k_factor = waveParams.packet_delta_k_factor; const k1 = k0 * (1 - delta_k_factor); const k2 = k0 * (1 + delta_k_factor); const v0_ref = baseOmega / k0; const D = waveParams.dispersionFactor * v0_ref / k0; const omega1 = k1 * v0_ref - D * k1 * (k1-k0); const omega2 = k2 * v0_ref - D * k2 * (k2-k0); const k_mod = (k2 - k1) / 2.0; const omega_mod = (omega2 - omega1) / 2.0; const lambda_env = (k_mod === 0 || isNaN(k_mod)) ? Infinity : (2 * Math.PI) / Math.abs(k_mod); const phaseOffset_env = -omega_mod * animationTime; updateWaveGeometry(groupWaveEnvelopeUpper, lambda_env, 2*A_comp, phaseOffset_env, true); updateWaveGeometry(groupWaveEnvelopeLower, lambda_env, -2*A_comp, phaseOffset_env, true); const positions = groupWaveSuperposition.geometry.attributes.position.array; const time_factor_vg = 1.0; for (let i = 0; i < waveParams.points; i++) { const x_pos = (i / (waveParams.points - 1)) * waveParams.extent - (waveParams.extent / 2); const y1 = calculateWavePoint(x_pos, k1, omega1, A_comp, animationTime * time_factor_vg, 0); const y2 = calculateWavePoint(x_pos, k2, omega2, A_comp, animationTime * time_factor_vg, 0); positions[i * 3 + 1] = y1 + y2; } groupWaveSuperposition.geometry.attributes.position.needsUpdate = true; if(groupWaveComp1) updateWaveGeometry(groupWaveComp1, (2*Math.PI)/k1, A_comp, -omega1 * animationTime * time_factor_vg); if(groupWaveComp2) updateWaveGeometry(groupWaveComp2, (2*Math.PI)/k2, A_comp, -omega2 * animationTime * time_factor_vg); let groupMarkerX = (k_mod === 0) ? 0 : (-phaseOffset_env) / k_mod; const lambda_env_vis = (k_mod === 0) ? waveParams.extent * 2 : Math.abs(2*Math.PI/k_mod); while(groupMarkerX > waveParams.extent/2 + lambda_env_vis) groupMarkerX -= lambda_env_vis; while(groupMarkerX < -waveParams.extent/2 - lambda_env_vis) groupMarkerX += lambda_env_vis; if (groupMarkerX > waveParams.extent / 2 && k_mod !==0) groupMarkerX -= lambda_env_vis; else if (groupMarkerX < -waveParams.extent /2 && k_mod !==0) groupMarkerX += lambda_env_vis; groupMarkerViz.position.set(groupMarkerX, 2 * A_comp * Math.cos(k_mod * groupMarkerX + phaseOffset_env), 0.1); const k_carr_avg = (k1+k2)/2; const omega_carr_avg = (omega1+omega2)/2; let phaseMarkerX_g = (k_carr_avg === 0) ? 0 : (Math.PI/2 - (-omega_carr_avg * animationTime * time_factor_vg)) / k_carr_avg; const lambda_carr_vis = (k_carr_avg === 0) ? waveParams.extent * 2 : Math.abs(2*Math.PI/k_carr_avg); while(phaseMarkerX_g > waveParams.extent/2 + lambda_carr_vis) phaseMarkerX_g -= lambda_carr_vis; while(phaseMarkerX_g < -waveParams.extent/2 - lambda_carr_vis) phaseMarkerX_g += lambda_carr_vis; const y_env_at_phase_marker = 2 * A_comp * Math.cos(k_mod * phaseMarkerX_g + phaseOffset_env); const y_carrier_at_marker = y_env_at_phase_marker * Math.sin(k_carr_avg * phaseMarkerX_g - omega_carr_avg * animationTime * time_factor_vg + Math.PI/2); phaseMarkerViz.position.set(phaseMarkerX_g, y_carrier_at_marker, 0.1); } } else if (concept === 'wave_type_comparison') { const k_comp = (2 * Math.PI) / waveParams.wavelength; const omega_comp = omegaAnimation; particleSystemViz.forEach(particle => { const x_i = particle.userData.initialX; if(waveParams.waveComparisonType === 'transverse') { particle.position.y = waveParams.amplitude * Math.sin(k_comp * x_i - omega_comp * animationTime); particle.position.x = x_i; } else { particle.position.x = x_i + waveParams.amplitude * 0.5 * Math.sin(k_comp * x_i - omega_comp * animationTime); particle.position.y = 0; } }); } else if (concept === 'wavefront') { const wavefrontSpeed = 0.02; wavefrontObjects.forEach(wf => { if(waveParams.wavefrontType === 'plane') { wf.position.x += wavefrontSpeed; if(wf.geometry.parameters && wf.position.x > waveParams.extent / 2 + wf.geometry.parameters.width/2 + 1.0) { wf.position.x = -waveParams.extent / 2 - wf.geometry.parameters.width/2 - (Math.random()*0.5); } } else { if (wf.geometry.parameters && typeof wf.geometry.parameters.radius !== 'undefined') { let newScale = wf.scale.x + wavefrontSpeed * 0.3; if (newScale * wf.geometry.parameters.radius > waveParams.extent / 1.8) { newScale = 0.1 + (Math.random()*0.2); } wf.scale.setScalar(newScale); } } }); } }
        function clearConceptVisualization() { if (waveLine1) { scene.remove(waveLine1); waveLine1.geometry.dispose(); if(waveLine1.material)waveLine1.material.dispose(); waveLine1 = null; } if (waveLine2) { scene.remove(waveLine2); waveLine2.geometry.dispose(); if(waveLine2.material)waveLine2.material.dispose(); waveLine2 = null; } if (animatedEVector) { scene.remove(animatedEVector); animatedEVector = null; }  if (eVectorTracePath) { scene.remove(eVectorTracePath); eVectorTracePath.geometry.dispose(); if(eVectorTracePath.material)eVectorTracePath.material.dispose(); eVectorTracePath = null;} if (poyntingArrowViz) { scene.remove(poyntingArrowViz); poyntingArrowViz = null; } if (phaseMarkerViz) { scene.remove(phaseMarkerViz); phaseMarkerViz.geometry.dispose(); if(phaseMarkerViz.material)phaseMarkerViz.material.dispose(); phaseMarkerViz = null; } if (groupMarkerViz) { scene.remove(groupMarkerViz); groupMarkerViz.geometry.dispose(); if(groupMarkerViz.material)groupMarkerViz.material.dispose(); groupMarkerViz = null;} if (groupWaveComp1) { scene.remove(groupWaveComp1); groupWaveComp1.geometry.dispose(); if(groupWaveComp1.material)groupWaveComp1.material.dispose(); groupWaveComp1 = null;} if (groupWaveComp2) { scene.remove(groupWaveComp2); groupWaveComp2.geometry.dispose(); if(groupWaveComp2.material)groupWaveComp2.material.dispose(); groupWaveComp2 = null;} if (groupWaveSuperposition) { scene.remove(groupWaveSuperposition); groupWaveSuperposition.geometry.dispose(); if(groupWaveSuperposition.material) groupWaveSuperposition.material.dispose(); groupWaveSuperposition = null;} if (groupWaveEnvelopeUpper) { scene.remove(groupWaveEnvelopeUpper); groupWaveEnvelopeUpper.geometry.dispose(); if(groupWaveEnvelopeUpper.material)groupWaveEnvelopeUpper.material.dispose(); groupWaveEnvelopeUpper = null;} if (groupWaveEnvelopeLower) { scene.remove(groupWaveEnvelopeLower); groupWaveEnvelopeLower.geometry.dispose(); if(groupWaveEnvelopeLower.material)groupWaveEnvelopeLower.material.dispose(); groupWaveEnvelopeLower = null;} spatialPolarizationEVectors.forEach(arrow => scene.remove(arrow)); spatialPolarizationEVectors = []; particleSystemViz.forEach(p => { scene.remove(p); p.geometry.dispose(); if(p.material)p.material.dispose(); }); particleSystemViz = []; wavefrontObjects.forEach(wf => { scene.remove(wf); wf.geometry.dispose(); if(wf.material)wf.material.dispose(); }); wavefrontObjects = []; if (controls) { camera.position.set(0, 0, 10); controls.target.set(0, 0, 0); controls.update(); } }
        function animate() { requestAnimationFrame(animate); animationTime += 0.015; if (controls && (controls.enableDamping || controls.autoRotate)) { controls.update(); } if (currentConcept === 'polarization' || currentConcept === 'phase_group_velocity' || currentConcept === 'wave_type_comparison' || currentConcept === 'wavefront') { updateConceptVisualization(currentConcept); } updateScales(); renderer.render(scene, camera); }
        function onWindowResize() {
            const vizArea = document.getElementById('visualization-area'); 
            if (!vizArea) return;
            const newWidth = vizArea.clientWidth; 
            const newHeight = vizArea.clientHeight;
            if (newWidth > 0 && newHeight > 0) { 
                const aspect = newWidth / newHeight;
                if (camera.isOrthographicCamera) {
                    camera.left = waveParams.extent / -2; 
                    camera.right = waveParams.extent / 2; 
                    camera.top = (waveParams.extent / aspect) / 2; 
                    camera.bottom = (waveParams.extent / aspect) / -2; 
                    camera.updateProjectionMatrix(); 
                } else { // For perspective cameras if ever used
                    camera.aspect = aspect;
                    camera.updateProjectionMatrix();
                }
                renderer.setSize(newWidth, newHeight); 
            } 
        }
        function worldToScreen(worldVector, camera, canvas) { const screenVector = worldVector.clone().project(camera); const x = Math.round((screenVector.x * 0.5 + 0.5) * canvas.clientWidth); const y = Math.round((-screenVector.y * 0.5 + 0.5) * canvas.clientHeight); return { x, y }; }
        function updateScales() { if (!scaleContainerElement || !renderer) return; while (scaleContainerElement.firstChild) scaleContainerElement.removeChild(scaleContainerElement.firstChild); const canvas = renderer.domElement; if (!canvas || canvas.clientWidth === 0 || canvas.clientHeight === 0) return; let xAxisZeroScreenPos = null; const xAxisYOffset = 30; const numXTicks = 11; const xMin = -waveParams.extent / 2; for (let i = 0; i < numXTicks; i++) { const value = xMin + i * (waveParams.extent / (numXTicks - 1)); const worldPos = new THREE.Vector3(value, 0, 0); const currentScreenPos = worldToScreen(worldPos, camera, canvas); const projectedVecForCheck = worldPos.clone().project(camera); if (Math.abs(projectedVecForCheck.x) > 1.1 || Math.abs(projectedVecForCheck.y) > 1.1) { if (!(Math.abs(value) < 0.001 && Math.abs(projectedVecForCheck.x) <= 1.1)) continue; } const label = document.createElement('span'); label.classList.add('scale-label', 'x-axis-label'); label.textContent = value.toFixed(Math.abs(value) < 0.01 && value !==0 ? 2 : 0); label.style.left = `${currentScreenPos.x}px`; label.style.top = `${currentScreenPos.y + xAxisYOffset}px`; label.style.transform = 'translateX(-50%)'; scaleContainerElement.appendChild(label); if (Math.abs(value) < 0.001) xAxisZeroScreenPos = { x: currentScreenPos.x, y: currentScreenPos.y + xAxisYOffset }; } const yAxisXOffset = -20; let amplitudeValues = []; let displayAmplitude = waveParams.amplitude; if (Math.abs(displayAmplitude) > 0.01) amplitudeValues.push(-displayAmplitude, displayAmplitude); if (amplitudeValues.indexOf(0) === -1 || amplitudeValues.length === 0 || (amplitudeValues.length > 0 && Math.abs(displayAmplitude) > 0.01) ) amplitudeValues.push(0); else if (amplitudeValues.length === 0 && Math.abs(displayAmplitude) < 0.01) amplitudeValues.push(0);  amplitudeValues.sort((a, b) => a - b); const uniqueAmplitudeValues = [...new Set(amplitudeValues)]; for (const value of uniqueAmplitudeValues) { let skipLabel = false; if (Math.abs(value) < 0.001 && xAxisZeroScreenPos) { const yZeroWorldPos = new THREE.Vector3(0, 0, 0); const yZeroScreenPos = worldToScreen(yZeroWorldPos, camera, canvas); const distBetweenZeros = Math.hypot( (yZeroScreenPos.x + yAxisXOffset) - xAxisZeroScreenPos.x,  yZeroScreenPos.y - (xAxisZeroScreenPos.y - xAxisYOffset)); if (distBetweenZeros < 25 && Math.abs(displayAmplitude) > 0.01) skipLabel = true; } if (skipLabel) continue; const worldPos = new THREE.Vector3(0, value, 0); const currentYScreenPos = worldToScreen(worldPos, camera, canvas); const projectedVecForCheck = worldPos.clone().project(camera); if (Math.abs(projectedVecForCheck.y) > 1.1 || Math.abs(projectedVecForCheck.x) > 1.1) { if (!(Math.abs(value) < 0.001 && Math.abs(projectedVecForCheck.y) <= 1.1)) continue; } const label = document.createElement('span'); label.classList.add('scale-label', 'y-axis-label'); label.textContent = value.toFixed(1); label.style.left = `${currentYScreenPos.x + yAxisXOffset}px`; label.style.top = `${currentYScreenPos.y}px`; label.style.transform = 'translateY(-50%) translateX(-100%)'; scaleContainerElement.appendChild(label); } }
        
        function setupResizer() {
            const resizer = document.getElementById('drag-handle');
            const leftPanel = document.getElementById('controls-panel');
            let isResizing = false;

            resizer.addEventListener('mousedown', function(e) {
                e.preventDefault();
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';

                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', stopResize);
            });

            function handleMouseMove(e) {
                if (!isResizing) return;
                const container = resizer.parentElement;
                const newLeftWidth = e.clientX - container.getBoundingClientRect().left;

                // Use the min/max width from CSS as bounds
                const minWidth = parseFloat(getComputedStyle(leftPanel).minWidth);
                const maxWidth = parseFloat(getComputedStyle(leftPanel).maxWidth);

                if (newLeftWidth > minWidth && newLeftWidth < maxWidth) {
                    leftPanel.style.width = `${newLeftWidth}px`;
                    onWindowResize(); // Update canvas size during drag
                }
            }

            function stopResize() {
                isResizing = false;
                document.body.style.cursor = 'default';
                document.body.style.userSelect = 'auto';

                window.removeEventListener('mousemove', handleMouseMove);
                window.removeEventListener('mouseup', stopResize);
                onWindowResize(); // Final update
            }
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>