<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WaveXplorer - Version Unique Complète</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        *, *::before, *::after {
            box-sizing: inherit;
        }

        #app-container {
            display: flex;
            background-color: #ffffff;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
            width: 95%;
            max-width: 1200px; 
            height: 90vh; 
            max-height: 800px; 
        }

        #controls-panel {
            width: 340px; 
            flex-shrink: 0; 
            padding: 25px;
            background-color: #f9f9f9;
            border-right: 1px solid #e0e0e0;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        #controls-panel h1 {
            font-size: 1.8em; 
            margin-top: 0;
            margin-bottom: 25px; 
            color: #0056b3; 
            text-align: center;
        }

        .control-group {
            margin-bottom: 22px;
        }

        .control-group label { 
            display: block;
            margin-bottom: 8px;
            font-weight: 600; 
            font-size: 0.95em;
            color: #444;
        }

        .control-group select,
        .control-group input[type="range"] {
            width: 100%;
            padding: 10px; 
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: #fff;
            font-size: 0.9em;
        }
        
        .control-group div > label.radio-label {
            display: inline; 
            margin-bottom: 0;
            font-weight: normal; 
        }

        .param-info { 
            width: 100%;
            padding: 10px; 
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: #e9ecef;
            font-size: 0.9em;
            margin-top: 4px;
            color: #495057;
            text-align: center;
        }

        .control-group input[type="range"] {
            padding: 0; 
            margin-top: 5px;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 18px;
          height: 18px;
          background: #007bff;
          cursor: pointer;
          border-radius: 50%;
        }

        .control-group input[type="range"]::-moz-range-thumb {
          width: 18px;
          height: 18px;
          background: #007bff;
          cursor: pointer;
          border-radius: 50%;
          border: none;
        }

        .radio-label {
            margin-left: 5px;
            font-weight: normal;
            font-size: 0.9em;
            color: #333; 
            vertical-align: middle; 
        }
 
        #parameter-controls .param-group div { 
            margin-bottom: 6px; 
        }
        #parameter-controls .param-group div:last-child {
            margin-bottom: 0;
        }

        #info-panel {
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px dashed #ccc;
            font-size: 0.88em;
            color: #555;
            line-height: 1.5;
        }

        #visualization-area {
            flex-grow: 1;
            display: flex; 
            background-color: #282c34;
            overflow: hidden;
            position: relative; 
        }

        #webgl-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #scale-container {
            position: absolute; 
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            font-size: 12px; 
            color: #b0b0b0;  
        }

        .scale-label {
            position: absolute; 
            background-color: rgba(40, 44, 52, 0.7); 
            padding: 2px 4px;
            border-radius: 3px;
            pointer-events: auto; 
            white-space: nowrap; 
            user-select: none; 
            -webkit-user-select: none; 
            -ms-user-select: none; 
        }

        .x-axis-label { }
        .y-axis-label { }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="controls-panel">
            <h1>WaveXplorer</h1>
            <div class="control-group">
                <label for="concept-selector">Concept à Illustrer :</label>
                <select id="concept-selector">
                    <option value="wavelength_amplitude">Longueur d'onde & Amplitude</option>
                    <option value="phase">Phase (Déphasage)</option>
                    <option value="polarization">Polarisation</option>
                    <option value="poynting_vector">Vecteur de Poynting</option>
                    <option value="phase_group_velocity">Vitesses Phase/Groupe</option>
                    <option value="wave_type_comparison">Type d'Onde (Comparaison)</option>
                    <option value="wavefront">Front d'Onde</option>
                </select>
            </div>
            <div id="parameter-controls">
                </div>
            <div id="info-panel">
                <p>NitaD, Univ Paris-Saclay, version 04 juin 2025.</p> 
            </div>
        </div>
        <div id="visualization-area">
            <canvas id="webgl-canvas"></canvas>
            <div id="scale-container">
                </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // l'ancienne partie en js

        let scene, camera, renderer;
        let axesHelper;
        let controls; 
        let scaleContainerElement;
        let parameterControlsContainer; 
        let waveLine1, waveLine2; 
        let animatedEVector, eVectorTracePath; 
        let spatialPolarizationEVectors = []; 
        let poyntingArrowViz;
        let phaseMarkerViz, groupMarkerViz; 
        let groupWaveComp1, groupWaveComp2, groupWaveSuperposition, groupWaveEnvelopeUpper, groupWaveEnvelopeLower; 
        let particleSystemViz = []; 
        let wavefrontObjects = []; 
        let animationTime = 0;
        const omegaAnimation = Math.PI / 1.5; 
        let currentConcept = 'wavelength_amplitude'; 
        const waveParams = { 
            wavelength: 2.0, 
            amplitude: 1.0, 
            points: 500,
            extent: 10,  
            phaseShift: 0,
            polarizationType: 'linear_vertical', 
            polarizationViewMode: 'temporal', 
            Ey_amplitude: 1.0, 
            Ez_amplitude: 0.5, 
            packet_delta_k_factor: 0.15, 
            dispersionFactor: 0.1, 
            poyntingShow: true, 
            velocityDisplayType: 'phase', 
            waveComparisonType: 'transverse', 
            wavefrontType: 'plane', 
            particleCount: 30 
        };
        let conceptSelector;

        function createSingleWaveObject(color, opacity = 1) {
            const material = new THREE.LineBasicMaterial({ color: color, transparent: opacity < 1, opacity: opacity });
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(waveParams.points * 3);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            return new THREE.Line(geometry, material);
        }

        function updateWaveGeometry(lineObject, wavelength, amplitude, phase, isEnvelopeModulation = false) {
            if (!lineObject) { return; }
            const positions = lineObject.geometry.attributes.position.array;
            if (wavelength <= 0.001) wavelength = 0.001; 
            const k = (2 * Math.PI) / wavelength;
            for (let i = 0; i < waveParams.points; i++) {
                const x = (i / (waveParams.points - 1)) * waveParams.extent - (waveParams.extent / 2);
                let y;
                if (isEnvelopeModulation) { y = amplitude * Math.cos(k * x + phase); } 
                else { y = amplitude * Math.sin(k * x + phase); }
                const z = 0;
                positions[i * 3] = x; positions[i * 3 + 1] = y; positions[i * 3 + 2] = z;
            }
            lineObject.geometry.attributes.position.needsUpdate = true;
        }

        function calculateWavePoint(x, k_val, omega_val, amplitude_val, time_val, initial_phase = 0) {
            return amplitude_val * Math.sin(k_val * x - omega_val * time_val + initial_phase);
        }

        function aspectVerticalFix(cam) { 
            if (!cam || cam.top === cam.bottom || cam.right === cam.left) return 1; 
            return (cam.right - cam.left) / (cam.top - cam.bottom);
        }

        function init() {
            scaleContainerElement = document.getElementById('scale-container');
            parameterControlsContainer = document.getElementById('parameter-controls'); 
            if (!scaleContainerElement || !parameterControlsContainer) { console.error("Conteneurs d'UI manquants !"); return; }
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x282c34);
            axesHelper = new THREE.AxesHelper(waveParams.extent / 2); scene.add(axesHelper);
            const canvasElement = document.getElementById('webgl-canvas');
            const vizArea = document.getElementById('visualization-area');
            if (!canvasElement || !vizArea) { console.error("Canvas ou vizArea manquant."); return; }
            const initialWidth = vizArea.clientWidth; const initialHeight = vizArea.clientHeight;
            camera = new THREE.OrthographicCamera( waveParams.extent / -2, waveParams.extent / 2, (waveParams.extent * initialHeight / initialWidth) / 2, (waveParams.extent * initialHeight / initialWidth) / -2, 0.1, 1000 );
            camera.position.set(0, 0, 10); 
            renderer = new THREE.WebGLRenderer({ canvas: canvasElement, antialias: true }); renderer.setSize(initialWidth, initialHeight);
            if (typeof THREE.OrbitControls !== 'undefined') {
                controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.screenSpacePanning = true; 
                controls.target.set(0, 0, 0); controls.minZoom = 0.2; controls.maxZoom = 5; controls.update();
            } else { console.error("THREE.OrbitControls n'est pas chargé."); }
            conceptSelector = document.getElementById('concept-selector');
            if (conceptSelector) { conceptSelector.disabled = false; conceptSelector.value = currentConcept; conceptSelector.addEventListener('change', handleConceptChange); }
            else { console.error("Sélecteur de concept introuvable !");}
            
            setupConceptUI(currentConcept); 
            setupConceptVisualization(currentConcept); 
            
            window.addEventListener('resize', onWindowResize, false); animate();
        }

        function handleConceptChange(event) {
            const newConcept = event.target.value; if (newConcept === currentConcept) return;
            animationTime = 0; clearConceptVisualization(); currentConcept = newConcept;
            setupConceptUI(currentConcept); setupConceptVisualization(currentConcept); 
        }

        function setupConceptUI(concept) {
            parameterControlsContainer.innerHTML = ''; 
            let preservedAmplitude = waveParams.amplitude; let preservedWavelength = waveParams.wavelength;
            if (waveParams.Ey_amplitude === undefined) waveParams.Ey_amplitude = 1.0; if (waveParams.Ez_amplitude === undefined) waveParams.Ez_amplitude = 0.5;

            if (concept === 'wavelength_amplitude') { const wlMin = 0.2; const wlMax = 3.0; const wlStep = 0.01; if (preservedWavelength < wlMin || preservedWavelength > wlMax || isNaN(preservedWavelength)) { waveParams.wavelength = wlMin; } else { waveParams.wavelength = preservedWavelength; } if (isNaN(preservedAmplitude) || preservedAmplitude <0.1 || preservedAmplitude > 3) { waveParams.amplitude = 1.0;} else { waveParams.amplitude = preservedAmplitude; } parameterControlsContainer.innerHTML = ` <div class="param-group"> <label for="wavelength-slider">Longueur d'onde (λ): <span id="wavelength-value">${waveParams.wavelength.toFixed(2)}</span></label> <input type="range" id="wavelength-slider" min="${wlMin}" max="${wlMax}" step="${wlStep}" value="${waveParams.wavelength}"> </div> <div class="param-group"> <label for="amplitude-slider">Amplitude (A): <span id="amplitude-value">${waveParams.amplitude.toFixed(1)}</span></label> <input type="range" id="amplitude-slider" min="0.1" max="3" step="0.05" value="${waveParams.amplitude}"> </div> `; const wlSlider = document.getElementById('wavelength-slider'); const ampSlider = document.getElementById('amplitude-slider'); const wlVal = document.getElementById('wavelength-value'); const ampVal = document.getElementById('amplitude-value'); if (wlSlider && wlVal) { wlSlider.addEventListener('input', (e) => { waveParams.wavelength = parseFloat(e.target.value); wlVal.textContent = waveParams.wavelength.toFixed(2); updateConceptVisualization(currentConcept); });} if (ampSlider && ampVal) { ampSlider.addEventListener('input', (e) => { waveParams.amplitude = parseFloat(e.target.value); ampVal.textContent = waveParams.amplitude.toFixed(1); updateConceptVisualization(currentConcept); });}
            } else if (concept === 'phase') { waveParams.amplitude = 1.0; waveParams.wavelength = 2.0; parameterControlsContainer.innerHTML = ` <div class="param-group"> <label for="phase-slider">Déphasage (ϕ): <span id="phase-value">${(waveParams.phaseShift * 180 / Math.PI).toFixed(0)}°</span></label> <input type="range" id="phase-slider" min="0" max="${(2 * Math.PI).toFixed(4)}" step="0.01" value="${waveParams.phaseShift.toFixed(4)}"> </div> <div class="param-group"><div class="param-info">Amplitude (A): ${waveParams.amplitude.toFixed(1)} (Fixe)</div></div> <div class="param-group"><div class="param-info">Longueur d'onde (λ): ${waveParams.wavelength.toFixed(1)} (Fixe)</div></div> `; const phSlider = document.getElementById('phase-slider'); const phVal = document.getElementById('phase-value'); if (phSlider && phVal) { phSlider.addEventListener('input', (e) => { waveParams.phaseShift = parseFloat(e.target.value); phVal.textContent = `${(waveParams.phaseShift * 180 / Math.PI).toFixed(0)}°`; updateConceptVisualization(currentConcept); });}
            } else if (concept === 'polarization') { waveParams.amplitude = 1.0; waveParams.wavelength = 4.0;  let polaCtrl = ` <div class="param-group"><label>Type de Polarisation :</label> <div><input type="radio" id="pola_lin_v" name="p_type" value="linear_vertical" ${waveParams.polarizationType === 'linear_vertical' ? 'checked' : ''}><label for="pola_lin_v" class="radio-label">Linéaire Verticale</label></div> <div><input type="radio" id="pola_lin_h" name="p_type" value="linear_horizontal" ${waveParams.polarizationType === 'linear_horizontal' ? 'checked' : ''}><label for="pola_lin_h" class="radio-label">Linéaire Horizontale</label></div> <div><input type="radio" id="pola_circ_d" name="p_type" value="circular_right_expected" ${waveParams.polarizationType === 'circular_right_expected' ? 'checked' : ''}><label for="pola_circ_d" class="radio-label">Circulaire Droite</label></div> <div><input type="radio" id="pola_circ_g" name="p_type" value="circular_left_expected" ${waveParams.polarizationType === 'circular_left_expected' ? 'checked' : ''}><label for="pola_circ_g" class="radio-label">Circulaire Gauche</label></div> <div><input type="radio" id="pola_elliptical" name="p_type" value="elliptical" ${waveParams.polarizationType === 'elliptical' ? 'checked' : ''}><label for="pola_elliptical" class="radio-label">Elliptique</label></div> <div><input type="radio" id="pola_unpolarized" name="p_type" value="unpolarized" ${waveParams.polarizationType === 'unpolarized' ? 'checked' : ''}><label for="pola_unpolarized" class="radio-label">Non Polarisée</label></div> </div> <div id="polarization_dynamic_controls"></div> <hr>  <div class="param-group"> <label>Mode de Visualisation :</label> <div><input type="radio" id="p_view_temp" name="p_view_mode" value="temporal" ${waveParams.polarizationViewMode === 'temporal' ? 'checked' : ''}><label for="p_view_temp" class="radio-label">Animation Temporelle (à x=0)</label></div> <div><input type="radio" id="p_view_spatial" name="p_view_mode" value="spatial" ${waveParams.polarizationViewMode === 'spatial' ? 'checked' : ''}><label for="p_view_spatial" class="radio-label">Instantané Spatial (le long de X)</label></div> </div> <hr> <div class="param-group"><div class="param-info" id="polarization_amplitude_info">Amplitude E max: ${waveParams.amplitude.toFixed(1)}</div></div> <div class="param-group"><div class="param-info">Longueur d'onde (λ): ${waveParams.wavelength.toFixed(1)} (Fixe)</div></div>`; parameterControlsContainer.innerHTML = polaCtrl; const polaDynCtrl = document.getElementById('polarization_dynamic_controls'); const polaAmpInfo = document.getElementById('polarization_amplitude_info'); function updEllipSliders() { const eyValText = (typeof waveParams.Ey_amplitude === 'number') ? waveParams.Ey_amplitude.toFixed(2) : "1.00"; const ezValText = (typeof waveParams.Ez_amplitude === 'number') ? waveParams.Ez_amplitude.toFixed(2) : "0.50"; const eySliderVal = (typeof waveParams.Ey_amplitude === 'number') ? waveParams.Ey_amplitude : 1.0; const ezSliderVal = (typeof waveParams.Ez_amplitude === 'number') ? waveParams.Ez_amplitude : 0.5; if (waveParams.polarizationType === 'elliptical') { polaDynCtrl.innerHTML = ` <div class="param-group"> <label for="Ey_amplitude_slider">Amplitude Ey: <span id="Ey_amplitude_value">${eyValText}</span></label> <input type="range" id="Ey_amplitude_slider" min="0.0" max="1.5" step="0.05" value="${eySliderVal}"> </div> <div class="param-group"> <label for="Ez_amplitude_slider">Amplitude Ez: <span id="Ez_amplitude_value">${ezValText}</span></label> <input type="range" id="Ez_amplitude_slider" min="0.0" max="1.5" step="0.05" value="${ezSliderVal}"> </div>`; polaAmpInfo.textContent = "Amplitudes Ey/Ez variables"; const EyS = document.getElementById('Ey_amplitude_slider'); const EzS = document.getElementById('Ez_amplitude_slider'); const EyV_disp = document.getElementById('Ey_amplitude_value'); const EzV_disp = document.getElementById('Ez_amplitude_value'); if(EyS && EyV_disp) EyS.addEventListener('input', e => { waveParams.Ey_amplitude = parseFloat(e.target.value); EyV_disp.textContent = waveParams.Ey_amplitude.toFixed(2); if(waveParams.polarizationViewMode === 'spatial') {clearConceptVisualization(); setupConceptVisualization(currentConcept); updateConceptVisualization(currentConcept);}}); if(EzS && EzV_disp) EzS.addEventListener('input', e => { waveParams.Ez_amplitude = parseFloat(e.target.value); EzV_disp.textContent = waveParams.Ez_amplitude.toFixed(2); if(waveParams.polarizationViewMode === 'spatial') {clearConceptVisualization(); setupConceptVisualization(currentConcept); updateConceptVisualization(currentConcept);}}); } else { polaDynCtrl.innerHTML = ''; polaAmpInfo.textContent = `Amplitude E max: ${waveParams.amplitude.toFixed(1)} (Fixe)`; } if (waveParams.polarizationViewMode === 'temporal' && eVectorTracePath && eVectorTracePath.userData) { const tracePos = eVectorTracePath.geometry.attributes.position.array; for(let i=0; i < eVectorTracePath.userData.pathLength * 3; i++) tracePos[i] = tracePos[0]; eVectorTracePath.userData.drawnPoints = 1; eVectorTracePath.geometry.setDrawRange(0, 1); eVectorTracePath.geometry.attributes.position.needsUpdate = true; } } updEllipSliders(); document.getElementsByName('p_type').forEach(r => r.addEventListener('change', e => { waveParams.polarizationType = e.target.value; updEllipSliders(); clearConceptVisualization(); setupConceptVisualization(currentConcept); if (waveParams.polarizationViewMode === 'spatial' || waveParams.polarizationType === 'unpolarized') {updateConceptVisualization(currentConcept);}})); document.getElementsByName('p_view_mode').forEach(r => r.addEventListener('change', e => { waveParams.polarizationViewMode = e.target.value; clearConceptVisualization(); setupConceptVisualization(currentConcept); if (waveParams.polarizationViewMode === 'spatial' || waveParams.polarizationType === 'unpolarized') {updateConceptVisualization(currentConcept); }}));} 
            else if (concept === 'poynting_vector') { if (typeof waveParams.amplitude !== 'number' || isNaN(waveParams.amplitude) || waveParams.amplitude < 0.1 || waveParams.amplitude > 2.5) { waveParams.amplitude = 1.0; } waveParams.wavelength = 3.0; parameterControlsContainer.innerHTML = ` <div class="param-group"> <label for="poynting_E_slider">Amplitude E₀: <span id="poynting_E_value">${waveParams.amplitude.toFixed(1)}</span></label> <input type="range" id="poynting_E_slider" min="0.1" max="2.5" step="0.1" value="${waveParams.amplitude}"> </div> <div class="param-info">Vecteur Poynting (rouge) ∝ E₀²</div> <div class="param-info">Onde guide (bleutée) montre E₀. λ=${waveParams.wavelength.toFixed(1)} (Fixe)</div> `; const eSliderPoynting = document.getElementById('poynting_E_slider'); const eValueDisplayPoynting = document.getElementById('poynting_E_value'); if (eSliderPoynting && eValueDisplayPoynting) { eSliderPoynting.addEventListener('input', (e) => { waveParams.amplitude = parseFloat(e.target.value); eValueDisplayPoynting.textContent = waveParams.amplitude.toFixed(1); updateConceptVisualization(currentConcept); }); }
            } else if (concept === 'phase_group_velocity') { waveParams.amplitude = 1.0; waveParams.wavelength = 2.0; waveParams.packet_delta_k_factor = 0.15; waveParams.dispersionFactor = 0.1; parameterControlsContainer.innerHTML = ` <div class="param-group"><label>Visualisation :</label> <div><input type="radio" id="vel_phase" name="vel_type" value="phase" ${waveParams.velocityDisplayType === 'phase' ? 'checked' : ''}><label for="vel_phase" class="radio-label">Vitesse de Phase (Onde Simple)</label></div> <div><input type="radio" id="vel_group" name="vel_type" value="group" ${waveParams.velocityDisplayType === 'group' ? 'checked' : ''}><label for="vel_group" class="radio-label">Vitesses Groupe & Phase (Paquet)</label></div> </div> <div class="param-group"> <label for="dispersion_slider">Facteur de Dispersion (D): <span id="dispersion_value">${waveParams.dispersionFactor.toFixed(2)}</span></label> <input type="range" id="dispersion_slider" min="0" max="0.5" step="0.01" value="${waveParams.dispersionFactor}"> </div> <div class="param-info">A=${waveParams.amplitude.toFixed(1)}, λ₀=${waveParams.wavelength.toFixed(1)} (Porteuse)</div> <div class="param-info">Écart relatif des k (paquet): ${(waveParams.packet_delta_k_factor*100).toFixed(0)}%</div> <div class="param-info" style="font-size:0.8em;">Composantes (bleu/violet), Superposition (blanc), Enveloppe (rouge). Marqueurs: Vp (jaune), Vg (cyan).</div>`; document.getElementsByName('vel_type').forEach(r => r.addEventListener('change', e => { waveParams.velocityDisplayType = e.target.value; animationTime = 0; clearConceptVisualization(); setupConceptVisualization(currentConcept); })); const dispSlider = document.getElementById('dispersion_slider'); const dispValue = document.getElementById('dispersion_value'); if(dispSlider && dispValue){ dispSlider.addEventListener('input', e => { waveParams.dispersionFactor = parseFloat(e.target.value); dispValue.textContent = waveParams.dispersionFactor.toFixed(2); if(waveParams.velocityDisplayType === 'group'){ animationTime = 0; } }); }} 
            else if (concept === 'wave_type_comparison') { waveParams.amplitude = 0.5; waveParams.wavelength = 3.0; parameterControlsContainer.innerHTML = ` <div class="param-group"><label>Type d'Onde :</label> <div><input type="radio" id="type_trans" name="comp_type" value="transverse" ${waveParams.waveComparisonType === 'transverse' ? 'checked' : ''}><label for="type_trans" class="radio-label">Transversale</label></div> <div><input type="radio" id="type_long" name="comp_type" value="longitudinal" ${waveParams.waveComparisonType === 'longitudinal' ? 'checked' : ''}><label for="type_long" class="radio-label">Longitudinale</label></div> </div> <div class="param-info">A=${waveParams.amplitude.toFixed(1)}, λ=${waveParams.wavelength.toFixed(1)} (Fixes)</div>`; document.getElementsByName('comp_type').forEach(r => r.addEventListener('change', e => { waveParams.waveComparisonType = e.target.value; animationTime = 0; }));
            } else if (concept === 'wavefront') { parameterControlsContainer.innerHTML = ` <div class="param-group"><label>Type de Front d'Onde :</label> <div><input type="radio" id="wf_plane" name="wf_type" value="plane" ${waveParams.wavefrontType === 'plane' ? 'checked' : ''}><label for="wf_plane" class="radio-label">Plan</label></div> <div><input type="radio" id="wf_sphere" name="wf_type" value="spherical" ${waveParams.wavefrontType === 'spherical' ? 'checked' : ''}><label for="wf_sphere" class="radio-label">Sphérique</label></div> </div>`; document.getElementsByName('wf_type').forEach(r => r.addEventListener('change', e => { waveParams.wavefrontType = e.target.value; animationTime = 0; clearConceptVisualization(); setupConceptVisualization(currentConcept); }));
            } else { parameterControlsContainer.innerHTML = '<p style="text-align:center; padding:10px;">Concept non implémenté.</p>'; }
    updateScales();
}

function setupConceptVisualization(concept) {
    if (concept === 'wavelength_amplitude') { waveLine1 = createSingleWaveObject(0x2ecc71); scene.add(waveLine1); updateWaveGeometry(waveLine1, waveParams.wavelength, waveParams.amplitude, 0);
    } else if (concept === 'phase') { waveLine1 = createSingleWaveObject(0x3498db, 0.6); scene.add(waveLine1); updateWaveGeometry(waveLine1, waveParams.wavelength, waveParams.amplitude, 0); waveLine2 = createSingleWaveObject(0xe67e22); scene.add(waveLine2); updateWaveGeometry(waveLine2, waveParams.wavelength, waveParams.amplitude, waveParams.phaseShift);
    } else if (concept === 'polarization') {
        animationTime = 0; 
        if (waveParams.polarizationViewMode === 'temporal') {
            waveLine1 = createSingleWaveObject(0xaaaaaa, 0.4); scene.add(waveLine1);
            const E_amp_temp = waveParams.amplitude; animatedEVector = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), E_amp_temp, 0xffff00, 0.25 * E_amp_temp, 0.15 * E_amp_temp); scene.add(animatedEVector);
            const traceMaterial = new THREE.LineBasicMaterial({color: 0xffffff, transparent: true, opacity:0.7}); const tracePointsCount = 100; const tracePositions = new Float32Array(tracePointsCount * 3); 
            let initialEy, initialEz; const temp_A_trace = (waveParams.polarizationType === 'elliptical' && waveParams.Ey_amplitude !== undefined) ? waveParams.Ey_amplitude : E_amp_temp; const temp_B_trace = (waveParams.polarizationType === 'elliptical' && waveParams.Ez_amplitude !== undefined) ? waveParams.Ez_amplitude : E_amp_temp;
            switch (waveParams.polarizationType) { case 'linear_vertical': initialEy = temp_A_trace * Math.cos(0); initialEz = 0; break; case 'linear_horizontal': initialEy = 0; initialEz = temp_A_trace * Math.cos(0); break; case 'circular_right_expected': initialEy = temp_A_trace * Math.cos(0); initialEz = -temp_A_trace * Math.sin(0); break; case 'circular_left_expected':  initialEy = temp_A_trace * Math.cos(0); initialEz =  temp_A_trace * Math.sin(0); break; case 'elliptical': initialEy = temp_A_trace * Math.cos(0); initialEz = temp_B_trace * Math.sin(0); break; case 'unpolarized': initialEy = temp_A_trace; initialEz = 0; break; default: initialEy = temp_A_trace; initialEz = 0; }
            for(let i=0; i < tracePointsCount; ++i) { tracePositions[i*3] = initialEy; tracePositions[i*3+1] = initialEz; tracePositions[i*3+2] = 0;}
            const traceGeometry = new THREE.BufferGeometry(); traceGeometry.setAttribute('position', new THREE.BufferAttribute(tracePositions, 3)); traceGeometry.setDrawRange(0, 1); 
            eVectorTracePath = new THREE.Line(traceGeometry, traceMaterial); eVectorTracePath.userData = { pathLength: tracePointsCount,  drawnPoints: 1}; scene.add(eVectorTracePath);
        } else { 
            const arrowColor = 0xffff00; const numberOfArrows = 25; const arrowSpacing = waveParams.extent / (numberOfArrows > 1 ? (numberOfArrows - 1) : 1) ;
            for (let i = 0; i < numberOfArrows; i++) { const xPos = -waveParams.extent / 2 + i * arrowSpacing; const origin = new THREE.Vector3(xPos, 0, 0); const arrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), origin, 1, arrowColor, 0.3, 0.2); if (waveParams.polarizationType === 'unpolarized') arrow.userData.randomAngleSpatial = Math.random() * 2 * Math.PI; spatialPolarizationEVectors.push(arrow); scene.add(arrow); }
        }
        updateConceptVisualization(currentConcept); 
    } else if (concept === 'poynting_vector') { 
        waveLine1 = createSingleWaveObject(0x3498db, 0.8); scene.add(waveLine1); updateWaveGeometry(waveLine1, waveParams.wavelength, waveParams.amplitude, 0);
        poyntingArrowViz = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(-waveParams.extent/2 - 0.8, 0,0), 1.5, 0xff0000, 0.3, 0.15); scene.add(poyntingArrowViz);
        updateConceptVisualization(currentConcept); 
    } else if (concept === 'phase_group_velocity') { 
        const baseAmp = waveParams.amplitude; const baseLambda = waveParams.wavelength; 
        if(waveParams.velocityDisplayType === 'phase') {
            waveLine1 = createSingleWaveObject(0x1abc9c); scene.add(waveLine1); updateWaveGeometry(waveLine1, baseLambda, baseAmp, 0); 
            const markerGeom = new THREE.SphereGeometry(0.15, 12, 8); const markerMat = new THREE.MeshBasicMaterial({color: 0xf1c40f}); 
            phaseMarkerViz = new THREE.Mesh(markerGeom, markerMat); scene.add(phaseMarkerViz); 
        } else { 
            groupWaveComp1 = createSingleWaveObject(0x3498db, 0.5); scene.add(groupWaveComp1); 
            groupWaveComp2 = createSingleWaveObject(0x9b59b6, 0.5); scene.add(groupWaveComp2); 
            groupWaveSuperposition = createSingleWaveObject(0xffffff, 0.9); scene.add(groupWaveSuperposition); 
            groupWaveEnvelopeUpper = createSingleWaveObject(0xe74c3c, 0.8); scene.add(groupWaveEnvelopeUpper); 
            groupWaveEnvelopeLower = createSingleWaveObject(0xe74c3c, 0.8); scene.add(groupWaveEnvelopeLower);
            const markerGeomPhase = new THREE.SphereGeometry(0.1, 10, 6); const markerMatPhase = new THREE.MeshBasicMaterial({color: 0xf1c40f}); 
            phaseMarkerViz = new THREE.Mesh(markerGeomPhase, markerMatPhase); scene.add(phaseMarkerViz);
            const markerGeomGroup = new THREE.SphereGeometry(0.12, 10, 6); const markerMatGroup = new THREE.MeshBasicMaterial({color: 'cyan'}); 
            groupMarkerViz = new THREE.Mesh(markerGeomGroup, markerMatGroup); scene.add(groupMarkerViz);
        }
        animationTime = 0; updateConceptVisualization(currentConcept); 
    } else if (concept === 'wave_type_comparison') { 
        const particleMat = new THREE.MeshBasicMaterial({color: 0xffffff}); const particleGeom = new THREE.SphereGeometry(0.08, 16, 12); 
        for(let i=0; i < waveParams.particleCount; i++) { const xPos = -waveParams.extent/2 + i * (waveParams.extent / (waveParams.particleCount > 1 ? (waveParams.particleCount -1) : 1) ); const particle = new THREE.Mesh(particleGeom.clone(), particleMat.clone()); particle.userData.initialX = xPos; particle.position.set(xPos, 0, 0); particleSystemViz.push(particle); scene.add(particle); }
        animationTime = 0;
    } else if (concept === 'wavefront') { 
        const wfMat = new THREE.MeshBasicMaterial({color:0x1abc9c, transparent: true, opacity: 0.4, side: THREE.DoubleSide}); const numFronts = 7; const planeSize = waveParams.extent / aspectVerticalFix(camera) * 0.8;
        if(waveParams.wavefrontType === 'plane') { const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize); for(let i=0; i < numFronts; i++) { const plane = new THREE.Mesh(planeGeom, wfMat.clone()); plane.rotation.y = Math.PI/2; plane.userData.initialX = -waveParams.extent/2 - i * 1.5; plane.position.x = plane.userData.initialX; wavefrontObjects.push(plane); scene.add(plane); }
        } else { const sphereGeom = new THREE.SphereGeometry(1, 32, 16); for(let i=0; i < numFronts -2 ; i++) { const sphere = new THREE.Mesh(sphereGeom, wfMat.clone()); sphere.material.wireframe = false; sphere.userData.currentRadius = 0.1 + i * 1.2; sphere.scale.setScalar(sphere.userData.currentRadius); wavefrontObjects.push(sphere); scene.add(sphere); } }
        animationTime = 0;
    }
}


function updateConceptVisualization(concept) {
    let A = waveParams.amplitude; let L = waveParams.wavelength; let k = (2 * Math.PI) / L; if (L <= 0.001) k = (2 * Math.PI) / 0.001; 
    if (concept === 'wavelength_amplitude') { if (waveLine1) updateWaveGeometry(waveLine1, L, A, 0);
    } else if (concept === 'phase') { A = waveParams.amplitude; L = waveParams.wavelength; if (waveLine1) updateWaveGeometry(waveLine1, L, A, 0); if (waveLine2) updateWaveGeometry(waveLine2, L, A, waveParams.phaseShift); 
    } else if (concept === 'polarization') { A = waveParams.amplitude; L = waveParams.wavelength; k = (2 * Math.PI) / L; if (waveParams.polarizationViewMode === 'temporal') { if (!animatedEVector || !eVectorTracePath || !waveLine1) return; const guideWavePhase = -omegaAnimation * animationTime * 0.5; updateWaveGeometry(waveLine1, L, A, guideWavePhase); let Ey, Ez; let Ay_t = (waveParams.polarizationType === 'elliptical' && waveParams.Ey_amplitude !== undefined) ? waveParams.Ey_amplitude : A; let Az_t = (waveParams.polarizationType === 'elliptical' && waveParams.Ez_amplitude !== undefined) ? waveParams.Ez_amplitude : A; if (waveParams.polarizationType === 'linear_horizontal') Ay_t = 0; if (waveParams.polarizationType === 'linear_vertical') Az_t = 0; switch (waveParams.polarizationType) { case 'linear_vertical': Ey = Ay_t * Math.cos(omegaAnimation * animationTime); Ez = 0; break; case 'linear_horizontal': Ey = 0; Ez = Az_t * Math.cos(omegaAnimation * animationTime); break; case 'circular_right_expected': Ey = Ay_t * Math.cos(omegaAnimation * animationTime); Ez = -Ay_t * Math.sin(omegaAnimation * animationTime); break; case 'circular_left_expected':  Ey = Ay_t * Math.cos(omegaAnimation * animationTime); Ez =  Ay_t * Math.sin(omegaAnimation * animationTime); break;  case 'elliptical': Ey = Ay_t * Math.cos(omegaAnimation * animationTime); Ez = Az_t * Math.sin(omegaAnimation * animationTime); break; case 'unpolarized': if (animatedEVector && (Math.floor(animationTime / 0.1) !== Math.floor((animationTime - 0.015) / 0.1) || animatedEVector.userData.randomAngle === undefined )) { animatedEVector.userData.randomAngle = Math.random() * 2 * Math.PI;} const unpolarizedMag = A * Math.cos(omegaAnimation * animationTime * 3); Ey = unpolarizedMag * Math.cos(animatedEVector ? animatedEVector.userData.randomAngle : 0); Ez = unpolarizedMag * Math.sin(animatedEVector ? animatedEVector.userData.randomAngle : 0); break; default: Ey = Ay_t; Ez = 0; } const direction = new THREE.Vector3(0, Ey, Ez); const currentLength = direction.length(); animatedEVector.position.set(0,0,0); if (currentLength < 0.001) { direction.set(0,1,0); animatedEVector.visible = false; } else { animatedEVector.visible = true; if(currentLength > 0.001) direction.normalize(); } animatedEVector.setDirection(direction); const headL = Math.max(0.05, 0.25 * currentLength); const headW = Math.max(0.025, 0.15 * currentLength); animatedEVector.setLength(currentLength, headL, headW); const tracePositions = eVectorTracePath.geometry.attributes.position.array; const pathLength = eVectorTracePath.userData.pathLength; for (let i = pathLength - 1; i > 0; i--) { tracePositions[i * 3] = tracePositions[(i - 1) * 3]; tracePositions[i * 3 + 1] = tracePositions[(i - 1) * 3 + 1]; tracePositions[i * 3 + 2] = tracePositions[(i - 1) * 3 + 2]; } tracePositions[0] = Ey; tracePositions[1] = Ez; tracePositions[2] = 0; if (eVectorTracePath.userData.drawnPoints < pathLength) eVectorTracePath.userData.drawnPoints++; eVectorTracePath.geometry.setDrawRange(0, eVectorTracePath.userData.drawnPoints); eVectorTracePath.geometry.attributes.position.needsUpdate = true; } else { if (spatialPolarizationEVectors.length === 0) return; const t_snapshot = 0; let Ay_s_val = (waveParams.polarizationType === 'elliptical' && waveParams.Ey_amplitude !==undefined) ? waveParams.Ey_amplitude : A; let Az_s_val = (waveParams.polarizationType === 'elliptical' && waveParams.Ez_amplitude !==undefined) ? waveParams.Ez_amplitude : A; if (waveParams.polarizationType === 'linear_horizontal') Ay_s_val = 0; if (waveParams.polarizationType === 'linear_vertical') Az_s_val = 0; spatialPolarizationEVectors.forEach(arrow => { const x_arrow = arrow.position.x; let Ey, Ez; switch (waveParams.polarizationType) { case 'linear_vertical': Ey = Ay_s_val * Math.cos(k * x_arrow - t_snapshot); Ez = 0; break; case 'linear_horizontal': Ey = 0; Ez = Az_s_val * Math.cos(k * x_arrow - t_snapshot); break; case 'circular_right_expected': Ey = Ay_s_val * Math.cos(k * x_arrow - t_snapshot); Ez = -Ay_s_val * Math.sin(k * x_arrow - t_snapshot); break; case 'circular_left_expected': Ey = Ay_s_val * Math.cos(k * x_arrow - t_snapshot); Ez =  Ay_s_val * Math.sin(k * x_arrow - t_snapshot); break;  case 'elliptical': Ey = Ay_s_val * Math.cos(k * x_arrow - t_snapshot); Ez = Az_s_val * Math.sin(k * x_arrow - t_snapshot); break; case 'unpolarized': if (arrow.userData.randomAngleSpatial === undefined) arrow.userData.randomAngleSpatial = Math.random() * 2 * Math.PI; const waveModulation = A * Math.cos(k * x_arrow - t_snapshot); Ey = waveModulation * Math.cos(arrow.userData.randomAngleSpatial); Ez = waveModulation * Math.sin(arrow.userData.randomAngleSpatial); break; default: Ey = Ay_s_val; Ez = 0; } const direction = new THREE.Vector3(0, Ey, Ez); let currentLength = direction.length(); if (currentLength < 0.001) { direction.set(0,1,0); arrow.visible = false; currentLength=0;} else { arrow.visible = true; direction.normalize(); } arrow.setDirection(direction); const headL = Math.max(0.05, 0.25 * currentLength); const headW = Math.max(0.025, 0.15 * currentLength); arrow.setLength(currentLength, headL, headW ); }); } }
    else if (concept === 'poynting_vector') { const E0 = waveParams.amplitude; if (waveLine1) updateWaveGeometry(waveLine1, waveParams.wavelength, E0, 0); if (poyntingArrowViz) { const poyntingMagnitude = 0.3 + Math.min(2.5, E0 * E0 * 0.4); const headLength = Math.max(0.1, 0.25 * poyntingMagnitude); const headWidth = Math.max(0.05, 0.12 * poyntingMagnitude); poyntingArrowViz.setLength(poyntingMagnitude, headLength, headWidth); }
    } else if (concept === 'phase_group_velocity') { const baseAmp = waveParams.amplitude; const baseLambda = waveParams.wavelength; const k0 = (2 * Math.PI) / baseLambda; const baseOmega = omegaAnimation * 1.2; if (waveParams.velocityDisplayType === 'phase') { if (waveLine1 && phaseMarkerViz) { const phaseOffset = -baseOmega * animationTime; updateWaveGeometry(waveLine1, baseLambda, baseAmp, phaseOffset); let markerX = (Math.PI/2 - phaseOffset) / k0; while(markerX > waveParams.extent/2 + baseLambda) markerX -= baseLambda; while(markerX < -waveParams.extent/2 - baseLambda) markerX += baseLambda; if (markerX > waveParams.extent / 2) markerX -= baseLambda; else if (markerX < -waveParams.extent /2) markerX += baseLambda; phaseMarkerViz.position.set(markerX, baseAmp * Math.sin(k0*markerX + phaseOffset) , 0.01); } } else { if (!groupWaveSuperposition || !groupWaveEnvelopeUpper || !groupWaveEnvelopeLower || !phaseMarkerViz || !groupMarkerViz) return; const A_comp = baseAmp * 0.5; const delta_k_factor = waveParams.packet_delta_k_factor; const k1 = k0 * (1 - delta_k_factor); const k2 = k0 * (1 + delta_k_factor); const v0_ref = baseOmega / k0; const D = waveParams.dispersionFactor * v0_ref / k0; const omega1 = k1 * v0_ref - D * k1 * (k1-k0); const omega2 = k2 * v0_ref - D * k2 * (k2-k0); const k_mod = (k2 - k1) / 2.0; const omega_mod = (omega2 - omega1) / 2.0; const lambda_env = (k_mod === 0 || isNaN(k_mod)) ? Infinity : (2 * Math.PI) / Math.abs(k_mod); const phaseOffset_env = -omega_mod * animationTime; updateWaveGeometry(groupWaveEnvelopeUpper, lambda_env, 2*A_comp, phaseOffset_env, true); updateWaveGeometry(groupWaveEnvelopeLower, lambda_env, -2*A_comp, phaseOffset_env, true); const positions = groupWaveSuperposition.geometry.attributes.position.array; const time_factor_vg = 1.0; for (let i = 0; i < waveParams.points; i++) { const x_pos = (i / (waveParams.points - 1)) * waveParams.extent - (waveParams.extent / 2); const y1 = calculateWavePoint(x_pos, k1, omega1, A_comp, animationTime * time_factor_vg, 0); const y2 = calculateWavePoint(x_pos, k2, omega2, A_comp, animationTime * time_factor_vg, 0); positions[i * 3 + 1] = y1 + y2; } groupWaveSuperposition.geometry.attributes.position.needsUpdate = true; if(groupWaveComp1) updateWaveGeometry(groupWaveComp1, (2*Math.PI)/k1, A_comp, -omega1 * animationTime * time_factor_vg); if(groupWaveComp2) updateWaveGeometry(groupWaveComp2, (2*Math.PI)/k2, A_comp, -omega2 * animationTime * time_factor_vg); let groupMarkerX = (k_mod === 0) ? 0 : (-phaseOffset_env) / k_mod; const lambda_env_vis = (k_mod === 0) ? waveParams.extent * 2 : Math.abs(2*Math.PI/k_mod); while(groupMarkerX > waveParams.extent/2 + lambda_env_vis) groupMarkerX -= lambda_env_vis; while(groupMarkerX < -waveParams.extent/2 - lambda_env_vis) groupMarkerX += lambda_env_vis; if (groupMarkerX > waveParams.extent / 2 && k_mod !==0) groupMarkerX -= lambda_env_vis; else if (groupMarkerX < -waveParams.extent /2 && k_mod !==0) groupMarkerX += lambda_env_vis; groupMarkerViz.position.set(groupMarkerX, 2 * A_comp * Math.cos(k_mod * groupMarkerX + phaseOffset_env), 0.1); const k_carr_avg = (k1+k2)/2; const omega_carr_avg = (omega1+omega2)/2; let phaseMarkerX_g = (k_carr_avg === 0) ? 0 : (Math.PI/2 - (-omega_carr_avg * animationTime * time_factor_vg)) / k_carr_avg; const lambda_carr_vis = (k_carr_avg === 0) ? waveParams.extent * 2 : Math.abs(2*Math.PI/k_carr_avg); while(phaseMarkerX_g > waveParams.extent/2 + lambda_carr_vis) phaseMarkerX_g -= lambda_carr_vis; while(phaseMarkerX_g < -waveParams.extent/2 - lambda_carr_vis) phaseMarkerX_g += lambda_carr_vis; const y_env_at_phase_marker = 2 * A_comp * Math.cos(k_mod * phaseMarkerX_g + phaseOffset_env); const y_carrier_at_marker = y_env_at_phase_marker * Math.sin(k_carr_avg * phaseMarkerX_g - omega_carr_avg * animationTime * time_factor_vg + Math.PI/2); phaseMarkerViz.position.set(phaseMarkerX_g, y_carrier_at_marker, 0.1); }
    } else if (concept === 'wave_type_comparison') { const k_comp = (2 * Math.PI) / waveParams.wavelength; const omega_comp = omegaAnimation; particleSystemViz.forEach(particle => { const x_i = particle.userData.initialX; if(waveParams.waveComparisonType === 'transverse') { particle.position.y = waveParams.amplitude * Math.sin(k_comp * x_i - omega_comp * animationTime); particle.position.x = x_i; } else { particle.position.x = x_i + waveParams.amplitude * 0.5 * Math.sin(k_comp * x_i - omega_comp * animationTime); particle.position.y = 0; } });
    } else if (concept === 'wavefront') { const wavefrontSpeed = 0.02; wavefrontObjects.forEach(wf => { if(waveParams.wavefrontType === 'plane') { wf.position.x += wavefrontSpeed; if(wf.geometry.parameters && wf.position.x > waveParams.extent / 2 + wf.geometry.parameters.width/2 + 1.0) { wf.position.x = -waveParams.extent / 2 - wf.geometry.parameters.width/2 - (Math.random()*0.5); } } else { if (wf.geometry.parameters && typeof wf.geometry.parameters.radius !== 'undefined') { let newScale = wf.scale.x + wavefrontSpeed * 0.3; if (newScale * wf.geometry.parameters.radius > waveParams.extent / 1.8) { newScale = 0.1 + (Math.random()*0.2); } wf.scale.setScalar(newScale); } } }); }
}


//wtf, I should clear this...
function clearConceptVisualization() { if (waveLine1) { scene.remove(waveLine1); waveLine1.geometry.dispose(); if(waveLine1.material)waveLine1.material.dispose(); waveLine1 = null; } if (waveLine2) { scene.remove(waveLine2); waveLine2.geometry.dispose(); if(waveLine2.material)waveLine2.material.dispose(); waveLine2 = null; } if (animatedEVector) { scene.remove(animatedEVector); animatedEVector = null; }  if (eVectorTracePath) { scene.remove(eVectorTracePath); eVectorTracePath.geometry.dispose(); if(eVectorTracePath.material)eVectorTracePath.material.dispose(); eVectorTracePath = null;} if (poyntingArrowViz) { scene.remove(poyntingArrowViz); poyntingArrowViz = null; } if (phaseMarkerViz) { scene.remove(phaseMarkerViz); phaseMarkerViz.geometry.dispose(); if(phaseMarkerViz.material)phaseMarkerViz.material.dispose(); phaseMarkerViz = null; } if (groupMarkerViz) { scene.remove(groupMarkerViz); groupMarkerViz.geometry.dispose(); if(groupMarkerViz.material)groupMarkerViz.material.dispose(); groupMarkerViz = null;} if (groupWaveComp1) { scene.remove(groupWaveComp1); groupWaveComp1.geometry.dispose(); if(groupWaveComp1.material)groupWaveComp1.material.dispose(); groupWaveComp1 = null;} if (groupWaveComp2) { scene.remove(groupWaveComp2); groupWaveComp2.geometry.dispose(); if(groupWaveComp2.material)groupWaveComp2.material.dispose(); groupWaveComp2 = null;} if (groupWaveSuperposition) { scene.remove(groupWaveSuperposition); groupWaveSuperposition.geometry.dispose(); if(groupWaveSuperposition.material) groupWaveSuperposition.material.dispose(); groupWaveSuperposition = null;} if (groupWaveEnvelopeUpper) { scene.remove(groupWaveEnvelopeUpper); groupWaveEnvelopeUpper.geometry.dispose(); if(groupWaveEnvelopeUpper.material)groupWaveEnvelopeUpper.material.dispose(); groupWaveEnvelopeUpper = null;} if (groupWaveEnvelopeLower) { scene.remove(groupWaveEnvelopeLower); groupWaveEnvelopeLower.geometry.dispose(); if(groupWaveEnvelopeLower.material)groupWaveEnvelopeLower.material.dispose(); groupWaveEnvelopeLower = null;} spatialPolarizationEVectors.forEach(arrow => scene.remove(arrow)); spatialPolarizationEVectors = []; particleSystemViz.forEach(p => { scene.remove(p); p.geometry.dispose(); if(p.material)p.material.dispose(); }); particleSystemViz = []; wavefrontObjects.forEach(wf => { scene.remove(wf); wf.geometry.dispose(); if(wf.material)wf.material.dispose(); }); wavefrontObjects = [];}
function animate() { requestAnimationFrame(animate); animationTime += 0.015; if (controls && (controls.enableDamping || controls.autoRotate)) { controls.update(); } if (currentConcept === 'polarization' || currentConcept === 'phase_group_velocity' || currentConcept === 'wave_type_comparison' || currentConcept === 'wavefront') { updateConceptVisualization(currentConcept); } updateScales(); renderer.render(scene, camera); }
function onWindowResize() { const vizArea = document.getElementById('visualization-area'); if (!vizArea) return; const newWidth = vizArea.clientWidth; const newHeight = vizArea.clientHeight; if (newWidth > 0 && newHeight > 0) { const aspect = newWidth / newHeight; camera.left = waveParams.extent / -2; camera.right = waveParams.extent / 2; camera.top = (waveParams.extent / aspect) / 2; camera.bottom = (waveParams.extent / aspect) / -2; camera.updateProjectionMatrix(); renderer.setSize(newWidth, newHeight); } }
function worldToScreen(worldVector, camera, canvas) { const screenVector = worldVector.clone().project(camera); const x = Math.round((screenVector.x * 0.5 + 0.5) * canvas.clientWidth); const y = Math.round((-screenVector.y * 0.5 + 0.5) * canvas.clientHeight); return { x, y }; }
function updateScales() { if (!scaleContainerElement || !renderer) return; while (scaleContainerElement.firstChild) scaleContainerElement.removeChild(scaleContainerElement.firstChild); const canvas = renderer.domElement; if (!canvas || canvas.clientWidth === 0 || canvas.clientHeight === 0) return; let xAxisZeroScreenPos = null; const xAxisYOffset = 30; const numXTicks = 11; const xMin = -waveParams.extent / 2; for (let i = 0; i < numXTicks; i++) { const value = xMin + i * (waveParams.extent / (numXTicks - 1)); const worldPos = new THREE.Vector3(value, 0, 0); const currentScreenPos = worldToScreen(worldPos, camera, canvas); const projectedVecForCheck = worldPos.clone().project(camera); if (Math.abs(projectedVecForCheck.x) > 1.1 || Math.abs(projectedVecForCheck.y) > 1.1) { if (!(Math.abs(value) < 0.001 && Math.abs(projectedVecForCheck.x) <= 1.1)) continue; } const label = document.createElement('span'); label.classList.add('scale-label', 'x-axis-label'); label.textContent = value.toFixed(Math.abs(value) < 0.01 && value !==0 ? 2 : 0); label.style.left = `${currentScreenPos.x}px`; label.style.top = `${currentScreenPos.y + xAxisYOffset}px`; label.style.transform = 'translateX(-50%)'; scaleContainerElement.appendChild(label); if (Math.abs(value) < 0.001) xAxisZeroScreenPos = { x: currentScreenPos.x, y: currentScreenPos.y + xAxisYOffset }; } const yAxisXOffset = -20; let amplitudeValues = []; let displayAmplitude = waveParams.amplitude; if (Math.abs(displayAmplitude) > 0.01) amplitudeValues.push(-displayAmplitude, displayAmplitude); if (amplitudeValues.indexOf(0) === -1 || amplitudeValues.length === 0 || (amplitudeValues.length > 0 && Math.abs(displayAmplitude) > 0.01) ) amplitudeValues.push(0); else if (amplitudeValues.length === 0 && Math.abs(displayAmplitude) < 0.01) amplitudeValues.push(0);  amplitudeValues.sort((a, b) => a - b); const uniqueAmplitudeValues = [...new Set(amplitudeValues)]; for (const value of uniqueAmplitudeValues) { let skipLabel = false; if (Math.abs(value) < 0.001 && xAxisZeroScreenPos) { const yZeroWorldPos = new THREE.Vector3(0, 0, 0); const yZeroScreenPos = worldToScreen(yZeroWorldPos, camera, canvas); const distBetweenZeros = Math.hypot( (yZeroScreenPos.x + yAxisXOffset) - xAxisZeroScreenPos.x,  yZeroScreenPos.y - (xAxisZeroScreenPos.y - xAxisYOffset)); if (distBetweenZeros < 25 && Math.abs(displayAmplitude) > 0.01) skipLabel = true; } if (skipLabel) continue; const worldPos = new THREE.Vector3(0, value, 0); const currentYScreenPos = worldToScreen(worldPos, camera, canvas); const projectedVecForCheck = worldPos.clone().project(camera); if (Math.abs(projectedVecForCheck.y) > 1.1 || Math.abs(projectedVecForCheck.x) > 1.1) { if (!(Math.abs(value) < 0.001 && Math.abs(projectedVecForCheck.y) <= 1.1)) continue; } const label = document.createElement('span'); label.classList.add('scale-label', 'y-axis-label'); label.textContent = value.toFixed(1); label.style.left = `${currentYScreenPos.x + yAxisXOffset}px`; label.style.top = `${currentYScreenPos.y}px`; label.style.transform = 'translateY(-50%) translateX(-100%)'; scaleContainerElement.appendChild(label); } }

        // let's gooooo ... , modif le 5 juin
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>